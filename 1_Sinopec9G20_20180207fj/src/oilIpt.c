//#include <inetLib.h>
//#include "oilCfg.h"
//#include "oilFram.h"
//#include "oilParam.h"
//#include "oilKb.h"
//#include "oilSpk.h"
//#include "oilDsp.h"
//#include "oilPcd.h"
//#include "oilJl.h"
//#include "oilBarcode.h"
//#include "oilLog.h"
//#include "oilKJLD.h"
//#include "oilPC.h"
//#include "oilMain.h"
#include "../inc/main.h"


//调试阶段相关参数
#if _IPT_DEBUG_

static char IsOilAtuo=0;		//是否自动加油；1=是；其它=否

#endif

//支付终端主用户ID
int iptMainUser = 0;


//当前IPT模块读取到的一些状态，参数等
IptParamStructType IptParamA, IptParamB;

//PC信息
PcdPcInfoType IptPcInfo;

//主板号及主板密钥
static unsigned char MboardID[8]={0};	//主板号
static unsigned char Key[16]={0};			//主板密钥
static unsigned char KeyData[32]={0};	//存储的原始的经过重新打乱顺序的密钥数据


//背光控制0=常亮；1=关闭；2=省电
static unsigned char IptBacklit=0;

//szb_fj_20171120:205的IAP与应用程序版本
unsigned char Ipt205IAP_Ver[2]={0x00,0x00};
unsigned char Ipt205APP_Ver[2]={0x00,0x00};

//私有函数列表
int iptSpk(const IptParamStructType *iptparam, int *list, int number);
int iptPrint(const IptParamStructType *iptparam, int prn_union, char *buffer, int nbytes);


int iptIsBig260(int nozzle);
int iptDiscountCompute(int nozzle, unsigned int volume, unsigned int pricediscount);
int iptIcBalanceDsp(int nozzle);
int iptParamInit(int nozzle);



/*******************************************************************
*Name				:iptIsBig260
*Description		:判断是否是260大流量程序
*Input				:nozzle		面板号 0=A1枪；1=B1枪
*Output			:无
*Return				:0=非260大流量程序；1=260大流量程序
*History			:2016-02-18,modified by syj  */

int iptIsBig260(int nozzle)
{
#if _TYPE_BIG260_
	return 1;
#else
	return 0;
#endif
}


/*******************************************************************
*Name				:iptIsLianda
*Description		:判断是否是社会站联达加油机系统
*Input				:nozzle		面板号 0=A1枪；1=B1枪
*Output			:无
*Return				:0=否；1=是
*History			:2016-02-18,modified by syj  */

//2017-01-22中燃联达灰卡解扣
int iptIsLianda(int nozzle)
{
	if(MODEL_LIANDA == paramModelGet())
	{
		return 1;
	}
	else
	{
		return 0;
	}
}


/*******************************************************************
*Name				:iptChgPidForce
*Description		:判断是否允许强行更改进程，某些时候不允许强行更改时则不可更改
*Input				:nozzle		面板号 0=A1枪；1=B1枪
*Output			:无
*Return				:0=允许；其它=不允许
*History			:2016-02-18,modified by syj  */

int iptChgPidForce(int nozzle)
{
	return 0;
}


/*******************************************************************
*Name				:iptDiscountCompute
*Description		:计算折扣
*Input				:nozzle				面板号 0=A1枪；1=B1枪
*						:volume			加油数量
*						:pricediscount	单价折扣额
*Output			:无
*Return			:折扣额
*History			:2016-04-05，modified by syj  */

int iptDiscountCompute(int nozzle, unsigned int volume, unsigned int pricediscount)
{
	unsigned int pdiscount = 0;

	pdiscount = volume*pricediscount/100;

	return pdiscount;
}


/*******************************************************************
*Name				:iptIcBalanceDsp
*Description		:IC卡余额界面显示
*Input				:nozzle				面板号 0=A1枪；1=B1枪
*Output			:无
*Return				:0=成功；其它=失败
*History			:2016-04-05，modified by syj  */

int iptIcBalanceDsp(int nozzle)
{
	IptParamStructType *param = NULL;
	char dsp_buffer[64] = {0};
	int dsp_len = 0;
	
	if(IPT_NOZZLE_1 == nozzle)			param = &IptParamA;
	else if(IPT_NOZZLE_2 == nozzle)	param = &IptParamB;
	else													return ERROR;

	memcpy(&dsp_buffer[0], param->IcAppId, 10);
	memcpy(&dsp_buffer[10], param->IcBalance, 4);
	if(1 == iptIsLianda(param->Id))
	{
		if(0x01 == param->IcDebitUnit)							dsp_buffer[14]=2;
		else if(IPT_PAYUNIT_MONEY==param->PayUnit)	dsp_buffer[14]=0;
		else																		dsp_buffer[14]=1;
	}
	else
	{
		if(IPT_PAYUNIT_MONEY==param->PayUnit)		dsp_buffer[14]=0;
		else																	dsp_buffer[14]=1;
	}
	dsp_buffer[15]=param->Payment;
	if(1 == iptIsLianda(param->Id) && 1 == param->IcDiscountFlag)
	{
		dsp_buffer[16] = (char)((param->OilPrice - param->PriceDiscount)>>8);
		dsp_buffer[17] = (char)((param->OilPrice - param->PriceDiscount)>>0);
	}
	if(1 == iptIsLianda(param->Id))	dsp_buffer[18] = param->IcAppType;
	else												dsp_buffer[18] = 0xff;
	dsp_len=19;
	dsp(param->DEVDsp, DSP_CARD_BALANCE, dsp_buffer, dsp_len);

	return 0;
}




/*******************************************************************
*Name				:iptPrinterRead
*Description		:获取本支付终端对应的打印机
*Input				:nozzle		面板号 0=A1枪；1=B1枪
*Output			:无
*Return				:打印机；失败返回ERROR
*History			:2016-03-11,modified by syj  */

int iptPrinterRead(int nozzle)
{
	if(0 == nozzle)		
		return IptParamA.Printer;
	if(1 == nozzle)		
		return IptParamB.Printer;
	return ERROR;
}


/*******************************************************************
*Name				:iptCardPayForAsk
*Description		:转入/退出支付流程
*Input				:panel		面板号 0=A1枪(IPT_NOZZLE_1)；1=B1枪(IPT_NOZZLE_2)
*						:inbuffer	操作(1byte 0=退出支付流程；1=进入支付流程)
*Output			:无
*Return				:打印机；失败返回ERROR
*History			:2016-03-11,modified by syj  */

int iptCardPayForAsk(int panel, char *inbuffer)
{
	int timer = 0;
	int ihandle = 0;
	
	IptParamStructType *iptparam = NULL;

	if(0 != panel && 1 != panel)	return ERROR;
	if(0 == panel)		iptparam = &IptParamA;
	if(1 == panel)		iptparam = &IptParamB;

	ihandle = *(inbuffer + 0);

	//通知油机进入支付流程，如果已经在非油消费支付界面则返回成功
	if(1 == ihandle &&\
		(IPT_PID_IC_DEBIT_START == iptparam->ProcessId || IPT_PID_IC_DEBIT_DONE == iptparam->ProcessId))
	{
		iptparam->CardDebitAsk = 0;
		return 0;
	}

	//通知油机退出支付流程，如果已经不在密码输入界面则返回成功
	if(0 == ihandle &&\
		(IPT_PID_IC_DEBIT_START != iptparam->ProcessId && IPT_PID_IC_DEBIT_DONE != iptparam->ProcessId))
	{
		iptparam->CardDebitAsk = 0;
		return 0;
	}

	//通过置位请求标识，由ipt任务进行处理，判断ipt任务处理结果，超时未执行成功则返回失败
	if(1 == ihandle)	iptparam->CardDebitAsk = 1;
	else					iptparam->CardDebitAsk = 2;
	for(timer = 0; timer < 2*1000; timer++)
	{
		if((1 == ihandle && (IPT_PID_IC_DEBIT_START == iptparam->ProcessId || IPT_PID_IC_DEBIT_DONE == iptparam->ProcessId))||\
			(1 != ihandle && (IPT_PID_IC_DEBIT_START != iptparam->ProcessId && IPT_PID_IC_DEBIT_DONE != iptparam->ProcessId)))
		{
			iptparam->CardDebitAsk = 0;
			return 0;
		}

		usleep(2000);
	}

	iptparam->CardDebitAsk = 0;

	return 0;
}


/*******************************************************************
*Name				:iptCardPayFor
*Description		:加油卡卡支付
*Input				:panel		面板号 0=A1枪(IPT_NOZZLE_1)；1=B1枪(IPT_NOZZLE_2)
*						:inbuffer	流水号(16bytes、后补空格) + 金额(3bytes、HEX)
*Output			:无
*Return				:打印机；失败返回ERROR
*History			:2016-03-11,modified by syj  */

int iptCardPayFor(int panel, char *inbuffer)
{
	IptParamStructType *iptparam = NULL;

	if(0 != panel && 1 != panel)	return ERROR;
	if(0 == panel)		iptparam = &IptParamA;
	if(1 == panel)		iptparam = &IptParamB;

	//通过置位请求标识，由ipt任务进行处理，判断ipt任务处理结果，超时未执行成功则返回失败
	//taskLock();  //fj:20170914
	iptparam->CardDebitAsk = 3;
	memcpy(iptparam->CardDebitData, inbuffer, 19);
	iptparam->CardDebitAmount = (inbuffer[16]<<16)|(inbuffer[17]<<8)|(inbuffer[18]<<0);
	//taskUnlock(); //fj:20170914

	return 0;
}


/*******************************************************************
*Name				:iptAuthETCPassInput
*Description		:通知IPT转入密码输入界面
*Input				:panel		面板号 0=A1枪；1=B1枪
*						:iHandle	1:通知油机开始输入密码；2:通知油机取消输入密码
*Output			:无
*Return				:成功返回0；失败返回其它值；
*History			:2016-03-11,modified by syj  */

int iptAuthETCPassInput(int panel, unsigned char iHandle)
{
	int timer = 0;
	IptParamStructType *iptparam = NULL;

	if(0 != panel && 1 != panel)	return ERROR;
	if(0 == panel)		iptparam = &IptParamA;
	if(1 == panel)		iptparam = &IptParamB;

	//通知油机开始输入密码，如果已经在密码输入界面则返回成功
	if(1 == iHandle && IPT_PID_AUTH_PASS_INPUT == iptparam->ProcessId)
	{
		iptparam->PassInputAsk = 0;
		return 0;
	}

	//通知油机取消输入密码，如果已经不在密码输入界面则返回成功
	if(2 == iHandle && IPT_PID_AUTH_PASS_INPUT != iptparam->ProcessId)
	{
		iptparam->PassInputAsk = 0;
		return 0;
	}

	//通过置位请求标识，由ipt任务进行处理，判断ipt任务处理结果，超时未执行成功则返回失败
	iptparam->PassInputAsk = iHandle;
	for(timer = 0; timer < 2*1000; timer++)
	{
		if((1 == iHandle && IPT_PID_AUTH_PASS_INPUT == iptparam->ProcessId)||\
			(1 != iHandle && IPT_PID_AUTH_PASS_INPUT != iptparam->ProcessId))
		{
			iptparam->PassInputAsk = 0;
			return 0;
		}

		usleep(2000);
	}

	iptparam->PassInputAsk = 0;
	return ERROR;
}


/*******************************************************************
*Name				:iptAuthorize
*Description		:对油机授权
*Input				:panel		面板号 0=A1枪；1=B1枪
*						:iHandle	操作 0=授权；1=取消授权
*						:inbuffer	授权数据
*						:				授权额4HEX + 
*						:				授权方式1Bin (00H=ETC; 01H=微信; 02H=支付宝;)+
*						:				ETC支付时后续数据:天线ID（1byte）+天线MAC号（4bytes）+ OBU合同序列号(8bytes)+车牌号（12bytes）+卡号（10bytes）)
*						:				微信或支付宝支付时暂无后续数据
*Output			:无
*Return			:成功返回0；失败返回其它值；
*History			:2016-03-11,modified by syj  */

int iptAuthorize(int panel, unsigned char iHandle, char *inbuffer)
{
	int timer = 0;
	unsigned char auth_type = 0;
	IptParamStructType *iptparam = NULL;

	if(0 != panel && 1 != panel)	return ERROR;
	if(0 == panel)		iptparam = &IptParamA;
	if(1 == panel)		iptparam = &IptParamB;

	//对油机授权，已处于授权界面则直接返回成功
	if(0 == iHandle && IPT_PID_AUTH_BALANCE == iptparam->ProcessId)
	{
		iptparam->AuthorizeAsk = 0;
		return 0;
	}

	//取消油机授权，已非授权界面则直接返回成功
	if(1 == iHandle && IPT_PID_AUTH_BALANCE != iptparam->ProcessId)
	{
		iptparam->AuthorizeAsk = 0;
		return 0;
	}


	//通过置位请求标识，由ipt任务进行处理，判断ipt任务处理结果，超时未执行成功则返回失败
	//如果是授权操作则保存授权数据并申请授权，如果是取消授权操作则清除授权数据
	
	//taskLock();  //fj:20170914
	memset(iptparam->AuthorizeData, 0, sizeof(iptparam->AuthorizeData));
	if(0 == iHandle)
	{
		auth_type = inbuffer[4];
		iptparam->AuthorizeAsk = 1;	
		if(0x00 == auth_type)	memcpy(iptparam->AuthorizeData, inbuffer, 40);
		else									memcpy(iptparam->AuthorizeData, inbuffer, 5);
	}
	else
	{
		iptparam->AuthorizeAsk = 2;	
	}
	//taskUnlock(); //fj:20170914
	
	for(timer = 0; timer < 2*1000; timer++)
	{
		if((0 == iHandle && IPT_PID_AUTH_BALANCE == iptparam->ProcessId)||\
			(1 == iHandle && IPT_PID_AUTH_BALANCE != iptparam->ProcessId))
		{
			iptparam->AuthorizeAsk = 0;
			return 0;
		}

		usleep(2000);
	}

	iptparam->AuthorizeAsk = 0;

	return ERROR;
}


/*******************************************************************
*Name				:iptCardDebit
*Description		:加油卡扣款
*Input				:panel		面板号 0=A1枪；1=B1枪
*						:inbuffer	扣款数据(金额(3HEX))
*Output			:无
*Return				:成功返回0；失败返回其它值；
*History			:2016-05-16,modified by syj  */

int iptCardDebit(int panel, char *inbuffer)
{
	//__IC卡灰锁初始化信息
	unsigned char IcLockInitBalance[4] = {0};			//灰锁初始化返回:卡余额
	unsigned char IcLockInitCTC[2] = {0};				//灰锁初始化返回:脱机交易序号
	unsigned char IcLockInitOverdraw[3] = {0};		//灰锁初始化返回:透支限额
	unsigned char IcLockInitKeysVersion = 0;			//灰锁初始化返回:密钥版本号
	unsigned char IcLockInitArithmetic = 0;				//灰锁初始化返回:算法标识
	unsigned char IcLockInitRandom[4] = {0};			//灰锁初始化返回:伪随机数
	//__PSAM计算MAC1
	unsigned char IcPsamTTC[4] = {0};					//PSAM返回:终端交易序号
	unsigned char IcPsamRandom[4] = {0};				//PSAM返回:终端随机数
	unsigned char IcPsamMAC1[4] = {0};					//PSAM返回:MAC1
	//__IC卡灰锁
	unsigned char IcGTAC[4] = {0};							//IC灰锁返回:GTAC
	unsigned char IcMAC2[4] = {0};							//IC灰锁返回:MAC2
	//__加油过程
	//__PSAM计算GMAC
	unsigned char IcPsamGMAC[4] = {0};					//PSAM返回:GMAC
	unsigned char IcPsamTAC[4] = {0};					//PSAM返回:TAC
	//__IC卡解扣返回数据
	unsigned char IcTac[4] = {0};								//IC解扣返回:TAC

	char buffer[128] = {0};
	int apdu_len = 0;

	char irandom[32] = {0};
	char imiwen[32] = {0};

	char itime[7] = {0};
	RTCTime rtc;

	int ttc_value = 0;

	unsigned ibanlance = 0,imoney = 0;
	
	int istate = 0;
	IptParamStructType *iptparam = NULL;

	if(0 != panel && 1 != panel)	return ERROR;
	if(0 == panel)		iptparam = &IptParamA;
	if(1 == panel)		iptparam = &IptParamB;

	//获取当前时间
	timeRead(&rtc);
	*(itime + 0) = rtc.century;	*(itime + 1) = rtc.year;		*(itime + 2) = rtc.month;	*(itime + 3) = rtc.date;
	*(itime + 4) = rtc.hour;			*(itime + 5) = rtc.minute;	*(itime + 6) = rtc.second;


	//计算并判断余额
	imoney = (inbuffer[0]<<16)|(inbuffer[1]<<8)|(inbuffer[2]<<0);
	ibanlance = (iptparam->IcBalance[0]<<24)|(iptparam->IcBalance[1]<<16)|(iptparam->IcBalance[2]<<8)|(iptparam->IcBalance[3]<<0);
	if(imoney > ibanlance)
	{
		jljRunLog("卡余额不足!\n");
		return ERROR;
	}


	//判断是否需要安全认证
	if(0 != iptparam->DESAuthen)
	{
		goto I_ICLockInit;
	}


I_PsamGetAPProof:
	//判断安全提升状态
	istate = PsamGetAPProof(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128);
	if(OK != istate)
	{
		jljRunLog("获取安全提升状态失败!\n");
		return ERROR;
	}
	if(ICSTATE_OK == istate)
	{
		apdu_len = (buffer[0]<<8)|(buffer[1]<<0);
		if(0 == memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
		{
		}
		else
		{
			jljRunLog("获取安全提升状态失败[%x%x]!\n", buffer[2+apdu_len-2], buffer[2+apdu_len-1]);
			return ERROR;
		}
	}


I_PsamGetRandom:
	//向PSAM申请随机数
	istate = PsamGetRandom(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128);
	if(ICSTATE_OK != istate)
	{
		jljRunLog("安全提升申请随机数失败\n");
		return ERROR;
	}
	if(ICSTATE_OK == istate)
	{
		apdu_len = (buffer[0]<<8)|(buffer[1]<<0);
		if(0 == memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
		{
			memcpy(&irandom[0], &buffer[2], 4);					//随机数
			memcpy(&irandom[4], "\x00\x00\x00\x00", 4);	//随机数后补0
			des_en3(Key, irandom, 8, imiwen);
		}
		else
		{
			jljRunLog("安全提升申请随机数失败[%x%x]!\n", buffer[2+apdu_len-2], buffer[2+apdu_len-1]);
			return ERROR;
		}
	}


I_PsamAPAuthen:
	//向PSAM进行安全提升认证 ANTI-PLAGIAREZE AUTHENTICATION
	istate = PsamAPAuthen(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, imiwen);
	if(ICSTATE_OK != istate)
	{
		jljRunLog("安全认证失败\n");
		return ERROR;
	}
	if(ICSTATE_OK == istate)
	{
		apdu_len = (buffer[0]<<8)|(buffer[1]<<0);
		if(0 == memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
		{
		}
		else
		{
			jljRunLog("安全认证失败[%x%x]!\n", buffer[2+apdu_len-2], buffer[2+apdu_len-1]);
			return ERROR;
		}
	}


I_ICLockInit:
	//IC卡灰锁初始化
	istate = ICLockInit(iptparam->DEVIC, 0, buffer, 128, iptparam->PsamKeyIndex, iptparam->PsamTermId);
	if(ICSTATE_OK != istate)
	{
		jljRunLog("IC卡灰锁初始化失败\n");
		return ERROR;
	}
	if(ICSTATE_OK == istate)
	{
		apdu_len = (buffer[0]<<8)|(buffer[1]<<0);
		if(0 == memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
		{
			memcpy(IcLockInitBalance, &buffer[2], 4);		//灰锁初始化返回卡余额		
			memcpy(IcLockInitCTC, &buffer[6], 2);				//灰锁初始化返回脱机交易序号
			memcpy(IcLockInitOverdraw, &buffer[8], 3);		//灰锁初始化返回透支限额
			IcLockInitKeysVersion=buffer[11];						//灰锁初始化返回密钥版本号		
			IcLockInitArithmetic=buffer[12];						//灰锁初始化返回算法标识	
			memcpy(IcLockInitRandom, &buffer[13], 4);		//灰锁初始化返回伪随机数
		}
		else
		{
			jljRunLog("IC卡灰锁初始化失败[%x%x]!\n", buffer[2+apdu_len-2], buffer[2+apdu_len-1]);
			return ERROR;
		}
	}


I_PsamLockInit:
	//PSAM卡灰锁初始化
	istate = PsamLockInit(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, IcLockInitRandom, IcLockInitCTC, IcLockInitBalance, itime, IcLockInitKeysVersion, IcLockInitArithmetic, &iptparam->IcAppId[2],  iptparam->IcIssuerMark);
	if(ICSTATE_OK != istate)
	{
		jljRunLog("PSAM灰锁初始化计算MAC1失败!\n");
		return ERROR;
	}
	if(ICSTATE_OK == istate)
	{
		apdu_len = (buffer[0]<<8)|(buffer[1]<<0);
		if(0 == memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
		{
			memcpy(IcPsamTTC, &buffer[2], 4);			//PSAM返回终端交易序号
			memcpy(IcPsamRandom, &buffer[6], 4);	//PSAM返回终端随机数
			memcpy(IcPsamMAC1, &buffer[10], 4);		//PSAM返回MAC1
		}
		else
		{
			jljRunLog("PSAM灰锁初始化计算MAC1失败[%x%x]!\n", buffer[2+apdu_len-2], buffer[2+apdu_len-1]);
			return ERROR;
		}
	}


I_ICGreyLock:
	//IC卡灰锁
	istate = ICGreyLock(iptparam->DEVIC, 0, buffer, 128, IcPsamTTC, IcPsamRandom, itime, IcPsamMAC1);
	if(ICSTATE_OK != istate)
	{
		jljRunLog("IC卡灰锁失败!\n");
		return ERROR;
	}
	if(ICSTATE_OK == istate)
	{
		apdu_len = (buffer[0]<<8)|(buffer[1]<<0);
		if(0 == memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
		{
			//保存数据
			memcpy(IcGTAC, &buffer[2], 4);	//IC灰锁返回GTAC
			memcpy(IcMAC2, &buffer[6], 4);	//IC灰锁返回MAC2

			//灰锁成功后脱机交易序号自加一位
			ttc_value = (IcLockInitCTC[0]<<8)|(IcLockInitCTC[1]<<0);
			ttc_value++;
			IcLockInitCTC[0]=(unsigned char)(ttc_value>>8);	IcLockInitCTC[1]=(unsigned char)(ttc_value>>0);
		}
		else
		{
			jljRunLog("IC卡灰锁失败[%x%x]!\n", buffer[2+apdu_len-2], buffer[2+apdu_len-1]);
			return ERROR;
		}
	}


I_PsamMAC2Check:
	//PSAM卡验证MAC2
	istate = PsamMAC2Check(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, IcMAC2);
	if(ICSTATE_OK != istate)
	{
		jljRunLog("PSAM卡验证MAC2失败!\n");
		return ERROR;
	}
	if(ICSTATE_OK == istate)
	{
		apdu_len = (buffer[0]<<8)|(buffer[1]<<0);
		if(0 == memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
		{
		}
		else
		{
			jljRunLog("PSAM卡验证MAC2失败[%x%x]!\n", buffer[2+apdu_len-2], buffer[2+apdu_len-1]);
			return ERROR;
		}
	}


I_PsamGMAC:
	//计算GMAC
	istate = PsamGMAC(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, &iptparam->IcAppId[2], IcLockInitCTC, imoney);
	if(ICSTATE_OK != istate)
	{
		jljRunLog("PSAM卡计算GMAC失败!\n");
		return ERROR;
	}
	if(ICSTATE_OK == istate)
	{
		apdu_len = (buffer[0]<<8)|(buffer[1]<<0);
		if(0 == memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
		{
			memcpy(IcPsamGMAC, &buffer[2], 4);	//PSAM返回GMAC
			memcpy(IcPsamTAC, &buffer[6], 4);		//PSAM返回TAC
		}
		else
		{
			jljRunLog("PSAM卡计算GMAC失败[%x%x]!\n", buffer[2+apdu_len-2], buffer[2+apdu_len-1]);
			return ERROR;
		}
	}


I_ICGreyUnlock:
	//IC卡解扣
	istate = ICGreyUnlock(iptparam->DEVIC, 0, buffer, 128, imoney, IcLockInitCTC, iptparam->PsamTermId, IcPsamTTC, itime, IcPsamGMAC);
	if(ICSTATE_OK != istate)
	{
		jljRunLog("IC卡解扣失败!\n");
		return ERROR;
	}
	//操作成功，继续执行下一步
	if(ICSTATE_OK == istate)
	{
		apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
		if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
		{
		}
		else
		{
			jljRunLog("IC卡解扣失败[%x%x]!\n", buffer[2+apdu_len-2], buffer[2+apdu_len-1]);
			return ERROR;
		}
	}


I_ICTacClr:
	//IC卡TAC标识清除
	istate = ICTacClr(iptparam->DEVIC, 0, buffer, 128);
	if(ICSTATE_OK != istate)
	{
		jljRunLog("IC卡TAC标识清除失败!\n");
		return ERROR;
	}
	//操作成功，继续执行下一步
	if(ICSTATE_OK == istate)
	{
		apdu_len = (buffer[0]<<8)|(buffer[1]<<0);
		if(0 == memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
		{
		}
		else
		{
			jljRunLog("IC卡TAC标识清除失败[%x%x]!\n", buffer[2+apdu_len-2], buffer[2+apdu_len-1]);
			return ERROR;
		}
	}
	
	return 0;
}


/*******************************************************************
*Name				:iptExterSuspendDo
*Description		:外部命令通知油机暂停/恢复使用
*Input				:panel		面板号 0=A1枪；1=B1枪
*						:handle		0 = 恢复使用；1 = 暂停使用；
*Output			:无
*Return				:成功返回0；失败返回其它值；
*History			:2016-05-16,modified by syj  */

int iptExterSuspendDo(int panel, int handle, char *ibuffer)
{
	IptParamStructType *iptparam = NULL;

	if(0 != panel && 1 != panel)	return ERROR;
	if(0 == panel)		iptparam = &IptParamA;
	if(1 == panel)		iptparam = &IptParamB;

	if(1 == handle)
	{
		iptparam->IsSuspend = 1;
	}
	else
	{
		iptparam->IsSuspend = 0;
	}

	return 0;
}


/*******************************************************************
*Name				:iptExterPreset
*Description		:外部命令通知油机预置量
*Input				:panel		面板号 0=A1枪；1=B1枪
*						:inbuffer	预置量 4HEX + 预置方式1HEX(0 = 预置升数；1 = 预置金额；)
*Output			:无
*Return				:成功返回0；失败返回其它值；
*History			:2016-05-16,modified by syj  */

int iptExterPreset(int panel, char *inbuffer)
{
	int timer = 0;
	IptParamStructType *iptparam = NULL;

	if(0 != panel && 1 != panel)	return ERROR;
	if(0 == panel)		iptparam = &IptParamA;
	if(1 == panel)		iptparam = &IptParamB;

	//通过置位请求标识，由ipt任务进行处理，判断ipt任务处理结果，超时未执行成功则返回失败
	//taskLock();  //fj:20170914
	iptparam->CardPresetAsk = 1;
	iptparam->CardPresetValue = (inbuffer[0]<<24)|(inbuffer[1]<<16)|(inbuffer[2]<<8)|(inbuffer[3]<<0);
	if(0 == *(inbuffer + 4))	iptparam->CardPresetMode = 0;
	else									iptparam->CardPresetMode = 1;
	iptparam->CardPresetRep = 0xFF;
	//taskUnlock(); //fj:20170914
	
	for(timer = 0; timer < 2*1000; timer++)
	{
		if(0 == iptparam->CardPresetRep)
		{
			iptparam->CardPresetAsk = 0xFF;
			return 0;
		}

		if(1 == iptparam->CardPresetRep)
		{
			iptparam->CardPresetAsk = 0xFF;
			return ERROR;
		}

		usleep(2000);
	}
	
	iptparam->CardPresetAsk = 0xFF;
	
	return ERROR;
}


/*******************************************************************
*Name				:iptExterCardAppSet
*Description		:外部命令通知油机加油卡应用选择
*Input				:panel		面板号 0=A1枪；1=B1枪
*						:inbuffer	预置量 1HEX(0 = 电子油票；1 = 积分应用；)
*Output			:无
*Return				:成功返回0；失败返回其它值；
*History			:2016-05-16,modified by syj  */

int iptExterCardAppSet(int panel, char *inbuffer)
{
	return 0;
}


/*******************************************************************
*Name				:iptExterCardPaymentSet
*Description		:外部命令通知油机加油卡支付方式选择
*Input				:panel		面板号 0=A1枪；1=B1枪
*						:inbuffer	预置量 1HEX(0 = 现金；1 = 油票；2 = 提油凭证；3 = 银行卡；4 = 其它一；5 = 其它二)
*Output			:无
*Return				:成功返回0；失败返回其它值；
*History			:2016-05-16,modified by syj  */

int iptExterCardPaymentSet(int panel, char *inbuffer)
{
	return 0;
}


/*******************************************************************
*Name				:iptExterCardShoot
*Description		:外部命令通知油机加油卡退卡
*Input				:panel		面板号 0=A1枪；1=B1枪
*Output			:无
*Return				:成功返回0；失败返回其它值；
*History			:2016-05-16,modified by syj  */

int iptExterCardShoot(int panel)
{
	int timer = 0;
	IptParamStructType *iptparam = NULL;

	if(0 != panel && 1 != panel)	return ERROR;
	if(0 == panel)		iptparam = &IptParamA;
	if(1 == panel)		iptparam = &IptParamB;

	//通过置位请求标识，由ipt任务进行处理，判断ipt任务处理结果，超时未执行成功则返回失败
	//taskLock();  //fj:20170914
	iptparam->CardShootAsk = 1;
	iptparam->CardShootRep = 0xFF;
	//taskUnlock(); //fj:20170914

	for(timer = 0; timer < 2*1000; timer++)
	{
		if(0 == iptparam->CardShootRep)
		{
			iptparam->CardShootAsk = 0xFF;
			return 0;
		}

		if(1 == iptparam->CardShootRep)
		{
			iptparam->CardShootAsk = 0xFF;
			return ERROR;
		}

		usleep(2000);
	}
	
	iptparam->CardShootAsk = 0xFF;

	return ERROR;
}


/*******************************************************************
*Name				:iptExterScanStart
*Description		:外部命令通知油机加油启动条码扫描
*Input				:panel		面板号 0=A1枪；1=B1枪
*						:handle		操作 0 = 开启条码扫描；1 = 退出条码扫描
*Output			:无
*Return				:成功返回0；失败返回其它值；
*History			:2016-06-23,modified by syj  */

int iptExterScanHandle(int panel, int handle)
{
	int timer = 0;
	IptParamStructType *iptparam = NULL;

	if(0 != panel && 1 != panel)	return ERROR;
	if(0 == panel)		iptparam = &IptParamA;
	if(1 == panel)		iptparam = &IptParamB;

	//判断当前是否已处于操作请求的目的状态
	if((0 == handle && IPT_PID_TM_SCAN == iptparam->ProcessId)||\
		(0 != handle && IPT_PID_TM_SCAN != iptparam->ProcessId))
	{
		return 0;
	}

	//通过置位请求标识，由ipt任务进行处理，判断ipt任务处理结果，超时未执行成功则返回失败
	//taskLock();  //fj:20170914
	if(0 == handle)	iptparam->TMScanAsk = 1;
	else						iptparam->TMScanAsk = 2;
	iptparam->TMScanRep = 0xFF;
	//taskUnlock(); //fj:20170914

	//判断操作结果
	for(timer = 0; timer < 2*1000; timer++)
	{
		if((1 == iptparam->TMScanAsk && IPT_PID_TM_SCAN == iptparam->ProcessId) || 0 == iptparam->TMScanRep)
		{
			iptparam->TMScanAsk = 0;	iptparam->TMScanRep = 0xFF;
			return 0;
		}

		if((2 == iptparam->TMScanAsk && IPT_PID_TM_SCAN != iptparam->ProcessId) || 0 == iptparam->TMScanRep)
		{
			iptparam->TMScanAsk = 0;	iptparam->TMScanRep = 0xFF;
			return ERROR;
		}

		usleep(2000);
	}
	
	iptparam->TMScanAsk = 0;	iptparam->TMScanRep = 0xFF;

	return ERROR;
}


/*******************************************************************
*Name				:iptExterBarcodeInput
*Description		:外部命令通知油机加油扫描或输入的条码
*Input				:panel		面板号 0=A1枪；1=B1枪
*						:handle		0 = 正在输入条码；1 = 条码输入完毕；
*						:inbuffer	条码位数(1HEX) + 条码(nASCII)
*						:				注: 仅handle = 0时有此数据
*Output			:无
*Return				:成功返回0；失败返回其它值；
*History			:2016-06-23,modified by syj  */

int iptExterBarcodeInput(int panel, int handle, char *inbuffer)
{
	IptParamStructType *iptparam = NULL;

	if(0 != panel && 1 != panel)	return ERROR;
	if(0 == panel)		iptparam = &IptParamA;
	if(1 == panel)		iptparam = &IptParamB;

	//taskLock();  //fj:20170914
	if(0 == handle)
	{
		if(*(inbuffer + 0) <= 10)	iptparam->TMNumberLenght = *(inbuffer + 0);
		else									iptparam->TMNumberLenght = 10;
		memcpy(iptparam->TMNumber, inbuffer + 1, iptparam->TMNumberLenght);
		iptparam->TMExterInputDone = 1;
	}
	else
	{
		iptparam->TMExterInputDone = 2;
	}
	//taskUnlock(); //fj:20170914

	return 0;
}


/*******************************************************************
*Name				:iptMainUserSet
*Description		:设置支付终端主用户ID，当只有一个支付终端可以占用资源时通过此接口设置占用资源的用户ID
*Input				:user		用户ID，0表示空闲
*Output			:无
*Return				:成功返回0；失败返回其它值；
*History			:2016-05-10,modified by syj  */

int iptMainUserSet(int user)
{
	iptMainUser = user;

	return 0;
}




/*******************************************************************
*Name				:iptPhysicalNozzleRead
*Description		:获取本支付终端对应的逻辑枪号
*Input				:nozzle		面板号 0=A1枪；1=B1枪
*Output			:无
*Return				:逻辑枪号；失败返回ERROR
*History			:2016-03-11,modified by syj  */

int iptPhysicalNozzleRead(int nozzle)
{
	unsigned int Gun_BCD=0;
#if 0
	if(0 == nozzle)		return IptParamA.LogicNozzle;
	if(1 == nozzle)		return IptParamB.LogicNozzle;
#endif

	if(0 == nozzle)
	{
		Gun_BCD=(IptParamA.LogicNozzle/10)*0x10+(IptParamA.LogicNozzle%10);
		return Gun_BCD;
	}
	if(1 == nozzle)
	{
		Gun_BCD=(IptParamB.LogicNozzle/10)*0x10+(IptParamB.LogicNozzle%10);
		return Gun_BCD;
	}
	
	return ERROR;
}

/*******************************************************************
*Name				:iptMsgIdRead
*Description		:获取IPT接收消息队列ID
*Input				:nozzle	面板号
*Output			:None
*Return				:消息队列ID
*History			:2013-07-01,modified by syj  */
//fj:20170914修改

int iptMsgIdRead(int nozzle)
{
	if(IPT_NOZZLE_1==nozzle)			
		return IptParamA.MsgIdRx;
	else if(IPT_NOZZLE_2==nozzle)	
		return IptParamB.MsgIdRx;
	else												
		return ERROR;
}


/*******************************************************************
*Name				:iptPassCalculate
*Description		:计算开发操作密码
*Input				:in_buffer	明码，固定6bytes，HEX码
*Output			:out_buffer	密码，固定6bytes，HEX码
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptPassCalculate(const unsigned char *in_buffer, unsigned char *out_buffer)
{
	unsigned char mingwen[8]={0}, miwen[8]={0};
	unsigned char key[16]={0x09,0x07,0x09,0x08,0x05,0x05,0x00,0x00,0x09,0x07,0x09,0x08,0x05,0x05,0x00,0x00};

	memcpy(&mingwen[0], in_buffer, 6);	mingwen[6]=0x09;	mingwen[7]=0x09;
	des_en3(key, mingwen, 8, miwen);	
	out_buffer[0]=miwen[0]%10;	out_buffer[1]=miwen[1]%10;	
	out_buffer[2]=miwen[2]%10;	out_buffer[3]=miwen[3]%10;	
	out_buffer[4]=miwen[4]%10;	out_buffer[5]=miwen[5]%10;

	return;
}


/*******************************************************************
*Name				:iptParamInit
*Description		:IPT数据初始化
*Input				:nozzle	面板号0=A1枪；1=B1枪
*Output			:None
*Return				:None
*History			:2014-04-10,modified by syj  */

int iptParamInit(int nozzle)
{
	unsigned char wrbuffer[16]={0}, rdbuffer[16]={0};
	int i=0, istate=0, rdbytes=0;

	if(0==nozzle)
	{
		//铁电数据清空
		for(i=0; i<IPT_FM_DATALEN; i++)	framWrite(FM_ADDR_IPT_SINO, IPT_FM_DATALEN*nozzle+i, "\x00", 1);
		for(i=0; i<IPT_FM_DATALEN; i++)	
		{
			rdbytes=framRead(FM_ADDR_IPT_SINO, IPT_FM_DATALEN*nozzle+i, rdbuffer, 1);
			if((0!=rdbytes)||(0x00!=rdbuffer[0]))	istate=1;
		}

		//szb_fj_20171120:add
	    framWrite(FM_ADDR_IPT_SINO, IPT_FM_DATALEN*nozzle+FM_ERR_BIAN_PRICE,"\x00",1);
		//上/下班信息清空
		if(0!=paramSetupWrite(IPT0_DUTY_INFO, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 14))	istate=1;
		//扬声器选择:扬声器A1
		if(0!=paramSetupWrite(IPT0_VOICE_SPEAKER, "\x10", 1))	istate=1;
		//语音类型:女声
		if(0!=paramSetupWrite(IPT0_VOICE_TYPE, "\x00", 1))			istate=1;						
		//音量:98
		if(0!=paramSetupWrite(IPT0_VOICE_VOLUME, "\x62", 1))		istate=1;					
		//打印机选择:打印机A1
		if(0!=paramSetupWrite(IPT0_PRINTER, "\x10", 1))				istate=1;			
		//自动打印标识:自动打印 (不自动打印)
		if(0!=paramSetupWrite(IPT0_PRINT_AUTO, "\x00", 1))			istate=1;						
		//打印联数:打印一联
		if(0!=paramSetupWrite(IPT0_PRINT_UNION, "\x00", 1))		istate=1;							
		//用户卡账单自动打印类型:全部
		if(0!=paramSetupWrite(IPT0_PRN_CARD_USER, "\x03\xff", 2))				istate=1;	
		//管理卡账单自动打印类型:全部
		if(0!=paramSetupWrite(IPT0_PRN_CARD_MANAGE, "\x03\xff", 2))		istate=1;
		//员工卡账单自动打印类型:全部
		if(0!=paramSetupWrite(IPT0_PRN_CARD_STAFF, "\x03\xff", 2))			istate=1;
		//验泵卡账单自动打印类型:全部
		if(0!=paramSetupWrite(IPT0_PRN_CARD_PUMP, "\x03\xff", 2))				istate=1;
		//维修卡账单自动打印类型:全部
		if(0!=paramSetupWrite(IPT0_PRN_CARD_SERVICE, "\x03\xff", 2))		istate=1;
		//夜间锁定:无锁定
		if(0!=paramSetupWrite(IPT0_NIGHT_LOCK, "\x00", 1))							istate=1;
		//逻辑枪号:1
		if(0!=paramSetupWrite(IPT0_LOGIC_NOZZLE, "\x01", 1))						istate=1;
		//物理枪号:1
		if(0!=paramSetupWrite(IPT0_PHYSICAL_NOZZLE, "\x01", 1))				istate=1;
		//操作密码:0000
		if(0!=paramSetupWrite(IPT0_PASSWORD, IPT_STAPASS_DEFAULT, 2))	istate=1;
		//工作模式:卡机联动
		if(0!=paramSetupWrite(IPT0_WORKMODE, "\x00", 1))							istate=1;
		//维护密码:9999
		if(0!=paramSetupWrite(IPT0_SERVICE_PASS, IPT_SERVEPASS_DEFAULT, 2))				istate=1;
		//是否认证:是
		if(0!=paramSetupWrite(IPT0_AUTHEN, "\x00", 1))									istate=1;
		//油品油价信息:油品号+价格+版本号
		if(0!=paramSetupWrite(IPT0_PRICE_INFO, "\x10\x10\x00\x64\x00", 5))							istate=1;
		//(A1枪)员工卡加油限制信息,1HEX，默认为不限制
		if(0!=paramSetupWrite(IPT0_STAFF_LIMIT, "\x00", 1))							istate=1;
		//(A1枪)绑定信息，时间，7BCD，默认为0
		if(0!=paramSetupWrite(IPT0_BIND_TIME, "\x00\x00\x00\x00\x00\x00\x00", 7))							istate=1;
		//(A1枪)绑定信息，主板号，8BCD，默认为0
		if(0!=paramSetupWrite(IPT0_BIND_MBOARD_ID, "\x00\x00\x00\x00\x00\x00\x00\x00", 8))		istate=1;
		//(A1枪)绑定信息，ACT卡号，10BCD，默认为0
		if(0!=paramSetupWrite(IPT0_BIND_ACT_APPID, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 10))			istate=1;
		//(A1枪)绑定信息，RID卡号，10BCD
		if(0!=paramSetupWrite(IPT0_STAFF_LIMIT, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 10))							istate=1;
		//(A1枪)油品语音代码信息，即语音文件的数字前缀，4ASCII, "\x00\x00\x00\x00"表示无指定
		if(0!=paramSetupWrite(IPT0_OIL_VOICE, "\x00\x00\x00\x00", 4))		istate=1;
		//(A1枪)键盘显示对比度，1HEX，默认为32
		if(0!=paramSetupWrite(IPT0_CONTRAST, "\x20", 1))							istate=1;
	}
	else
	{
		//铁电数据清空
		for(i=0; i<IPT_FM_DATALEN; i++)	framWrite(FM_ADDR_IPT_SINO, IPT_FM_DATALEN*nozzle+i, "\x00", 1);
		for(i=0; i<IPT_FM_DATALEN; i++)	
		{
			rdbytes=framRead(FM_ADDR_IPT_SINO, IPT_FM_DATALEN*nozzle+i, rdbuffer, 1);
			if((0!=rdbytes)||(0x00!=rdbuffer[0]))	istate=1;
		}

		//szb_fj_20171120:add
        framWrite(FM_ADDR_IPT_SINO, IPT_FM_DATALEN*nozzle+FM_ERR_BIAN_PRICE,"\x00",1);
		
		//上/下班信息清空
		if(0!=paramSetupWrite(IPT1_DUTY_INFO, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 14))	istate=1;
		//扬声器选择:扬声器A2
		if(0!=paramSetupWrite(IPT1_VOICE_SPEAKER, "\x11", 1))	istate=1;
		//语音类型:女声
		if(0!=paramSetupWrite(IPT1_VOICE_TYPE, "\x00", 1))			istate=1;						
		//音量:98
		if(0!=paramSetupWrite(IPT1_VOICE_VOLUME, "\x62", 1))		istate=1;					
		//打印机选择:打印机A2
		if(0!=paramSetupWrite(IPT1_PRINTER, "\x11", 1))				istate=1;				
		//自动打印标识:自动打印 (不自动打印)
		if(0!=paramSetupWrite(IPT1_PRINT_AUTO, "\x00", 1))		istate=1;						
		//打印联数:打印一联
		if(0!=paramSetupWrite(IPT1_PRINT_UNION, "\x00", 1))		istate=1;							
		//用户卡账单自动打印类型:无
		if(0!=paramSetupWrite(IPT1_PRN_CARD_USER, "\x03\xff", 2))				istate=1;	
		//管理卡账单自动打印类型:无
		if(0!=paramSetupWrite(IPT1_PRN_CARD_MANAGE, "\x03\xff", 2))		istate=1;
		//员工卡账单自动打印类型:无
		if(0!=paramSetupWrite(IPT1_PRN_CARD_STAFF, "\x03\xff", 2))			istate=1;
		//验泵卡账单自动打印类型:无
		if(0!=paramSetupWrite(IPT1_PRN_CARD_PUMP, "\x03\xff", 2))				istate=1;
		//维修卡账单自动打印类型:无
		if(0!=paramSetupWrite(IPT1_PRN_CARD_SERVICE, "\x03\xff", 2))		istate=1;
		//夜间锁定:无锁定
		if(0!=paramSetupWrite(IPT1_NIGHT_LOCK, "\x00", 1))							istate=1;
		//逻辑枪号:2
		if(0!=paramSetupWrite(IPT1_LOGIC_NOZZLE, "\x02", 1))						istate=1;
		//物理枪号:2
		if(0!=paramSetupWrite(IPT1_PHYSICAL_NOZZLE, "\x02", 1))				istate=1;
		//操作密码:0000
		if(0!=paramSetupWrite(IPT1_PASSWORD, IPT_STAPASS_DEFAULT, 2))					istate=1;
		//工作模式:卡机联动
		if(0!=paramSetupWrite(IPT1_WORKMODE, "\x00", 1))							istate=1;
		//维护密码:9999
		if(0!=paramSetupWrite(IPT1_SERVICE_PASS, IPT_SERVEPASS_DEFAULT, 2))				istate=1;
		//是否认证:是
		if(0!=paramSetupWrite(IPT1_AUTHEN, "\x00", 1))									istate=1;
		//油品油价信息:油品号+价格+版本号
		if(0!=paramSetupWrite(IPT1_PRICE_INFO, "\x10\x11\x00\x64\x00", 5))							istate=1;
		//(B1枪)员工卡加油限制信息,1HEX，默认为不限制
		if(0!=paramSetupWrite(IPT1_STAFF_LIMIT, "\x00", 1))							istate=1;
		//(B1枪)绑定信息，时间，7BCD，默认为0
		if(0!=paramSetupWrite(IPT1_BIND_TIME, "\x00\x00\x00\x00\x00\x00\x00", 7))							istate=1;
		//(B1枪)绑定信息，主板号，8BCD，默认为0
		if(0!=paramSetupWrite(IPT1_BIND_MBOARD_ID, "\x00\x00\x00\x00\x00\x00\x00\x00", 8))		istate=1;
		//(B1枪)绑定信息，ACT卡号，10BCD，默认为0
		if(0!=paramSetupWrite(IPT1_BIND_ACT_APPID, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 10))			istate=1;
		//(B1枪)绑定信息，RID卡号，10BCD
		if(0!=paramSetupWrite(IPT1_STAFF_LIMIT, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 10))							istate=1;
		//(B1枪)油品语音代码信息，即语音文件的数字前缀，4ASCII, "\x00\x00\x00\x00"表示无指定
		if(0!=paramSetupWrite(IPT1_OIL_VOICE, "\x00\x00\x00\x00", 4))		istate=1;
		//(B1枪)键盘显示对比度，1HEX，默认为32
		if(0!=paramSetupWrite(IPT1_CONTRAST, "\x20", 1))							istate=1;
	}

	//主板号，默认为1
	if(0!=paramSetupWrite(PRM_MBOARD_ID, "\x01", 1))								istate=1;
	//销售锁定:无
	if(0!=paramSetupWrite(PRM_SELL_LOCK, "\x00", 1))								istate=1;
	//背光控制:常亮
	if(0!=paramSetupWrite(PRM_BACKLIT, "\x00", 1))									istate=1;
	//销售锁定时间，4BCD(YYYYMMDD)+是否已锁定1byte，不锁定
	if(0!=paramSetupWrite(PRM_SELL_LOCK_TIME, "\x00\x00\x00\x00\x00", 5))	istate=1;
	//单面枪数 4HEX，0=单面单枪；1=单面双枪
	if(0!=paramSetupWrite(PRM_NOZZLE_NUMBER, "\x00\x00\x00\x00", 4))	istate=1;
	//A面条码扫描模块品牌，1ASCII
	wrbuffer[0] = YUANJD_LV1000;
	if(0!=paramSetupWrite(PRM_BARCODE_BRAND_A, wrbuffer, 1))				istate=1;
	//B面条码扫描模块品牌，1ASCII
	wrbuffer[0] = YUANJD_LV1000;
	if(0!=paramSetupWrite(PRM_BARCODE_BRAND_B, wrbuffer, 1))				istate=1;
	//机型 4HEX
	wrbuffer[0] = (char)(MODEL_SINOPEC>>24);	wrbuffer[1] = (char)(MODEL_SINOPEC>>16);
	wrbuffer[2] = (char)(MODEL_SINOPEC>>8);		wrbuffer[3] = (char)(MODEL_SINOPEC>>0);
	if(0!=paramSetupWrite(PRM_MODEL, wrbuffer, 4))									istate=1;
	//是否启用促销功能 4HEX 0 =不启用促销；1 = 启用促销功能
	//if(0!=paramSetupWrite(PRM_PROMOTION, "\x00\x00\x00\x00", 4))		istate=1;
	if(0 != paramPromotionSet(0))																	istate=1;
	//卡机联动后台连接方式，默认为电流环串口联网
	if(0 != kjldChannelSet(KJLD_CHANNEL_COM))											istate=1;
	//是否启用油品确认功能:启用
	if(0!=paramSetupWrite(PRM_YuLe_Grade_OK, "\x30", 1))								istate=1;
	//2017-02-13油品限制方式设置1HEX
	if(0!=paramSetupWrite(PRM_OilLimit_Style_Set, "\x32", 1))								istate=1;

	//szb_fj_20171120:ETC功能设置
	if(0!=paramSetupWrite(PRM_ETC_FUN_SET, "\x30", 1))	
		istate=1;

	return istate;
}


/*******************************************************************
*Name				:iptHexVoiceIdGet
*Description		:根据HEX数据获取读数的语音代码
*Input				:data			HEX数据，两位小数点
*Output			:voice_id		目前最多到万位，最多12bytes
*Return				:油品语音代码；失败返回ERROR
*History			:2013-07-01,modified by syj  */

int iptHexVoiceIdGet(const IptParamStructType *iptparam, unsigned int data, int *voice)
{
	unsigned long long bcd_data=0;			//HEX数据的BCD码表示
	int i=0;
	unsigned char number[16]={0};			//BCD码
	int voice_len=0;									//语音代码长度
	int voice_zero=0;								//前面是否有语音0


	//依次保存自高至低七位数字
	bcd_data=hex2Bcd(data);
	for(i=0; i<7; i++)	number[i]=(char)((bcd_data>>((6-i)*4))&0x0f);	//number[i]=(char)((bcd_data>>((6-i)*4))&0x0f);

	
	if(IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType){

		//女声
		//万位
		i=0;
		if(0==number[0])		;
		else
		{
			if(0==number[i])	voice[voice_len++]=SPKW_0;
			if(1==number[i])	voice[voice_len++]=SPKW_1;
			if(2==number[i])	voice[voice_len++]=SPKW_2;
			if(3==number[i])	voice[voice_len++]=SPKW_3;
			if(4==number[i])	voice[voice_len++]=SPKW_4;
			if(5==number[i])	voice[voice_len++]=SPKW_5;
			if(6==number[i])	voice[voice_len++]=SPKW_6;
			if(7==number[i])	voice[voice_len++]=SPKW_7;
			if(8==number[i])	voice[voice_len++]=SPKW_8;
			if(9==number[i])	voice[voice_len++]=SPKW_9;
			voice[voice_len++]=SPKW_TENTHOUSAND;
		}
		//千位
		i=1;
		if(0==number[1] && 0==number[2] && 0==number[3] && 0==number[4])	;
		else if(0==number[0] && 0==number[i])	;
		else
		{
			if(0==number[i])	voice[voice_len++]=SPKW_0;
			if(1==number[i])	voice[voice_len++]=SPKW_1;
			if(2==number[i])	voice[voice_len++]=SPKW_2;
			if(3==number[i])	voice[voice_len++]=SPKW_3;
			if(4==number[i])	voice[voice_len++]=SPKW_4;
			if(5==number[i])	voice[voice_len++]=SPKW_5;
			if(6==number[i])	voice[voice_len++]=SPKW_6;
			if(7==number[i])	voice[voice_len++]=SPKW_7;
			if(8==number[i])	voice[voice_len++]=SPKW_8;
			if(9==number[i])	voice[voice_len++]=SPKW_9;
			if(0!=number[i])	voice[voice_len++]=SPKW_THOUSAND;
			if(0==number[i])	voice_zero=1;
			else						voice_zero=0;
		}
		//百位
		i=2;
		if(0==number[2] && 0==number[3] && 0==number[4])	;
		else if(0==number[0] && 0==number[1] && 0==number[i])		;
		else if(0!=voice_zero && 0==number[i])	;
		else
		{
			if(0==number[i])	voice[voice_len++]=SPKW_0;
			if(1==number[i])	voice[voice_len++]=SPKW_1;
			if(2==number[i])	voice[voice_len++]=SPKW_2;
			if(3==number[i])	voice[voice_len++]=SPKW_3;
			if(4==number[i])	voice[voice_len++]=SPKW_4;
			if(5==number[i])	voice[voice_len++]=SPKW_5;
			if(6==number[i])	voice[voice_len++]=SPKW_6;
			if(7==number[i])	voice[voice_len++]=SPKW_7;
			if(8==number[i])	voice[voice_len++]=SPKW_8;
			if(9==number[i])	voice[voice_len++]=SPKW_9;
			if(0!=number[i])	voice[voice_len++]=SPKW_HUNDRED;

			if(0==number[i])	voice_zero=1;
			else						voice_zero=0;
		}
		//十位
		i=3;
		if(0==number[3] && 0==number[4])	;
		else if(0==number[0] && 0==number[1] && 0==number[2] && 0==number[i])	;
		else if(0!=voice_zero && 0==number[i])	;
		else
		{
			if(0==number[i])	voice[voice_len++]=SPKW_0;
			if(1==number[i])	voice[voice_len++]=SPKW_1;
			if(2==number[i])	voice[voice_len++]=SPKW_2;
			if(3==number[i])	voice[voice_len++]=SPKW_3;
			if(4==number[i])	voice[voice_len++]=SPKW_4;
			if(5==number[i])	voice[voice_len++]=SPKW_5;
			if(6==number[i])	voice[voice_len++]=SPKW_6;
			if(7==number[i])	voice[voice_len++]=SPKW_7;
			if(8==number[i])	voice[voice_len++]=SPKW_8;
			if(9==number[i])	voice[voice_len++]=SPKW_9;
			if(0!=number[i])	voice[voice_len++]=SPKW_TEN;

			if(0==number[i])	voice_zero=1;
			else						voice_zero=0;
		}
		//个位，高位全为0
		i=4;
		if(0==number[0]&&0==number[1]&&0==number[2]&&0==number[3]&&0==number[4])
		{
			voice[voice_len++]=SPKW_0;
		}
		else
		{
			//if(0==number[i])	voice[voicelen++]=SPKW_0;
			if(1==number[i])	voice[voice_len++]=SPKW_1;
			if(2==number[i])	voice[voice_len++]=SPKW_2;
			if(3==number[i])	voice[voice_len++]=SPKW_3;
			if(4==number[i])	voice[voice_len++]=SPKW_4;
			if(5==number[i])	voice[voice_len++]=SPKW_5;
			if(6==number[i])	voice[voice_len++]=SPKW_6;
			if(7==number[i])	voice[voice_len++]=SPKW_7;
			if(8==number[i])	voice[voice_len++]=SPKW_8;
			if(9==number[i])	voice[voice_len++]=SPKW_9;
		}
		//小数点及两位小数
		if(0!=number[5] || 0!=number[6])
		{
			voice[voice_len++]=SPKW_POINT;
			//小数点第一位
			i=5;
			if(0==number[i])	voice[voice_len++]=SPKW_0;
			if(1==number[i])	voice[voice_len++]=SPKW_1;
			if(2==number[i])	voice[voice_len++]=SPKW_2;
			if(3==number[i])	voice[voice_len++]=SPKW_3;
			if(4==number[i])	voice[voice_len++]=SPKW_4;
			if(5==number[i])	voice[voice_len++]=SPKW_5;
			if(6==number[i])	voice[voice_len++]=SPKW_6;
			if(7==number[i])	voice[voice_len++]=SPKW_7;
			if(8==number[i])	voice[voice_len++]=SPKW_8;
			if(9==number[i])	voice[voice_len++]=SPKW_9;
		
			//小数点第二位
			i=6;
			if(0==number[i])	voice[voice_len++]=SPKW_0;
			if(1==number[i])	voice[voice_len++]=SPKW_1;
			if(2==number[i])	voice[voice_len++]=SPKW_2;
			if(3==number[i])	voice[voice_len++]=SPKW_3;
			if(4==number[i])	voice[voice_len++]=SPKW_4;
			if(5==number[i])	voice[voice_len++]=SPKW_5;
			if(6==number[i])	voice[voice_len++]=SPKW_6;
			if(7==number[i])	voice[voice_len++]=SPKW_7;
			if(8==number[i])	voice[voice_len++]=SPKW_8;
			if(9==number[i])	voice[voice_len++]=SPKW_9;
		}
	}
	else{

		//男声
		//万位
		i=0;
		if(0==number[0])		;
		else
		{
			if(0==number[i])	voice[voice_len++]=SPKM_0;
			if(1==number[i])	voice[voice_len++]=SPKM_1;
			if(2==number[i])	voice[voice_len++]=SPKM_2;
			if(3==number[i])	voice[voice_len++]=SPKM_3;
			if(4==number[i])	voice[voice_len++]=SPKM_4;
			if(5==number[i])	voice[voice_len++]=SPKM_5;
			if(6==number[i])	voice[voice_len++]=SPKM_6;
			if(7==number[i])	voice[voice_len++]=SPKM_7;
			if(8==number[i])	voice[voice_len++]=SPKM_8;
			if(9==number[i])	voice[voice_len++]=SPKM_9;
			voice[voice_len++]=SPKM_TENTHOUSAND;
		}
		//千位
		i=1;
		if(0==number[1] && 0==number[2] && 0==number[3] && 0==number[4])	;
		else if(0==number[0] && 0==number[i])	;
		else
		{
			if(0==number[i])	voice[voice_len++]=SPKM_0;
			if(1==number[i])	voice[voice_len++]=SPKM_1;
			if(2==number[i])	voice[voice_len++]=SPKM_2;
			if(3==number[i])	voice[voice_len++]=SPKM_3;
			if(4==number[i])	voice[voice_len++]=SPKM_4;
			if(5==number[i])	voice[voice_len++]=SPKM_5;
			if(6==number[i])	voice[voice_len++]=SPKM_6;
			if(7==number[i])	voice[voice_len++]=SPKM_7;
			if(8==number[i])	voice[voice_len++]=SPKM_8;
			if(9==number[i])	voice[voice_len++]=SPKM_9;
			if(0!=number[i])	voice[voice_len++]=SPKM_THOUSAND;
			if(0==number[i])	voice_zero=1;
			else						voice_zero=0;
		}
		//百位
		i=2;
		if(0==number[2] && 0==number[3] && 0==number[4])	;
		else if(0==number[0] && 0==number[1] && 0==number[i])	;
		else if(0!=voice_zero && 0==number[i])	;
		else
		{
			if(0==number[i])	voice[voice_len++]=SPKM_0;
			if(1==number[i])	voice[voice_len++]=SPKM_1;
			if(2==number[i])	voice[voice_len++]=SPKM_2;
			if(3==number[i])	voice[voice_len++]=SPKM_3;
			if(4==number[i])	voice[voice_len++]=SPKM_4;
			if(5==number[i])	voice[voice_len++]=SPKM_5;
			if(6==number[i])	voice[voice_len++]=SPKM_6;
			if(7==number[i])	voice[voice_len++]=SPKM_7;
			if(8==number[i])	voice[voice_len++]=SPKM_8;
			if(9==number[i])	voice[voice_len++]=SPKM_9;
			if(0!=number[i])	voice[voice_len++]=SPKM_HUNDRED;

			if(0==number[i])	voice_zero=1;
			else						voice_zero=0;
		}
		//十位
		i=3;
		if(0==number[3] && 0==number[4])	;
		else if(0==number[0] && 0==number[1] && 0==number[2] && 0==number[i])	;
		else if(0!=voice_zero && 0==number[i])	;
		else
		{
			if(0==number[i])	voice[voice_len++]=SPKM_0;
			if(1==number[i])	voice[voice_len++]=SPKM_1;
			if(2==number[i])	voice[voice_len++]=SPKM_2;
			if(3==number[i])	voice[voice_len++]=SPKM_3;
			if(4==number[i])	voice[voice_len++]=SPKM_4;
			if(5==number[i])	voice[voice_len++]=SPKM_5;
			if(6==number[i])	voice[voice_len++]=SPKM_6;
			if(7==number[i])	voice[voice_len++]=SPKM_7;
			if(8==number[i])	voice[voice_len++]=SPKM_8;
			if(9==number[i])	voice[voice_len++]=SPKM_9;
			if(0!=number[i])	voice[voice_len++]=SPKM_TEN;

			if(0==number[i])	voice_zero=1;
			else						voice_zero=0;
		}
		//个位，高位全为0
		i=4;
		if(0==number[0]&&0==number[1]&&0==number[2]&&0==number[3]&&0==number[4])
		{
			voice[voice_len++]=SPKM_0;
		}
		else
		{
			//if(0==number[i])	voice[voicelen++]=SPKM_0;
			if(1==number[i])	voice[voice_len++]=SPKM_1;
			if(2==number[i])	voice[voice_len++]=SPKM_2;
			if(3==number[i])	voice[voice_len++]=SPKM_3;
			if(4==number[i])	voice[voice_len++]=SPKM_4;
			if(5==number[i])	voice[voice_len++]=SPKM_5;
			if(6==number[i])	voice[voice_len++]=SPKM_6;
			if(7==number[i])	voice[voice_len++]=SPKM_7;
			if(8==number[i])	voice[voice_len++]=SPKM_8;
			if(9==number[i])	voice[voice_len++]=SPKM_9;
		}
		//小数点及两位小数
		if(0!=number[5] || 0!=number[6])
		{
			voice[voice_len++]=SPKM_POINT;
			//小数点第一位
			i=5;
			if(0==number[i])	voice[voice_len++]=SPKM_0;
			if(1==number[i])	voice[voice_len++]=SPKM_1;
			if(2==number[i])	voice[voice_len++]=SPKM_2;
			if(3==number[i])	voice[voice_len++]=SPKM_3;
			if(4==number[i])	voice[voice_len++]=SPKM_4;
			if(5==number[i])	voice[voice_len++]=SPKM_5;
			if(6==number[i])	voice[voice_len++]=SPKM_6;
			if(7==number[i])	voice[voice_len++]=SPKM_7;
			if(8==number[i])	voice[voice_len++]=SPKM_8;
			if(9==number[i])	voice[voice_len++]=SPKM_9;
		
			//小数点第二位
			i=6;
			if(0==number[i])	voice[voice_len++]=SPKM_0;
			if(1==number[i])	voice[voice_len++]=SPKM_1;
			if(2==number[i])	voice[voice_len++]=SPKM_2;
			if(3==number[i])	voice[voice_len++]=SPKM_3;
			if(4==number[i])	voice[voice_len++]=SPKM_4;
			if(5==number[i])	voice[voice_len++]=SPKM_5;
			if(6==number[i])	voice[voice_len++]=SPKM_6;
			if(7==number[i])	voice[voice_len++]=SPKM_7;
			if(8==number[i])	voice[voice_len++]=SPKM_8;
			if(9==number[i])	voice[voice_len++]=SPKM_9;
		}
	}

	return	voice_len;	
}


/*******************************************************************
*Name				:iptOilVoiceIdGet
*Description		:根据油品代码获取油品语音代码
*Input				:None
*Output			:None
*Return				:油品语音代码；失败返回ERROR
*History			:2013-07-01,modified by syj  */

int iptOilVoiceIdGet(const IptParamStructType *iptparam, const char *oil_code)
{
	int id=ERROR;

	if(0x10==(oil_code[0]&0xf0) && IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType)
	{
		//汽油大类，女声
		if(0==memcmp(oil_code, "\x10\x10", 2))			id=SPKW_GAS90;
		else if(0==memcmp(oil_code, "\x10\x12", 2))	id=SPKW_GAS90CLEAN;
		else if(0==memcmp(oil_code, "\x10\x11", 2))	id=SPKW_GAS90LEAD;
//		else if(0==memcmp(oil_code, "\x10\x20", 2))	id=SPKW_GAS92;
//		else if(0==memcmp(oil_code, "\x10\x22", 2))	id=SPKW_GAS92CLEAN;
//		else if(0==memcmp(oil_code, "\x10\x21", 2))	id=SPKW_GAS92LEAD;
		else if(0==memcmp(oil_code, "\x10\x30", 2))	id=SPKW_GAS92;
		else if(0==memcmp(oil_code, "\x10\x32", 2))	id=SPKW_GAS92CLEAN;
		else if(0==memcmp(oil_code, "\x10\x31", 2))	id=SPKW_GAS92LEAD;
		else if(0==memcmp(oil_code, "\x10\x40", 2))	id=SPKW_GAS95;
		else if(0==memcmp(oil_code, "\x10\x42", 2))	id=SPKW_GAS95CLEAN;
		else if(0==memcmp(oil_code, "\x10\x41", 2))	id=SPKW_GAS95LEAD;
		else if(0==memcmp(oil_code, "\x10\x50", 2))	id=SPKW_GAS95;
		else if(0==memcmp(oil_code, "\x10\x52", 2))	id=SPKW_GAS95CLEAN;
		else if(0==memcmp(oil_code, "\x10\x51", 2))	id=SPKW_GAS95LEAD;
		else if(0==memcmp(oil_code, "\x10\x90", 2))	id=SPKW_GAS98;
		else if(0==memcmp(oil_code, "\x10\x92", 2))	id=SPKW_GAS98CLEAN;
		else if(0==memcmp(oil_code, "\x10\x91", 2))	id=SPKW_GAS98LEAD;
		else if(0==memcmp(oil_code, "\x10\x60", 2))	id=SPKW_GAS120;
		else																		id=SPKW_GASONLINE;
	}
	else if(0x20==(oil_code[0]&0xf0) && IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType)
	{
		//柴油大类，女声
		if(0==memcmp(oil_code, "\x20\x01", 2))			id=SPKW_DIE0;
		else if(0==memcmp(oil_code, "\x20\x06", 2))	id=SPKW_DIE05MINUS;
		else if(0==memcmp(oil_code, "\x20\x07", 2))	id=SPKW_DIE10MINUS;
		else if(0==memcmp(oil_code, "\x20\x08", 2))	id=SPKW_DIE15MINUS;
		else if(0==memcmp(oil_code, "\x20\x09", 2))	id=SPKW_DIE20MINUS;
		else if(0==memcmp(oil_code, "\x20\x10", 2))	id=SPKW_DIE30MINUS;
		else if(0==memcmp(oil_code, "\x20\x11", 2))	id=SPKW_DIE35MINUS;
		else if(0==memcmp(oil_code, "\x20\x15", 2))	id=SPKW_DIE50MINUS;
		else if(0==memcmp(oil_code, "\x20\x02", 2))	id=SPKW_DIE05PLUS;
		else if(0==memcmp(oil_code, "\x20\x03", 2))	id=SPKW_DIE10PLUS;
		else if(0==memcmp(oil_code, "\x20\x04", 2))	id=SPKW_DIE15PLUS;
		else if(0==memcmp(oil_code, "\x20\x05", 2))	id=SPKW_DIE20PLUS;
		else																		id=SPKW_DIESELFUEL;
	}
	else if(0x10==(oil_code[0]&0xf0) && IPT_VOICE_TYPE_MAN==iptparam->VoiceType)
	{
		//汽油大类，男声
		if(0==memcmp(oil_code, "\x10\x10", 2))			id=SPKM_GAS90;
		else if(0==memcmp(oil_code, "\x10\x12", 2))	id=SPKM_GAS90CLEAN;
		else if(0==memcmp(oil_code, "\x10\x11", 2))	id=SPKM_GAS90LEAD;
//		else if(0==memcmp(oil_code, "\x10\x20", 2))	id=SPKM_GAS92;
//		else if(0==memcmp(oil_code, "\x10\x22", 2))	id=SPKM_GAS92CLEAN;
//		else if(0==memcmp(oil_code, "\x10\x21", 2))	id=SPKM_GAS92LEAD;
		else if(0==memcmp(oil_code, "\x10\x30", 2))	id=SPKM_GAS92;
		else if(0==memcmp(oil_code, "\x10\x32", 2))	id=SPKM_GAS92CLEAN;
		else if(0==memcmp(oil_code, "\x10\x31", 2))	id=SPKM_GAS92LEAD;
		else if(0==memcmp(oil_code, "\x10\x40", 2))	id=SPKM_GAS95;
		else if(0==memcmp(oil_code, "\x10\x42", 2))	id=SPKM_GAS95CLEAN;
		else if(0==memcmp(oil_code, "\x10\x41", 2))	id=SPKM_GAS95LEAD;
		else if(0==memcmp(oil_code, "\x10\x50", 2))	id=SPKM_GAS95;
		else if(0==memcmp(oil_code, "\x10\x52", 2))	id=SPKM_GAS95CLEAN;
		else if(0==memcmp(oil_code, "\x10\x51", 2))	id=SPKM_GAS95LEAD;
		else if(0==memcmp(oil_code, "\x10\x90", 2))	id=SPKM_GAS98;
		else if(0==memcmp(oil_code, "\x10\x92", 2))	id=SPKM_GAS98CLEAN;
		else if(0==memcmp(oil_code, "\x10\x91", 2))	id=SPKM_GAS98LEAD;
		else if(0==memcmp(oil_code, "\x10\x60", 2))	id=SPKM_GAS120;
		else																		id=SPKM_GASONLINE;
	}
	else if(0x20==(oil_code[0]&0xf0) && IPT_VOICE_TYPE_MAN==iptparam->VoiceType)
	{
		//柴油大类，男声
		if(0==memcmp(oil_code, "\x20\x01", 2))			id=SPKM_DIE0;
		else if(0==memcmp(oil_code, "\x20\x06", 2))	id=SPKM_DIE05MINUS;
		else if(0==memcmp(oil_code, "\x20\x07", 2))	id=SPKM_DIE10MINUS;
		else if(0==memcmp(oil_code, "\x20\x08", 2))	id=SPKM_DIE15MINUS;
		else if(0==memcmp(oil_code, "\x20\x09", 2))	id=SPKM_DIE20MINUS;
		else if(0==memcmp(oil_code, "\x20\x10", 2))	id=SPKM_DIE30MINUS;
		else if(0==memcmp(oil_code, "\x20\x11", 2))	id=SPKM_DIE35MINUS;
		else if(0==memcmp(oil_code, "\x20\x15", 2))	id=SPKM_DIE50MINUS;
		else if(0==memcmp(oil_code, "\x20\x02", 2))	id=SPKM_DIE05PLUS;
		else if(0==memcmp(oil_code, "\x20\x03", 2))	id=SPKM_DIE10PLUS;
		else if(0==memcmp(oil_code, "\x20\x04", 2))	id=SPKM_DIE15PLUS;
		else if(0==memcmp(oil_code, "\x20\x05", 2))	id=SPKM_DIE20PLUS;
		else																		id=SPKM_DIESELFUEL;
	}

	return id;
}


/*******************************************************************
*Name				:iptSpk
*Description		:语音播放
*Input				:iptparam		ipt参数结构体，一次最多16段语音
*						:name			语音文件序号
*						:number		语音文件数目
*Output			:None
*Return				:成功返回0；失败返回ERROR
*History			:2014-04-10,modified by syj  */

int iptSpk(const IptParamStructType *iptparam, int *list, int number)
{
	spkPlay(iptparam->Speaker, iptparam->VoiceVolume, list, number);

	return 0;
}

/*******************************************************************
*Name				:iptPrintLianDaUser
*Description		:打印联达系统客户联小票
*Input				:iptparam		IPT参数结构体
*						:isagain		是否是重打印0 = 否；1 = 是；
*						:buffer			打印的完整账单内容
*						:nbytes		打印内容长度
*Output			:None
*Return			:成功返回0；失败返回ERROR
*History			:2014-04-10,modified by syj  */

static int iptPrintLianDaUser(const IptParamStructType *iptparam, char isagain, const char *buffer, int nbytes)
{
	unsigned char tmp_buffer[32]={0}, tmp_buffer2[32]={0}, tx_buffer[2048]={0};
	unsigned int data_len=0, tmp_int=0, tmp_int2=0, tmp_int3=0;
	int i=0, card_type = 0;
	long long data=0;

	//联达加油站参照中石油，打印小票格式如下:
	//
	//	-------------------------------------------
	//	|                        欢迎光临  						|
	//	|        				----------------					  	|
	//	|加油站名称:XXXXXXXX	XXXXXXX				|
	//	|交易时间:XXXX年XX月XX日XX:XX:XX	|
	//	|交易ID:XXXX													|
	//	|---------------------------------------|
	//	|卡号:XXXXXXXXXXXXXXXXXXXX						|
	//	|支付类型:XXXXXXXXXX								|
	//	|油枪号:XXX													|
	//	|油品名称:XXXXXXXXXXXX							|
	//	|单价:XX.XX元/升										|
	//	|数量:XXXX.XX升											|
	//	|开票类型:XXXXXXXXXXXX							|
	//	|---------------------------------------|
	//	|卡应付余额:XXXX.XX元							|
	//	|卡折扣金额:XXXX.XX元							|
	//	|实收金额:XXXX.XX元								|
	//	|卡片余额:XXXXXXXX.XX元						|
	//	|        																	  	|
	//	|		谢谢惠顾!欢迎下次再来!		|
	//	-------------------------------------------
	
	//初始化打印机
	memcpy(&tx_buffer[data_len], "\x1B\x40",2);				data_len+=2;	//初始化打印机
	//memcpy(&tx_buffer[10], "\x1D\x21\x00",3);				data_len+=3;	//定义字符倍数
	//memcpy(&tx_buffer[data_len], "\x1B\x33\x20",3);	data_len+=3;	//行间距间距

	memcpy(&tx_buffer[data_len], "            欢迎光临", 20);				data_len+=20;
	tx_buffer[data_len]=0x0a;																			data_len+=1;
	
	memcpy(&tx_buffer[data_len], "        ----------------", 24);				data_len+=24;
	tx_buffer[data_len]=0x0a;																			data_len+=1;

	memcpy(&tx_buffer[data_len], "加油站名称:", 11);						data_len+=11;
	strcpy(&tx_buffer[data_len], iptparam->StationName);							data_len+=strlen(iptparam->StationName);
	tx_buffer[data_len]=0x0a;																			data_len+=1;

	memcpy(&tx_buffer[data_len], "交易时间:", 11);							data_len+=11;
	memcpy(tmp_buffer,&buffer[5],7);
	tx_buffer[data_len+0]=((tmp_buffer[0]>>4)&0x0f)+0x30;tx_buffer[data_len+1]=((tmp_buffer[0]>>0)&0x0f)+0x30;
	tx_buffer[data_len+2]=((tmp_buffer[1]>>4)&0x0f)+0x30;tx_buffer[data_len+3]=((tmp_buffer[1]>>0)&0x0f)+0x30;
	memcpy(&tx_buffer[data_len+4], "年", 2);
	tx_buffer[data_len+6]=((tmp_buffer[2]>>4)&0x0f)+0x30;tx_buffer[data_len+7]=((tmp_buffer[2]>>0)&0x0f)+0x30;
	memcpy(&tx_buffer[data_len+8], "月", 2);
	tx_buffer[data_len+10]=((tmp_buffer[3]>>4)&0x0f)+0x30;tx_buffer[data_len+11]=((tmp_buffer[3]>>0)&0x0f)+0x30;
	memcpy(&tx_buffer[data_len+12], "日", 2);
	tx_buffer[data_len+14]=((tmp_buffer[4]>>4)&0x0f)+0x30;tx_buffer[data_len+15]=((tmp_buffer[4]>>0)&0x0f)+0x30;
	tx_buffer[data_len+16]=':';
	tx_buffer[data_len+17]=((tmp_buffer[5]>>4)&0x0f)+0x30;tx_buffer[data_len+18]=((tmp_buffer[5]>>0)&0x0f)+0x30;
	tx_buffer[data_len+19]=':';
	tx_buffer[data_len+20]=((tmp_buffer[6]>>4)&0x0f)+0x30;tx_buffer[data_len+21]=((tmp_buffer[6]>>0)&0x0f)+0x30;
																														data_len+=22;
	tx_buffer[data_len]=0x0a;																			data_len+=1;

	memcpy(&tx_buffer[data_len], "交易ID:", 7);										data_len+=7;
	memcpy(tmp_buffer,&buffer[0],4);
	tmp_int=(tmp_buffer[0]<<24)|(tmp_buffer[1]<<16)|(tmp_buffer[2]<<8)|(tmp_buffer[3]<<0);
	data=hex2Bcd(tmp_int);
	for(i=0; i<=8; i++)	tmp_buffer[i]=((data>>((8-i)*4))&0x0f)+0x30;
	for(i=0; i<=7; i++)	if('0'!=tmp_buffer[i])	break;
	memcpy(&tx_buffer[data_len], &tmp_buffer[i], 9-i);									data_len+=(9-i);
	tx_buffer[data_len]=0x0a;																			data_len+=1;

	memset(&tx_buffer[data_len], '-', 32);														data_len+=32;
	tx_buffer[data_len]=0x0a;																			data_len+=1;

	memcpy(&tx_buffer[data_len], "卡号:", 5);											data_len+=5;
	hex2Ascii(&buffer[12],10, &tx_buffer[data_len], 20);								data_len+=20;
	tx_buffer[data_len]=0x0a;																			data_len+=1;

	card_type = buffer[IPT_OFFSET_ASN + 2];
	memcpy(&tx_buffer[data_len], "支付类型:", 9);								data_len+=9;
	if(0x04 == card_type)
	{
		tmp_buffer[0] = buffer[IPT_OFFSET_UNIT];
		if(0==((tmp_buffer[0]>>4)&0x0f))					
		{
			memcpy(&tx_buffer[data_len], "现金", 4);																data_len+=4;
		}
		else if(1==((tmp_buffer[0]>>4)&0x0f))
		{
			memcpy(&tx_buffer[data_len], "油票", 4);																data_len+=4;
		}
		else if(2==((tmp_buffer[0]>>4)&0x0f))
		{
			memcpy(&tx_buffer[data_len], "记账", 4);																data_len+=4;
		}
		else if(3==((tmp_buffer[0]>>4)&0x0f))
		{
			memcpy(&tx_buffer[data_len], "银行卡", 6);															data_len+=6;
		}
		else if(4==((tmp_buffer[0]>>4)&0x0f))
		{
			memcpy(&tx_buffer[data_len], "其它1", 5);																data_len+=5;
		}
		else if(5==((tmp_buffer[0]>>4)&0x0f))
		{
			memcpy(&tx_buffer[data_len], "其它2", 5);																data_len+=5;
		}
	}
	else
	{
		memcpy(tmp_buffer,&buffer[IPT_OFFSET_UNIT],1);
		if(0 == ((tmp_buffer[0] >> 4)&0x0f))					
		{
			memcpy(&tx_buffer[data_len], "电子油票", 8);							data_len+=8;
		}
		else
		{
			memcpy(&tx_buffer[data_len], "积分应用", 8);							data_len+=8;
		}
	}
	tx_buffer[data_len]=0x0a;																			data_len+=1;

	memcpy(&tx_buffer[data_len], "油枪号:", 7);									data_len+=7;
	memcpy(tmp_buffer,&buffer[67],1);
	data=hex2Bcd(tmp_buffer[0]);	
	tmp_buffer[0]=((data>>8)&0x0f)+0x30;	tmp_buffer[1]=((data>>4)&0x0f)+0x30;	tmp_buffer[2]=((data>>0)&0x0f)+0x30;
	for(i=0; i<2; i++)	if('0'!=tmp_buffer[i])	break;
	memcpy(&tx_buffer[data_len], &tmp_buffer[i], 3-i);									data_len+=(3-i);
	tx_buffer[data_len]=0x0a;																			data_len+=1;

	memcpy(&tx_buffer[data_len], "油品名称:", 9);								data_len+=9;
	strcpy(&tx_buffer[data_len], iptparam->OilName);									data_len+=strlen(iptparam->OilName);
	tx_buffer[data_len]=0x0a;																			data_len+=1;

	memcpy(&tx_buffer[data_len], "单价:", 5);											data_len+=5;
	memcpy(tmp_buffer,&buffer[73],2);
	tmp_int=(tmp_buffer[0]<<8)|(tmp_buffer[1]<<0);
	data=hex2Bcd(tmp_int);
	if(0!=(unsigned char)((data>>12)&0x0f))
	{
		tx_buffer[data_len]=((data>>12)&0x0f)+0x30;									data_len+=1;
	}
	tx_buffer[data_len]=((data>>8)&0x0f)+0x30;											data_len+=1;
	tx_buffer[data_len]='.';																				data_len+=1;
	tx_buffer[data_len]=((data>>4)&0x0f)+0x30;											data_len+=1;
	tx_buffer[data_len]=((data>>0)&0x0f)+0x30;											data_len+=1;
	strcpy(&tx_buffer[data_len], "元/升");													data_len+=strlen("元/升");
	tx_buffer[data_len]=0x0a;																			data_len+=1;

	memcpy(&tx_buffer[data_len], "数量:", 5);											data_len+=5;
	memcpy(tmp_buffer,&buffer[70],3);
	tmp_int=(tmp_buffer[0]<<16)|(tmp_buffer[1]<<8)|(tmp_buffer[2]<<0);
	data=hex2Bcd(tmp_int);
	for(i=0; i<=7; i++)	tmp_buffer[i]=((data>>((7-i)*4))&0x0f)+0x30;
	for(i=0; i<=4; i++)	if('0'!=tmp_buffer[i])	break;
	memcpy(&tx_buffer[data_len], &tmp_buffer[i], 6-i);									data_len+=(6-i);
	tx_buffer[data_len]='.';																				data_len+=1;
	tx_buffer[data_len]=((data>>4)&0x0f)+0x30;											data_len+=1;
	tx_buffer[data_len]=((data>>0)&0x0f)+0x30;											data_len+=1;
	memcpy(&tx_buffer[data_len], "升",2);													data_len+=2;
	tx_buffer[data_len]=0x0a;																			data_len+=1;

	memcpy(&tx_buffer[data_len], "开票类型:", 9);								data_len+=9;
	if(0x01 == buffer[IPT_OFFSET_INVOICE_TYPE])
	{
		strcpy(&tx_buffer[data_len], "消费开发票");	data_len+=strlen("消费开发票");
	}
	if(0x02 == buffer[IPT_OFFSET_INVOICE_TYPE])
	{
		strcpy(&tx_buffer[data_len], "充值开发票");	data_len+=strlen("充值开发票");
	}
	if(0x03 == buffer[IPT_OFFSET_INVOICE_TYPE])
	{
		strcpy(&tx_buffer[data_len], "统一开增值税发票");			data_len+=strlen("统一开增值税发票");
	}
	tx_buffer[data_len]=0x0a;																			data_len+=1;

	memset(&tx_buffer[data_len], '-', 32);														data_len+=32;
	tx_buffer[data_len]=0x0a;																			data_len+=1;

	memcpy(&tx_buffer[data_len], "卡应付金额:", 11);						data_len+=11;
	memcpy(tmp_buffer,&buffer[26],3);
	tmp_int=(tmp_buffer[0]<<16)|(tmp_buffer[1]<<8)|(tmp_buffer[2]<<0);
	data=hex2Bcd(tmp_int);
	for(i=0; i<=7; i++)	tmp_buffer[i]=((data>>((7-i)*4))&0x0f)+0x30;
	for(i=0; i<=4; i++)	if('0'!=tmp_buffer[i])	break;
	memcpy(&tx_buffer[data_len], &tmp_buffer[i], 6-i);									data_len+=(6-i);
	tx_buffer[data_len]='.';																				data_len+=1;
	tx_buffer[data_len]=((data>>4)&0x0f)+0x30;											data_len+=1;
	tx_buffer[data_len]=((data>>0)&0x0f)+0x30;											data_len+=1;
	memcpy(tmp_buffer,&buffer[64],1);
	if(0==(tmp_buffer[0]&0x03))					
	{
		memcpy(&tx_buffer[data_len], "元", 2);												data_len+=2;
	}
	else
	{
		memcpy(&tx_buffer[data_len], "点", 2);												data_len+=2;
	}
	tx_buffer[data_len]=0x0a;																			data_len+=1;

	memcpy(&tx_buffer[data_len], "卡折扣金额:", 11);						data_len+=11;
	tmp_int3 = (buffer[IPT_OFFSET_MONEY_DISCOUNT + 0]<<16)|(buffer[IPT_OFFSET_MONEY_DISCOUNT + 1]<<8)|(buffer[IPT_OFFSET_MONEY_DISCOUNT + 2]<<0);
	tmp_int2 = (buffer[IPT_OFFSET_AMN + 0]<<16)|(buffer[IPT_OFFSET_AMN + 1]<<8)|(buffer[IPT_OFFSET_AMN + 2]<<0);
	tmp_int = tmp_int2 - tmp_int3;
	data=hex2Bcd(tmp_int);
	for(i=0; i<=7; i++)	tmp_buffer[i]=((data>>((7-i)*4))&0x0f)+0x30;
	for(i=0; i<=4; i++)	if('0'!=tmp_buffer[i])	break;
	memcpy(&tx_buffer[data_len], &tmp_buffer[i], 6-i);									data_len+=(6-i);
	tx_buffer[data_len]='.';																				data_len+=1;
	tx_buffer[data_len]=((data>>4)&0x0f)+0x30;											data_len+=1;
	tx_buffer[data_len]=((data>>0)&0x0f)+0x30;											data_len+=1;
	memcpy(tmp_buffer,&buffer[64],1);
	if(0==(tmp_buffer[0]&0x03))					
	{
		memcpy(&tx_buffer[data_len], "元", 2);												data_len+=2;
	}
	else
	{
		memcpy(&tx_buffer[data_len], "点", 2);												data_len+=2;
	}
	tx_buffer[data_len]=0x0a;																			data_len+=1;

	memcpy(&tx_buffer[data_len], "实收金额:", 9);								data_len+=9;
	memcpy(tmp_buffer,&buffer[IPT_OFFSET_MONEY_DISCOUNT],3);
	tmp_int=(tmp_buffer[0]<<16)|(tmp_buffer[1]<<8)|(tmp_buffer[2]<<0);
	data=hex2Bcd(tmp_int);
	for(i=0; i<=7; i++)	tmp_buffer[i]=((data>>((7-i)*4))&0x0f)+0x30;
	for(i=0; i<=4; i++)	if('0'!=tmp_buffer[i])	break;
	memcpy(&tx_buffer[data_len], &tmp_buffer[i], 6-i);									data_len+=(6-i);
	tx_buffer[data_len]='.';																				data_len+=1;
	tx_buffer[data_len]=((data>>4)&0x0f)+0x30;											data_len+=1;
	tx_buffer[data_len]=((data>>0)&0x0f)+0x30;											data_len+=1;
	memcpy(tmp_buffer,&buffer[64],1);
	if(0==(tmp_buffer[0]&0x03))					
	{
		memcpy(&tx_buffer[data_len], "元", 2);												data_len+=2;
	}
	else
	{
		memcpy(&tx_buffer[data_len], "点", 2);												data_len+=2;
	}
	tx_buffer[data_len]=0x0a;																			data_len+=1;

	memcpy(&tx_buffer[data_len], "卡片余额:", 9);								data_len+=9;
	memcpy(tmp_buffer,&buffer[22],4);
	tmp_int=(tmp_buffer[0]<<24)|(tmp_buffer[1]<<16)|(tmp_buffer[2]<<8)|(tmp_buffer[3]<<0);
	data=hex2Bcd(tmp_int);
	for(i=0; i<=9; i++)	tmp_buffer[i]=((data>>((9-i)*4))&0x0f)+0x30;
	for(i=0; i<=6; i++)	if('0'!=tmp_buffer[i])	break;
	memcpy(&tx_buffer[data_len], &tmp_buffer[i], 8-i);									data_len+=(8-i);
	tx_buffer[data_len]='.';																				data_len+=1;
	tx_buffer[data_len]=((data>>4)&0x0f)+0x30;											data_len+=1;
	tx_buffer[data_len]=((data>>0)&0x0f)+0x30;											data_len+=1;
	tx_buffer[data_len]=0x0a;																			data_len+=1;

	tx_buffer[data_len]=0x0a;																			data_len+=1;
	
	strcpy(&tx_buffer[data_len], "     谢谢惠顾!欢迎下次再来!");		data_len+=strlen("     谢谢惠顾!欢迎下次再来!");													data_len+=32;
	tx_buffer[data_len]=0x0a;																							data_len+=1;

	memcpy(&tx_buffer[data_len], "\x1B\x4A\x50\x1D\x56\x01", 6);			data_len+=6;//半切纸 (通用)
	//memcpy(&tx_buffer[data_len], "\x1B\x6D", 2);																data_len+=2;//半切纸 (莹浦通)
	//memcpy(&tx_buffer[data_len], "\x1D\x56\x42\x00\x1B\x63\x38", 7);							data_len+=7;//半切纸 (公达)

	pprint(iptparam->Printer, tx_buffer, data_len);

	return 0;
}


/*******************************************************************
*Name				:iptPrintSINOPECUser
*Description		:打印石化客户存根联小票
*Input				:iptparam		IPT参数结构体
*						:isagain		是否是重打印0 = 否；1 = 是；
*						:buffer			打印的完整账单内容
*						:nbytes		打印内容长度
*Output			:None
*Return			:成功返回0；失败返回ERROR
*History			:2014-04-10,modified by syj  */

static int iptPrintSINOPECUser(const IptParamStructType *iptparam, char isagain, const char *buffer, int nbytes)
{
	unsigned char tmp_buffer[32]={0}, tmp_buffer2[32]={0}, tx_buffer[2048]={0};
	unsigned int data_len=0, tmp_int=0, tmp_int2=0, tmp_int3=0;
	int i=0;
	long long data=0;

	//打印用户联
	//用户联格式如下:
	//	-------------------------------------------
	//	|     欢迎使用中石化加油IC卡  		|
	//	|        				----------------					  	|
	//	|加油站编码:XXXXXXXX								|
	//	|枪号:XXX															|
	//	|卡号:XXXXXXXXXXXXXXXXXXXX						|
	//	|流水号(POS_TTC):XXXXXXXXXX					|
	//	|扣前余额:XXXXXXXX.XX								|
	//	|油品代码:XXXX											|
	//	|单价:XX.XX														|
	//	|加油升数:XXXX.XX升								|
	//	|加油金额:XXXX.XX元								|
	//	|扣后余额:XXXXXXXX.XX								|
	//	|交易类型:正常										|
	//	|交易时间:XXXX年XX月XX日XX:XX:XX	|
	//	|        				----------------					  	|
	//	|			不做报销凭证(第2联)				|
	//	-------------------------------------------
	
	//初始化打印机
	memcpy(&tx_buffer[data_len], "\x1B\x40",2);				data_len+=2;	//初始化打印机
	//memcpy(&tx_buffer[10], "\x1D\x21\x00",3);				data_len+=3;	//定义字符倍数
	//memcpy(&tx_buffer[data_len], "\x1B\x33\x20",3);	data_len+=3;	//行间距间距

	memcpy(&tx_buffer[data_len], "     欢迎使用中石化加油IC卡", 27);		data_len+=27;
	tx_buffer[data_len]=0x0a;																							data_len+=1;
	
	memcpy(&tx_buffer[data_len], "        ----------------", 24);									data_len+=24;
	tx_buffer[data_len]=0x0a;																							data_len+=1;

	memcpy(&tx_buffer[data_len], "加油站编码:", 11);											data_len+=11;
	memcpy(tmp_buffer, IptPcInfo.SInfo.S_ID, 4);
	hex2Ascii(tmp_buffer, 4, &tx_buffer[data_len], 8);														data_len+=8;
	tx_buffer[data_len]=0x0a;																							data_len+=1;

	memcpy(&tx_buffer[data_len], "枪号:", 5);																data_len+=5;
	memcpy(tmp_buffer,&buffer[67],1);
	data=hex2Bcd(tmp_buffer[0]);	
	tmp_buffer2[0]=((data>>8)&0x0f)+0x30;	tmp_buffer2[1]=((data>>4)&0x0f)+0x30;	tmp_buffer2[2]=((data>>0)&0x0f)+0x30;
	for(i=0; i<2; i++)	if('0'!=tmp_buffer2[i])	break;
	memcpy(&tx_buffer[data_len], &tmp_buffer2[i], 3-i);													data_len+=(3-i);
	tx_buffer[data_len]=0x0a;																							data_len+=1;

	memcpy(&tx_buffer[data_len], "卡号:", 5);																data_len+=5;
	hex2Ascii(&buffer[12],10, &tx_buffer[data_len], 20);													data_len+=20;
	tx_buffer[data_len]=0x0a;																								data_len+=1;

	memcpy(&tx_buffer[data_len], "流水号(POS_TTC):", 16);										data_len+=16;
	memcpy(tmp_buffer,&buffer[0],4);
	tmp_int=(tmp_buffer[0]<<24)|(tmp_buffer[1]<<16)|(tmp_buffer[2]<<8)|(tmp_buffer[3]<<0);
	data=hex2Bcd(tmp_int);
	for(i=0; i<=8; i++)	tmp_buffer[i]=((data>>((8-i)*4))&0x0f)+0x30;
	for(i=0; i<=7; i++)	if('0'!=tmp_buffer[i])	break;
	memcpy(&tx_buffer[data_len], &tmp_buffer[i], 9-i);														data_len+=(9-i);
	tx_buffer[data_len]=0x0a;																							data_len+=1;

	memcpy(&tx_buffer[data_len], "扣前余额:", 9);													data_len+=9;
	memcpy(tmp_buffer,&buffer[97],4);
	tmp_int=(tmp_buffer[0]<<24)|(tmp_buffer[1]<<16)|(tmp_buffer[2]<<8)|(tmp_buffer[3]<<0);
	data=hex2Bcd(tmp_int);
	for(i=0; i<=9; i++)	tmp_buffer[i]=((data>>((9-i)*4))&0x0f)+0x30;
	for(i=0; i<=6; i++)	if('0'!=tmp_buffer[i])	break;
	memcpy(&tx_buffer[data_len], &tmp_buffer[i], 8-i);														data_len+=(8-i);
	tx_buffer[data_len]='.';																									data_len+=1;
	tx_buffer[data_len]=((data>>4)&0x0f)+0x30;																data_len+=1;
	tx_buffer[data_len]=((data>>0)&0x0f)+0x30;																data_len+=1;
	tx_buffer[data_len]=0x0a;																							data_len+=1;

	memcpy(&tx_buffer[data_len], "油品代码:", 9);													data_len+=9;
	hex2Ascii(&buffer[68], 2, &tx_buffer[data_len], 4);														data_len+=4;
	tx_buffer[data_len]=0x0a;																							data_len+=1;

	memcpy(&tx_buffer[data_len], "单价:", 5);																data_len+=5;
	memcpy(tmp_buffer,&buffer[73],2);
	tmp_int=(tmp_buffer[0]<<8)|(tmp_buffer[1]<<0);
	data=hex2Bcd(tmp_int);
	if(0!=(unsigned char)((data>>12)&0x0f))
	{
		tx_buffer[data_len]=((data>>12)&0x0f)+0x30;															data_len+=1;
	}
	tx_buffer[data_len]=((data>>8)&0x0f)+0x30;																data_len+=1;
	tx_buffer[data_len]='.';																										data_len+=1;
	tx_buffer[data_len]=((data>>4)&0x0f)+0x30;																data_len+=1;
	tx_buffer[data_len]=((data>>0)&0x0f)+0x30;																data_len+=1;
	tx_buffer[data_len]=0x0a;																								data_len+=1;

	memcpy(&tx_buffer[data_len], "加油升数:", 9);													data_len+=9;
	memcpy(tmp_buffer,&buffer[70],3);
	tmp_int=(tmp_buffer[0]<<16)|(tmp_buffer[1]<<8)|(tmp_buffer[2]<<0);
	data=hex2Bcd(tmp_int);
	for(i=0; i<=7; i++)	tmp_buffer[i]=((data>>((7-i)*4))&0x0f)+0x30;
	for(i=0; i<=4; i++)	if('0'!=tmp_buffer[i])	break;
	memcpy(&tx_buffer[data_len], &tmp_buffer[i], 6-i);														data_len+=(6-i);
	tx_buffer[data_len]='.';																									data_len+=1;
	tx_buffer[data_len]=((data>>4)&0x0f)+0x30;																data_len+=1;
	tx_buffer[data_len]=((data>>0)&0x0f)+0x30;																data_len+=1;
	memcpy(&tx_buffer[data_len], "升",2);																		data_len+=2;
	tx_buffer[data_len]=0x0a;																							data_len+=1;

	memcpy(&tx_buffer[data_len], "加油金额:", 9);													data_len+=9;
	memcpy(tmp_buffer,&buffer[26],3);
	tmp_int=(tmp_buffer[0]<<16)|(tmp_buffer[1]<<8)|(tmp_buffer[2]<<0);
	data=hex2Bcd(tmp_int);
	for(i=0; i<=7; i++)	tmp_buffer[i]=((data>>((7-i)*4))&0x0f)+0x30;
	for(i=0; i<=4; i++)	if('0'!=tmp_buffer[i])	break;
	memcpy(&tx_buffer[data_len], &tmp_buffer[i], 6-i);														data_len+=(6-i);
	tx_buffer[data_len]='.';																									data_len+=1;
	tx_buffer[data_len]=((data>>4)&0x0f)+0x30;																data_len+=1;
	tx_buffer[data_len]=((data>>0)&0x0f)+0x30;																data_len+=1;
	memcpy(tmp_buffer,&buffer[64],1);
	if(0==(tmp_buffer[0]&0x03))					
	{
		memcpy(&tx_buffer[data_len], "元", 2);																	data_len+=2;
	}
	else
	{
		memcpy(&tx_buffer[data_len], "点", 2);																	data_len+=2;
	}
	tx_buffer[data_len]=0x0a;																							data_len+=1;

	memcpy(&tx_buffer[data_len], "扣后余额:", 9);													data_len+=9;
	memcpy(tmp_buffer,&buffer[22],4);
	tmp_int=(tmp_buffer[0]<<24)|(tmp_buffer[1]<<16)|(tmp_buffer[2]<<8)|(tmp_buffer[3]<<0);
	data=hex2Bcd(tmp_int);
	for(i=0; i<=9; i++)	tmp_buffer[i]=((data>>((9-i)*4))&0x0f)+0x30;
	for(i=0; i<=6; i++)	if('0'!=tmp_buffer[i])	break;
	memcpy(&tx_buffer[data_len], &tmp_buffer[i], 8-i);														data_len+=(8-i);
	tx_buffer[data_len]='.';																									data_len+=1;
	tx_buffer[data_len]=((data>>4)&0x0f)+0x30;																data_len+=1;
	tx_buffer[data_len]=((data>>0)&0x0f)+0x30;																data_len+=1;
	tx_buffer[data_len]=0x0a;																							data_len+=1;

	memcpy(&tx_buffer[data_len], "交易类型:", 9);													data_len+=9;
	memcpy(tmp_buffer,&buffer[4],1);
	if(IPT_BILLTYPE_NORMAL==(tmp_buffer[0]&0x0f))
	{memcpy(&tx_buffer[data_len], "正常", 4);																data_len+=4;}
	else if(IPT_BILLTYPE_ESCAPE==(tmp_buffer[0]&0x0f))
	{memcpy(&tx_buffer[data_len], "逃卡", 4);																data_len+=4;}
	else if(IPT_BILLTYPE_ERROR==(tmp_buffer[0]&0x0f))
	{memcpy(&tx_buffer[data_len], "错卡", 4);																data_len+=4;}
	else if(IPT_BILLTYPE_UNLOCK==(tmp_buffer[0]&0x0f))
	{memcpy(&tx_buffer[data_len], "补扣", 4);																data_len+=4;}
	else if(IPT_BILLTYPE_FINISH==(tmp_buffer[0]&0x0f))
	{memcpy(&tx_buffer[data_len], "补充", 4);																data_len+=4;}
	else if(IPT_BILLTYPE_WORKON==(tmp_buffer[0]&0x0f))
	{memcpy(&tx_buffer[data_len], "上班", 4);																data_len+=4;}
	else if(IPT_BILLTYPE_WORKOFF==(tmp_buffer[0]&0x0f))
	{memcpy(&tx_buffer[data_len], "下班", 4);																data_len+=4;}
	else if(IPT_BILLTYPE_UNSELF==(tmp_buffer[0]&0x0f))
	{memcpy(&tx_buffer[data_len], "非卡", 4);																data_len+=4;}
	else if(IPT_BILLTYPE_OILINFO==(tmp_buffer[0]&0x0f))
	{memcpy(&tx_buffer[data_len], "油价接收", 8);													data_len+=8;}
	else if(IPT_BILLTYPE_REFUSE==(tmp_buffer[0]&0x0f))
	{memcpy(&tx_buffer[data_len], "卡错拒绝", 8);													data_len+=8;}
	tx_buffer[data_len]=0x0a;																								data_len+=1;

	memcpy(&tx_buffer[data_len], "交易时间:", 11);													data_len+=11;
	memcpy(tmp_buffer,&buffer[5],7);
	tx_buffer[data_len+0]=((tmp_buffer[0]>>4)&0x0f)+0x30;tx_buffer[data_len+1]=((tmp_buffer[0]>>0)&0x0f)+0x30;
	tx_buffer[data_len+2]=((tmp_buffer[1]>>4)&0x0f)+0x30;tx_buffer[data_len+3]=((tmp_buffer[1]>>0)&0x0f)+0x30;
	memcpy(&tx_buffer[data_len+4], "年", 2);
	tx_buffer[data_len+6]=((tmp_buffer[2]>>4)&0x0f)+0x30;tx_buffer[data_len+7]=((tmp_buffer[2]>>0)&0x0f)+0x30;
	memcpy(&tx_buffer[data_len+8], "月", 2);
	tx_buffer[data_len+10]=((tmp_buffer[3]>>4)&0x0f)+0x30;tx_buffer[data_len+11]=((tmp_buffer[3]>>0)&0x0f)+0x30;
	memcpy(&tx_buffer[data_len+12], "日", 2);
	tx_buffer[data_len+14]=((tmp_buffer[4]>>4)&0x0f)+0x30;tx_buffer[data_len+15]=((tmp_buffer[4]>>0)&0x0f)+0x30;
	tx_buffer[data_len+16]=':';
	tx_buffer[data_len+17]=((tmp_buffer[5]>>4)&0x0f)+0x30;tx_buffer[data_len+18]=((tmp_buffer[5]>>0)&0x0f)+0x30;
	tx_buffer[data_len+19]=':';
	tx_buffer[data_len+20]=((tmp_buffer[6]>>4)&0x0f)+0x30;tx_buffer[data_len+21]=((tmp_buffer[6]>>0)&0x0f)+0x30;
																																						data_len+=22;
	tx_buffer[data_len]=0x0a;																								data_len+=1;

	memcpy(&tx_buffer[data_len], "        ----------------", 24);									data_len+=24;
	tx_buffer[data_len]=0x0a;																								data_len+=1;

	memcpy(&tx_buffer[data_len], "       不做报销凭证(第2联)", 26);			data_len+=26;
	tx_buffer[data_len]=0x0a;																								data_len+=1;

	memcpy(&tx_buffer[data_len], "\x1B\x4A\x50\x1D\x56\x01", 6);		data_len+=6;//半切纸 (通用)
	//memcpy(&tx_buffer[data_len], "\x1B\x6D", 2);																data_len+=2;//半切纸 (莹浦通)
	//memcpy(&tx_buffer[data_len], "\x1D\x56\x42\x00\x1B\x63\x38", 7);							data_len+=7;//半切纸 (公达)
		
	pprint(iptparam->Printer, tx_buffer, data_len);

	return 0;
}


/*******************************************************************
*Name				:iptPrintSINOPECStation
*Description		:打印石化加油站存根联小票
*Input				:iptparam		IPT参数结构体
*						:isagain		是否是重打印0 = 否；1 = 是；
*						:buffer			打印的完整账单内容
*						:nbytes		打印内容长度
*Output			:None
*Return			:成功返回0；失败返回ERROR
*History			:2014-04-10,modified by syj  */

static int iptPrintSINOPECStation(const IptParamStructType *iptparam, char isagain, const char *buffer, int nbytes)
{
	unsigned char tmp_buffer[32]={0}, tmp_buffer2[32]={0}, tx_buffer[2048]={0};
	unsigned int data_len=0, tmp_int=0, tmp_int2=0, tmp_int3=0;
	int i=0;
	long long data=0;

	//打印油站联
	//加油站联格式如下:
	//	-------------------------------------------
	//	|     欢迎使用中石化加油IC卡  		|
	//	|        				----------------					  	|
	//	|卡的CTC:XXXXX													|
	//	|电子签名:XXXXXXXX										|
	//	|解灰认证码:XXXXXXXX								|
	//	|灰锁签名:XXXXXXXX										|
	//	|PSAM应用号: XXXXXXXXXXXXXXXXXXX		|
	//	|PSAM编号:XXXXXXXXXXXX								|
	//	|PSAM-TTC:XXXXXXXXXX										|
	//	|扣款来源:电子油票/积分应用	|
	//	|支付类型:现金/油票....						|
	//	|结算单位:分/点										|
	//	|卡类: 00/01															|
	//	|卡密钥版本号:X       (HEX)						|
	//	|卡密钥索引号:X       (HEX)						|
	//	|员工号:XXX														|
	//	|升累计:XXXXXXXX.XX升								|
	//	|终端数据认证码:XXXXXXXX					|
	//	|        				----------------					  	|
	//	|加油站编码:XXXXXXXX								|
	//	|枪号:XXX																|
	//	|卡号:XXXXXXXXXXXXXXXXXXXX						|
	//	|流水号(POS_TTC):XXXXXXXXXX					|
	//	|扣前余额:XXXXXXXX.XX								|
	//	|油品代码:XXXX												|
	//	|单价:XX.XX															|
	//	|加油升数:XXXX.XX升									|
	//	|加油金额:XXXX.XX元									|
	//	|扣后余额:XXXXXXXX.XX								|
	//	|交易类型:正常											|
	//	|交易时间:XXXX年XX月XX日XX:XX:XX	|
	//	|        				----------------					  	|
	//	|			不做报销凭证(第1联)				|
	//	-------------------------------------------
	
	//初始化打印机
	memcpy(&tx_buffer[data_len], "\x1B\x40",2);				data_len+=2;	//初始化打印机
	//memcpy(&tx_buffer[10], "\x1D\x21\x00",3);				data_len+=3;	//定义字符倍数
	//memcpy(&tx_buffer[data_len], "\x1B\x33\x20",3);	data_len+=3;	//行间距间距

	if(MODEL_SINOPEC == paramModelGet())
	{
		memcpy(&tx_buffer[data_len], "     欢迎使用中石化加油IC卡", 27);			data_len+=27;
	}
	else
	{
		memcpy(&tx_buffer[data_len], "        欢迎使用加油IC卡", 24);			data_len+=24;
	}
	tx_buffer[data_len]=0x0a;																								data_len+=1;
		
	memcpy(&tx_buffer[data_len], "        ----------------", 24);										data_len+=24;
	tx_buffer[data_len]=0x0a;																								data_len+=1;

	memcpy(&tx_buffer[data_len], "卡的CTC:", 8);															data_len+=8;
	memcpy(tmp_buffer,&buffer[29],2);
	tmp_int=(tmp_buffer[0]<<8)|(tmp_buffer[1]<<0);
	data=hex2Bcd(tmp_int);
	for(i=0; i<=4; i++)	tmp_buffer[i]=((data>>((4-i)*4))&0x0f)+0x30;
	for(i=0; i<=3; i++)	if('0'!=tmp_buffer[i])	break;
	memcpy(&tx_buffer[data_len], &tmp_buffer[i], 5-i);															data_len+=(5-i);
	tx_buffer[data_len]=0x0a;																								data_len+=1;

	memcpy(&tx_buffer[data_len], "电子签名:", 9);														data_len+=9;
	hex2Ascii(&buffer[31],4, &tx_buffer[data_len], 8);															data_len+=8;
	tx_buffer[data_len]=0x0a;																								data_len+=1;

	memcpy(&tx_buffer[data_len], "解灰认证码:", 11);												data_len+=11;
	hex2Ascii(&buffer[35],4, &tx_buffer[data_len], 8);															data_len+=8;
	tx_buffer[data_len]=0x0a;																								data_len+=1;

	memcpy(&tx_buffer[data_len], "灰锁签名:", 9);														data_len+=9;
	hex2Ascii(&buffer[39],4, &tx_buffer[data_len], 8);															data_len+=8;
	tx_buffer[data_len]=0x0a;																								data_len+=1;

	memcpy(&tx_buffer[data_len], "PSAM应用号:", 11);													data_len+=11;
	hex2Ascii(&buffer[43], 10, &tx_buffer[data_len], 20);														data_len+=20;
	tx_buffer[data_len]=0x0a;																								data_len+=1;

	memcpy(&tx_buffer[data_len], "PSAM编号:", 9);															data_len+=9;
	hex2Ascii(&buffer[53], 6, &tx_buffer[data_len], 12);														data_len+=12;
	tx_buffer[data_len]=0x0a;																								data_len+=1;

	memcpy(&tx_buffer[data_len], "PSAM-TTC:", 9);																data_len+=9;
	memcpy(tmp_buffer,&buffer[59],4);
	tmp_int=(tmp_buffer[0]<<24)|(tmp_buffer[1]<<16)|(tmp_buffer[2]<<8)|(tmp_buffer[3]<<0);
	data=hex2Bcd(tmp_int);
	for(i=0; i<=9; i++)	tmp_buffer[i]=((data>>((9-i)*4))&0x0f)+0x30;
	for(i=0; i<=8; i++)	if('0'!=tmp_buffer[i])	break;
	memcpy(&tx_buffer[data_len], &tmp_buffer[i], 10-i);														data_len+=(10-i);
	tx_buffer[data_len]=0x0a;																								data_len+=1;

	memcpy(&tx_buffer[data_len], "扣款来源:", 9);														data_len+=9;
	memcpy(tmp_buffer,&buffer[63],1);
	if(0==tmp_buffer[0])					
	{
		memcpy(&tx_buffer[data_len], "电子油票", 8);													data_len+=8;
	}
	else if(1==tmp_buffer[0])
	{
		memcpy(&tx_buffer[data_len], "积分应用", 8);													data_len+=8;
	}
	else if(0x90 ==tmp_buffer[0])
	{
		memcpy(&tx_buffer[data_len], "条码现金", 8);													data_len+=8;
	}
	else if(0x91 ==tmp_buffer[0])
	{
		memcpy(&tx_buffer[data_len], "ETC卡", 5);														data_len+=5;
	}
	else if(0x92 ==tmp_buffer[0])
	{
		memcpy(&tx_buffer[data_len], "微信", 4);															data_len+=4;
	}
	else if(0x93 ==tmp_buffer[0])
	{
		memcpy(&tx_buffer[data_len], "支付宝", 6);														data_len+=6;
	}
	else if(0x94 ==tmp_buffer[0])
	{
		memcpy(&tx_buffer[data_len], "现金", 4);															data_len+=4;
	}
	else if(0x95 ==tmp_buffer[0])
	{
		memcpy(&tx_buffer[data_len], "油票", 4);															data_len+=4;
	}
	tx_buffer[data_len]=0x0a;																					data_len+=1;

	memcpy(&tx_buffer[data_len], "支付类型:", 9);														data_len+=9;
	memcpy(tmp_buffer,&buffer[64],1);
	if(0==((tmp_buffer[0]>>4)&0x0f))					
	{
		memcpy(&tx_buffer[data_len], "现金", 4);																data_len+=4;
	}
	else if(1==((tmp_buffer[0]>>4)&0x0f))
	{
		memcpy(&tx_buffer[data_len], "油票", 4);																data_len+=4;
	}
	else if(2==((tmp_buffer[0]>>4)&0x0f))
	{
		memcpy(&tx_buffer[data_len], "记账", 4);																data_len+=4;
	}
	else if(3==((tmp_buffer[0]>>4)&0x0f))
	{
		memcpy(&tx_buffer[data_len], "银行卡", 6);															data_len+=6;
	}
	else if(4==((tmp_buffer[0]>>4)&0x0f))
	{
		memcpy(&tx_buffer[data_len], "其它1", 5);																data_len+=5;
	}
	else if(5==((tmp_buffer[0]>>4)&0x0f))
	{
		memcpy(&tx_buffer[data_len], "其它2", 5);																data_len+=5;
	}
	tx_buffer[data_len]=0x0a;																								data_len+=1;

	memcpy(&tx_buffer[data_len], "结算单位:", 9);														data_len+=9;
	memcpy(tmp_buffer,&buffer[64],1);
	if(0==(tmp_buffer[0]&0x03))					
	{
		memcpy(&tx_buffer[data_len], "分", 2);																		data_len+=2;
	}
	else
	{
		memcpy(&tx_buffer[data_len], "点", 2);																		data_len+=2;
	}
	tx_buffer[data_len]=0x0a;																								data_len+=1;

	memcpy(&tx_buffer[data_len], "卡类:", 5);																	data_len+=5;
	hex2Ascii(&buffer[65], 1, &tx_buffer[data_len], 2);															data_len+=2;
	tx_buffer[data_len]=0x0a;																								data_len+=1;

	hex2Ascii(&buffer[66], 1, &tmp_buffer[0], 2);	

	memcpy(&tx_buffer[data_len], "卡密钥版本号:", 13);										data_len+=13;
	tx_buffer[data_len]=tmp_buffer[1];																					data_len+=1;
	tx_buffer[data_len]=0x0a;																								data_len+=1;

	memcpy(&tx_buffer[data_len], "卡密钥索引号:", 13);										data_len+=13;
	tx_buffer[data_len]=tmp_buffer[0];																					data_len+=1;
	tx_buffer[data_len]=0x0a;																								data_len+=1;

	memcpy(&tx_buffer[data_len], "员工号:", 7);															data_len+=7;
	memcpy(tmp_buffer,&buffer[75],1);
	data=hex2Bcd(tmp_buffer[0]);
	tmp_buffer[0]=((data>>8)&0x0f)+0x30;	tmp_buffer[1]=((data>>4)&0x0f)+0x30;	tmp_buffer[2]=((data>>0)&0x0f)+0x30;
	for(i=0; i<2; i++)	if('0'!=tmp_buffer[i])	break;
	memcpy(&tx_buffer[data_len], &tmp_buffer[i], 3-i);															data_len+=(3-i);
	tx_buffer[data_len]=0x0a;																								data_len+=1;

	memcpy(&tx_buffer[data_len], "升累计:", 7);															data_len+=7;
	memcpy(tmp_buffer,&buffer[76],4);
	tmp_int=(tmp_buffer[0]<<24)|(tmp_buffer[1]<<16)|(tmp_buffer[2]<<8)|(tmp_buffer[3]<<0);
	data=hex2Bcd(tmp_int);
	for(i=0; i<=9; i++)	tmp_buffer[i]=((data>>((9-i)*4))&0x0f)+0x30;
	for(i=0; i<=6; i++)	if('0'!=tmp_buffer[i])	break;
	memcpy(&tx_buffer[data_len], &tmp_buffer[i], 8-i);															data_len+=(8-i);
	tx_buffer[data_len]='.';																										data_len+=1;
	tx_buffer[data_len]=((data>>4)&0x0f)+0x30;																	data_len+=1;
	tx_buffer[data_len]=((data>>0)&0x0f)+0x30;																	data_len+=1;
	memcpy(&tx_buffer[data_len], "升", 2);																			data_len+=2;
	tx_buffer[data_len]=0x0a;																								data_len+=1;

	memcpy(&tx_buffer[data_len], "终端数据认证码:", 15);									data_len+=15;
	hex2Ascii(&buffer[91], 4, &tx_buffer[data_len], 8);														data_len+=8;
	tx_buffer[data_len]=0x0a;																								data_len+=1;

	memcpy(&tx_buffer[data_len], "        ----------------", 24);									data_len+=24;
	tx_buffer[data_len]=0x0a;																							data_len+=1;

	memcpy(&tx_buffer[data_len], "加油站编码:", 11);											data_len+=11;
	memcpy(tmp_buffer, IptPcInfo.SInfo.S_ID, 4);
	hex2Ascii(tmp_buffer, 4, &tx_buffer[data_len], 8);														data_len+=8;
	tx_buffer[data_len]=0x0a;																							data_len+=1;

	memcpy(&tx_buffer[data_len], "枪号:", 5);																data_len+=5;
	memcpy(tmp_buffer,&buffer[67],1);
	data=hex2Bcd(tmp_buffer[0]);	
	tmp_buffer[0]=((data>>8)&0x0f)+0x30;	tmp_buffer[1]=((data>>4)&0x0f)+0x30;	tmp_buffer[2]=((data>>0)&0x0f)+0x30;
	for(i=0; i<2; i++)	if('0'!=tmp_buffer[i])	break;
	memcpy(&tx_buffer[data_len], &tmp_buffer[i], 3-i);														data_len+=(3-i);
	tx_buffer[data_len]=0x0a;																							data_len+=1;

	memcpy(&tx_buffer[data_len], "卡号:", 5);																data_len+=5;
	hex2Ascii(&buffer[12], 10, &tx_buffer[data_len], 20);													data_len+=20;
	tx_buffer[data_len]=0x0a;																							data_len+=1;

	memcpy(&tx_buffer[data_len], "流水号(POS_TTC):", 16);										data_len+=16;
	memcpy(tmp_buffer,&buffer[0],4);
	tmp_int=(tmp_buffer[0]<<24)|(tmp_buffer[1]<<16)|(tmp_buffer[2]<<8)|(tmp_buffer[3]<<0);
	data=hex2Bcd(tmp_int);
	for(i=0; i<=9; i++)	tmp_buffer[i]=((data>>((9-i)*4))&0x0f)+0x30;
	for(i=0; i<=8; i++)	if('0'!=tmp_buffer[i])	break;
	memcpy(&tx_buffer[data_len], &tmp_buffer[i], 10-i);													data_len+=(10-i);
	tx_buffer[data_len]=0x0a;																							data_len+=1;

	memcpy(&tx_buffer[data_len], "扣前余额:", 9);													data_len+=9;
	memcpy(tmp_buffer,&buffer[97],4);
	tmp_int=(tmp_buffer[0]<<24)|(tmp_buffer[1]<<16)|(tmp_buffer[2]<<8)|(tmp_buffer[3]<<0);
	data=hex2Bcd(tmp_int);
	for(i=0; i<=9; i++)	tmp_buffer[i]=((data>>((9-i)*4))&0x0f)+0x30;
	for(i=0; i<=6; i++)	if('0'!=tmp_buffer[i])	break;
	memcpy(&tx_buffer[data_len], &tmp_buffer[i], 8-i);														data_len+=(8-i);
	tx_buffer[data_len]='.';																									data_len+=1;
	tx_buffer[data_len]=((data>>4)&0x0f)+0x30;																data_len+=1;
	tx_buffer[data_len]=((data>>0)&0x0f)+0x30;																data_len+=1;
	tx_buffer[data_len]=0x0a;																							data_len+=1;

	memcpy(&tx_buffer[data_len], "油品代码:", 9);													data_len+=9;
	hex2Ascii(&buffer[68], 2, &tx_buffer[data_len], 4);														data_len+=4;
	tx_buffer[data_len]=0x0a;																							data_len+=1;

	memcpy(&tx_buffer[data_len], "单价:", 5);																data_len+=5;
	memcpy(tmp_buffer,&buffer[73],2);
	tmp_int=(tmp_buffer[0]<<8)|(tmp_buffer[1]<<0);
	data=hex2Bcd(tmp_int);
	if(0!=(unsigned char)((data>>12)&0x0f))
	{
		tx_buffer[data_len]=((data>>12)&0x0f)+0x30;														data_len+=1;
	}
	tx_buffer[data_len]=((data>>8)&0x0f)+0x30;																data_len+=1;
	tx_buffer[data_len]='.';																									data_len+=1;
	tx_buffer[data_len]=((data>>4)&0x0f)+0x30;																data_len+=1;
	tx_buffer[data_len]=((data>>0)&0x0f)+0x30;																data_len+=1;
	tx_buffer[data_len]=0x0a;																							data_len+=1;

	memcpy(&tx_buffer[data_len], "加油升数:", 9);													data_len+=9;
	memcpy(tmp_buffer,&buffer[70],3);
	tmp_int=(tmp_buffer[0]<<16)|(tmp_buffer[1]<<8)|(tmp_buffer[2]<<0);
	data=hex2Bcd(tmp_int);
	for(i=0; i<=7; i++)	tmp_buffer[i]=((data>>((7-i)*4))&0x0f)+0x30;
	for(i=0; i<=4; i++)	if('0'!=tmp_buffer[i])	break;
	memcpy(&tx_buffer[data_len], &tmp_buffer[i], 6-i);														data_len+=(6-i);
	tx_buffer[data_len]='.';																									data_len+=1;
	tx_buffer[data_len]=((data>>4)&0x0f)+0x30;																data_len+=1;
	tx_buffer[data_len]=((data>>0)&0x0f)+0x30;																data_len+=1;
	memcpy(&tx_buffer[data_len], "升",2);																			data_len+=2;
	tx_buffer[data_len]=0x0a;																							data_len+=1;

	memcpy(&tx_buffer[data_len], "加油金额:", 9);																data_len+=9;
	memcpy(tmp_buffer,&buffer[26],3);
	tmp_int=(tmp_buffer[0]<<16)|(tmp_buffer[1]<<8)|(tmp_buffer[2]<<0);
	data=hex2Bcd(tmp_int);
	for(i=0; i<=7; i++)	tmp_buffer[i]=((data>>((7-i)*4))&0x0f)+0x30;
	for(i=0; i<=4; i++)	if('0'!=tmp_buffer[i])	break;
	memcpy(&tx_buffer[data_len], &tmp_buffer[i], 6-i);														data_len+=(6-i);
	tx_buffer[data_len]='.';																									data_len+=1;
	tx_buffer[data_len]=((data>>4)&0x0f)+0x30;																data_len+=1;
	tx_buffer[data_len]=((data>>0)&0x0f)+0x30;																data_len+=1;
	memcpy(tmp_buffer,&buffer[64],1);
	if(0==(tmp_buffer[0]&0x03))					
	{
		memcpy(&tx_buffer[data_len], "元", 2);																	data_len+=2;
	}
	else
	{
		memcpy(&tx_buffer[data_len], "点", 2);																	data_len+=2;
	}
	tx_buffer[data_len]=0x0a;																							data_len+=1;

	memcpy(&tx_buffer[data_len], "扣后余额:", 9);																data_len+=9;
	memcpy(tmp_buffer,&buffer[22],4);
	tmp_int=(tmp_buffer[0]<<24)|(tmp_buffer[1]<<16)|(tmp_buffer[2]<<8)|(tmp_buffer[3]<<0);
	data=hex2Bcd(tmp_int);
	for(i=0; i<=9; i++)	tmp_buffer[i]=((data>>((9-i)*4))&0x0f)+0x30;
	for(i=0; i<=6; i++)	if('0'!=tmp_buffer[i])	break;
	memcpy(&tx_buffer[data_len], &tmp_buffer[i], 8-i);														data_len+=(8-i);
	tx_buffer[data_len]='.';																									data_len+=1;
	tx_buffer[data_len]=((data>>4)&0x0f)+0x30;																data_len+=1;
	tx_buffer[data_len]=((data>>0)&0x0f)+0x30;																data_len+=1;
	tx_buffer[data_len]=0x0a;																							data_len+=1;

	memcpy(&tx_buffer[data_len], "交易类型:", 9);																data_len+=9;
	memcpy(tmp_buffer,&buffer[4],1);
	if(IPT_BILLTYPE_NORMAL==(tmp_buffer[0]&0x0f))
	{memcpy(&tx_buffer[data_len], "正常", 4);																data_len+=4;}
	else if(IPT_BILLTYPE_ESCAPE==(tmp_buffer[0]&0x0f))
	{memcpy(&tx_buffer[data_len], "逃卡", 4);																data_len+=4;}
	else if(IPT_BILLTYPE_ERROR==(tmp_buffer[0]&0x0f))
	{memcpy(&tx_buffer[data_len], "错卡", 4);																data_len+=4;}
	else if(IPT_BILLTYPE_UNLOCK==(tmp_buffer[0]&0x0f))
	{memcpy(&tx_buffer[data_len], "补扣", 4);																data_len+=4;}
	else if(IPT_BILLTYPE_FINISH==(tmp_buffer[0]&0x0f))
	{memcpy(&tx_buffer[data_len], "补充", 4);																data_len+=4;}
	else if(IPT_BILLTYPE_WORKON==(tmp_buffer[0]&0x0f))
	{memcpy(&tx_buffer[data_len], "上班", 4);																data_len+=4;}
	else if(IPT_BILLTYPE_WORKOFF==(tmp_buffer[0]&0x0f))
	{memcpy(&tx_buffer[data_len], "下班", 4);																data_len+=4;}
	else if(IPT_BILLTYPE_UNSELF==(tmp_buffer[0]&0x0f))
	{memcpy(&tx_buffer[data_len], "非卡", 4);																data_len+=4;}
	else if(IPT_BILLTYPE_OILINFO==(tmp_buffer[0]&0x0f))
	{memcpy(&tx_buffer[data_len], "油价接收", 8);													data_len+=8;}
	else if(IPT_BILLTYPE_REFUSE==(tmp_buffer[0]&0x0f))
	{memcpy(&tx_buffer[data_len], "卡错拒绝", 8);													data_len+=8;}
	tx_buffer[data_len]=0x0a;																							data_len+=1;

	memcpy(&tx_buffer[data_len], "交易时间:", 11);												data_len+=11;
	memcpy(tmp_buffer,&buffer[5],7);
	tx_buffer[data_len+0]=((tmp_buffer[0]>>4)&0x0f)+0x30;tx_buffer[data_len+1]=((tmp_buffer[0]>>0)&0x0f)+0x30;
	tx_buffer[data_len+2]=((tmp_buffer[1]>>4)&0x0f)+0x30;tx_buffer[data_len+3]=((tmp_buffer[1]>>0)&0x0f)+0x30;
	memcpy(&tx_buffer[data_len+4], "年", 2);
	tx_buffer[data_len+6]=((tmp_buffer[2]>>4)&0x0f)+0x30;tx_buffer[data_len+7]=((tmp_buffer[2]>>0)&0x0f)+0x30;
	memcpy(&tx_buffer[data_len+8], "月", 2);
	tx_buffer[data_len+10]=((tmp_buffer[3]>>4)&0x0f)+0x30;tx_buffer[data_len+11]=((tmp_buffer[3]>>0)&0x0f)+0x30;
	memcpy(&tx_buffer[data_len+12], "日", 2);
	tx_buffer[data_len+14]=((tmp_buffer[4]>>4)&0x0f)+0x30;tx_buffer[data_len+15]=((tmp_buffer[4]>>0)&0x0f)+0x30;
	tx_buffer[data_len+16]=':';
	tx_buffer[data_len+17]=((tmp_buffer[5]>>4)&0x0f)+0x30;tx_buffer[data_len+18]=((tmp_buffer[5]>>0)&0x0f)+0x30;
	tx_buffer[data_len+19]=':';
	tx_buffer[data_len+20]=((tmp_buffer[6]>>4)&0x0f)+0x30;tx_buffer[data_len+21]=((tmp_buffer[6]>>0)&0x0f)+0x30;
																																						data_len+=22;
	tx_buffer[data_len]=0x0a;																								data_len+=1;

	memcpy(&tx_buffer[data_len], "        ----------------", 24);									data_len+=24;
	tx_buffer[data_len]=0x0a;																								data_len+=1;

	memcpy(&tx_buffer[data_len], "       不做报销凭证(第1联)", 26);			data_len+=26;
	tx_buffer[data_len]=0x0a;																								data_len+=1;

	memcpy(&tx_buffer[data_len], "\x1B\x4A\x50\x1D\x56\x01", 6);		data_len+=6;//半切纸 (通用)
	//memcpy(&tx_buffer[data_len], "\x1B\x6D", 2);																data_len+=2;//半切纸 (莹浦通)
	//memcpy(&tx_buffer[data_len], "\x1D\x56\x42\x00\x1B\x63\x38", 7);							data_len+=7;//半切纸 (公达)

	pprint(iptparam->Printer, tx_buffer, data_len);

	return 0;
}


/*******************************************************************
*Name				:iptPrintSINOPECSelf
*Description		:打印石化条码自助联小票
*Input				:iptparam		IPT参数结构体
*						:isagain		是否是重打印0 = 否；1 = 是；
*						:buffer			打印的完整账单内容
*						:nbytes		打印内容长度
*Output			:None
*Return			:成功返回0；失败返回ERROR
*History			:2014-04-10,modified by syj  */

static int iptPrintSINOPECSelf(const IptParamStructType *iptparam, char isagain, const char *buffer, int nbytes)
{
	unsigned char tmp_buffer[32]={0}, tmp_buffer2[32]={0}, tx_buffer[2048]={0};
	unsigned int data_len=0, tmp_int=0, tmp_int2=0, tmp_int3=0;
	int i=0;
	long long data=0;
	unsigned char oilname1[60]={0},oilname2[60]={0},namelen=0;

	//打印自助加油联
	//用户联格式如下:
	//	__________________________________________________________
	//	|		欢迎自助加油																		|
	//	|-----------------------------------------								|
	//	|授权验证码：933955																	|
	//	|加油站编码：32851143																|
	//	|枪号：4																								|
	//	|交易序号：2367																			|
	//	|加油油品：90#汽油																	|
	//	|单价：5.58元/升																			|
	//	|加油升数：10.75升																		|
	//	|加油金额：60.00元																		|
	//	|缴费金额：100.00元																	|
	//	|余额：40.00元																					|
	//	|交易时间：2008年10月23日 9:10:00										|
	//	|-----------------------------------------								|
	//	|如有余额，请凭此小票立即到营业室找零，|
	//	|并索取发票，小票自交易时间24小时内有		|
	//	|效，该小票不作为报销凭证。									|
	//	__________________________________________________________	
	
	//初始化打印机
	memcpy(&tx_buffer[data_len], "\x1B\x40",2);				data_len+=2;	//初始化打印机
	//memcpy(&tx_buffer[10], "\x1D\x21\x00",3);				data_len+=3;	//定义字符倍数
	//memcpy(&tx_buffer[data_len], "\x1B\x33\x20",3);	data_len+=3;	//行间距间距

	memcpy(&tx_buffer[data_len], "          欢迎自助加油", 22);		data_len+=22;
	tx_buffer[data_len]=0x0a;																		data_len+=1;
		
	memcpy(&tx_buffer[data_len], "        ----------------", 24);				data_len+=24;
	tx_buffer[data_len]=0x0a;																		data_len+=1;

	memcpy(&tx_buffer[data_len], "授权验证码:", 11);											data_len+=11;	
	if(((buffer[21]>>4)&0x0f)<=9)	tx_buffer[data_len]=((buffer[21]>>4)&0x0f)+0x30;								
	else																	tx_buffer[data_len]=' ';
	data_len+=1;
	if(((buffer[21]>>0)&0x0f)<=9)	tx_buffer[data_len]=((buffer[21]>>0)&0x0f)+0x30;								
	else																	tx_buffer[data_len]=' ';
	data_len+=1;
	if(((buffer[22]>>4)&0x0f)<=9)	tx_buffer[data_len]=((buffer[22]>>4)&0x0f)+0x30;								
	else																	tx_buffer[data_len]=' ';
	data_len+=1;
	if(((buffer[22]>>0)&0x0f)<=9)	tx_buffer[data_len]=((buffer[22]>>0)&0x0f)+0x30;								
	else																	tx_buffer[data_len]=' ';
	data_len+=1;
	if(((buffer[23]>>4)&0x0f)<=9)	tx_buffer[data_len]=((buffer[23]>>4)&0x0f)+0x30;								
	else																	tx_buffer[data_len]=' ';
	data_len+=1;
	if(((buffer[23]>>0)&0x0f)<=9)	tx_buffer[data_len]=((buffer[23]>>0)&0x0f)+0x30;								
	else																	tx_buffer[data_len]=' ';
	data_len+=1;
	if(((buffer[24]>>4)&0x0f)<=9)	tx_buffer[data_len]=((buffer[24]>>4)&0x0f)+0x30;								
	else																	tx_buffer[data_len]=' ';
	data_len+=1;
	if(((buffer[24]>>0)&0x0f)<=9)	tx_buffer[data_len]=((buffer[24]>>0)&0x0f)+0x30;								
	else																	tx_buffer[data_len]=' ';
	data_len+=1;
	if(((buffer[25]>>4)&0x0f)<=9)	tx_buffer[data_len]=((buffer[25]>>4)&0x0f)+0x30;								
	else																	tx_buffer[data_len]=' ';
	data_len+=1;
	if(((buffer[25]>>0)&0x0f)<=9)	tx_buffer[data_len]=((buffer[25]>>0)&0x0f)+0x30;								
	else																	tx_buffer[data_len]=' ';
	data_len+=1;
	tx_buffer[data_len]=0x0a;																							data_len+=1;

	memcpy(&tx_buffer[data_len], "加油站编码:", 11);											data_len+=11;
	memcpy(tmp_buffer, IptPcInfo.SInfo.S_ID, 4);
	hex2Ascii(tmp_buffer, 4, &tx_buffer[data_len], 8);														data_len+=8;
	tx_buffer[data_len]=0x0a;																							data_len+=1;

	memcpy(&tx_buffer[data_len], "枪号:", 5);																data_len+=5;
	memcpy(tmp_buffer,&buffer[0],1);
	data=hex2Bcd(tmp_buffer[0]);	
	tmp_buffer2[0]=((data>>8)&0x0f)+0x30;	tmp_buffer2[1]=((data>>4)&0x0f)+0x30;	tmp_buffer2[2]=((data>>0)&0x0f)+0x30;
	for(i=0; i<2; i++)	if('0'!=tmp_buffer2[i])	break;
	memcpy(&tx_buffer[data_len], &tmp_buffer2[i], 3-i);													data_len+=(3-i);
	tx_buffer[data_len]=0x0a;																							data_len+=1;

	memcpy(&tx_buffer[data_len], "交易序号:", 9);													data_len+=9;
	memcpy(tmp_buffer,&buffer[1],4);
	tmp_int=(tmp_buffer[0]<<24)|(tmp_buffer[1]<<16)|(tmp_buffer[2]<<8)|(tmp_buffer[3]<<0);
	data=hex2Bcd(tmp_int);
	for(i=0; i<=8; i++)	tmp_buffer[i]=((data>>((8-i)*4))&0x0f)+0x30;
	for(i=0; i<=7; i++)	if('0'!=tmp_buffer[i])	break;
	memcpy(&tx_buffer[data_len], &tmp_buffer[i], 9-i);														data_len+=(9-i);
	tx_buffer[data_len]=0x0a;																							data_len+=1;

	memcpy(&tx_buffer[data_len], "加油油品:", 9);	
	data_len+=9;
	spkFileNameGet(iptparam->OilVoice, oilname1, 60); //szb_fj_20171120:增加
	for(i=0;i<strlen(oilname1);i++)
	{
		if(oilname1[i]=='_')	
		{
			namelen++;
			if(namelen==2)
				{
					memcpy(oilname2,oilname1+i+1,strlen(oilname1)-4-(i+1));
					break;
				}
		}
	}
	memset(oilname1,0,sizeof(oilname1));
	memcpy(oilname1,oilname2,strlen(oilname2));
	memset(oilname2,0,sizeof(oilname2));
	for(i=0;i<strlen(oilname1);i++)
	{
		if(memcmp(oilname1+i,"??",2)==0)
		{
			oilname2[i]='#';
			if(oilname1[i+2]==' ')
				memcpy(oilname2+i+1,oilname1+i+2+1,strlen(oilname1)-(i+2+1));
			else
				memcpy(oilname2+i+1,oilname1+i+2,strlen(oilname1)-(i+2));
		}
		else
			oilname2[i]=oilname1[i];
	}
	memcpy(&tx_buffer[data_len], oilname2, strlen(oilname2));
	data_len+=strlen(oilname2);
	//memcpy(&tx_buffer[data_len], iptparam->OilName, strlen(iptparam->OilName));		data_len+=strlen(iptparam->OilName);
	tx_buffer[data_len]=0x0a;																							data_len+=1;

	memcpy(&tx_buffer[data_len], "单价:", 5);																data_len+=5;
	memcpy(tmp_buffer,&buffer[26],2);
	tmp_int=(tmp_buffer[0]<<8)|(tmp_buffer[1]<<0);
	data=hex2Bcd(tmp_int);
	if(0!=(unsigned char)((data>>12)&0x0f))
	{
		tx_buffer[data_len]=((data>>12)&0x0f)+0x30;														data_len+=1;
	}
	tx_buffer[data_len]=((data>>8)&0x0f)+0x30;																data_len+=1;
	tx_buffer[data_len]='.';																									data_len+=1;
	tx_buffer[data_len]=((data>>4)&0x0f)+0x30;																data_len+=1;
	tx_buffer[data_len]=((data>>0)&0x0f)+0x30;																data_len+=1;
	tx_buffer[data_len]=0x0a;																							data_len+=1;

	memcpy(&tx_buffer[data_len], "加油升数:", 9);													data_len+=9;
	memcpy(tmp_buffer,&buffer[15],3);
	tmp_int=(tmp_buffer[0]<<16)|(tmp_buffer[1]<<8)|(tmp_buffer[2]<<0);
	data=hex2Bcd(tmp_int);
	for(i=0; i<=7; i++)	tmp_buffer[i]=((data>>((7-i)*4))&0x0f)+0x30;
	for(i=0; i<=4; i++)	if('0'!=tmp_buffer[i])	break;
	memcpy(&tx_buffer[data_len], &tmp_buffer[i], 6-i);														data_len+=(6-i);
	tx_buffer[data_len]='.';																									data_len+=1;
	tx_buffer[data_len]=((data>>4)&0x0f)+0x30;																data_len+=1;
	tx_buffer[data_len]=((data>>0)&0x0f)+0x30;																data_len+=1;
	memcpy(&tx_buffer[data_len], "升",2);																		data_len+=2;
	tx_buffer[data_len]=0x0a;																							data_len+=1;

	memcpy(&tx_buffer[data_len], "加油金额:", 9);													data_len+=9;
	memcpy(tmp_buffer,&buffer[12],3);
	tmp_int=(tmp_buffer[0]<<16)|(tmp_buffer[1]<<8)|(tmp_buffer[2]<<0);
	data=hex2Bcd(tmp_int);
	for(i=0; i<=7; i++)	tmp_buffer[i]=((data>>((7-i)*4))&0x0f)+0x30;
	for(i=0; i<=4; i++)	if('0'!=tmp_buffer[i])	break;
	memcpy(&tx_buffer[data_len], &tmp_buffer[i], 6-i);														data_len+=(6-i);
	tx_buffer[data_len]='.';																									data_len+=1;
	tx_buffer[data_len]=((data>>4)&0x0f)+0x30;																data_len+=1;
	tx_buffer[data_len]=((data>>0)&0x0f)+0x30;																data_len+=1;
	memcpy(&tx_buffer[data_len], "元",2);																		data_len+=2;
	tx_buffer[data_len]=0x0a;																							data_len+=1;

	memcpy(&tx_buffer[data_len], "缴费金额:", 9);													data_len+=9;
	memcpy(tmp_buffer,&buffer[18],3);
	tmp_int=(tmp_buffer[0]<<16)|(tmp_buffer[1]<<8)|(tmp_buffer[2]<<0);
	data=hex2Bcd(tmp_int);
	for(i=0; i<=7; i++)	tmp_buffer[i]=((data>>((7-i)*4))&0x0f)+0x30;
	for(i=0; i<=4; i++)	if('0'!=tmp_buffer[i])	break;
	memcpy(&tx_buffer[data_len], &tmp_buffer[i], 6-i);														data_len+=(6-i);
	tx_buffer[data_len]='.';																									data_len+=1;
	tx_buffer[data_len]=((data>>4)&0x0f)+0x30;																data_len+=1;
	tx_buffer[data_len]=((data>>0)&0x0f)+0x30;																data_len+=1;
	memcpy(&tx_buffer[data_len], "元",2);																			data_len+=2;
	tx_buffer[data_len]=0x0a;																							data_len+=1;

	memcpy(&tx_buffer[data_len], "余额:", 5);																	data_len+=5;
	tmp_int2=(buffer[18]<<16)|(buffer[19]<<8)|(buffer[20]<<0);
	tmp_int3=(buffer[12]<<16)|(buffer[13]<<8)|(buffer[14]<<0);
	if(tmp_int2>=tmp_int3)	tmp_int=tmp_int2-tmp_int3;
	else									tmp_int=0;
	data=hex2Bcd(tmp_int);
	for(i=0; i<=7; i++)	tmp_buffer[i]=((data>>((7-i)*4))&0x0f)+0x30;
	for(i=0; i<=4; i++)	if('0'!=tmp_buffer[i])	break;
	memcpy(&tx_buffer[data_len], &tmp_buffer[i], 6-i);														data_len+=(6-i);
	tx_buffer[data_len]='.';																									data_len+=1;
	tx_buffer[data_len]=((data>>4)&0x0f)+0x30;																data_len+=1;
	tx_buffer[data_len]=((data>>0)&0x0f)+0x30;																data_len+=1;
	memcpy(&tx_buffer[data_len], "元",2);																			data_len+=2;
	tx_buffer[data_len]=0x0a;																							data_len+=1;

	memcpy(&tx_buffer[data_len], "交易时间:", 11);															data_len+=11;
	memcpy(tmp_buffer,&buffer[5],7);
	tx_buffer[data_len+0]=((tmp_buffer[0]>>4)&0x0f)+0x30;tx_buffer[data_len+1]=((tmp_buffer[0]>>0)&0x0f)+0x30;
	tx_buffer[data_len+2]=((tmp_buffer[1]>>4)&0x0f)+0x30;tx_buffer[data_len+3]=((tmp_buffer[1]>>0)&0x0f)+0x30;
	memcpy(&tx_buffer[data_len+4], "年", 2);
	tx_buffer[data_len+6]=((tmp_buffer[2]>>4)&0x0f)+0x30;tx_buffer[data_len+7]=((tmp_buffer[2]>>0)&0x0f)+0x30;
	memcpy(&tx_buffer[data_len+8], "月", 2);
	tx_buffer[data_len+10]=((tmp_buffer[3]>>4)&0x0f)+0x30;tx_buffer[data_len+11]=((tmp_buffer[3]>>0)&0x0f)+0x30;
	memcpy(&tx_buffer[data_len+12], "日", 2);
	tx_buffer[data_len+14]=((tmp_buffer[4]>>4)&0x0f)+0x30;tx_buffer[data_len+15]=((tmp_buffer[4]>>0)&0x0f)+0x30;
	tx_buffer[data_len+16]=':';
	tx_buffer[data_len+17]=((tmp_buffer[5]>>4)&0x0f)+0x30;tx_buffer[data_len+18]=((tmp_buffer[5]>>0)&0x0f)+0x30;
	tx_buffer[data_len+19]=':';
	tx_buffer[data_len+20]=((tmp_buffer[6]>>4)&0x0f)+0x30;tx_buffer[data_len+21]=((tmp_buffer[6]>>0)&0x0f)+0x30;
																																					data_len+=22;
	tx_buffer[data_len]=0x0a;																								data_len+=1;

	memcpy(&tx_buffer[data_len], "        ----------------", 24);				data_len+=24;
	tx_buffer[data_len]=0x0a;																		data_len+=1;

	//正常打印和重打印的条码小票最下方打印不同内容
	if(0 == isagain)
	{
		memcpy(&tx_buffer[data_len], "如有余额，请凭此小票立即到营业室找零，并索取发票，小票自交易时间24小时内有效，该小票不作为报销凭证。", 100);													
																																			data_len+=100;
		tx_buffer[data_len]=0x0a;																					data_len+=1;
	}
	else
	{
		memcpy(&tx_buffer[data_len], "该小票不作为报销凭证", 20);		data_len+=20;
		tx_buffer[data_len]=0x0a;																					data_len+=1;
		tx_buffer[data_len]=0x0a;																					data_len+=1;
		memcpy(&tx_buffer[data_len], "            重打凭证", 20);								data_len+=20;
		tx_buffer[data_len]=0x0a;																					data_len+=1;
	}

	memcpy(&tx_buffer[data_len], "\x1B\x4A\x50\x1D\x56\x01", 6);		data_len+=6;//半切纸 (通用)
	//memcpy(&tx_buffer[data_len], "\x1B\x6D", 2);																data_len+=2;//半切纸 (莹浦通)
	//memcpy(&tx_buffer[data_len], "\x1D\x56\x42\x00\x1B\x63\x38", 7);							data_len+=7;//半切纸 (公达)
		
	pprint(iptparam->Printer, tx_buffer, data_len);

	return 0;
}

/*******************************************************************
*Name				:iptPrint
*Description		:打印账单小票，根据prn_union以一定格式打印buffer内容
*						:每行最多32个ASCII字符
*Input				:iptparam		IPT参数结构体
*						:prn_union	0=打印用户联；1=打印两联；2=打印油站联；
*						:					3=打印自助加油联；4=重打印自助加油联
*						:buffer			打印账单内容
*						:nbytes		打印账单内容长度
*Output			:None
*Return			:成功返回0；失败返回ERROR
*History			:2014-04-10,modified by syj  */

//fj: 
int iptPrint(const IptParamStructType *iptparam, int prn_union, char *buffer, int nbytes)
{
	char isagain = 0;

	//打印联达加油站联
	if(MODEL_LIANDA == paramModelGet() && (0 == prn_union || 1 == prn_union || 2 == prn_union))
	{
		//iptPrintLianDaUser(iptparam, isagain, buffer, nbytes);
	
		return;
	}

	//打印油站联
	if(2 == prn_union || 1 == prn_union)
	{
		iptPrintSINOPECStation(iptparam, isagain, buffer, nbytes);
	}

	//打印用户联
	if(0 == prn_union || 1 == prn_union)
	{
		iptPrintSINOPECUser(iptparam, isagain, buffer, nbytes);
	}

	//打印自助加油联
	if(3==prn_union || 4==prn_union)
	{
		if(4 == prn_union)	isagain = 1;
		iptPrintSINOPECSelf(iptparam, isagain, buffer, nbytes);
	}

	return 0;
}

#if 0
/*******************************************************************
*Name				:iptPrint
*Description		:打印账单小票，根据prn_union以一定格式打印buffer内容
*						:每行最多32个ASCII字符
*Input				:iptparam		IPT参数结构体
*						:prn_union	0=打印用户联；1=打印两联；2=打印油站联；
*						:					3=打印自助加油联；4=重打印自助加油联
*						:buffer			打印内容
*						:nbytes			打印内容长度
*Output			:None
*Return				:成功返回0；失败返回ERROR
*History			:2014-04-10,modified by syj  */

static int iptPrint(const IptParamStructType *iptparam, int prn_union, const char *buffer, int nbytes)
{
	unsigned char tmp_buffer[32]={0}, tmp_buffer2[32]={0}, tx_buffer[2048]={0};
	unsigned int data_len=0, tmp_int=0, tmp_int2=0, tmp_int3=0;
	int i=0;
	long long data=0;

	//初始化打印机
	memcpy(&tx_buffer[data_len], "\x1B\x40",2);				data_len+=2;	//初始化打印机
	//memcpy(&tx_buffer[10], "\x1D\x21\x00",3);	data_len+=3;	//定义字符倍数
	//memcpy(&tx_buffer[data_len], "\x1B\x33\x20",3);		data_len+=3;	//行间距间距

	//打印油站联
	if((2==prn_union)||(1==prn_union))
	{
		//加油站联格式如下:
		-------------------------------------------
		|     欢迎使用中石化加油IC卡  		|
		|        				----------------					  	|
		|卡的CTC:XXXXX													|
		|电子签名:XXXXXXXX										|
		|解灰认证码:XXXXXXXX								|
		|灰锁签名:XXXXXXXX										|
		|PSAM应用号: XXXXXXXXXXXXXXXXXXX		|
		|PSAM编号:XXXXXXXXXXXX								|
		|PSAM-TTC:XXXXXXXXXX										|
		|扣款来源:电子油票/积分应用	|
		|支付类型:现金/油票....						|
		|结算单位:分/点										|
		|卡类: 00/01															|
		|卡密钥版本号:X       (HEX)						|
		|卡密钥索引号:X       (HEX)						|
		|员工号:XXX														|
		|升累计:XXXXXXXX.XX升								|
		|终端数据认证码:XXXXXXXX					|
		|        				----------------					  	|
		|加油站编码:XXXXXXXX								|
		|枪号:XXX																|
		|卡号:XXXXXXXXXXXXXXXXXXXX						|
		|流水号(POS_TTC):XXXXXXXXXX					|
		|扣前余额:XXXXXXXX.XX								|
		|油品代码:XXXX												|
		|单价:XX.XX															|
		|加油升数:XXXX.XX升									|
		|加油金额:XXXX.XX元									|
		|扣后余额:XXXXXXXX.XX								|
		|交易类型:正常											|
		|交易时间:XXXX年XX月XX日XX:XX:XX	|
		|        				----------------					  	|
		|			不做报销凭证(第1联)				|
		-------------------------------------------
		
		data_len = 5;

		if(MODEL_SINOPEC == paramModelGet())
		{
			memcpy(&tx_buffer[data_len], "     欢迎使用中石化加油IC卡", 27);			data_len+=27;
		}
		else
		{
			memcpy(&tx_buffer[data_len], "        欢迎使用加油IC卡", 24);			data_len+=24;
		}
		tx_buffer[data_len]=0x0a;																								data_len+=1;
		
		memcpy(&tx_buffer[data_len], "        ----------------", 24);										data_len+=24;
		tx_buffer[data_len]=0x0a;																								data_len+=1;

		memcpy(&tx_buffer[data_len], "卡的CTC:", 8);															data_len+=8;
		memcpy(tmp_buffer,&buffer[29],2);
		tmp_int=(tmp_buffer[0]<<8)|(tmp_buffer[1]<<0);
		data=hex2Bcd(tmp_int);
		for(i=0; i<=4; i++)	tmp_buffer[i]=((data>>((4-i)*4))&0x0f)+0x30;
		for(i=0; i<=3; i++)	if('0'!=tmp_buffer[i])	break;
		memcpy(&tx_buffer[data_len], &tmp_buffer[i], 5-i);															data_len+=(5-i);
		tx_buffer[data_len]=0x0a;																								data_len+=1;

		memcpy(&tx_buffer[data_len], "电子签名:", 9);														data_len+=9;
		hex2Ascii(&buffer[31],4, &tx_buffer[data_len], 8);															data_len+=8;
		tx_buffer[data_len]=0x0a;																								data_len+=1;

		memcpy(&tx_buffer[data_len], "解灰认证码:", 11);												data_len+=11;
		hex2Ascii(&buffer[35],4, &tx_buffer[data_len], 8);															data_len+=8;
		tx_buffer[data_len]=0x0a;																								data_len+=1;

		memcpy(&tx_buffer[data_len], "灰锁签名:", 9);														data_len+=9;
		hex2Ascii(&buffer[39],4, &tx_buffer[data_len], 8);															data_len+=8;
		tx_buffer[data_len]=0x0a;																								data_len+=1;

		memcpy(&tx_buffer[data_len], "PSAM应用号:", 11);													data_len+=11;
		hex2Ascii(&buffer[43], 10, &tx_buffer[data_len], 20);														data_len+=20;
		tx_buffer[data_len]=0x0a;																								data_len+=1;

		memcpy(&tx_buffer[data_len], "PSAM编号:", 9);															data_len+=9;
		hex2Ascii(&buffer[53], 6, &tx_buffer[data_len], 12);														data_len+=12;
		//memcpy(tmp_buffer,&buffer[53],6);
		for(i=0; i<6 ;i++)
		{
			tx_buffer[data_len]=((tmp_buffer[i]>>4)&0x0f)+0x30;												data_len+=1;
			tx_buffer[data_len]=((tmp_buffer[i]>>0)&0x0f)+0x30;												data_len+=1;
		}
		tx_buffer[data_len]=0x0a;																								data_len+=1;

		memcpy(&tx_buffer[data_len], "PSAM-TTC:", 9);																data_len+=9;
		memcpy(tmp_buffer,&buffer[59],4);
		tmp_int=(tmp_buffer[0]<<24)|(tmp_buffer[1]<<16)|(tmp_buffer[2]<<8)|(tmp_buffer[3]<<0);
		data=hex2Bcd(tmp_int);
		for(i=0; i<=9; i++)	tmp_buffer[i]=((data>>((9-i)*4))&0x0f)+0x30;
		for(i=0; i<=8; i++)	if('0'!=tmp_buffer[i])	break;
		memcpy(&tx_buffer[data_len], &tmp_buffer[i], 10-i);														data_len+=(10-i);
		tx_buffer[data_len]=0x0a;																								data_len+=1;

		memcpy(&tx_buffer[data_len], "扣款来源:", 9);														data_len+=9;
		memcpy(tmp_buffer,&buffer[63],1);
		if(0==tmp_buffer[0])					
		{
			memcpy(&tx_buffer[data_len], "电子油票", 8);													data_len+=8;
		}
		else if(1==tmp_buffer[0])
		{
			memcpy(&tx_buffer[data_len], "积分应用", 8);													data_len+=8;
		}
		else if(0x90 ==tmp_buffer[0])
		{
			memcpy(&tx_buffer[data_len], "条码现金", 8);													data_len+=8;
		}
		else if(0x91 ==tmp_buffer[0])
		{
			memcpy(&tx_buffer[data_len], "ETC卡", 5);														data_len+=5;
		}
		else if(0x92 ==tmp_buffer[0])
		{
			memcpy(&tx_buffer[data_len], "微信", 4);															data_len+=4;
		}
		else if(0x93 ==tmp_buffer[0])
		{
			memcpy(&tx_buffer[data_len], "支付宝", 6);														data_len+=6;
		}
		else if(0x94 ==tmp_buffer[0])
		{
			memcpy(&tx_buffer[data_len], "现金", 4);															data_len+=4;
		}
		else if(0x95 ==tmp_buffer[0])
		{
			memcpy(&tx_buffer[data_len], "油票", 4);															data_len+=4;
		}
		tx_buffer[data_len]=0x0a;																					data_len+=1;

		memcpy(&tx_buffer[data_len], "支付类型:", 9);														data_len+=9;
		memcpy(tmp_buffer,&buffer[64],1);
		if(0==((tmp_buffer[0]>>4)&0x0f))					
		{
			memcpy(&tx_buffer[data_len], "现金", 4);																data_len+=4;
		}
		else if(1==((tmp_buffer[0]>>4)&0x0f))
		{
			memcpy(&tx_buffer[data_len], "油票", 4);																data_len+=4;
		}
		else if(2==((tmp_buffer[0]>>4)&0x0f))
		{
			memcpy(&tx_buffer[data_len], "记账", 4);																data_len+=4;
		}
		else if(3==((tmp_buffer[0]>>4)&0x0f))
		{
			memcpy(&tx_buffer[data_len], "银行卡", 6);															data_len+=6;
		}
		else if(4==((tmp_buffer[0]>>4)&0x0f))
		{
			memcpy(&tx_buffer[data_len], "其它1", 5);																data_len+=5;
		}
		else if(5==((tmp_buffer[0]>>4)&0x0f))
		{
			memcpy(&tx_buffer[data_len], "其它2", 5);																data_len+=5;
		}
		tx_buffer[data_len]=0x0a;																								data_len+=1;

		memcpy(&tx_buffer[data_len], "结算单位:", 9);														data_len+=9;
		memcpy(tmp_buffer,&buffer[64],1);
		if(0==(tmp_buffer[0]&0x03))					
		{
			memcpy(&tx_buffer[data_len], "分", 2);																		data_len+=2;
		}
		else
		{
			memcpy(&tx_buffer[data_len], "点", 2);																		data_len+=2;
		}
		tx_buffer[data_len]=0x0a;																								data_len+=1;

		memcpy(&tx_buffer[data_len], "卡类:", 5);																	data_len+=5;
		hex2Ascii(&buffer[65], 1, &tx_buffer[data_len], 2);															data_len+=2;
		tx_buffer[data_len]=0x0a;																								data_len+=1;

		hex2Ascii(&buffer[66], 1, &tmp_buffer[0], 2);	

		memcpy(&tx_buffer[data_len], "卡密钥版本号:", 13);										data_len+=13;
		tx_buffer[data_len]=tmp_buffer[1];																					data_len+=1;
		tx_buffer[data_len]=0x0a;																								data_len+=1;

		memcpy(&tx_buffer[data_len], "卡密钥索引号:", 13);										data_len+=13;
		tx_buffer[data_len]=tmp_buffer[0];																					data_len+=1;
		tx_buffer[data_len]=0x0a;																								data_len+=1;

		memcpy(&tx_buffer[data_len], "员工号:", 7);															data_len+=7;
		memcpy(tmp_buffer,&buffer[75],1);
		data=hex2Bcd(tmp_buffer[0]);
		tmp_buffer[0]=((data>>8)&0x0f)+0x30;	tmp_buffer[1]=((data>>4)&0x0f)+0x30;	tmp_buffer[2]=((data>>0)&0x0f)+0x30;
		for(i=0; i<2; i++)	if('0'!=tmp_buffer[i])	break;
		memcpy(&tx_buffer[data_len], &tmp_buffer[i], 3-i);															data_len+=(3-i);
		tx_buffer[data_len]=0x0a;																								data_len+=1;

		memcpy(&tx_buffer[data_len], "升累计:", 7);															data_len+=7;
		memcpy(tmp_buffer,&buffer[76],4);
		tmp_int=(tmp_buffer[0]<<24)|(tmp_buffer[1]<<16)|(tmp_buffer[2]<<8)|(tmp_buffer[3]<<0);
		data=hex2Bcd(tmp_int);
		for(i=0; i<=9; i++)	tmp_buffer[i]=((data>>((9-i)*4))&0x0f)+0x30;
		for(i=0; i<=6; i++)	if('0'!=tmp_buffer[i])	break;
		memcpy(&tx_buffer[data_len], &tmp_buffer[i], 8-i);															data_len+=(8-i);
		tx_buffer[data_len]='.';																										data_len+=1;
		tx_buffer[data_len]=((data>>4)&0x0f)+0x30;																	data_len+=1;
		tx_buffer[data_len]=((data>>0)&0x0f)+0x30;																	data_len+=1;
		memcpy(&tx_buffer[data_len], "升", 2);																			data_len+=2;
		tx_buffer[data_len]=0x0a;																								data_len+=1;

		memcpy(&tx_buffer[data_len], "终端数据认证码:", 15);									data_len+=15;
		hex2Ascii(&buffer[91], 4, &tx_buffer[data_len], 8);														data_len+=8;
		tx_buffer[data_len]=0x0a;																								data_len+=1;

		memcpy(&tx_buffer[data_len], "        ----------------", 24);									data_len+=24;
		tx_buffer[data_len]=0x0a;																							data_len+=1;

		memcpy(&tx_buffer[data_len], "加油站编码:", 11);											data_len+=11;
		memcpy(tmp_buffer, IptPcInfo.SInfo.S_ID, 4);
		hex2Ascii(tmp_buffer, 4, &tx_buffer[data_len], 8);														data_len+=8;
		tx_buffer[data_len]=0x0a;																							data_len+=1;

		memcpy(&tx_buffer[data_len], "枪号:", 5);																data_len+=5;
		memcpy(tmp_buffer,&buffer[67],1);
		data=hex2Bcd(tmp_buffer[0]);	
		tmp_buffer[0]=((data>>8)&0x0f)+0x30;	tmp_buffer[1]=((data>>4)&0x0f)+0x30;	tmp_buffer[2]=((data>>0)&0x0f)+0x30;
		for(i=0; i<2; i++)	if('0'!=tmp_buffer[i])	break;
		memcpy(&tx_buffer[data_len], &tmp_buffer[i], 3-i);														data_len+=(3-i);
		tx_buffer[data_len]=0x0a;																							data_len+=1;

		memcpy(&tx_buffer[data_len], "卡号:", 5);																data_len+=5;
		hex2Ascii(&buffer[12], 10, &tx_buffer[data_len], 20);													data_len+=20;
		tx_buffer[data_len]=0x0a;																							data_len+=1;

		memcpy(&tx_buffer[data_len], "流水号(POS_TTC):", 16);										data_len+=16;
		memcpy(tmp_buffer,&buffer[0],4);
		tmp_int=(tmp_buffer[0]<<24)|(tmp_buffer[1]<<16)|(tmp_buffer[2]<<8)|(tmp_buffer[3]<<0);
		data=hex2Bcd(tmp_int);
		for(i=0; i<=9; i++)	tmp_buffer[i]=((data>>((9-i)*4))&0x0f)+0x30;
		for(i=0; i<=8; i++)	if('0'!=tmp_buffer[i])	break;
		memcpy(&tx_buffer[data_len], &tmp_buffer[i], 10-i);													data_len+=(10-i);
		tx_buffer[data_len]=0x0a;																							data_len+=1;

		memcpy(&tx_buffer[data_len], "扣前余额:", 9);													data_len+=9;
		memcpy(tmp_buffer,&buffer[97],4);
		tmp_int=(tmp_buffer[0]<<24)|(tmp_buffer[1]<<16)|(tmp_buffer[2]<<8)|(tmp_buffer[3]<<0);
		data=hex2Bcd(tmp_int);
		for(i=0; i<=9; i++)	tmp_buffer[i]=((data>>((9-i)*4))&0x0f)+0x30;
		for(i=0; i<=6; i++)	if('0'!=tmp_buffer[i])	break;
		memcpy(&tx_buffer[data_len], &tmp_buffer[i], 8-i);														data_len+=(8-i);
		tx_buffer[data_len]='.';																									data_len+=1;
		tx_buffer[data_len]=((data>>4)&0x0f)+0x30;																data_len+=1;
		tx_buffer[data_len]=((data>>0)&0x0f)+0x30;																data_len+=1;
		tx_buffer[data_len]=0x0a;																							data_len+=1;

		memcpy(&tx_buffer[data_len], "油品代码:", 9);													data_len+=9;
		hex2Ascii(&buffer[68], 2, &tx_buffer[data_len], 4);														data_len+=4;
		tx_buffer[data_len]=0x0a;																							data_len+=1;

		memcpy(&tx_buffer[data_len], "单价:", 5);																data_len+=5;
		memcpy(tmp_buffer,&buffer[73],2);
		tmp_int=(tmp_buffer[0]<<8)|(tmp_buffer[1]<<0);
		data=hex2Bcd(tmp_int);
		if(0!=(unsigned char)((data>>12)&0x0f))
		{
			tx_buffer[data_len]=((data>>12)&0x0f)+0x30;														data_len+=1;
		}
		tx_buffer[data_len]=((data>>8)&0x0f)+0x30;																data_len+=1;
		tx_buffer[data_len]='.';																									data_len+=1;
		tx_buffer[data_len]=((data>>4)&0x0f)+0x30;																data_len+=1;
		tx_buffer[data_len]=((data>>0)&0x0f)+0x30;																data_len+=1;
		tx_buffer[data_len]=0x0a;																							data_len+=1;

		memcpy(&tx_buffer[data_len], "加油升数:", 9);													data_len+=9;
		memcpy(tmp_buffer,&buffer[70],3);
		tmp_int=(tmp_buffer[0]<<16)|(tmp_buffer[1]<<8)|(tmp_buffer[2]<<0);
		data=hex2Bcd(tmp_int);
		for(i=0; i<=7; i++)	tmp_buffer[i]=((data>>((7-i)*4))&0x0f)+0x30;
		for(i=0; i<=4; i++)	if('0'!=tmp_buffer[i])	break;
		memcpy(&tx_buffer[data_len], &tmp_buffer[i], 6-i);														data_len+=(6-i);
		tx_buffer[data_len]='.';																									data_len+=1;
		tx_buffer[data_len]=((data>>4)&0x0f)+0x30;																data_len+=1;
		tx_buffer[data_len]=((data>>0)&0x0f)+0x30;																data_len+=1;
		memcpy(&tx_buffer[data_len], "升",2);																			data_len+=2;
		tx_buffer[data_len]=0x0a;																							data_len+=1;

		memcpy(&tx_buffer[data_len], "加油金额:", 9);																data_len+=9;
		memcpy(tmp_buffer,&buffer[26],3);
		tmp_int=(tmp_buffer[0]<<16)|(tmp_buffer[1]<<8)|(tmp_buffer[2]<<0);
		data=hex2Bcd(tmp_int);
		for(i=0; i<=7; i++)	tmp_buffer[i]=((data>>((7-i)*4))&0x0f)+0x30;
		for(i=0; i<=4; i++)	if('0'!=tmp_buffer[i])	break;
		memcpy(&tx_buffer[data_len], &tmp_buffer[i], 6-i);														data_len+=(6-i);
		tx_buffer[data_len]='.';																									data_len+=1;
		tx_buffer[data_len]=((data>>4)&0x0f)+0x30;																data_len+=1;
		tx_buffer[data_len]=((data>>0)&0x0f)+0x30;																data_len+=1;
		memcpy(tmp_buffer,&buffer[64],1);
		if(0==(tmp_buffer[0]&0x03))					
		{
			memcpy(&tx_buffer[data_len], "元", 2);																	data_len+=2;
		}
		else
		{
			memcpy(&tx_buffer[data_len], "点", 2);																	data_len+=2;
		}
		tx_buffer[data_len]=0x0a;																							data_len+=1;

		memcpy(&tx_buffer[data_len], "扣后余额:", 9);																data_len+=9;
		memcpy(tmp_buffer,&buffer[22],4);
		tmp_int=(tmp_buffer[0]<<24)|(tmp_buffer[1]<<16)|(tmp_buffer[2]<<8)|(tmp_buffer[3]<<0);
		data=hex2Bcd(tmp_int);
		for(i=0; i<=9; i++)	tmp_buffer[i]=((data>>((9-i)*4))&0x0f)+0x30;
		for(i=0; i<=6; i++)	if('0'!=tmp_buffer[i])	break;
		memcpy(&tx_buffer[data_len], &tmp_buffer[i], 8-i);														data_len+=(8-i);
		tx_buffer[data_len]='.';																									data_len+=1;
		tx_buffer[data_len]=((data>>4)&0x0f)+0x30;																data_len+=1;
		tx_buffer[data_len]=((data>>0)&0x0f)+0x30;																data_len+=1;
		tx_buffer[data_len]=0x0a;																							data_len+=1;

		memcpy(&tx_buffer[data_len], "交易类型:", 9);																data_len+=9;
		memcpy(tmp_buffer,&buffer[4],1);
		if(IPT_BILLTYPE_NORMAL==(tmp_buffer[0]&0x0f))
		{memcpy(&tx_buffer[data_len], "正常", 4);																data_len+=4;}
		else if(IPT_BILLTYPE_ESCAPE==(tmp_buffer[0]&0x0f))
		{memcpy(&tx_buffer[data_len], "逃卡", 4);																data_len+=4;}
		else if(IPT_BILLTYPE_ERROR==(tmp_buffer[0]&0x0f))
		{memcpy(&tx_buffer[data_len], "错卡", 4);																data_len+=4;}
		else if(IPT_BILLTYPE_UNLOCK==(tmp_buffer[0]&0x0f))
		{memcpy(&tx_buffer[data_len], "补扣", 4);																data_len+=4;}
		else if(IPT_BILLTYPE_FINISH==(tmp_buffer[0]&0x0f))
		{memcpy(&tx_buffer[data_len], "补充", 4);																data_len+=4;}
		else if(IPT_BILLTYPE_WORKON==(tmp_buffer[0]&0x0f))
		{memcpy(&tx_buffer[data_len], "上班", 4);																data_len+=4;}
		else if(IPT_BILLTYPE_WORKOFF==(tmp_buffer[0]&0x0f))
		{memcpy(&tx_buffer[data_len], "下班", 4);																data_len+=4;}
		else if(IPT_BILLTYPE_UNSELF==(tmp_buffer[0]&0x0f))
		{memcpy(&tx_buffer[data_len], "非卡", 4);																data_len+=4;}
		else if(IPT_BILLTYPE_OILINFO==(tmp_buffer[0]&0x0f))
		{memcpy(&tx_buffer[data_len], "油价接收", 8);													data_len+=8;}
		else if(IPT_BILLTYPE_REFUSE==(tmp_buffer[0]&0x0f))
		{memcpy(&tx_buffer[data_len], "卡错拒绝", 8);													data_len+=8;}
		tx_buffer[data_len]=0x0a;																							data_len+=1;

		memcpy(&tx_buffer[data_len], "交易时间:", 11);												data_len+=11;
		memcpy(tmp_buffer,&buffer[5],7);
		tx_buffer[data_len+0]=((tmp_buffer[0]>>4)&0x0f)+0x30;tx_buffer[data_len+1]=((tmp_buffer[0]>>0)&0x0f)+0x30;
		tx_buffer[data_len+2]=((tmp_buffer[1]>>4)&0x0f)+0x30;tx_buffer[data_len+3]=((tmp_buffer[1]>>0)&0x0f)+0x30;
		memcpy(&tx_buffer[data_len+4], "年", 2);
		tx_buffer[data_len+6]=((tmp_buffer[2]>>4)&0x0f)+0x30;tx_buffer[data_len+7]=((tmp_buffer[2]>>0)&0x0f)+0x30;
		memcpy(&tx_buffer[data_len+8], "月", 2);
		tx_buffer[data_len+10]=((tmp_buffer[3]>>4)&0x0f)+0x30;tx_buffer[data_len+11]=((tmp_buffer[3]>>0)&0x0f)+0x30;
		memcpy(&tx_buffer[data_len+12], "日", 2);
		tx_buffer[data_len+14]=((tmp_buffer[4]>>4)&0x0f)+0x30;tx_buffer[data_len+15]=((tmp_buffer[4]>>0)&0x0f)+0x30;
		tx_buffer[data_len+16]=':';
		tx_buffer[data_len+17]=((tmp_buffer[5]>>4)&0x0f)+0x30;tx_buffer[data_len+18]=((tmp_buffer[5]>>0)&0x0f)+0x30;
		tx_buffer[data_len+19]=':';
		tx_buffer[data_len+20]=((tmp_buffer[6]>>4)&0x0f)+0x30;tx_buffer[data_len+21]=((tmp_buffer[6]>>0)&0x0f)+0x30;
																																						data_len+=22;
		tx_buffer[data_len]=0x0a;																								data_len+=1;

		memcpy(&tx_buffer[data_len], "        ----------------", 24);									data_len+=24;
		tx_buffer[data_len]=0x0a;																								data_len+=1;

		memcpy(&tx_buffer[data_len], "       不做报销凭证(第1联)", 26);			data_len+=26;
		tx_buffer[data_len]=0x0a;																								data_len+=1;

		memcpy(&tx_buffer[data_len], "\x1B\x4A\x50\x1D\x56\x01", 6);		data_len+=6;//半切纸 (通用)
		//memcpy(&tx_buffer[data_len], "\x1B\x6D", 2);																data_len+=2;//半切纸 (莹浦通)
		//memcpy(&tx_buffer[data_len], "\x1D\x56\x42\x00\x1B\x63\x38", 7);							data_len+=7;//半切纸 (公达)

		pprint(iptparam->Printer, tx_buffer, data_len);
	}


	//打印用户联
	if((0==prn_union)||(1==prn_union))
	{
		//用户联格式如下:
		-------------------------------------------
		|     欢迎使用中石化加油IC卡  		|
		|        				----------------					  	|
		|加油站编码:XXXXXXXX								|
		|枪号:XXX																|
		|卡号:XXXXXXXXXXXXXXXXXXXX						|
		|流水号(POS_TTC):XXXXXXXXXX					|
		|扣前余额:XXXXXXXX.XX								|
		|油品代码:XXXX												|
		|单价:XX.XX															|
		|加油升数:XXXX.XX升									|
		|加油金额:XXXX.XX元									|
		|扣后余额:XXXXXXXX.XX								|
		|交易类型:正常											|
		|交易时间:XXXX年XX月XX日XX:XX:XX	|
		|        				----------------					  	|
		|			不做报销凭证(第2联)				|
		-------------------------------------------
		
		data_len = 5;

		if(MODEL_SINOPEC == paramModelGet())
		{
			memcpy(&tx_buffer[data_len], "     欢迎使用中石化加油IC卡", 27);			data_len+=27;
		}
		else
		{
			memcpy(&tx_buffer[data_len], "        欢迎使用加油IC卡", 24);			data_len+=24;
		}
		//memcpy(&tx_buffer[data_len], "     欢迎使用中石化加油IC卡", 27);		data_len+=27;
		tx_buffer[data_len]=0x0a;																							data_len+=1;
		
		memcpy(&tx_buffer[data_len], "        ----------------", 24);									data_len+=24;
		tx_buffer[data_len]=0x0a;																							data_len+=1;

		memcpy(&tx_buffer[data_len], "加油站编码:", 11);											data_len+=11;
		memcpy(tmp_buffer, IptPcInfo.SInfo.S_ID, 4);
		hex2Ascii(tmp_buffer, 4, &tx_buffer[data_len], 8);														data_len+=8;
		tx_buffer[data_len]=0x0a;																							data_len+=1;

		memcpy(&tx_buffer[data_len], "枪号:", 5);																data_len+=5;
		memcpy(tmp_buffer,&buffer[67],1);
		data=hex2Bcd(tmp_buffer[0]);	
		tmp_buffer2[0]=((data>>8)&0x0f)+0x30;	tmp_buffer2[1]=((data>>4)&0x0f)+0x30;	tmp_buffer2[2]=((data>>0)&0x0f)+0x30;
		for(i=0; i<2; i++)	if('0'!=tmp_buffer2[i])	break;
		memcpy(&tx_buffer[data_len], &tmp_buffer2[i], 3-i);													data_len+=(3-i);
		tx_buffer[data_len]=0x0a;																							data_len+=1;

		memcpy(&tx_buffer[data_len], "卡号:", 5);																data_len+=5;
		hex2Ascii(&buffer[12],10, &tx_buffer[data_len], 20);													data_len+=20;
		tx_buffer[data_len]=0x0a;																								data_len+=1;

		memcpy(&tx_buffer[data_len], "流水号(POS_TTC):", 16);										data_len+=16;
		memcpy(tmp_buffer,&buffer[0],4);
		tmp_int=(tmp_buffer[0]<<24)|(tmp_buffer[1]<<16)|(tmp_buffer[2]<<8)|(tmp_buffer[3]<<0);
		data=hex2Bcd(tmp_int);
		for(i=0; i<=8; i++)	tmp_buffer[i]=((data>>((8-i)*4))&0x0f)+0x30;
		for(i=0; i<=7; i++)	if('0'!=tmp_buffer[i])	break;
		memcpy(&tx_buffer[data_len], &tmp_buffer[i], 9-i);														data_len+=(9-i);
		tx_buffer[data_len]=0x0a;																							data_len+=1;

		memcpy(&tx_buffer[data_len], "扣前余额:", 9);													data_len+=9;
		memcpy(tmp_buffer,&buffer[97],4);
		tmp_int=(tmp_buffer[0]<<24)|(tmp_buffer[1]<<16)|(tmp_buffer[2]<<8)|(tmp_buffer[3]<<0);
		data=hex2Bcd(tmp_int);
		for(i=0; i<=9; i++)	tmp_buffer[i]=((data>>((9-i)*4))&0x0f)+0x30;
		for(i=0; i<=6; i++)	if('0'!=tmp_buffer[i])	break;
		memcpy(&tx_buffer[data_len], &tmp_buffer[i], 8-i);														data_len+=(8-i);
		tx_buffer[data_len]='.';																									data_len+=1;
		tx_buffer[data_len]=((data>>4)&0x0f)+0x30;																data_len+=1;
		tx_buffer[data_len]=((data>>0)&0x0f)+0x30;																data_len+=1;
		tx_buffer[data_len]=0x0a;																							data_len+=1;

		memcpy(&tx_buffer[data_len], "油品代码:", 9);													data_len+=9;
		hex2Ascii(&buffer[68], 2, &tx_buffer[data_len], 4);														data_len+=4;
		tx_buffer[data_len]=0x0a;																							data_len+=1;

		memcpy(&tx_buffer[data_len], "单价:", 5);																data_len+=5;
		memcpy(tmp_buffer,&buffer[73],2);
		tmp_int=(tmp_buffer[0]<<8)|(tmp_buffer[1]<<0);
		data=hex2Bcd(tmp_int);
		if(0!=(unsigned char)((data>>12)&0x0f))
		{
			tx_buffer[data_len]=((data>>12)&0x0f)+0x30;															data_len+=1;
		}
		tx_buffer[data_len]=((data>>8)&0x0f)+0x30;																data_len+=1;
		tx_buffer[data_len]='.';																										data_len+=1;
		tx_buffer[data_len]=((data>>4)&0x0f)+0x30;																data_len+=1;
		tx_buffer[data_len]=((data>>0)&0x0f)+0x30;																data_len+=1;
		tx_buffer[data_len]=0x0a;																								data_len+=1;

		memcpy(&tx_buffer[data_len], "加油升数:", 9);													data_len+=9;
		memcpy(tmp_buffer,&buffer[70],3);
		tmp_int=(tmp_buffer[0]<<16)|(tmp_buffer[1]<<8)|(tmp_buffer[2]<<0);
		data=hex2Bcd(tmp_int);
		for(i=0; i<=7; i++)	tmp_buffer[i]=((data>>((7-i)*4))&0x0f)+0x30;
		for(i=0; i<=4; i++)	if('0'!=tmp_buffer[i])	break;
		memcpy(&tx_buffer[data_len], &tmp_buffer[i], 6-i);														data_len+=(6-i);
		tx_buffer[data_len]='.';																									data_len+=1;
		tx_buffer[data_len]=((data>>4)&0x0f)+0x30;																data_len+=1;
		tx_buffer[data_len]=((data>>0)&0x0f)+0x30;																data_len+=1;
		memcpy(&tx_buffer[data_len], "升",2);																		data_len+=2;
		tx_buffer[data_len]=0x0a;																							data_len+=1;

		memcpy(&tx_buffer[data_len], "加油金额:", 9);													data_len+=9;
		memcpy(tmp_buffer,&buffer[26],3);
		tmp_int=(tmp_buffer[0]<<16)|(tmp_buffer[1]<<8)|(tmp_buffer[2]<<0);
		data=hex2Bcd(tmp_int);
		for(i=0; i<=7; i++)	tmp_buffer[i]=((data>>((7-i)*4))&0x0f)+0x30;
		for(i=0; i<=4; i++)	if('0'!=tmp_buffer[i])	break;
		memcpy(&tx_buffer[data_len], &tmp_buffer[i], 6-i);														data_len+=(6-i);
		tx_buffer[data_len]='.';																									data_len+=1;
		tx_buffer[data_len]=((data>>4)&0x0f)+0x30;																data_len+=1;
		tx_buffer[data_len]=((data>>0)&0x0f)+0x30;																data_len+=1;
		memcpy(tmp_buffer,&buffer[64],1);
		if(0==(tmp_buffer[0]&0x03))					
		{
			memcpy(&tx_buffer[data_len], "元", 2);																	data_len+=2;
		}
		else
		{
			memcpy(&tx_buffer[data_len], "点", 2);																	data_len+=2;
		}
		tx_buffer[data_len]=0x0a;																							data_len+=1;

		memcpy(&tx_buffer[data_len], "扣后余额:", 9);													data_len+=9;
		memcpy(tmp_buffer,&buffer[22],4);
		tmp_int=(tmp_buffer[0]<<24)|(tmp_buffer[1]<<16)|(tmp_buffer[2]<<8)|(tmp_buffer[3]<<0);
		data=hex2Bcd(tmp_int);
		for(i=0; i<=9; i++)	tmp_buffer[i]=((data>>((9-i)*4))&0x0f)+0x30;
		for(i=0; i<=6; i++)	if('0'!=tmp_buffer[i])	break;
		memcpy(&tx_buffer[data_len], &tmp_buffer[i], 8-i);														data_len+=(8-i);
		tx_buffer[data_len]='.';																									data_len+=1;
		tx_buffer[data_len]=((data>>4)&0x0f)+0x30;																data_len+=1;
		tx_buffer[data_len]=((data>>0)&0x0f)+0x30;																data_len+=1;
		tx_buffer[data_len]=0x0a;																							data_len+=1;

		memcpy(&tx_buffer[data_len], "交易类型:", 9);													data_len+=9;
		memcpy(tmp_buffer,&buffer[4],1);
		if(IPT_BILLTYPE_NORMAL==(tmp_buffer[0]&0x0f))
		{memcpy(&tx_buffer[data_len], "正常", 4);																data_len+=4;}
		else if(IPT_BILLTYPE_ESCAPE==(tmp_buffer[0]&0x0f))
		{memcpy(&tx_buffer[data_len], "逃卡", 4);																data_len+=4;}
		else if(IPT_BILLTYPE_ERROR==(tmp_buffer[0]&0x0f))
		{memcpy(&tx_buffer[data_len], "错卡", 4);																data_len+=4;}
		else if(IPT_BILLTYPE_UNLOCK==(tmp_buffer[0]&0x0f))
		{memcpy(&tx_buffer[data_len], "补扣", 4);																data_len+=4;}
		else if(IPT_BILLTYPE_FINISH==(tmp_buffer[0]&0x0f))
		{memcpy(&tx_buffer[data_len], "补充", 4);																data_len+=4;}
		else if(IPT_BILLTYPE_WORKON==(tmp_buffer[0]&0x0f))
		{memcpy(&tx_buffer[data_len], "上班", 4);																data_len+=4;}
		else if(IPT_BILLTYPE_WORKOFF==(tmp_buffer[0]&0x0f))
		{memcpy(&tx_buffer[data_len], "下班", 4);																data_len+=4;}
		else if(IPT_BILLTYPE_UNSELF==(tmp_buffer[0]&0x0f))
		{memcpy(&tx_buffer[data_len], "非卡", 4);																data_len+=4;}
		else if(IPT_BILLTYPE_OILINFO==(tmp_buffer[0]&0x0f))
		{memcpy(&tx_buffer[data_len], "油价接收", 8);													data_len+=8;}
		else if(IPT_BILLTYPE_REFUSE==(tmp_buffer[0]&0x0f))
		{memcpy(&tx_buffer[data_len], "卡错拒绝", 8);													data_len+=8;}
		tx_buffer[data_len]=0x0a;																								data_len+=1;

		memcpy(&tx_buffer[data_len], "交易时间:", 11);													data_len+=11;
		memcpy(tmp_buffer,&buffer[5],7);
		tx_buffer[data_len+0]=((tmp_buffer[0]>>4)&0x0f)+0x30;tx_buffer[data_len+1]=((tmp_buffer[0]>>0)&0x0f)+0x30;
		tx_buffer[data_len+2]=((tmp_buffer[1]>>4)&0x0f)+0x30;tx_buffer[data_len+3]=((tmp_buffer[1]>>0)&0x0f)+0x30;
		memcpy(&tx_buffer[data_len+4], "年", 2);
		tx_buffer[data_len+6]=((tmp_buffer[2]>>4)&0x0f)+0x30;tx_buffer[data_len+7]=((tmp_buffer[2]>>0)&0x0f)+0x30;
		memcpy(&tx_buffer[data_len+8], "月", 2);
		tx_buffer[data_len+10]=((tmp_buffer[3]>>4)&0x0f)+0x30;tx_buffer[data_len+11]=((tmp_buffer[3]>>0)&0x0f)+0x30;
		memcpy(&tx_buffer[data_len+12], "日", 2);
		tx_buffer[data_len+14]=((tmp_buffer[4]>>4)&0x0f)+0x30;tx_buffer[data_len+15]=((tmp_buffer[4]>>0)&0x0f)+0x30;
		tx_buffer[data_len+16]=':';
		tx_buffer[data_len+17]=((tmp_buffer[5]>>4)&0x0f)+0x30;tx_buffer[data_len+18]=((tmp_buffer[5]>>0)&0x0f)+0x30;
		tx_buffer[data_len+19]=':';
		tx_buffer[data_len+20]=((tmp_buffer[6]>>4)&0x0f)+0x30;tx_buffer[data_len+21]=((tmp_buffer[6]>>0)&0x0f)+0x30;
																																						data_len+=22;
		tx_buffer[data_len]=0x0a;																								data_len+=1;

		memcpy(&tx_buffer[data_len], "        ----------------", 24);									data_len+=24;
		tx_buffer[data_len]=0x0a;																								data_len+=1;

		memcpy(&tx_buffer[data_len], "       不做报销凭证(第2联)", 26);			data_len+=26;
		tx_buffer[data_len]=0x0a;																								data_len+=1;

		memcpy(&tx_buffer[data_len], "\x1B\x4A\x50\x1D\x56\x01", 6);		data_len+=6;//半切纸 (通用)
		//memcpy(&tx_buffer[data_len], "\x1B\x6D", 2);																data_len+=2;//半切纸 (莹浦通)
		//memcpy(&tx_buffer[data_len], "\x1D\x56\x42\x00\x1B\x63\x38", 7);							data_len+=7;//半切纸 (公达)
		
		pprint(iptparam->Printer, tx_buffer, data_len);
	}


	//打印自助加油联
	if(3==prn_union || 4==prn_union)
	{
		//用户联格式如下:
		__________________________________________________________
		|		欢迎自助加油																		|
		|-----------------------------------------								|
		|授权验证码：933955																	|
		|加油站编码：32851143																|
		|枪号：4																								|
		|交易序号：2367																			|
		|加油油品：90#汽油																	|
		|单价：5.58元/升																			|
		|加油升数：10.75升																		|
		|加油金额：60.00元																		|
		|缴费金额：100.00元																	|
		|余额：40.00元																					|
		|交易时间：2008年10月23日 9:10:00										|
		|-----------------------------------------								|
		|如有余额，请凭此小票立即到营业室找零，|
		|并索取发票，小票自交易时间24小时内有		|
		|效，该小票不作为报销凭证。									|
		__________________________________________________________	
		
		data_len = 5;

		memcpy(&tx_buffer[data_len], "          欢迎自助加油", 22);		data_len+=22;
		tx_buffer[data_len]=0x0a;																		data_len+=1;
		
		memcpy(&tx_buffer[data_len], "        ----------------", 24);				data_len+=24;
		tx_buffer[data_len]=0x0a;																		data_len+=1;

		memcpy(&tx_buffer[data_len], "授权验证码:", 11);											data_len+=11;	
		if(((buffer[21]>>4)&0x0f)<=9)	tx_buffer[data_len]=((buffer[21]>>4)&0x0f)+0x30;								
		else																	tx_buffer[data_len]=' ';
		data_len+=1;
		if(((buffer[21]>>0)&0x0f)<=9)	tx_buffer[data_len]=((buffer[21]>>0)&0x0f)+0x30;								
		else																	tx_buffer[data_len]=' ';
		data_len+=1;
		if(((buffer[22]>>4)&0x0f)<=9)	tx_buffer[data_len]=((buffer[22]>>4)&0x0f)+0x30;								
		else																	tx_buffer[data_len]=' ';
		data_len+=1;
		if(((buffer[22]>>0)&0x0f)<=9)	tx_buffer[data_len]=((buffer[22]>>0)&0x0f)+0x30;								
		else																	tx_buffer[data_len]=' ';
		data_len+=1;
		if(((buffer[23]>>4)&0x0f)<=9)	tx_buffer[data_len]=((buffer[23]>>4)&0x0f)+0x30;								
		else																	tx_buffer[data_len]=' ';
		data_len+=1;
		if(((buffer[23]>>0)&0x0f)<=9)	tx_buffer[data_len]=((buffer[23]>>0)&0x0f)+0x30;								
		else																	tx_buffer[data_len]=' ';
		data_len+=1;
		if(((buffer[24]>>4)&0x0f)<=9)	tx_buffer[data_len]=((buffer[24]>>4)&0x0f)+0x30;								
		else																	tx_buffer[data_len]=' ';
		data_len+=1;
		if(((buffer[24]>>0)&0x0f)<=9)	tx_buffer[data_len]=((buffer[24]>>0)&0x0f)+0x30;								
		else																	tx_buffer[data_len]=' ';
		data_len+=1;
		if(((buffer[25]>>4)&0x0f)<=9)	tx_buffer[data_len]=((buffer[25]>>4)&0x0f)+0x30;								
		else																	tx_buffer[data_len]=' ';
		data_len+=1;
		if(((buffer[25]>>0)&0x0f)<=9)	tx_buffer[data_len]=((buffer[25]>>0)&0x0f)+0x30;								
		else																	tx_buffer[data_len]=' ';
		data_len+=1;
		tx_buffer[data_len]=0x0a;																							data_len+=1;

		memcpy(&tx_buffer[data_len], "加油站编码:", 11);											data_len+=11;
		memcpy(tmp_buffer, IptPcInfo.SInfo.S_ID, 4);
		hex2Ascii(tmp_buffer, 4, &tx_buffer[data_len], 8);														data_len+=8;
		tx_buffer[data_len]=0x0a;																							data_len+=1;

		memcpy(&tx_buffer[data_len], "枪号:", 5);																data_len+=5;
		memcpy(tmp_buffer,&buffer[0],1);
		data=hex2Bcd(tmp_buffer[0]);	
		tmp_buffer2[0]=((data>>8)&0x0f)+0x30;	tmp_buffer2[1]=((data>>4)&0x0f)+0x30;	tmp_buffer2[2]=((data>>0)&0x0f)+0x30;
		for(i=0; i<2; i++)	if('0'!=tmp_buffer2[i])	break;
		memcpy(&tx_buffer[data_len], &tmp_buffer2[i], 3-i);													data_len+=(3-i);
		tx_buffer[data_len]=0x0a;																							data_len+=1;

		memcpy(&tx_buffer[data_len], "交易序号:", 9);													data_len+=9;
		memcpy(tmp_buffer,&buffer[1],4);
		tmp_int=(tmp_buffer[0]<<24)|(tmp_buffer[1]<<16)|(tmp_buffer[2]<<8)|(tmp_buffer[3]<<0);
		data=hex2Bcd(tmp_int);
		for(i=0; i<=8; i++)	tmp_buffer[i]=((data>>((8-i)*4))&0x0f)+0x30;
		for(i=0; i<=7; i++)	if('0'!=tmp_buffer[i])	break;
		memcpy(&tx_buffer[data_len], &tmp_buffer[i], 9-i);														data_len+=(9-i);
		tx_buffer[data_len]=0x0a;																							data_len+=1;

		memcpy(&tx_buffer[data_len], "加油油品:", 9);													data_len+=9;
		memcpy(&tx_buffer[data_len], iptparam->OilName, strlen(iptparam->OilName));		data_len+=strlen(iptparam->OilName);
		tx_buffer[data_len]=0x0a;																							data_len+=1;

		memcpy(&tx_buffer[data_len], "单价:", 5);																data_len+=5;
		memcpy(tmp_buffer,&buffer[26],2);
		tmp_int=(tmp_buffer[0]<<8)|(tmp_buffer[1]<<0);
		data=hex2Bcd(tmp_int);
		if(0!=(unsigned char)((data>>12)&0x0f))
		{
			tx_buffer[data_len]=((data>>12)&0x0f)+0x30;														data_len+=1;
		}
		tx_buffer[data_len]=((data>>8)&0x0f)+0x30;																data_len+=1;
		tx_buffer[data_len]='.';																									data_len+=1;
		tx_buffer[data_len]=((data>>4)&0x0f)+0x30;																data_len+=1;
		tx_buffer[data_len]=((data>>0)&0x0f)+0x30;																data_len+=1;
		tx_buffer[data_len]=0x0a;																							data_len+=1;

		memcpy(&tx_buffer[data_len], "加油升数:", 9);													data_len+=9;
		memcpy(tmp_buffer,&buffer[15],3);
		tmp_int=(tmp_buffer[0]<<16)|(tmp_buffer[1]<<8)|(tmp_buffer[2]<<0);
		data=hex2Bcd(tmp_int);
		for(i=0; i<=7; i++)	tmp_buffer[i]=((data>>((7-i)*4))&0x0f)+0x30;
		for(i=0; i<=4; i++)	if('0'!=tmp_buffer[i])	break;
		memcpy(&tx_buffer[data_len], &tmp_buffer[i], 6-i);														data_len+=(6-i);
		tx_buffer[data_len]='.';																									data_len+=1;
		tx_buffer[data_len]=((data>>4)&0x0f)+0x30;																data_len+=1;
		tx_buffer[data_len]=((data>>0)&0x0f)+0x30;																data_len+=1;
		memcpy(&tx_buffer[data_len], "升",2);																		data_len+=2;
		tx_buffer[data_len]=0x0a;																							data_len+=1;

		memcpy(&tx_buffer[data_len], "加油金额:", 9);													data_len+=9;
		memcpy(tmp_buffer,&buffer[12],3);
		tmp_int=(tmp_buffer[0]<<16)|(tmp_buffer[1]<<8)|(tmp_buffer[2]<<0);
		data=hex2Bcd(tmp_int);
		for(i=0; i<=7; i++)	tmp_buffer[i]=((data>>((7-i)*4))&0x0f)+0x30;
		for(i=0; i<=4; i++)	if('0'!=tmp_buffer[i])	break;
		memcpy(&tx_buffer[data_len], &tmp_buffer[i], 6-i);														data_len+=(6-i);
		tx_buffer[data_len]='.';																									data_len+=1;
		tx_buffer[data_len]=((data>>4)&0x0f)+0x30;																data_len+=1;
		tx_buffer[data_len]=((data>>0)&0x0f)+0x30;																data_len+=1;
		memcpy(&tx_buffer[data_len], "元",2);																		data_len+=2;
		tx_buffer[data_len]=0x0a;																							data_len+=1;

		memcpy(&tx_buffer[data_len], "缴费金额:", 9);													data_len+=9;
		memcpy(tmp_buffer,&buffer[18],3);
		tmp_int=(tmp_buffer[0]<<16)|(tmp_buffer[1]<<8)|(tmp_buffer[2]<<0);
		data=hex2Bcd(tmp_int);
		for(i=0; i<=7; i++)	tmp_buffer[i]=((data>>((7-i)*4))&0x0f)+0x30;
		for(i=0; i<=4; i++)	if('0'!=tmp_buffer[i])	break;
		memcpy(&tx_buffer[data_len], &tmp_buffer[i], 6-i);														data_len+=(6-i);
		tx_buffer[data_len]='.';																									data_len+=1;
		tx_buffer[data_len]=((data>>4)&0x0f)+0x30;																data_len+=1;
		tx_buffer[data_len]=((data>>0)&0x0f)+0x30;																data_len+=1;
		memcpy(&tx_buffer[data_len], "元",2);																			data_len+=2;
		tx_buffer[data_len]=0x0a;																							data_len+=1;

		memcpy(&tx_buffer[data_len], "余额:", 5);																	data_len+=5;
		tmp_int2=(buffer[18]<<16)|(buffer[19]<<8)|(buffer[20]<<0);
		tmp_int3=(buffer[12]<<16)|(buffer[13]<<8)|(buffer[14]<<0);
		if(tmp_int2>=tmp_int3)	tmp_int=tmp_int2-tmp_int3;
		else									tmp_int=0;
		data=hex2Bcd(tmp_int);
		for(i=0; i<=7; i++)	tmp_buffer[i]=((data>>((7-i)*4))&0x0f)+0x30;
		for(i=0; i<=4; i++)	if('0'!=tmp_buffer[i])	break;
		memcpy(&tx_buffer[data_len], &tmp_buffer[i], 6-i);														data_len+=(6-i);
		tx_buffer[data_len]='.';																									data_len+=1;
		tx_buffer[data_len]=((data>>4)&0x0f)+0x30;																data_len+=1;
		tx_buffer[data_len]=((data>>0)&0x0f)+0x30;																data_len+=1;
		memcpy(&tx_buffer[data_len], "元",2);																			data_len+=2;
		tx_buffer[data_len]=0x0a;																							data_len+=1;

		memcpy(&tx_buffer[data_len], "交易时间:", 11);															data_len+=11;
		memcpy(tmp_buffer,&buffer[5],7);
		tx_buffer[data_len+0]=((tmp_buffer[0]>>4)&0x0f)+0x30;tx_buffer[data_len+1]=((tmp_buffer[0]>>0)&0x0f)+0x30;
		tx_buffer[data_len+2]=((tmp_buffer[1]>>4)&0x0f)+0x30;tx_buffer[data_len+3]=((tmp_buffer[1]>>0)&0x0f)+0x30;
		memcpy(&tx_buffer[data_len+4], "年", 2);
		tx_buffer[data_len+6]=((tmp_buffer[2]>>4)&0x0f)+0x30;tx_buffer[data_len+7]=((tmp_buffer[2]>>0)&0x0f)+0x30;
		memcpy(&tx_buffer[data_len+8], "月", 2);
		tx_buffer[data_len+10]=((tmp_buffer[3]>>4)&0x0f)+0x30;tx_buffer[data_len+11]=((tmp_buffer[3]>>0)&0x0f)+0x30;
		memcpy(&tx_buffer[data_len+12], "日", 2);
		tx_buffer[data_len+14]=((tmp_buffer[4]>>4)&0x0f)+0x30;tx_buffer[data_len+15]=((tmp_buffer[4]>>0)&0x0f)+0x30;
		tx_buffer[data_len+16]=':';
		tx_buffer[data_len+17]=((tmp_buffer[5]>>4)&0x0f)+0x30;tx_buffer[data_len+18]=((tmp_buffer[5]>>0)&0x0f)+0x30;
		tx_buffer[data_len+19]=':';
		tx_buffer[data_len+20]=((tmp_buffer[6]>>4)&0x0f)+0x30;tx_buffer[data_len+21]=((tmp_buffer[6]>>0)&0x0f)+0x30;
																																					data_len+=22;
		tx_buffer[data_len]=0x0a;																								data_len+=1;

		memcpy(&tx_buffer[data_len], "        ----------------", 24);				data_len+=24;
		tx_buffer[data_len]=0x0a;																		data_len+=1;

		//正常打印和重打印的条码小票最下方打印不同内容
		if(3==prn_union)
		{
			memcpy(&tx_buffer[data_len], "如有余额，请凭此小票立即到营业室找零，并索取发票，小票自交易时间24小时内有效，该小票不作为报销凭证。", 100);													
																																			data_len+=100;
			tx_buffer[data_len]=0x0a;																					data_len+=1;
		}
		else{

			memcpy(&tx_buffer[data_len], "该小票不作为报销凭证", 20);		data_len+=20;
			tx_buffer[data_len]=0x0a;																					data_len+=1;
			tx_buffer[data_len]=0x0a;																					data_len+=1;
			memcpy(&tx_buffer[data_len], "            重打凭证", 20);								data_len+=20;
			tx_buffer[data_len]=0x0a;																					data_len+=1;
		}

		memcpy(&tx_buffer[data_len], "\x1B\x4A\x50\x1D\x56\x01", 6);		data_len+=6;//半切纸 (通用)
		//memcpy(&tx_buffer[data_len], "\x1B\x6D", 2);																data_len+=2;//半切纸 (莹浦通)
		//memcpy(&tx_buffer[data_len], "\x1D\x56\x42\x00\x1B\x63\x38", 7);							data_len+=7;//半切纸 (公达)
		
		pprint(iptparam->Printer, tx_buffer, data_len);
	}

	return 0;
}
#endif

/*******************************************************************
*Name				:iptPidSet
*Description		:处理状态过程ID设置
*Input				:iptparam		IPT处理数据结构
*						:pid				进程处理号
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

void iptPidSet(IptParamStructType *iptparam, unsigned short pid)
{
	iptparam->ProcessId=pid;	
	iptparam->Step=0;

    //szb_fj_20171120,add
	iptparam->EtcTxCi=0;  
	iptparam->EtcTxFlg=0; 
	iptparam->etc_update_flag=0;
	iptparam->etc_yue_dis_flag=0;
	return;
}


/*******************************************************************
*Name				:iptTMACCalculate
*Description		:TMAC计算
*Input				:iptparam			IPT处理数据结构
*						:inbuffer			计算TMAC的数据
*						:nbytes				计算TMAC的数据长度
*Output			:TMAC				计算所得TMAC，固定4bytes
*						:apdu_return		apdu返回代码，操作失败时有效，固定2bytes
*Return				:成功返回0；失败返回其它
*						:失败返回的错误定义如下:
*						:0x0101			PSAM选择应用2失败，含错误apdu代码，因操作PSAM产生失败
*						:0x0102			PSAM选择应用2失败，无错误apdu代码，卡座返回的操作失败
*						:0x0103			PSAM选择应用2超时，函数内超时三次返回本错误
*						:0x0104			PSAM选择应用2错误，不知原因的操作错误
*						:0x0201			PSAM计算T_MAC初始化失败，含错误apdu代码，因操作PSAM产生失败
*						:0x0202			PSAM计算T_MAC初始化失败，无错误apdu代码，卡座返回的操作失败
*						:0x0203			PSAM计算T_MAC初始化超时，函数内超时三次返回本错误
*						:0x0204			PSAM计算T_MAC初始化错误，不知原因的操作错误
*						:0x0301			PSAM计算T_MAC第1部分失败，含错误apdu代码，因操作PSAM产生失败
*						:0x0302			PSAM计算T_MAC第1部分失败，无错误apdu代码，卡座返回的操作失败
*						:0x0303			PSAM计算T_MAC第1部分超时，函数内超时三次返回本错误
*						:0x0304			PSAM计算T_MAC第1部分错误，不知原因的操作错误
*						:0x0401			PSAM计算T_MAC第2部分失败，含错误apdu代码，因操作PSAM产生失败
*						:0x0402			PSAM计算T_MAC第2部分失败，无错误apdu代码，卡座返回的操作失败
*						:0x0403			PSAM计算T_MAC第2部分超时，函数内超时三次返回本错误
*						:0x0404			PSAM计算T_MAC第2部分错误，不知原因的操作错误
*						:0x0501			PSAM选择应用1失败，含错误apdu代码，因操作PSAM产生失败
*						:0x0502			PSAM选择应用1失败，无错误apdu代码，卡座返回的操作失败
*						:0x0503			PSAM选择应用1超时，函数内超时三次返回本错误
*						:0x0504			PSAM选择应用1错误，不知原因的操作错误
*History			:2014-12-29,modified by syj  */

int iptTMACCalculate(IptParamStructType *iptparam, unsigned char *TMAC, unsigned char *apdu_return, unsigned char *inbuffer, int nbytes)
{
	unsigned char buffer[128]={0}, tmac_buffer[128]={0};
	int istate=0, apdu_len=0, overtimes=0;
	int ireturn = 0;

	//中燃联达加油系统加油机直接返回正确的TMAC
	if(MODEL_LIANDA == paramModelGet())
	{
		jljRunLog("中燃联达加油系统不计算TMAC.\n");
	
		memcpy(TMAC, IPT_TMAC_DEFUALT, 4);
		memcpy(apdu_return, "\x90\x00", 2);
		return 0;
	}
	

	//PSAM选择应用2
PSAM_TMAC_ADF2_START:
	memset(buffer, 0, 128);
	istate=PsamDFSelect(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, 2);

	if(ICSTATE_OK==istate)
	{
		apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
		if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
		{}
		else
		{	
			memcpy(apdu_return, &buffer[2+apdu_len-2], 2);
			ireturn = 0x0101;	goto PSAM_TMAC_ADF1_START;
		}
	}
	else if(ICSTATE_FAILED==istate)
	{	
		ireturn = 0x0102;	goto PSAM_TMAC_ADF1_START;
	}
	else if(ICSTATE_OVERTIME==istate)
	{
		ireturn = 0x0103;	goto PSAM_TMAC_ADF1_START;
	}
	else
	{	
		ireturn = 0x0104;	goto PSAM_TMAC_ADF1_START;
	}


	//PSAM计算T_MAC初始化
PSAM_TMAC_INIT_START:
	memset(buffer, 0, 128);
	istate=PsamTMACInit(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128);

	if(ICSTATE_OK==istate)
	{	
		apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
		if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
		{}
		else
		{
			memcpy(apdu_return, &buffer[2+apdu_len-2], 2);
			ireturn = 0x0201;		goto PSAM_TMAC_ADF1_START;
		}
	}
	else if(ICSTATE_FAILED==istate){
		
		ireturn = 0x0202;	goto PSAM_TMAC_ADF1_START;
	}
	else if(ICSTATE_OVERTIME==istate){
			
		ireturn = 0x0203;	goto PSAM_TMAC_ADF1_START;
	}
	else{
		
		ireturn = 0x0204;	goto PSAM_TMAC_ADF1_START;
	}

	//计算账单第一部分
PSAM_TMAC_PART1_START:
	memset(buffer, 0, 128);
	memset(&tmac_buffer[0], 0, 8);								//初始值
	memcpy(&tmac_buffer[8], &inbuffer[0], 48);			//加油数据前48字节
	istate=PsamTMACOperat(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, tmac_buffer, 56, 1, 1);

	if(ICSTATE_OK==istate)
	{	
		apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
		if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
		{}
		else
		{	
			memcpy(apdu_return, &buffer[2+apdu_len-2], 2);
			ireturn = 0x0301;	goto PSAM_TMAC_ADF1_START;
		}
	}
	else if(ICSTATE_FAILED==istate)
	{	
		ireturn = 0x0302;	goto PSAM_TMAC_ADF1_START;
	}
	else if(ICSTATE_OVERTIME==istate)
	{		
		ireturn = 0x0303;	goto PSAM_TMAC_ADF1_START;
	}
	else
	{	
		ireturn = 0x0304;	goto PSAM_TMAC_ADF1_START;
	}


	//计算账单第二部分
PSAM_TMAC_PART2_START:
	memset(buffer, 0, 128);
	memcpy(&tmac_buffer[0], &inbuffer[48], 43);		//加油数据后43字节
	memset(&tmac_buffer[43], 0, 5);							//后补0
	istate=PsamTMACOperat(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, tmac_buffer, 48, 0, 0);

	if(ICSTATE_OK==istate)
	{	
		apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
		if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
		{	
			memcpy(TMAC, &buffer[2], 4);//保存TMAC计算结果
		}
		else
		{	
			memcpy(apdu_return, &buffer[2+apdu_len-2], 2);
			ireturn = 0x0401;	goto PSAM_TMAC_ADF1_START;
		}
	}
	else if(ICSTATE_FAILED==istate)
	{	
		ireturn = 0x0402;	goto PSAM_TMAC_ADF1_START;
	}
	else if(ICSTATE_OVERTIME==istate)
	{	
		ireturn = 0x0403;	goto PSAM_TMAC_ADF1_START;
	}
	else
	{
		ireturn = 0x0404;	goto PSAM_TMAC_ADF1_START;
	}

	//PSAM恢复选择应用1
PSAM_TMAC_ADF1_START:
	memset(buffer, 0, 128);
	istate=PsamDFSelect(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, 1);

	if(ICSTATE_OK==istate)
	{
		apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
		if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
		{
		}
		else
		{		
			memcpy(apdu_return, &buffer[2+apdu_len-2], 2);
			return 0x0501;
		}
	}
	else if(ICSTATE_FAILED==istate)
	{		
		return 0x0502;
	}
	else if(ICSTATE_OVERTIME==istate)
	{			
		return 0x0503;
	}
	else
	{		
		return 0x0504;
	}

	return ireturn;

#if 0
	//PSAM选择应用2
PSAM_TMAC_ADF2_START:
	memset(buffer, 0, 128);
	istate=PsamDFSelect(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, 2);

	if(ICSTATE_OK==istate)
	{
		apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
		if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
		{}
		else
		{	
			memcpy(apdu_return, &buffer[2+apdu_len-2], 2);
			return 0x0101;
		}
	}
	else if(ICSTATE_FAILED==istate)
	{	
		return 0x0102;
	}
	else if(ICSTATE_OVERTIME==istate)
	{
		return 0x0103;
	}
	else
	{	
		return 0x0104;
	}


	//PSAM计算T_MAC初始化
PSAM_TMAC_INIT_START:
	memset(buffer, 0, 128);
	istate=PsamTMACInit(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128);

	if(ICSTATE_OK==istate){
		
		apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
		if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2)){

		}
		else{
			memcpy(apdu_return, &buffer[2+apdu_len-2], 2);
			return 0x0201;
		}
	}
	else if(ICSTATE_FAILED==istate){
		
		return 0x0202;
	}
	else if(ICSTATE_OVERTIME==istate){
			
		return 0x0203;
	}
	else{
		
		return 0x0204;
	}

	//计算账单第一部分
PSAM_TMAC_PART1_START:
	memset(buffer, 0, 128);
	memset(&tmac_buffer[0], 0, 8);								//初始值
	memcpy(&tmac_buffer[8], &inbuffer[0], 48);			//加油数据前48字节
	istate=PsamTMACOperat(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, tmac_buffer, 56, 1, 1);

	if(ICSTATE_OK==istate){
		
		apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
		if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2)){

		}
		else{
			
			memcpy(apdu_return, &buffer[2+apdu_len-2], 2);
			return 0x0301;
		}
	}
	else if(ICSTATE_FAILED==istate){
		
		return 0x0302;
	}
	else if(ICSTATE_OVERTIME==istate){
			
		return 0x0303;
	}
	else{
		
		return 0x0304;
	}


	//计算账单第二部分
PSAM_TMAC_PART2_START:
	memset(buffer, 0, 128);
	memcpy(&tmac_buffer[0], &inbuffer[48], 43);		//加油数据后43字节
	memset(&tmac_buffer[43], 0, 5);							//后补0
	istate=PsamTMACOperat(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, tmac_buffer, 48, 0, 0);

	if(ICSTATE_OK==istate){
		
		apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
		if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2)){
			
			memcpy(TMAC, &buffer[2], 4);//保存TMAC计算结果
		}
		else
		{	
			memcpy(apdu_return, &buffer[2+apdu_len-2], 2);
			return 0x0401;
		}
	}
	else if(ICSTATE_FAILED==istate){
		
		return 0x0402;
	}
	else if(ICSTATE_OVERTIME==istate){
			
		return 0x0403;
	}
	else{

		return 0x0404;
	}

	//PSAM恢复选择应用1
PSAM_TMAC_ADF1_START:
	memset(buffer, 0, 128);
	istate=PsamDFSelect(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, 1);

	if(ICSTATE_OK==istate)
	{
		apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
		if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
		{
		}
		else
		{		
			memcpy(apdu_return, &buffer[2+apdu_len-2], 2);
			return 0x0501;
		}
	}
	else if(ICSTATE_FAILED==istate)
	{		
		return 0x0502;
	}
	else if(ICSTATE_OVERTIME==istate)
	{			
		return 0x0503;
	}
	else
	{		
		return 0x0504;
	}

	return 0;

#endif
}


/*******************************************************************
*Name				:iptZDSaveProcess
*Description		:支付终端账单存储处理
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptZDSaveProcess(IptParamStructType *iptparam,unsigned char *msg_buffer,	int msg_len)
{
	unsigned char tx_buffer[256]={0}, tx_len=0;
	int istate=0, i=0;

	//当加油过程保存账单失败或其他非加油过程需要保存账单时，
	//	将OilBillSave置1，本处理过程判断到有保存账单的请求时自动保存账单
	

	//判断是否有账单需要保存
	if(0==iptparam->OilBillSave)
	{
		return;
	}

	switch(iptparam->OilBillSaveStep)
	{
	case 0:
		//申请TTC
		if(IPT_2PCD_UNUSED==iptparam->PcdTxFlag)
		{
			//发送PCD获取TTC命令
			tx_buffer[0]=++iptparam->PcdTxFrame;
			tx_buffer[1]=pcdMboardIDRead();
			tx_buffer[2]=iptparam->Id;
			tx_buffer[3]=iptparam->PhysicalNozzle;
			tx_buffer[4]=IPT_CMD_FORTTC;
			memcpy(&tx_buffer[5], iptparam->OilBill, IPT_BILL_SIZE);
			tx_len=133;
			//msgQSend((MSG_Q_ID)pcdMsgIdRead(), tx_buffer, tx_len, NO_WAIT, MSG_PRI_NORMAL);

			struct msg_struct msg_stIptSend;  //fj:20170918
			msg_stIptSend.msgType = 1;
			memcpy(msg_stIptSend.msgBuffer,tx_buffer,tx_len);
			msgsnd(pcdMsgIdRead(),&msg_stIptSend,tx_len,IPC_NOWAIT);

			iptparam->PcdTxFlag=IPT_2PCD_ZDSAVE;	iptparam->PcdTxTimer=0;
			break;
		}
		else if(IPT_2PCD_ZDSAVE==iptparam->PcdTxFlag && msg_len>0 && iptparam->PhysicalNozzle==msg_buffer[3] && IPT_CMD_FORTTC==msg_buffer[4] && 0==msg_buffer[5]){

			iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdSaveOverTimes=0;
		
			//申请TTC成功
			memcpy(&iptparam->OilBill[IPT_OFFSET_TTC], &msg_buffer[6], 4);

			//计算账单校验值
			iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

			//保存账单及备份
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

			//转入T_MAC计算过程
			iptparam->OilBillSaveStep++;
		}
		else
		if(IPT_2PCD_ZDSAVE==iptparam->PcdTxFlag && iptparam->PcdTxTimer>=(2*ONE_SECOND))
		{
			//超时三次放弃本次账单存储过程
			iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdSaveOverTimes++;
			if(iptparam->PcdSaveOverTimes>=3)
			{
				iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	
				iptparam->PcdSaveOverTimes=0;
				iptparam->OilBillSave=0;
				iptparam->OilBillSaveStep=0;
				//szb_fj_20171120,add
                framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_BILL_FLAG,&iptparam->OilBillSave , 1);
			}
		}
		break;

	case 1:
		//首次计算TMAC
		for(i=0; i<3; i++)
		{
			istate=iptTMACCalculate(iptparam, &tx_buffer[0], &tx_buffer[16], iptparam->OilBill, 95);
			if(0==istate)	break;
		}

		if(0==istate)
		{
			//保存TMAC
			memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], &tx_buffer[0], 4);

			//计算账单校验值
			iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

			//保存账单及备份
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

			//转入保存账单过程
			iptparam->OilBillSaveStep=4;
		}
		else{

			//计算TMAC失败，进行PSAM复位
			iptparam->OilBillSaveStep++;
		}
		break;

	case 2:
		//计算TMAC失败，复位PSAM
		istate=PsamReset(iptparam->DEVIC, iptparam->DEVPsam);
		iptparam->OilBillSaveStep++;
		break;
		
	case 3:
		//再次计算TMAC
		for(i=0; i<3; i++)
		{
			istate=iptTMACCalculate(iptparam, &tx_buffer[0], &tx_buffer[16], iptparam->OilBill, 95);
			if(0==istate)	break;
		}

		//保存TMAC，计算失败时以默认TMAC填充
		if(0==istate)memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], tx_buffer, 4);
		else				memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], IPT_TMAC_DEFUALT, 4);

		//计算账单校验值
		iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

		//保存账单及备份
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

		//转入保存账单过程
		iptparam->OilBillSaveStep=4;
		break;

	case 4:
		//保存账单
		if(IPT_2PCD_UNUSED==iptparam->PcdTxFlag)
		{
			//保存账单
			tx_buffer[0]=++iptparam->PcdTxFrame;
			tx_buffer[1]=pcdMboardIDRead();
			tx_buffer[2]=iptparam->Id;
			tx_buffer[3]=iptparam->PhysicalNozzle;
			tx_buffer[4]=IPT_CMD_ZDSAVE;
			memcpy(&tx_buffer[5], iptparam->OilBill, IPT_BILL_SIZE);
			tx_len=133;
			//msgQSend((MSG_Q_ID)pcdMsgIdRead(), tx_buffer, tx_len, NO_WAIT, MSG_PRI_NORMAL);

			struct msg_struct msg_stIptSend;  //fj:20170918
			msg_stIptSend.msgType = 1;
			memcpy(msg_stIptSend.msgBuffer,tx_buffer,tx_len);
			msgsnd(pcdMsgIdRead(),&msg_stIptSend,tx_len,IPC_NOWAIT);

			iptparam->PcdTxFlag=IPT_2PCD_ZDSAVE;	iptparam->PcdTxTimer=0;
		}
		else
		if((IPT_2PCD_ZDSAVE==iptparam->PcdTxFlag)&&(msg_len>0)&&(iptparam->PhysicalNozzle==msg_buffer[3])&&(IPT_CMD_ZDSAVE==msg_buffer[4])&&(0==msg_buffer[5]))
		{
			//账单状态改为完成
			iptparam->OilBill[IPT_OFFSET_ZD_STATE]=0;

			//计算账单校验值
			iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

			//保存账单及备份
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

			//完成了本次账单存储
			iptparam->OilBillSaveStep++;

			iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdSaveOverTimes=0;
		}
		else
		if(IPT_2PCD_ZDSAVE==iptparam->PcdTxFlag && iptparam->PcdTxTimer>=(2*ONE_SECOND))
		{
			//超时三次放弃本次账单存储过程
			iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdSaveOverTimes++;
			if(iptparam->PcdSaveOverTimes>=3)
			{
				iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	
				iptparam->PcdSaveOverTimes=0;
				iptparam->OilBillSave=0;	
				iptparam->OilBillSaveStep=0;
				//szb_fj_20171120,add
                framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_BILL_FLAG,&iptparam->OilBillSave , 1);
			}
		}
		break;

	case 5:
		//账单打印
		if(1==iptparam->PrintAuto && 0==iptparam->PrintUnion)
			iptPrint(iptparam, 0, iptparam->OilBill, IPT_BILL_SIZE);
		else if(1==iptparam->PrintAuto && 0!=iptparam->PrintUnion)
			iptPrint(iptparam, 1, iptparam->OilBill, IPT_BILL_SIZE);

		iptparam->OilBillSave=0;
		iptparam->OilBillSaveStep=0;
		//szb_fj_20171120,add
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_BILL_FLAG,&iptparam->OilBillSave , 1);
		break;
	default:
		iptparam->OilBillSave=0;
		iptparam->OilBillSaveStep=0;
		//szb_fj_20171120,add
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_BILL_FLAG,&iptparam->OilBillSave , 1);
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptBarZDUploadProcess
*Description		:条码加油账单上传处理
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptBarZDUploadProcess(IptParamStructType *iptparam,unsigned char *msg_buffer,	int msg_len)
{
	unsigned char tx_buffer[128]={0};
	int tx_len=0, istate=0;
	unsigned char dsp_buffer[64]={0}, dsp_len=0;

	//正常的加油过程未成功上传条码加油账单，需要将BarBillUpload置1
	//本处检测到需要上传账单时会定时上传直到上传成功
	
	if(0==iptparam->BarBillUpload){

		return;
	}

	//定时间隔5秒上传一次
	if(IPT_2CPOS_UNUSED==iptparam->CPOSFlag && iptparam->CPOSTimer>=(5*ONE_SECOND)){

		tx_buffer[0]=0x64;
		tx_buffer[1]=iptparam->LogicNozzle;
		framRead(FM_ADDR_IPT_SINO, IPT_FM_DATALEN*iptparam->Id+IPT_FM_ZD_TM, &tx_buffer[1], 28);
		tx_len=29;
		
		//fj:
		istate=CPOSWrite(iptparam->Id, IptPcInfo.SInfo.POS_P, tx_buffer, tx_len);
		iptparam->CPOSFlag=IPT_2CPOS_ZDUPLOAD;	
		iptparam->CPOSTimer=0;
	}
	else	if(IPT_2CPOS_ZDUPLOAD==iptparam->CPOSFlag && msg_len>0 && 0xfa==msg_buffer[0] && 0x65==msg_buffer[6] && iptparam->LogicNozzle==msg_buffer[7]){

		//1byte账单状态0=已上传；1=未上传；
		iptparam->BarOilBill[IPT_BAR_OFF_STATE]=0;
		//1byte异或校验码
		iptparam->BarOilBill[IPT_BAR_OFF_CHECK]=xorGet(iptparam->BarOilBill, IPT_BAR_BILL_SIZE-1);
		//存储账单数据
		framWrite(FM_ADDR_IPT_SINO, IPT_FM_DATALEN*iptparam->Id+IPT_FM_ZD_TM, iptparam->BarOilBill, IPT_BAR_BILL_SIZE);
		framWrite(FM_ADDR_IPT_SINO, IPT_FM_DATALEN*iptparam->Id+IPT_FM_ZD_TM2, iptparam->BarOilBill, IPT_BAR_BILL_SIZE);

		//清除上传标识
		iptparam->BarBillUpload=0;

		iptparam->CPOSFlag=IPT_2CPOS_UNUSED;	iptparam->CPOSTimer=0;
	}
	else if(IPT_2CPOS_ZDUPLOAD==iptparam->CPOSFlag && iptparam->CPOSTimer>=(2*ONE_SECOND)){

		iptparam->CPOSFlag=IPT_2CPOS_UNUSED;	iptparam->CPOSTimer=0;
	}
	return;
}


/*******************************************************************
*Name				:iptMainInterface
*Description		:返回主界面
*Input				:gun_id	枪选0=A1枪；1=B1枪
*Output			:None
*Return			:进程处理号
*History			:2013-07-01,modified by syj  */

void iptMainInterface(IptParamStructType *iptparam)
{
	unsigned char dsp_buffer[64]={0}, dsp_len=0;
	RTCTime time;

	//相关参数初始化
	memset(iptparam->IntegerBuffer, 0, sizeof(iptparam->IntegerBuffer));	iptparam->IntegerLen=0;
	iptparam->Point=0;
	memset(iptparam->DecimalBuffer, 0, sizeof(iptparam->DecimalBuffer));	iptparam->DecimalLen=0;
	iptparam->PresetMode=IPT_PRESET_NO;
	iptparam->SetPage=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;

	//szb_fj_20171120,异常停机缺一路脉冲
	if(iptparam->JlErr_QYL>=6)
	{
		memset(iptparam->JlErr_Freebuff,0,sizeof(iptparam->JlErr_Freebuff));
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "连续多次缺一路脉冲锁机", strlen("连续多次缺一路脉冲锁机"));

		iptPidSet(iptparam, IPT_PID_ERR_QUEYILU);
		return;
	}
	//szb_fj_20171120,异常停机无脉冲超时
	else if(iptparam->JlErr_WMCCS>=6)
	{
		memset(iptparam->JlErr_Freebuff,0,sizeof(iptparam->JlErr_Freebuff));
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "连续多次无脉冲超时锁机", strlen("连续多次无脉冲超时锁机"));

		iptPidSet(iptparam, IPT_PID_ERR_WUPULSE);
		return;
	}
	//szb_fj_20171120,异常停机缺一组脉冲
	else if(iptparam->JlErr_QYZ>=6)
	{
		memset(iptparam->JlErr_Freebuff,0,sizeof(iptparam->JlErr_Freebuff));
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "连续多次缺一组脉冲锁机", strlen("连续多次缺一组脉冲锁机"));

		iptPidSet(iptparam, IPT_PID_ERR_QUEYIZU);
		return;
	}
	//szb_fj_20171120,异常停机零加油
	else if(iptparam->JlErr_ZERO>=6)
	{
		memset(iptparam->JlErr_Freebuff,0,sizeof(iptparam->JlErr_Freebuff));
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "连续多次零加油锁机", strlen("连续多次零加油锁机"));

		iptPidSet(iptparam, IPT_PID_ERR_LINGJIAYOU);
		return;
	}

	//累计过冲升数超过5升或连续三次过冲锁机
	if(IPT_MODE_UNSELF!=iptparam->Mode && (iptparam->VolumeUnselfSum>=500 || iptparam->OilOverTimes>=3))
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "加油机过冲故障，请联系厂家维修", 30);

		iptPidSet(iptparam, IPT_PID_ERR_OILOVER);
	}
	else
	{
		//获取时间
		timeRead(&time);

		//非卡机联动模式显示非卡界面；卡机及条码模式显示卡机界面
		dsp_buffer[0]=time.century;	dsp_buffer[1]=time.year;	dsp_buffer[2]=time.month;	dsp_buffer[3]=time.date;
		dsp_buffer[4]=time.hour;dsp_buffer[5]=time.minute; dsp_buffer[6]=time.second;
		dsp_buffer[7]=iptparam->PcOnline;			dsp_buffer[8]=iptparam->WorkState;
		dsp_buffer[9]=iptparam->Mode;
		dsp_len=10;
		if(IPT_MODE_UNSELF==iptparam->Mode)
		{
			//printf("---------dsp connetc keyboard!mode = 1\n");
			dsp(iptparam->DEVDsp, DSP_UNSELF_STANDBY, dsp_buffer, dsp_len);
		}
		else
		{
	        //printf("---------dsp connetc keyboard!mode = 1\n");
            //printf("dsp_buffer = %s\n",dsp_buffer);
			//PrintH(dsp_len,dsp_buffer);
			dsp(iptparam->DEVDsp, DSP_CARD_STANDBY, dsp_buffer, dsp_len);
		}

		//转入待机过程
		iptPidSet(iptparam, IPT_PID_STANDBY);

		//促销机通知平板电脑状态
		if(1 == paramPromotionGet())
		{
			iptparam->TaState = IPT_STATE_IDLE;	iptparam->TaStateParamLength = 0;
			pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
		}
	}

	return;
}


/*******************************************************************
*Name				:ipt2PcdPoll
*Description		:IPT与PCD间普通通讯处理
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static int ipt2PcdPoll(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char tx_buffer[128]={0}, tx_len=0, time[7]={0}, buffer[32]={0};
	int i=0, istate=0, ihandle = 0;
	unsigned int price=0, priceold = 0, pricenew=0, time1=0, time2=0, timediff=0;
	unsigned long long money_sum=0, volume_sum=0;

	//接收到PCD主动的计算账单TMAC命令进行处理，失败时以默认TMAC
	if(msg_len>0 && IPT_CMD_FOR_TMAC==msg_buffer[4])
	{
		istate=iptTMACCalculate(iptparam, &buffer[0], &buffer[4], &msg_buffer[5], IPT_BILL_SIZE);
		if(0 == istate)	;
		else					memcpy(&buffer[0], IPT_TMAC_DEFUALT, 4);

		tx_buffer[0]=iptparam->PcdTxFrame;
		tx_buffer[1]=pcdMboardIDRead();
		tx_buffer[2]=iptparam->Id;
		tx_buffer[3]=iptparam->PhysicalNozzle;
		tx_buffer[4]=IPT_CMD_FOR_TMAC;
		memcpy(&tx_buffer[5], &msg_buffer[5], IPT_BILL_SIZE);
		memcpy(&tx_buffer[5+IPT_OFFSET_T_MAC], &buffer[0], 4);
		tx_len=5+IPT_BILL_SIZE;
		//msgQSend((MSG_Q_ID)pcdMsgIdRead(), tx_buffer, tx_len, NO_WAIT, MSG_PRI_NORMAL);

		struct msg_struct msg_stIptSend;  //fj:20170918
		msg_stIptSend.msgType = 1;
		memcpy(msg_stIptSend.msgBuffer,tx_buffer,tx_len);
		msgsnd(pcdMsgIdRead(),&msg_stIptSend,tx_len,IPC_NOWAIT);

		//printf("text  bbbbbbb\n");

	}

    //printf("test pcdTxFlag = %d,pcdTxTimer=%d\n",iptparam->PcdTxFlag,iptparam->PcdTxTimer);

	//定时向PCD发送普通查询命令,fj:20170919
	if(IPT_2PCD_UNUSED==iptparam->PcdTxFlag && iptparam->PcdTxTimer>=ONE_SECOND)
	{
		tx_buffer[0]=++iptparam->PcdTxFrame;
		tx_buffer[1]=pcdMboardIDRead();
		tx_buffer[2]=iptparam->Id;
		tx_buffer[3]=iptparam->PhysicalNozzle;
		tx_buffer[4]=IPT_CMD_POLL;
		tx_buffer[5]=iptparam->NozzleNumber;						//油枪数
		if(IPT_OIL_FUELLING==iptparam->OilState)		
		{tx_buffer[6]=2;}			//状态；0=空闲；1=卡插入；2=抬枪或加油中
		else if(1==iptparam->IcValid)	
		{tx_buffer[6]=1;}
		else											
		{tx_buffer[6]=0;}
		tx_buffer[7]=iptparam->LogicNozzle;							//逻辑枪号
		//fj:先不定时查询
		//jlSumRead(iptparam->JlNozzle, &volume_sum, &money_sum);
		GetjlSumRead(iptparam->JlNozzle,&volume_sum,&money_sum); //fj:20171020

		tx_buffer[8]=(char)(money_sum>>24);						//总累金额
		tx_buffer[9]=(char)(money_sum>>16);
		tx_buffer[10]=(char)(money_sum>>8);
		tx_buffer[11]=(char)(money_sum>>0);
		tx_buffer[12]=(char)(volume_sum>>24);						//总累油量
		tx_buffer[13]=(char)(volume_sum>>16);
		tx_buffer[14]=(char)(volume_sum>>8);
		tx_buffer[15]=(char)(volume_sum>>0);			
		if(1==iptparam->IcValid)
		{
			memcpy(&tx_buffer[16], iptparam->IcAppId, 10);	 //卡应用号
			memcpy(&tx_buffer[26], iptparam->OilIcState, 2); //卡状态
			memcpy(&tx_buffer[28], iptparam->IcBalance, 4);  //卡余额
		}
		if(IPT_OIL_FUELLING==iptparam->OilState)
		{
			tx_buffer[32]=((iptparam->Payment&0x3f)<<2)|(iptparam->PayUnit&0x03);	//结算单位/方式
			tx_buffer[33]=(char)(iptparam->OilMoney>>16);	//数额
			tx_buffer[34]=(char)(iptparam->OilMoney>>8);
			tx_buffer[35]=(char)(iptparam->OilMoney>>0);
			tx_buffer[36]=(char)(iptparam->OilVolume>>16);	//升数
			tx_buffer[37]=(char)(iptparam->OilVolume>>8);
			tx_buffer[38]=(char)(iptparam->OilVolume>>0);
			tx_buffer[39]=(char)(iptparam->OilPrice>>8);		//价格
			tx_buffer[40]=(char)(iptparam->OilPrice>>0);
		}
		tx_len=41;
		//msgQSend((MSG_Q_ID)pcdMsgIdRead(), tx_buffer, tx_len, NO_WAIT, MSG_PRI_NORMAL);

		struct msg_struct msg_stIptSend;  //fj:20170918
		msg_stIptSend.msgType = 1;
		memcpy(msg_stIptSend.msgBuffer,tx_buffer,tx_len);
		
		int nSendRet = -1;
	    nSendRet = msgsnd(pcdMsgIdRead(),&msg_stIptSend,tx_len,IPC_NOWAIT);
        //printf("ipt msg send,nRet = %d,msgid = %d\n",nSendRet,pcdMsgIdRead);
		//PrintH(tx_len,msg_stIptSend.msgBuffer);
		iptparam->PcdTxFlag=IPT_2PCD_POLL;	
		iptparam->PcdTxTimer=0;
		//printf("querry ipt2PcdPoll\n");
	}

	//printf("PcdTxFlag = %d,msg_len= %d,msg_buffer[4] = %d\n",iptparam->PcdTxFlag,msg_len,msg_buffer[4]);

	//判断并处理PCD返回的数据
	if(IPT_2PCD_POLL==iptparam->PcdTxFlag && msg_len>0 && IPT_CMD_POLL==msg_buffer[4])
	{
		iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdState=1;	iptparam->PcdPollOverTimes=0;

		//PC通讯状态
		iptparam->PcOnline=msg_buffer[6];
		//PCD异常状态
		iptparam->PcdErrNO=msg_buffer[7];
		//整机当前TTC
		iptparam->BillTTC=(msg_buffer[8]<<24)|(msg_buffer[9]<<16)|(msg_buffer[10]<<8)|(msg_buffer[11]<<0);
		//本枪当前TTC
		iptparam->FuelBillTTC=(msg_buffer[12]<<24)|(msg_buffer[13]<<16)|(msg_buffer[14]<<8)|(msg_buffer[15]<<0);
		//整机未传账单数目
		iptparam->UnloadNumber=(msg_buffer[16]<<24)|(msg_buffer[17]<<16)|(msg_buffer[18]<<8)|(msg_buffer[19]<<0);
		//本枪未传账单数目
		iptparam->FuelUnloadNumber=(msg_buffer[20]<<24)|(msg_buffer[21]<<16)|(msg_buffer[22]<<8)|(msg_buffer[23]<<0);
		//PC参数
		memcpy(&IptPcInfo, &msg_buffer[26], sizeof(PcdPcInfoType));


		
		//后台时间与油机时间比较，如果年月日发生变更
		//或每天的时间相差2分钟更新油机时间
		
		time[0]=iptparam->Time.century;	time[1]=iptparam->Time.year;	time[2]=iptparam->Time.month;	
		time[3]=iptparam->Time.date;		time[4]=iptparam->Time.hour;	time[5]=iptparam->Time.minute;
		time[6]=iptparam->Time.second;
		if(0==timeVerification(IptPcInfo.Time, 7) && PCD_PC_ONLINE==iptparam->PcOnline)
		{
			time1=((time[4]>>4)&0x0f)*10*60*60+((time[4]>>0)&0x0f)*1*60*60+((time[5]>>4)&0x0f)*10*60+((time[5]>>0)&0x0f)*1*60+((time[6]>>4)&0x0f)*10+((time[6]>>0)&0x0f)*1;
			time2=((IptPcInfo.Time[4]>>4)&0x0f)*10*60*60+((IptPcInfo.Time[4]>>0)&0x0f)*1*60*60+((IptPcInfo.Time[5]>>4)&0x0f)*10*60+\
						((IptPcInfo.Time[5]>>0)&0x0f)*1*60+((IptPcInfo.Time[6]>>4)&0x0f)*10+((IptPcInfo.Time[6]>>0)&0x0f)*1;
			if(time1>time2)	timediff=time1-time2;
			else						timediff=time2-time1;
			if(0!=memcmp(&time[0],&IptPcInfo.Time[0], 4)||timediff>=120)
			{
				iptparam->Time.century=IptPcInfo.Time[0];	iptparam->Time.year=IptPcInfo.Time[1];	iptparam->Time.month=IptPcInfo.Time[2];	
				iptparam->Time.date=IptPcInfo.Time[3];		iptparam->Time.hour=IptPcInfo.Time[4];	iptparam->Time.minute=IptPcInfo.Time[5];	
				iptparam->Time.second=IptPcInfo.Time[6];
				timeWrite(iptparam->Time);
			}
		}

		//更新逻辑枪号，物理枪号合法且逻辑枪号不一致时更改本地逻辑枪号
		if(iptparam->PhysicalNozzle >= IPT_PHY_NOZZLE_MIN &&\
			iptparam->PhysicalNozzle <= IPT_PHY_NOZZLE_MAX &&\
			IPT_OIL_IDLE==iptparam->OilState &&\
			iptparam->LogicNozzle!=IptPcInfo.SInfo.NZN[iptparam->PhysicalNozzle-1] &&\
			0!=IptPcInfo.SInfo.NZN[iptparam->PhysicalNozzle-1])
		{
			iptparam->LogicNozzle = IptPcInfo.SInfo.NZN[iptparam->PhysicalNozzle-1];
		}

		//printf("IptPcInfo.OilInfo.FieldNumber = %d\n",IptPcInfo.OilInfo.FieldNumber);
		//根据实际油品数目，判断条件满足时修改当前油品油价
		for(i=0; (i<6)&&(i<IptPcInfo.OilInfo.FieldNumber); i++)
		//for(i = 0; (i<6)&&(i<0); i++)   //fj:20171013
		{
			//非本逻辑油枪的价格不处理
			if(iptparam->LogicNozzle != IptPcInfo.OilInfo.FieldNew[i].NZN)
			{
				continue;
			}

			//szb_fj_20171120:后台配置单枪，B枪不执行变价
			if(iptparam->JlNozzle==1 && IptPcInfo.OilInfo.FieldNumber==1)
				continue;

			//油枪非空闲状态，不处理价格
			if(IPT_OIL_IDLE != IptParamA.OilState || IPT_OIL_IDLE != IptParamB.OilState)
			{
				//printf("%s:%d:当前支付模块非空闲状态，不进行变价!\n", __FUNCTION__, __LINE__);
				break;
			}

			//printf("ipt2PcdPoll,read price,FieldNumber = %d\n",IptPcInfo.OilInfo.FieldNumber);
			
			//获取本地单价、并计算后台单价
			//jlPriceRead(iptparam->JlNozzle, &price); //fj:20171117
			GetjlPriceRead(iptparam->JlNozzle,&price);
			priceold = (IptPcInfo.OilInfo.Field[i].Price[0]<<8)|(IptPcInfo.OilInfo.Field[i].Price[1]<<0);
			pricenew = (IptPcInfo.OilInfo.FieldNew[i].Price[0]<<8)|(IptPcInfo.OilInfo.FieldNew[i].Price[1]<<0);
			//printf("Priceold = %d,pricenew = %d,tax - price = %d\n",priceold,pricenew,price);

			//判断如果未到生效时间，当前版本号、油品代码和价格均与油品油价表当前油品数据一致时表示已根据油品油价表更改过价格；
			//判断如果已到生效时间，当前版本号、油品代码和价格均与油品油价表新油品数据一致时表示已根据油品油价表更改过价格；
			//int nPriceBySNPC = iptparam->OilPriceBySNPC[0];
			//nPriceBySNPC = (nPriceBySNPC << 8) | (iptparam->OilPriceBySNPC[1] & 0xff);
			//printf("OilVersion = %d,OilInfo.Version =%d,OilPriceBySNPC = %d\n",iptparam->OilVersion,IptPcInfo.OilInfo.Version,nPriceBySNPC);
			
			if(memcmp(time, IptPcInfo.OilInfo.ValidTime, 6) < 0 && iptparam->OilVersion == IptPcInfo.OilInfo.Version && 0 == memcmp(iptparam->OilCode, IptPcInfo.OilInfo.Field[i].O_TYPE, 2) && 0 == memcmp(iptparam->OilPriceBySNPC, IptPcInfo.OilInfo.Field[i].Price, 2))
			{
				break;
			}
			if(memcmp(time, IptPcInfo.OilInfo.ValidTime, 6) >= 0 && iptparam->OilVersion == IptPcInfo.OilInfo.Version && 0 == memcmp(iptparam->OilCode, IptPcInfo.OilInfo.FieldNew[i].O_TYPE, 2) && 0 == memcmp(iptparam->OilPriceBySNPC, IptPcInfo.OilInfo.FieldNew[i].Price, 2))
			{
				break;
			}
				
			//如果未达到生效时间，油品油价表当前价格与实际价格不一致时更新价格
			if(iptparam->PriceChgTimer >= 5*ONE_SECOND && (memcmp(time, IptPcInfo.OilInfo.ValidTime, 6) < 0) && (priceold != price || 0 != memcmp(iptparam->OilCode, IptPcInfo.OilInfo.Field[i].O_TYPE, 2)))
			{
                if(iptparam->KeyLock==0)//szb_fj_20171120:设置位置时，后台不允许变价
				{
					istate = jlPriceWrite(iptparam->JlNozzle, priceold);
	                //printf("un time ,priceold = %d,price=%d,istate = %d\n",priceold,price,istate);
					if(istate==0)
					{
						iptparam->JlErr_BianJia=0;
						framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+FM_ERR_BIAN_PRICE,&iptparam->JlErr_BianJia,1);
						iptparam->PriceChgTimer = 0;
						ihandle = 1;
					}
					else
					{
						iptparam->JlErr_BianJia=1;	
						framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+FM_ERR_BIAN_PRICE,&iptparam->JlErr_BianJia,1);
						iptparam->PriceChgTimer = 0;
					}
				}
				//fj:
			    //istate = jlPriceWrite(iptparam->JlNozzle, priceold);	
				//printf("old:test oil price is write success!"); //fj:
				//iptparam->PriceChgTimer = 0;	ihandle = 1;
			}

			//如果已达到生效时间，油品油价表新价格与实际价格不一致时更新价格
			if(iptparam->PriceChgTimer >= 5*ONE_SECOND && (memcmp(time, IptPcInfo.OilInfo.ValidTime, 6)>=0) && (pricenew!=price || 0!=memcmp(iptparam->OilCode, IptPcInfo.OilInfo.FieldNew[i].O_TYPE, 2)))
			{
            	if(iptparam->KeyLock==0)//szb_fj_20171120:设置位置时后台不允许变价
				{
	              
					istate = jlPriceWrite(iptparam->JlNozzle, pricenew);
                    //printf("have time ,pricenew = %d,price=%d,istate = %d\n",pricenew,price,istate);
					if(istate==0)
					{
						iptparam->JlErr_BianJia=0;
						framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+FM_ERR_BIAN_PRICE,&iptparam->JlErr_BianJia,1);
						iptparam->PriceChgTimer = 0;
						ihandle = 2;
					}
					else
					{
						iptparam->JlErr_BianJia=1;	
						framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+FM_ERR_BIAN_PRICE,&iptparam->JlErr_BianJia,1);
						iptparam->PriceChgTimer = 0;
					}
				}
				//fj:
				//istate = jlPriceWrite(iptparam->JlNozzle, pricenew);
			    //printf("new:test oil price is write success!");//fj:
				//iptparam->PriceChgTimer = 0;	ihandle = 2;
			}

			//更新价格成功，油机下班，更新油品信息
			if(0 == istate && (1 == ihandle || 2 == ihandle))
			{
				if((iptparam->ProcessId>=IPT_PID_IC_PRETREAT) && (iptparam->ProcessId<IPT_PID_IC_OILCHECK))	
					ICShoot(iptparam->DEVIC);
				//待填充:POS_TTC
				memcpy(&iptparam->OilBill[IPT_OFFSET_TTC], "\x00\x00\x00\x00", 4);

				//已完成:交易类型设为无卡错，后台/本地黑白名单，扣款签名无效，下班
				iptparam->OilBill[IPT_OFFSET_T_TYPE]=(0<<7)|((iptparam->BlistSrc&1)<<6)|(0<<4)|(6<<0);

				//已完成:交易日期及时间
				iptparam->OilBill[IPT_OFFSET_TIME+0]=iptparam->Time.century;
				iptparam->OilBill[IPT_OFFSET_TIME+1]=iptparam->Time.year;
				iptparam->OilBill[IPT_OFFSET_TIME+2]=iptparam->Time.month;
				iptparam->OilBill[IPT_OFFSET_TIME+3]=iptparam->Time.date;
				iptparam->OilBill[IPT_OFFSET_TIME+4]=iptparam->Time.hour;
				iptparam->OilBill[IPT_OFFSET_TIME+5]=iptparam->Time.minute;
				iptparam->OilBill[IPT_OFFSET_TIME+6]=iptparam->Time.second;

				//已完成:卡应用号
				//memcpy(&iptparam->OilBill[IPT_OFFSET_ASN], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 10);
				memcpy(&iptparam->OilBill[IPT_OFFSET_ASN], iptparam->EMPCardID, 10);
						
				//已完成:余额(扣前)，交易完成后填扣后余额
				//memcpy(&iptparam->OilBill[IPT_OFFSET_BALANCE], iptparam->IcBalance, 4);
				memcpy(&iptparam->OilBill[IPT_OFFSET_BALANCE], "\x00\x00\x00\x00", 4);
						
				//已完成:数额，交易完成后填实际数额		
				memcpy(&iptparam->OilBill[IPT_OFFSET_AMN], "\x00\x00\x00", 3);
						
				//已完成:卡交易序号
				memcpy(&iptparam->OilBill[IPT_OFFSET_CTC], "\x00\x00", 2);
						
				//已完成:电子签名，加油/补扣/补充时未TAC，逃卡时为GTAC	
				memcpy(&iptparam->OilBill[IPT_OFFSET_TAC], "\x00\x00\x00\x00", 4);
						
				//已完成:解灰认证码4bytes，加油完成，PSAM计算GMAC后添加
				memcpy(&iptparam->OilBill[IPT_OFFSET_GMAC], "\x00\x00\x00\x00", 4);

				//已完成:PSAM会所签名4bytes，加油完成，PSAM计算GMAC后添加
				memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TAC], "\x00\x00\x00\x00", 4);
						
				//已完成:PSAM应用号10bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_ASN], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 10);

				//已完成:PSAM编号6bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_TID], "\x00\x00\x00\x00\x00\x00", 6);

				//已完成:PSAM终端交易序号4bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TTC], "\x00\x00\x00\x00", 4);

				//已完成:扣款来源1byte
				iptparam->OilBill[IPT_OFFSET_DS]=0;

				//已完成:结算单位/方式1byte
				iptparam->OilBill[IPT_OFFSET_UNIT]=0;
						
				//已完成:卡类1byte
				iptparam->OilBill[IPT_OFFSET_C_TYPE]=0;
						
				//已完成:卡版本1byte，b7~b4卡密钥索引号；b3~b0卡密钥版本号
				iptparam->OilBill[IPT_OFFSET_VER]=0;
						
				//已完成:枪号1byte
				iptparam->OilBill[IPT_OFFSET_NZN]=iptparam->LogicNozzle;
						
				//已完成:油品代码2bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_G_CODE], iptparam->OilCode, 2);
						
				//已完成:升数3bytes，交易完成后填实际升数
				memcpy(&iptparam->OilBill[IPT_OFFSET_VOL], "\x00\x00\x00", 3);
						
				//已完成:成交价格2bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_PRC], "\x00\x00", 2);
						
				//已完成:员工号1byte
				iptparam->OilBill[IPT_OFFSET_EMP]=iptparam->EMP;

				//已完成:升累计4bytes，交易完成后填实际总累,fj:
				//jlSumRead(iptparam->JlNozzle, &volume_sum, &money_sum);
				GetjlSumRead(iptparam->JlNozzle,&volume_sum,&money_sum);
				iptparam->OilBill[IPT_OFFSET_V_TOT+0]=(char)(volume_sum>>24);
				iptparam->OilBill[IPT_OFFSET_V_TOT+1]=(char)(volume_sum>>16);
				iptparam->OilBill[IPT_OFFSET_V_TOT+2]=(char)(volume_sum>>8);	
				iptparam->OilBill[IPT_OFFSET_V_TOT+3]=(char)(volume_sum>>0);

				//已完成:备用部分11bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_RFU], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 11);

				//待填充:T-MAC	4bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], "\x00\x00\x00\x00", 4);
								
				//已完成:物理枪号PhysicsGunId
				iptparam->OilBill[IPT_OFFSET_PHYGUN]=iptparam->PhysicalNozzle;
								
				//已完成:计量停机原因
				iptparam->OilBill[IPT_OFFSET_STOPNO]=0;

				//已完成:扣前余额
				memcpy(&iptparam->OilBill[IPT_OFFSET_BEFOR_BAL], "\x00\x00\x00\x00", 4);
								
				//账单状态:0=正常；1=未完成
				iptparam->OilBill[IPT_OFFSET_ZD_STATE]=1;

				//计量设备ID
				iptparam->OilBill[IPT_OFFSET_JLNOZZLE]=iptparam->JlNozzle;

				//计算账单校验值
				iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

				//保存账单及备份
				framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
				framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

				//提请保存账单
				iptparam->OilBillSave=1;
				//szb_fj_20171120:增加
            	framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_BILL_FLAG,&iptparam->OilBillSave , 1);

				//保存下班信息，下班状态(1byte)，员工号(1byte)，员工密码(2bytes)，员工卡号(10bytes)
				memcpy(&buffer[0], "\x00", 1);		memcpy(&buffer[1], &iptparam->EMP, 1);
				memcpy(&buffer[2], iptparam->EMPPassword, 2);	memcpy(&buffer[4], iptparam->EMPCardID, 10);
				if(0==iptparam->Id)		paramSetupWrite(IPT0_DUTY_INFO, buffer, 14);
				else									paramSetupWrite(IPT1_DUTY_INFO, buffer, 14);

				//更新内存中下班信息
				iptparam->WorkState = IPT_WORK_OFFDUTY;

				//修改成功之后更新本地油品信息，以油品油价表当前价格更新油机价格时不更新版本号
				if(1 == ihandle)
				{
					memcpy(iptparam->OilCode, IptPcInfo.OilInfo.Field[i].O_TYPE, 2);
					memcpy(iptparam->OilPriceBySNPC, IptPcInfo.OilInfo.Field[i].Price, 2);
					//iptparam->OilVersion = iptparam->OilVersion;
	                iptparam->OilVersion = IptPcInfo.OilInfo.Version;//szb_fj_20171120
				}
				else
				{
					memcpy(iptparam->OilCode, IptPcInfo.OilInfo.FieldNew[i].O_TYPE, 2);
					memcpy(iptparam->OilPriceBySNPC, IptPcInfo.OilInfo.FieldNew[i].Price, 2);
					iptparam->OilVersion = IptPcInfo.OilInfo.Version;
				}
					
				iptparam->OilPrice = (iptparam->OilPriceBySNPC[0]<<8)|(iptparam->OilPriceBySNPC[1]<<0);
						
				memcpy(tx_buffer + 0, iptparam->OilCode, 2);
				memcpy(tx_buffer + 2, iptparam->OilPriceBySNPC, 2);
				*(tx_buffer + 4) = iptparam->OilVersion;
				tx_len = 5;
				if(IPT_NOZZLE_1==iptparam->Id)			paramSetupWrite(IPT0_PRICE_INFO, tx_buffer, tx_len);
				else if(IPT_NOZZLE_2==iptparam->Id)	paramSetupWrite(IPT1_PRICE_INFO, tx_buffer, tx_len);

				//更新油品名称
				tx_buffer[0]=((iptparam->OilCode[0]>>4)&0x0f)+0x30;	tx_buffer[1]=((iptparam->OilCode[0]>>0)&0x0f)+0x30;
				tx_buffer[2]=((iptparam->OilCode[1]>>4)&0x0f)+0x30;	tx_buffer[3]=((iptparam->OilCode[1]>>0)&0x0f)+0x30;
				memset(iptparam->OilName, 0xff, 16);
				oilNameGet(tx_buffer, iptparam->OilName, 16);
			}

			//szb_fj_20171120:增加
			if(iptparam->OilVersion!=IptPcInfo.OilInfo.Version) 
			{ 
				iptparam->OilVersion = IptPcInfo.OilInfo.Version; 
				memcpy(tx_buffer,iptparam->OilCode, 2); 
				memcpy(tx_buffer+2, iptparam->OilPriceBySNPC, 2); 
				tx_buffer[4] = iptparam->OilVersion; 
				tx_len = 5; 
				if(IPT_NOZZLE_1==iptparam->Id)
					paramSetupWrite(IPT0_PRICE_INFO, tx_buffer, tx_len);                
				else if(IPT_NOZZLE_2==iptparam->Id)  
					paramSetupWrite(IPT1_PRICE_INFO, tx_buffer, tx_len);    
			}
		}


#if 0
		//联网正常状态，根据PC信息修正本地数据
		if(PCD_PC_ONLINE==iptparam->PcOnline)
		{
			//
			后台时间与油机时间比较，如果年月日发生变更
			或每天的时间相差2分钟更新油机时间
			
			time[0]=iptparam->Time.century;	time[1]=iptparam->Time.year;	time[2]=iptparam->Time.month;	
			time[3]=iptparam->Time.date;		time[4]=iptparam->Time.hour;	time[5]=iptparam->Time.minute;
			time[6]=iptparam->Time.second;
			if(0==timeVerification(IptPcInfo.Time, 7))
			{
				time1=((time[4]>>4)&0x0f)*10*60*60+((time[4]>>0)&0x0f)*1*60*60+((time[5]>>4)&0x0f)*10*60+((time[5]>>0)&0x0f)*1*60+((time[6]>>4)&0x0f)*10+((time[6]>>0)&0x0f)*1;
				time2=((IptPcInfo.Time[4]>>4)&0x0f)*10*60*60+((IptPcInfo.Time[4]>>0)&0x0f)*1*60*60+((IptPcInfo.Time[5]>>4)&0x0f)*10*60+\
						((IptPcInfo.Time[5]>>0)&0x0f)*1*60+((IptPcInfo.Time[6]>>4)&0x0f)*10+((IptPcInfo.Time[6]>>0)&0x0f)*1;
				if(time1>time2)	timediff=time1-time2;
				else						timediff=time2-time1;
				if(0!=memcmp(&time[0],&IptPcInfo.Time[0], 4)||timediff>=120)
				{
					iptparam->Time.century=IptPcInfo.Time[0];	iptparam->Time.year=IptPcInfo.Time[1];	iptparam->Time.month=IptPcInfo.Time[2];	
					iptparam->Time.date=IptPcInfo.Time[3];		iptparam->Time.hour=IptPcInfo.Time[4];	iptparam->Time.minute=IptPcInfo.Time[5];	
					iptparam->Time.second=IptPcInfo.Time[6];
					timeWrite(iptparam->Time);
				}
			}

			//更新逻辑枪号，物理枪号合法且逻辑枪号不一致时更改本地逻辑枪号
			if(iptparam->PhysicalNozzle >= IPT_PHY_NOZZLE_MIN &&\
				iptparam->PhysicalNozzle <= IPT_PHY_NOZZLE_MAX &&\
				IPT_OIL_IDLE==iptparam->OilState &&\
				iptparam->LogicNozzle!=IptPcInfo.SInfo.NZN[iptparam->PhysicalNozzle-1] &&\
				0!=IptPcInfo.SInfo.NZN[iptparam->PhysicalNozzle-1])
			{
				iptparam->LogicNozzle = IptPcInfo.SInfo.NZN[iptparam->PhysicalNozzle-1];
			}

			//根据实际油品数目，判断条件满足时修改当前油品油价
			for(i=0; (i<6)&&(i<IptPcInfo.OilInfo.FieldNumber); i++)
			{
				//非本逻辑油枪的价格不处理
				if(iptparam->LogicNozzle != IptPcInfo.OilInfo.FieldNew[i].NZN)
				{
					continue;
				}

				//油枪非空闲状态，不处理价格
				if(IPT_OIL_IDLE != IptParamA.OilState || IPT_OIL_IDLE != IptParamB.OilState)
				{
					//printf("%s:%d:当前支付模块非空闲状态，不进行变价!\n", __FUNCTION__, __LINE__);
					break;
				}
			
				//获取本地单价、并计算后台单价
				jlPriceRead(iptparam->JlNozzle, &price);
				priceold = (IptPcInfo.OilInfo.Field[i].Price[0]<<8)|(IptPcInfo.OilInfo.Field[i].Price[1]<<0);
				pricenew = (IptPcInfo.OilInfo.FieldNew[i].Price[0]<<8)|(IptPcInfo.OilInfo.FieldNew[i].Price[1]<<0);

				//IPT存储的油品油价表版本号和油品代码与PCD一致时表示已更改过价格则不再更改，防止手工变价后价格自动更改
				if(0 == memcmp(iptparam->OilCode, IptPcInfo.OilInfo.FieldNew[i].O_TYPE, 2) &&\
					iptparam->OilVersion == IptPcInfo.OilInfo.Version)
				{
					//printf("%s:%d:当前存储价格表版本与后台价格表版本一致，不进行变价!\n", __FUNCTION__, __LINE__);
					break;
				}

				//判断如果未到生效时间、当前油品代码和价格均与油品油价表当前油品数据一致时表示已根据油品油价表更改过价格；
				//判断如果已到生效时间、当前油品代码和价格均与油品油价表新油品数据一致时表示已根据油品油价表更改过价格；
				
				if(memcmp(time, IptPcInfo.OilInfo.ValidTime, 6) < 0 && iptparam->OilVersion == IptPcInfo.OilInfo.Version && 0 == memcmp(iptparam->OilCode, IptPcInfo.OilInfo.Field[i].O_TYPE, 2) && 0 == memcmp(iptparam->OilPriceBySNPC, IptPcInfo.OilInfo.Field[i].Price, 2))
				{
					break;
				}
				if(memcmp(time, IptPcInfo.OilInfo.ValidTime, 6) >= 0 && iptparam->OilVersion == IptPcInfo.OilInfo.Version && 0 == memcmp(iptparam->OilCode, IptPcInfo.OilInfo.FieldNew[i].O_TYPE, 2) && 0 == memcmp(iptparam->OilPriceBySNPC, IptPcInfo.OilInfo.FieldNew[i].Price, 2))
				{
					break;
				}
					
				//如果未达到生效时间，油品油价表当前价格与实际价格不一致时更新价格
				if(iptparam->PriceChgTimer >= 5*ONE_SECOND && memcmp(time, IptPcInfo.OilInfo.ValidTime, 6) < 0 && (priceold != price || 0 != memcmp(iptparam->OilCode, IptPcInfo.OilInfo.Field[i].O_TYPE, 2)))
				{
					istate = jlPriceWrite(iptparam->JlNozzle, priceold);	
					iptparam->PriceChgTimer = 0;	ihandle = 1;
				}

				//如果已达到生效时间，油品油价表新价格与实际价格不一致时更新价格
				if(iptparam->PriceChgTimer >= 5*ONE_SECOND && memcmp(time, IptPcInfo.OilInfo.ValidTime, 6)>=0 && (pricenew!=price || 0!=memcmp(iptparam->OilCode, IptPcInfo.OilInfo.FieldNew[i].O_TYPE, 2)))
				{
					istate = jlPriceWrite(iptparam->JlNozzle, pricenew);	
					iptparam->PriceChgTimer = 0;	ihandle = 2;
				}

				//更新价格成功，油机下班，更新油品信息
				if(0 == istate && (1 == ihandle || 2 == ihandle))
				{
					//待填充:POS_TTC
					memcpy(&iptparam->OilBill[IPT_OFFSET_TTC], "\x00\x00\x00\x00", 4);

					//已完成:交易类型设为无卡错，后台/本地黑白名单，扣款签名无效，下班
					iptparam->OilBill[IPT_OFFSET_T_TYPE]=(0<<7)|((iptparam->BlistSrc&1)<<6)|(0<<4)|(6<<0);

					//已完成:交易日期及时间
					iptparam->OilBill[IPT_OFFSET_TIME+0]=iptparam->Time.century;
					iptparam->OilBill[IPT_OFFSET_TIME+1]=iptparam->Time.year;
					iptparam->OilBill[IPT_OFFSET_TIME+2]=iptparam->Time.month;
					iptparam->OilBill[IPT_OFFSET_TIME+3]=iptparam->Time.date;
					iptparam->OilBill[IPT_OFFSET_TIME+4]=iptparam->Time.hour;
					iptparam->OilBill[IPT_OFFSET_TIME+5]=iptparam->Time.minute;
					iptparam->OilBill[IPT_OFFSET_TIME+6]=iptparam->Time.second;

					//已完成:卡应用号
					//memcpy(&iptparam->OilBill[IPT_OFFSET_ASN], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 10);
					memcpy(&iptparam->OilBill[IPT_OFFSET_ASN], iptparam->EMPCardID, 10);
						
					//已完成:余额(扣前)，交易完成后填扣后余额
					//memcpy(&iptparam->OilBill[IPT_OFFSET_BALANCE], iptparam->IcBalance, 4);
					memcpy(&iptparam->OilBill[IPT_OFFSET_BALANCE], "\x00\x00\x00\x00", 4);
						
					//已完成:数额，交易完成后填实际数额		
					memcpy(&iptparam->OilBill[IPT_OFFSET_AMN], "\x00\x00\x00", 3);
						
					//已完成:卡交易序号
					memcpy(&iptparam->OilBill[IPT_OFFSET_CTC], "\x00\x00", 2);
						
					//已完成:电子签名，加油/补扣/补充时未TAC，逃卡时为GTAC	
					memcpy(&iptparam->OilBill[IPT_OFFSET_TAC], "\x00\x00\x00\x00", 4);
						
					//已完成:解灰认证码4bytes，加油完成，PSAM计算GMAC后添加
					memcpy(&iptparam->OilBill[IPT_OFFSET_GMAC], "\x00\x00\x00\x00", 4);

					//已完成:PSAM会所签名4bytes，加油完成，PSAM计算GMAC后添加
					memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TAC], "\x00\x00\x00\x00", 4);
						
					//已完成:PSAM应用号10bytes
					memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_ASN], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 10);

					//已完成:PSAM编号6bytes
					memcpy(&iptparam->OilBill[IPT_OFFSET_TID], "\x00\x00\x00\x00\x00\x00", 6);

					//已完成:PSAM终端交易序号4bytes
					memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TTC], "\x00\x00\x00\x00", 4);

					//已完成:扣款来源1byte
					iptparam->OilBill[IPT_OFFSET_DS]=0;

					//已完成:结算单位/方式1byte
					iptparam->OilBill[IPT_OFFSET_UNIT]=0;
						
					//已完成:卡类1byte
					iptparam->OilBill[IPT_OFFSET_C_TYPE]=0;
						
					//已完成:卡版本1byte，b7~b4卡密钥索引号；b3~b0卡密钥版本号
					iptparam->OilBill[IPT_OFFSET_VER]=0;
						
					//已完成:枪号1byte
					iptparam->OilBill[IPT_OFFSET_NZN]=iptparam->LogicNozzle;
						
					//已完成:油品代码2bytes
					memcpy(&iptparam->OilBill[IPT_OFFSET_G_CODE], iptparam->OilCode, 2);
						
					//已完成:升数3bytes，交易完成后填实际升数
					memcpy(&iptparam->OilBill[IPT_OFFSET_VOL], "\x00\x00\x00", 3);
						
					//已完成:成交价格2bytes
					memcpy(&iptparam->OilBill[IPT_OFFSET_PRC], "\x00\x00", 2);
						
					//已完成:员工号1byte
					iptparam->OilBill[IPT_OFFSET_EMP]=iptparam->EMP;

					//已完成:升累计4bytes，交易完成后填实际总累
					jlSumRead(iptparam->JlNozzle, &volume_sum, &money_sum);
					iptparam->OilBill[IPT_OFFSET_V_TOT+0]=(char)(volume_sum>>24);
					iptparam->OilBill[IPT_OFFSET_V_TOT+1]=(char)(volume_sum>>16);
					iptparam->OilBill[IPT_OFFSET_V_TOT+2]=(char)(volume_sum>>8);	
					iptparam->OilBill[IPT_OFFSET_V_TOT+3]=(char)(volume_sum>>0);

					//已完成:备用部分11bytes
					memcpy(&iptparam->OilBill[IPT_OFFSET_RFU], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 11);

					//待填充:T-MAC	4bytes
					memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], "\x00\x00\x00\x00", 4);
								
					//已完成:物理枪号PhysicsGunId
					iptparam->OilBill[IPT_OFFSET_PHYGUN]=iptparam->PhysicalNozzle;
								
					//已完成:计量停机原因
					iptparam->OilBill[IPT_OFFSET_STOPNO]=0;

					//已完成:扣前余额
					memcpy(&iptparam->OilBill[IPT_OFFSET_BEFOR_BAL], "\x00\x00\x00\x00", 4);
								
					//账单状态:0=正常；1=未完成
					iptparam->OilBill[IPT_OFFSET_ZD_STATE]=1;

					//计量设备ID
					iptparam->OilBill[IPT_OFFSET_JLNOZZLE]=iptparam->JlNozzle;

					//计算账单校验值
					iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

					//保存账单及备份
					framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
					framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

					//提请保存账单
					iptparam->OilBillSave=1;

					//保存下班信息，下班状态(1byte)，员工号(1byte)，员工密码(2bytes)，员工卡号(10bytes)
					memcpy(&buffer[0], "\x00", 1);		memcpy(&buffer[1], &iptparam->EMP, 1);
					memcpy(&buffer[2], iptparam->EMPPassword, 2);	memcpy(&buffer[4], iptparam->EMPCardID, 10);
					if(0==iptparam->Id)		paramSetupWrite(IPT0_DUTY_INFO, buffer, 14);
					else									paramSetupWrite(IPT1_DUTY_INFO, buffer, 14);

					//更新内存中下班信息
					iptparam->WorkState = IPT_WORK_OFFDUTY;

					//修改成功之后更新本地油品信息，以油品油价表当前价格更新油机价格时不更新版本号
					if(1 == ihandle)
					{
						memcpy(iptparam->OilCode, IptPcInfo.OilInfo.Field[i].O_TYPE, 2);
						memcpy(iptparam->OilPriceBySNPC, IptPcInfo.OilInfo.Field[i].Price, 2);
						iptparam->OilVersion = iptparam->OilVersion;
					}
					else
					{
						memcpy(iptparam->OilCode, IptPcInfo.OilInfo.FieldNew[i].O_TYPE, 2);
						memcpy(iptparam->OilPriceBySNPC, IptPcInfo.OilInfo.FieldNew[i].Price, 2);
						iptparam->OilVersion = IptPcInfo.OilInfo.Version;
					}
					
					iptparam->OilPrice = (iptparam->OilPriceBySNPC[0]<<8)|(iptparam->OilPriceBySNPC[1]<<0);
						
					memcpy(tx_buffer + 0, iptparam->OilCode, 2);
					memcpy(tx_buffer + 2, iptparam->OilPriceBySNPC, 2);
					*(tx_buffer + 4) = iptparam->OilVersion;
					tx_len = 5;
					if(IPT_NOZZLE_1==iptparam->Id)			paramSetupWrite(IPT0_PRICE_INFO, tx_buffer, tx_len);
					else if(IPT_NOZZLE_2==iptparam->Id)	paramSetupWrite(IPT1_PRICE_INFO, tx_buffer, tx_len);

					//更新油品名称
					tx_buffer[0]=((iptparam->OilCode[0]>>4)&0x0f)+0x30;	tx_buffer[1]=((iptparam->OilCode[0]>>0)&0x0f)+0x30;
					tx_buffer[2]=((iptparam->OilCode[1]>>4)&0x0f)+0x30;	tx_buffer[3]=((iptparam->OilCode[1]>>0)&0x0f)+0x30;
					memset(iptparam->OilName, 0xff, 16);
					oilNameGet(tx_buffer, iptparam->OilName, 16);
				}
			}
		}
#endif
	}

	//普通命令返回超时2秒
	if(IPT_2PCD_POLL==iptparam->PcdTxFlag && iptparam->PcdTxTimer>=(2*ONE_SECOND))
	{
		iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdPollOverTimes++;
		if(iptparam->PcdPollOverTimes>=3)
		{
			iptparam->PcdState=0;
		}
	}

	return 0;
}


/*******************************************************************
*Name				:iptPretreat
*Description		:IPT上电预处理
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptPretreat(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char stop_no=0;
	unsigned long long money_sum=0, volume_sum=0;
	unsigned int money=0, volume=0, price=0, crc_check=0;
	unsigned char bill_buffer[IPT_BILL_SIZE]={0}, tmp_bill2[IPT_BILL_SIZE]={0}, xor=0;
	int istate=0;
	char ibuffer[128]={0};
	int apdu_len = 0, i = 0;
	unsigned int tmp_ttc = 0;
	unsigned char apdu_buffer[8] = {0}, tmac_buffer[8] = {0};
	unsigned char dsp_data[4]={0},IcDebitUnit=0,IcDiscountFlag=0;
	unsigned short PriceDiscount=0,pdiscount=0,OilMoneyDiscount=0;
	unsigned char IC_yue[4]={0},dsp_buffer[20]={0},tmp_buffer[32]={0}; //szb_fj_20171120:
	unsigned int balance=0,crc_return=0,self_sum_price=0,data=0,suanfa=0,state=0; //szb_fj_20171120:
	
	switch(iptparam->Step)
	{
	case 0:
		//非自助账单数据，账单校验失败则判断备份是否正常，正常则以备份恢复账单数据
		framRead(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_UNSELF, bill_buffer, IPT_UNSELF_BILL_SIZE);
		crc_check=crc16Get(bill_buffer, IPT_UNSELF_BILL_SIZE-2);
		if(crc_check!=((bill_buffer[IPT_UNSELF_OFF_CHECK+0]<<8)|(bill_buffer[IPT_UNSELF_OFF_CHECK+1]<<0)))
		{
			framRead(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_UNSELF2, tmp_bill2, IPT_UNSELF_BILL_SIZE);
			crc_check=crc16Get(tmp_bill2, IPT_UNSELF_BILL_SIZE-2);
			if(crc_check!=((tmp_bill2[IPT_UNSELF_OFF_CHECK+0]<<8)|(tmp_bill2[IPT_UNSELF_OFF_CHECK+1]<<0)))
			{
				memcpy(bill_buffer, tmp_bill2, IPT_UNSELF_BILL_SIZE);
				framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_UNSELF, bill_buffer, IPT_UNSELF_BILL_SIZE);
			}
		}

		iptparam->MoneyUnself=(bill_buffer[0]<<16)|(bill_buffer[1]<<8)|(bill_buffer[2]<<0);
		iptparam->VolumeUnself=(bill_buffer[3]<<16)|(bill_buffer[4]<<8)|(bill_buffer[5]<<0);
		iptparam->OilStateUnself=bill_buffer[6];
		iptparam->MoneyUnselfSum=(bill_buffer[7]<<16)|(bill_buffer[8]<<8)|(bill_buffer[9]<<0);
		iptparam->VolumeUnselfSum=(bill_buffer[10]<<16)|(bill_buffer[11]<<8)|(bill_buffer[12]<<0);
		iptparam->OilOverTimes=bill_buffer[13];
		
		//卡账单数据，账单校验失败则判断备份是否正常，正常则以备份恢复账单数据
		framRead(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
		xor=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);
		if(xor!=iptparam->OilBill[IPT_OFFSET_ZDXOR])
		{
			framRead(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, tmp_bill2, IPT_BILL_SIZE);
			xor=xorGet(tmp_bill2, IPT_BILL_SIZE-1);
			if(xor==tmp_bill2[IPT_OFFSET_ZDXOR])
			{
				memcpy(iptparam->OilBill, tmp_bill2, IPT_BILL_SIZE);
				framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, tmp_bill2, IPT_BILL_SIZE);
			}
		}

		//条码账单数据，账单校验失败则判断备份是否正常，正常则以备份恢复账单数据
		framRead(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_TM, iptparam->BarOilBill, IPT_BAR_BILL_SIZE);
		xor=xorGet(iptparam->BarOilBill, IPT_BAR_BILL_SIZE-1);
		if(xor!=iptparam->BarOilBill[IPT_BAR_OFF_CHECK])
		{
			framRead(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_TM2, tmp_bill2, IPT_BAR_BILL_SIZE);
			xor=xorGet(tmp_bill2, IPT_BAR_BILL_SIZE-1);
			if(xor==tmp_bill2[IPT_BAR_OFF_CHECK])
			{
				memcpy(iptparam->BarOilBill, tmp_bill2, IPT_BAR_BILL_SIZE);
				framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_TM, tmp_bill2, IPT_BAR_BILL_SIZE);
			}
		}

		//szb_fj_20171120:
		framRead(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_BILL_FLAG,&iptparam->OilBillSave , 1);
		if(iptparam->OilBillSave>1)
		{
			iptparam->OilBillSave=0;
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_BILL_FLAG,&iptparam->OilBillSave , 1);
		}

		//szb_fj_20171120:断上次加油状态，未完成则完成该笔账单，正常则转入待机
     	if(IPT_MODE_IC==iptparam->Mode || IPT_MODE_BARCODE==iptparam->Mode)//szb_fj_20171120:卡机联动和条码自助模式
		{
			if(0==iptparam->OilBill[IPT_OFFSET_ZD_STATE] || iptparam->OilBillSave==1)
			{
		 		iptMainInterface(iptparam);
			}
			else
			{
				iptparam->Step=1;
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "正在恢复上笔账单", 16);
				jljUserLog("有加油过程未结束，正在恢复上一笔账单\n");
			}
		}
		else if(IPT_MODE_UNSELF==iptparam->Mode)//szb_fj_20171120:非卡机联动模式
		{
			if(iptparam->OilStateUnself==1)
			{
				iptparam->Step=1;
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "正在恢复上笔账单", 16);
				jljUserLog("有加油过程未结束，正在恢复上一笔账单\n");
			}
			else
			{
				iptMainInterface(iptparam);
			}	
		}
		break;

	case 1:
		//断电恢复，如果有未完成账单则完成该账单,fj:
        printf("断电，jlOilFinish\n");
		istate=jlOilFinish(iptparam->JlNozzle, &money_sum, &volume_sum, &money, &volume, &price, &stop_no);
		iptAbnormalStopHandle(iptparam,stop_no,money); //szb_fj_20171120
		if(0 != istate)
		{
			break;
		}

		//卡机联动或条码自助
		if(IPT_MODE_IC==iptparam->Mode || IPT_MODE_BARCODE==iptparam->Mode)
		{
			//待填充：余额（扣前），交易完成后填扣后余额
			memcpy(IC_yue,&iptparam->OilBill[IPT_OFFSET_BALANCE] ,4);
			//加油金额大于卡余额，以卡余额为本次卡账单加油金额，差额为非卡加油累计
			balance=(IC_yue[0]<<24)|(IC_yue[1]<<16)|(IC_yue[2]<<8)|(IC_yue[3]<<0);
			if(money <= balance)
			{
				iptparam->SumMoney=money_sum;	iptparam->SumVolume=volume_sum;
				iptparam->OilMoney=money;	iptparam->OilVolume=volume;	iptparam->OilPrice=price;	iptparam->JlStopNO=stop_no;

				//清除过冲数据
				memset(bill_buffer, 0, 32);	iptparam->MoneyUnself=0;	iptparam->VolumeUnself=0;
				iptparam->MoneyUnselfSum=0;	iptparam->VolumeUnselfSum=0;	iptparam->OilOverTimes=0;
				bill_buffer[0]=(char)(iptparam->MoneyUnself>>16);
				bill_buffer[1]=(char)(iptparam->MoneyUnself>>8);		bill_buffer[2]=(char)(iptparam->MoneyUnself>>0);
				bill_buffer[3]=(char)(iptparam->VolumeUnself>>16);
				bill_buffer[4]=(char)(iptparam->VolumeUnself>>8);	bill_buffer[5]=(char)(iptparam->VolumeUnself>>0);
				bill_buffer[6]=stop_no;
				bill_buffer[7]=(char)(iptparam->MoneyUnselfSum>>16);	
				bill_buffer[8]=(char)(iptparam->MoneyUnselfSum>>8);		bill_buffer[9]=(char)(iptparam->MoneyUnselfSum>>0);
				bill_buffer[10]=(char)(iptparam->VolumeUnselfSum>>16);	
				bill_buffer[11]=(char)(iptparam->VolumeUnselfSum>>8);	bill_buffer[12]=(char)(iptparam->VolumeUnselfSum>>0);
				bill_buffer[13]=iptparam->OilOverTimes;
				crc_return=crc16Get(bill_buffer, 30);
				bill_buffer[30]=(char)(crc_return>>8);	bill_buffer[31]=(char)(crc_return>>0);
				framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_UNSELF, bill_buffer, 32);
				framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_UNSELF2, bill_buffer, 32);

				//2017-02-13主板直接掉电卡解扣
				if(1 == iptIsLianda(iptparam->Id))
				{
					framRead(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_LDPowerData, dsp_data, 4);
					IcDebitUnit=dsp_data[0];
					IcDiscountFlag=dsp_data[1];
					PriceDiscount=(dsp_data[2]<<8)|(dsp_data[3]<<0);

					//如果有单价折扣则计算折扣额
					if(0x01 == IcDiscountFlag)
					{
						pdiscount = iptDiscountCompute(iptparam->Id, volume, PriceDiscount);
					}

					iptparam->SumMoney=money_sum;	iptparam->SumVolume=volume_sum;
					iptparam->OilMoney=money;	iptparam->OilVolume=volume;	iptparam->OilPrice=price;	iptparam->JlStopNO=stop_no;

				}

				//获取账单数据
				framRead(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, 128);

				//保存加油数据--油量
				iptparam->OilBill[IPT_OFFSET_VOL+0]=(char)(iptparam->OilVolume>>16);
				iptparam->OilBill[IPT_OFFSET_VOL+1]=(char)(iptparam->OilVolume>>8);
				iptparam->OilBill[IPT_OFFSET_VOL+2]=(char)(iptparam->OilVolume>>0);
				//保存加油数据--数额
				iptparam->OilBill[IPT_OFFSET_AMN+0]=(char)(iptparam->OilMoney>>16);
				iptparam->OilBill[IPT_OFFSET_AMN+1]=(char)(iptparam->OilMoney>>8);	
				iptparam->OilBill[IPT_OFFSET_AMN+2]=(char)(iptparam->OilMoney>>0);

				printf("---OilMoney = %d\n",iptparam->OilMoney);

				//保存加油数据--单价
				iptparam->OilBill[IPT_OFFSET_PRC+0]=(char)(iptparam->OilPrice>>8);
				iptparam->OilBill[IPT_OFFSET_PRC+1]=(char)(iptparam->OilPrice>>0);
				//保存加油数据--总累油量
				iptparam->OilBill[IPT_OFFSET_V_TOT+0]=(char)(iptparam->SumVolume>>24);	
				iptparam->OilBill[IPT_OFFSET_V_TOT+1]=(char)(iptparam->SumVolume>>16);
				iptparam->OilBill[IPT_OFFSET_V_TOT+2]=(char)(iptparam->SumVolume>>8);	
				iptparam->OilBill[IPT_OFFSET_V_TOT+3]=(char)(iptparam->SumVolume>>0);
				//保存加油数据--停机代码
				iptparam->OilBill[IPT_OFFSET_STOPNO]=iptparam->JlStopNO;

				//2017-02-13主板直接掉电卡解扣
				if(1 == iptIsLianda(iptparam->Id))
				{
					if(1 ==IcDebitUnit)
					{
						OilMoneyDiscount = iptparam->OilVolume;
						//数额字段以升数替换
						iptparam->OilBill[IPT_OFFSET_AMN+0]=(char)(iptparam->OilVolume>>16);	
						iptparam->OilBill[IPT_OFFSET_AMN+1]=(char)(iptparam->OilVolume>>8);	
						iptparam->OilBill[IPT_OFFSET_AMN+2]=(char)(iptparam->OilVolume>>0);
					}
					else if(iptparam->OilMoney >= pdiscount)
					{
						OilMoneyDiscount = iptparam->OilMoney - pdiscount;
					}
					else
					{
						OilMoneyDiscount = iptparam->OilMoney;
					}
					//折扣后的金额(代储卡时为升数)
					iptparam->OilBill[IPT_OFFSET_MONEY_DISCOUNT+0] = (char)(OilMoneyDiscount>>16);
					iptparam->OilBill[IPT_OFFSET_MONEY_DISCOUNT+1] = (char)(OilMoneyDiscount>>8);
					iptparam->OilBill[IPT_OFFSET_MONEY_DISCOUNT+2] = (char)(OilMoneyDiscount>>0);
					//价格折扣
					//iptparam->OilBill[IPT_OFFSET_DISCOUNT+0] = (char)(iptparam->PriceDiscount>>8);
					//iptparam->OilBill[IPT_OFFSET_DISCOUNT+1] = (char)(iptparam->PriceDiscount>>0);
				}

				//复位PSAM
				for(i = 0; i < 2; i++)
				{
					istate=PsamReset(iptparam->DEVIC, iptparam->DEVPsam);
					if(ICSTATE_OK == istate)	break;
				}

				//逃卡账单，计算GMAC
				if(0x01 == (iptparam->OilBill[IPT_OFFSET_T_TYPE] & 0x0F))
				{
					for(i = 0; i < 2; i++)
					{
						//选择应用1
						istate=PsamDFSelect(iptparam->DEVIC, iptparam->DEVPsam, ibuffer, 128, 1);
						//计算GMAC
						istate = PsamGMAC(iptparam->DEVIC, iptparam->DEVPsam, ibuffer, 128, &iptparam->OilBill[IPT_OFFSET_ASN + 2], &iptparam->OilBill[IPT_OFFSET_CTC], iptparam->OilMoney);
						if(ICSTATE_OK == istate)	break;
					}

					if(ICSTATE_OK == istate)
					{
						apdu_len = (ibuffer[0]<<8)|(ibuffer[1]<<0);
						if(0==memcmp(&ibuffer[2+apdu_len-2], "\x90\x00", 2))
						{
							//解灰认证码4bytes
							memcpy(&iptparam->OilBill[IPT_OFFSET_GMAC], &ibuffer[2], 4);
							//PSAM灰锁签名4bytes，加油完成，PSAM计算GMAC后添加
							memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TAC], &ibuffer[6], 4);
						}
					}
				}

				//申请TTC
				for(i = 0; i < 3; i++)
				{
					istate = pcdApplyForTTC(iptparam->PhysicalNozzle, iptparam->OilBill, IPT_BILL_SIZE, &tmp_ttc);
					if(0 == istate)	break;

					usleep(100000);
				}
				if(0 == istate)
				{
					iptparam->OilBill[IPT_OFFSET_TTC + 0] = (char)(tmp_ttc>>24);	iptparam->OilBill[IPT_OFFSET_TTC + 1] = (char)(tmp_ttc>>16);
					iptparam->OilBill[IPT_OFFSET_TTC + 2] = (char)(tmp_ttc>>8);	iptparam->OilBill[IPT_OFFSET_TTC + 3] = (char)(tmp_ttc>>0);
				}

				//计算TMAC，计算失败时以默认TMAC填充
				for(i=0; i<3; i++)
				{
					//计算TMAC
					istate = iptTMACCalculate(iptparam, tmac_buffer, apdu_buffer, iptparam->OilBill, 95);
					if(0==istate)		break;

					usleep(100000);
				}
				if(0==istate)memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], tmac_buffer, 4);
				else				memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], IPT_TMAC_DEFUALT, 4);

				//完成状态
				iptparam->OilBill[IPT_OFFSET_ZD_STATE] = 0;
				//计算账单校验值
				iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);
				//保存到铁电中
				framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
				//保存备份
				framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

				//保存账单
				for(i = 0; i < 3; i++)
				{
					istate = pcdApplyForBillSave(iptparam->PhysicalNozzle, iptparam->OilBill, IPT_BILL_SIZE);
					if(0 == istate)	break;

					usleep(100000);
				}
			}
			else
			{
				//szb_fj_20171120:以卡余额为本次卡账单加油金额
				iptparam->OilMoney=balance;	
				iptparam->OilPrice=price;
				iptparam->JlStopNO=stop_no;
				state=jlAlgorithmRead(iptparam->JlNozzle,&suanfa);
				if(state!=0)
					suanfa=JL_ALGORITHM_45;
				if(suanfa!=JL_ALGORITHM_45)
				{
					if(((iptparam->OilMoney*100)%iptparam->OilPrice)>0)
						iptparam->OilVolume=iptparam->OilMoney*100/iptparam->OilPrice+1;
					else
						iptparam->OilVolume=iptparam->OilMoney*100/iptparam->OilPrice;
				}
				else if((iptparam->OilMoney*1000/iptparam->OilPrice%10)<JL_ROUNDING)
					iptparam->OilVolume=iptparam->OilMoney*100/iptparam->OilPrice;
				else	
					iptparam->OilVolume=iptparam->OilMoney*100/iptparam->OilPrice+1;

				//szb_fj_20171120:计算过冲金额及油量
				iptparam->MoneyUnself=money-iptparam->OilMoney;
				iptparam->VolumeUnself=volume-iptparam->OilVolume;
				//szb_fj_20171120:计算卡加油账单总累
				iptparam->SumMoney=money_sum-iptparam->MoneyUnself;	
				iptparam->SumVolume=volume_sum-iptparam->VolumeUnself;
				//szb_fj_20171120:计算过冲累计
				iptparam->MoneyUnselfSum+=iptparam->MoneyUnself;
				iptparam->VolumeUnselfSum+=iptparam->VolumeUnself;
				//szb_fj_20171120:过冲次数累加
				iptparam->OilOverTimes++;
				//szb_fj_20171120:存储过冲数据
				memset(bill_buffer, 0, 32);
				bill_buffer[0]=(char)(iptparam->MoneyUnself>>16);
				bill_buffer[1]=(char)(iptparam->MoneyUnself>>8);	
				bill_buffer[2]=(char)(iptparam->MoneyUnself>>0);
				bill_buffer[3]=(char)(iptparam->VolumeUnself>>16);	
				bill_buffer[4]=(char)(iptparam->VolumeUnself>>8);	
				bill_buffer[5]=(char)(iptparam->VolumeUnself>>0);
				bill_buffer[6]=stop_no;
				bill_buffer[7]=(char)(iptparam->MoneyUnselfSum>>16);	
				bill_buffer[8]=(char)(iptparam->MoneyUnselfSum>>8);
				bill_buffer[9]=(char)(iptparam->MoneyUnselfSum>>0);
				bill_buffer[10]=(char)(iptparam->VolumeUnselfSum>>16);	
				bill_buffer[11]=(char)(iptparam->VolumeUnselfSum>>8);
				bill_buffer[12]=(char)(iptparam->VolumeUnselfSum>>0);
				bill_buffer[13]=iptparam->OilOverTimes;
				crc_return=crc16Get(bill_buffer, 30);
				bill_buffer[30]=(char)(crc_return>>8);	bill_buffer[31]=(char)(crc_return>>0);
				framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_UNSELF, bill_buffer, 32);
				framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_UNSELF2, bill_buffer, 32);

				//szb_fj_20171120:主板直接掉电卡解扣
				if(1 == iptIsLianda(iptparam->Id))
				{
					framRead(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_LDPowerData, dsp_data, 4);
					IcDebitUnit=dsp_data[0];
					IcDiscountFlag=dsp_data[1];
					PriceDiscount=(dsp_data[2]<<8)|(dsp_data[3]<<0);

					//szb_fj_20171120:如果有单价折扣则计算折扣额
					if(0x01 == IcDiscountFlag)
					{
						pdiscount = iptDiscountCompute(iptparam->Id, volume, PriceDiscount);
					}

					iptparam->SumMoney=money_sum;
					iptparam->SumVolume=volume_sum;
					iptparam->OilMoney=money;	
					iptparam->OilVolume=volume;	
					iptparam->OilPrice=price;
					iptparam->JlStopNO=stop_no;
				}
				
				//szb_fj_20171120:获取账单数据
				framRead(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, 128);

				//szb_fj_20171120:保存加油数据，油量
				iptparam->OilBill[IPT_OFFSET_VOL+0]=(char)(iptparam->OilVolume>>16);
				iptparam->OilBill[IPT_OFFSET_VOL+1]=(char)(iptparam->OilVolume>>8);
				iptparam->OilBill[IPT_OFFSET_VOL+2]=(char)(iptparam->OilVolume>>0);
				//szb_fj_20171120:金额
				iptparam->OilBill[IPT_OFFSET_AMN+0]=(char)(iptparam->OilMoney>>16);
				iptparam->OilBill[IPT_OFFSET_AMN+1]=(char)(iptparam->OilMoney>>8);	
				iptparam->OilBill[IPT_OFFSET_AMN+2]=(char)(iptparam->OilMoney>>0);
				//szb_fj_20171120:单价
				iptparam->OilBill[IPT_OFFSET_PRC+0]=(char)(iptparam->OilPrice>>8);
				iptparam->OilBill[IPT_OFFSET_PRC+1]=(char)(iptparam->OilPrice>>0);
				//szb_fj_20171120:总累油量
				iptparam->OilBill[IPT_OFFSET_V_TOT+0]=(char)(iptparam->SumVolume>>24);	
				iptparam->OilBill[IPT_OFFSET_V_TOT+1]=(char)(iptparam->SumVolume>>16);
				iptparam->OilBill[IPT_OFFSET_V_TOT+2]=(char)(iptparam->SumVolume>>8);	
				iptparam->OilBill[IPT_OFFSET_V_TOT+3]=(char)(iptparam->SumVolume>>0);
				//szb_fj_20171120:停机代码
				iptparam->OilBill[IPT_OFFSET_STOPNO]=iptparam->JlStopNO;

				//szb_fj_20171120:主板直接掉电卡解扣
				if(1 == iptIsLianda(iptparam->Id))
				{
					if(1 ==IcDebitUnit)
					{
						OilMoneyDiscount = iptparam->OilVolume;
						//数额字段以升数替换
						iptparam->OilBill[IPT_OFFSET_AMN+0]=(char)(iptparam->OilVolume>>16);	
						iptparam->OilBill[IPT_OFFSET_AMN+1]=(char)(iptparam->OilVolume>>8);	
						iptparam->OilBill[IPT_OFFSET_AMN+2]=(char)(iptparam->OilVolume>>0);
					}
					else if(iptparam->OilMoney >= pdiscount)
					{
						OilMoneyDiscount = iptparam->OilMoney - pdiscount;
					}
					else
					{
						OilMoneyDiscount = iptparam->OilMoney;
					}
					//折扣后的金额              
					iptparam->OilBill[IPT_OFFSET_MONEY_DISCOUNT+0] = (char)(OilMoneyDiscount>>16);
					iptparam->OilBill[IPT_OFFSET_MONEY_DISCOUNT+1] = (char)(OilMoneyDiscount>>8);
					iptparam->OilBill[IPT_OFFSET_MONEY_DISCOUNT+2] = (char)(OilMoneyDiscount>>0);
					//
					//iptparam->OilBill[IPT_OFFSET_DISCOUNT+0] = (char)(iptparam->PriceDiscount>>8);
					//iptparam->OilBill[IPT_OFFSET_DISCOUNT+1] = (char)(iptparam->PriceDiscount>>0);
				}
				
				//szb_fj_20171120:复位PSAM
				for(i = 0; i < 2; i++)
				{
					istate=PsamReset(iptparam->DEVIC, iptparam->DEVPsam);
					if(ICSTATE_OK == istate)
						break;
				}

				//szb_fj_20171120:逃卡账单，计算GMAC
				if(0x01 == (iptparam->OilBill[IPT_OFFSET_T_TYPE] & 0x0F))
				{
					for(i = 0; i < 2; i++)
					{
						//选择应用1
						istate=PsamDFSelect(iptparam->DEVIC, iptparam->DEVPsam, ibuffer, 128, 1);
						//计算GMAC
						istate = PsamGMAC(iptparam->DEVIC, iptparam->DEVPsam, ibuffer, 128, &iptparam->OilBill[IPT_OFFSET_ASN + 2], &iptparam->OilBill[IPT_OFFSET_CTC], iptparam->OilMoney);
						if(ICSTATE_OK == istate)
							break;
					}

					if(ICSTATE_OK == istate)
					{
						apdu_len = (ibuffer[0]<<8)|(ibuffer[1]<<0);
						if(0==memcmp(&ibuffer[2+apdu_len-2], "\x90\x00", 2))
						{
							//解灰认证码4bytes
							memcpy(&iptparam->OilBill[IPT_OFFSET_GMAC], &ibuffer[2], 4);
							//PSAM灰锁签名4bytes,加油完成，PSAM计算GMAC后添加
							memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TAC], &ibuffer[6], 4);
						}
					}
				}

				//申请TTC
				for(i = 0; i < 3; i++)
				{
					istate = pcdApplyForTTC(iptparam->PhysicalNozzle, iptparam->OilBill, IPT_BILL_SIZE, &tmp_ttc);
					if(0 == istate)	break;

					//taskDelay(100*sysClkRateGet()/1000);
					usleep(100000);
				}
				if(0 == istate)
				{
					iptparam->OilBill[IPT_OFFSET_TTC + 0] = (char)(tmp_ttc>>24);	iptparam->OilBill[IPT_OFFSET_TTC + 1] = (char)(tmp_ttc>>16);
					iptparam->OilBill[IPT_OFFSET_TTC + 2] = (char)(tmp_ttc>>8);	iptparam->OilBill[IPT_OFFSET_TTC + 3] = (char)(tmp_ttc>>0);
				}

				//计算TMAC，计算失败时以默认TMAC填充
				for(i=0; i<3; i++)
				{
					//计算TMAC
					istate = iptTMACCalculate(iptparam, tmac_buffer, apdu_buffer, iptparam->OilBill, 95);
					if(0==istate)	
						break;
                    //taskDelay(100*sysClkRateGet()/1000);
                    usleep(100000);  
				}
				if(0==istate)
					memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], tmac_buffer, 4);
				else
					memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], IPT_TMAC_DEFUALT, 4);

				//完成状态
				iptparam->OilBill[IPT_OFFSET_ZD_STATE] = 0;
				//计算账单校验值
				iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);
				//保存到铁电中
				framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
				//保存备份
				framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

				//保存账单
				for(i = 0; i < 3; i++)
				{
					istate = pcdApplyForBillSave(iptparam->PhysicalNozzle, iptparam->OilBill, IPT_BILL_SIZE);
					if(0 == istate)	
						break;
					//taskDelay(100*sysClkRateGet()/1000);
					usleep(100000);
				}

		        //产生非卡加油账单，待填充：POS_TTC
				memcpy(&iptparam->OilBill[IPT_OFFSET_TTC], "\x00\x00\x00\x00", 4);

				//待填充：交易类型设为无卡错，后台/本地黑名单，扣款签名无效，非卡
				iptparam->OilBill[IPT_OFFSET_T_TYPE]=(0<<7)|(0<<6)|(0<<4)|(7<<0);

				//已完成：交易日期及时间
				iptparam->OilTime[0]=iptparam->Time.century;	iptparam->OilTime[1]=iptparam->Time.year;
				iptparam->OilTime[2]=iptparam->Time.month;		iptparam->OilTime[3]=iptparam->Time.date;
				iptparam->OilTime[4]=iptparam->Time.hour;		iptparam->OilTime[5]=iptparam->Time.minute;
				iptparam->OilTime[6]=iptparam->Time.second;
				memcpy(&iptparam->OilBill[IPT_OFFSET_TIME], iptparam->OilTime, 7);

				//已完成，卡应用号
				memcpy(&iptparam->OilBill[IPT_OFFSET_ASN], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 10);

				//待填充，余额（扣前），交易完成后填口后余额
				memcpy(&iptparam->OilBill[IPT_OFFSET_BALANCE], "\x00\x00\x00\x00", 4);

				//待填充：数额，交易完成后填实际数额
				memcpy(&iptparam->OilBill[IPT_OFFSET_AMN], "\x00\x00\x00", 3);

				//已完成，卡交易序号
				memcpy(&iptparam->OilBill[IPT_OFFSET_CTC], "\x00\x00", 2);

				//待填充，电子签名，加油/不扣/补充时未TAC，逃卡时位GTAC
				memcpy(&iptparam->OilBill[IPT_OFFSET_TAC], "\x00\x00\x00\x00", 4);

				//待填充，解灰认证码4bytes,加油完成，PSAM计算GMAC后添加
				memcpy(&iptparam->OilBill[IPT_OFFSET_GMAC], "\x00\x00\x00\x00", 4);

				//待填充：PSAM会所签名4bytes,加油完成，PSAM计算GMAC后添加
				memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TAC], "\x00\x00\x00\x00", 4);

				//已完成，PSAM应用序列号10bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_ASN], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 10);

				//已完成，PSAM编号6bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_TID], "\x00\x00\x00\x00\x00\x00", 6);
					
				//已完成，PSAM终端交易序号4bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TTC], "\x00\x00\x00\x00", 4);

				//已完成，扣款来源1byte
				iptparam->OilBill[IPT_OFFSET_DS]=0;
					
				//已完成，结算单位/方式1byte
				iptparam->OilBill[IPT_OFFSET_UNIT]=0;
					
				//已完成，卡类型1byte
				iptparam->OilBill[IPT_OFFSET_C_TYPE]=0;

				//已完成，卡版本1byte,b7~b4卡密钥索引号；b3~b0卡密钥版本号
				iptparam->OilBill[IPT_OFFSET_VER]=0;

				//已完成，枪号1byte
				iptparam->OilBill[IPT_OFFSET_NZN]=iptparam->LogicNozzle;
					
				//已完成，油品代码2bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_G_CODE], iptparam->OilCode, 2);

				//升数3bytes,交易完成后填实际升数
				dsp_buffer[0]=(char)(iptparam->VolumeUnself>>16);	
				dsp_buffer[1]=(char)(iptparam->VolumeUnself>>8);
				dsp_buffer[2]=(char)(iptparam->VolumeUnself>>0);
				memcpy(&iptparam->OilBill[IPT_OFFSET_VOL], dsp_buffer, 3);

				//已完成，成交价格2bytes,根据累计金额及油量计算
				money=iptparam->MoneyUnself;	
				volume=iptparam->VolumeUnself;	
				if((money*1000/volume%10)<IPT_ROUNDING)	
					self_sum_price=money*100/volume;
				else
					self_sum_price=money*100/volume+1;
				iptparam->OilBill[IPT_OFFSET_PRC+0]=(char)(self_sum_price>>8);
				iptparam->OilBill[IPT_OFFSET_PRC+1]=(char)(self_sum_price>>0);

				//已完成，员工号1byte
				iptparam->OilBill[IPT_OFFSET_EMP]=iptparam->EMP;

				//已完成，升累计4bytes
				jlSumRead(iptparam->JlNozzle, &volume_sum, &money_sum);
				iptparam->OilBill[IPT_OFFSET_V_TOT+0]=(char)(volume_sum>>24);
				iptparam->OilBill[IPT_OFFSET_V_TOT+1]=(char)(volume_sum>>16);
				iptparam->OilBill[IPT_OFFSET_V_TOT+2]=(char)(volume_sum>>8);
				iptparam->OilBill[IPT_OFFSET_V_TOT+3]=(char)(volume_sum>>0);

				//已完成，备用部分11bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_RFU], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 11);

				//待填充：T-MAC 4bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], "\x00\x00\x00\x00", 4);
							
				//已完成，物理抢号PhysicsGunId
				iptparam->OilBill[IPT_OFFSET_PHYGUN]=iptparam->PhysicalNozzle;

				//已完成，计量停机原因
				iptparam->OilBill[IPT_OFFSET_STOPNO]=0;

				//已完成：扣前余额
				memcpy(&iptparam->OilBill[IPT_OFFSET_BEFOR_BAL], iptparam->IcBalance, 4);

				//账单状态：0 = 正常 ，1 = 未完成
				iptparam->OilBill[IPT_OFFSET_ZD_STATE]=1;

				//计量设备ID
				iptparam->OilBill[IPT_OFFSET_JLNOZZLE]=iptparam->JlNozzle;

				//计算账单校验值
				iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

				//保存账单及备份
				framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
				framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

				//提请保存账单
				iptparam->OilBillSave=1;
				framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_BILL_FLAG,&iptparam->OilBillSave , 1);

				//清除上一次单次过冲数据，不清除累计过充数据
				memset(tmp_buffer, 0, 32);	iptparam->MoneyUnself=0;	iptparam->VolumeUnself=0;
				tmp_buffer[0]=(char)(iptparam->MoneyUnself>>16);
				tmp_buffer[1]=(char)(iptparam->MoneyUnself>>8);	tmp_buffer[2]=(char)(iptparam->MoneyUnself>>0);
				tmp_buffer[3]=(char)(iptparam->VolumeUnself>>16);
				tmp_buffer[4]=(char)(iptparam->VolumeUnself>>8);	tmp_buffer[5]=(char)(iptparam->VolumeUnself>>0);
				tmp_buffer[6]=0;
				tmp_buffer[7]=(char)(iptparam->MoneyUnselfSum>>16);	
				tmp_buffer[8]=(char)(iptparam->MoneyUnselfSum>>8);	tmp_buffer[9]=(char)(iptparam->MoneyUnselfSum>>0);
				tmp_buffer[10]=(char)(iptparam->VolumeUnselfSum>>16);	
				tmp_buffer[11]=(char)(iptparam->VolumeUnselfSum>>8);	tmp_buffer[12]=(char)(iptparam->VolumeUnselfSum>>0);
				tmp_buffer[13]=iptparam->OilOverTimes;
				data=crc16Get(tmp_buffer, 30);
				tmp_buffer[30]=(char)(data>>8);	tmp_buffer[31]=(char)(data>>0);
				framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_UNSELF, tmp_buffer, 32);
				framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_UNSELF2, tmp_buffer, 32);
			}

			if(IPT_MODE_BARCODE==iptparam->Mode && iptparam->BarOilBill[IPT_BAR_OFF_STATE]==1)//szb_fj_20171120:条码账单
			{
				//szb_fj_20171120:保存加油数据
				iptparam->SumMoney=money_sum;	
				iptparam->SumVolume=volume_sum;
				iptparam->OilMoney=money;	
				iptparam->OilVolume=volume;	
				iptparam->OilPrice=price;	
				iptparam->JlStopNO=stop_no;

				//3bytes加油金额
				iptparam->BarOilBill[IPT_BAR_OFF_MONEY+0]=(char)(iptparam->OilMoney>>16);
				iptparam->BarOilBill[IPT_BAR_OFF_MONEY+1]=(char)(iptparam->OilMoney>>8);
				iptparam->BarOilBill[IPT_BAR_OFF_MONEY+2]=(char)(iptparam->OilMoney>>0);
				//3bytes加油升数
				iptparam->BarOilBill[IPT_BAR_OFF_VOLUME+0]=(char)(iptparam->OilVolume>>16);
				iptparam->BarOilBill[IPT_BAR_OFF_VOLUME+1]=(char)(iptparam->OilVolume>>8);
				iptparam->BarOilBill[IPT_BAR_OFF_VOLUME+2]=(char)(iptparam->OilVolume>>0);
				//2bytes单价
				iptparam->BarOilBill[IPT_BAR_OFF_PRICE+0]=(char)(iptparam->OilPrice>>8);	
				iptparam->BarOilBill[IPT_BAR_OFF_PRICE+1]=(char)(iptparam->OilPrice>>0);
				//1byte异或校验
				iptparam->BarOilBill[IPT_BAR_OFF_CHECK]=xorGet(iptparam->BarOilBill, IPT_BAR_BILL_SIZE-1);
				//数据存储，写铁电
				framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_TM, iptparam->BarOilBill, IPT_BAR_BILL_SIZE);
				framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_TM2, iptparam->BarOilBill, IPT_BAR_BILL_SIZE);
				iptparam->BarBillUpload=1;
			}
		}
		else if(IPT_MODE_UNSELF==iptparam->Mode)//szb_fj_20171120:非卡机联动模式
		{
			if(iptparam->MoneyUnselfSum+money>=0xffffff ||iptparam->VolumeUnselfSum+volume>=0xffffff)
			{
				//szb_fj_20171120:产生非卡加油账单，待填充：POS_TTC
				memcpy(&iptparam->OilBill[IPT_OFFSET_TTC], "\x00\x00\x00\x00", 4);

				//szb_fj_20171120:待填充，交易类型设为无卡错，后台/本地黑名单，扣款签名无效，逃卡                                                                 
				iptparam->OilBill[IPT_OFFSET_T_TYPE]=(0<<7)|(0<<6)|(0<<4)|(7<<0);

				//szb_fj_20171120:已完成，交易日期及时间
				iptparam->OilTime[0]=iptparam->Time.century;	iptparam->OilTime[1]=iptparam->Time.year;
				iptparam->OilTime[2]=iptparam->Time.month;		iptparam->OilTime[3]=iptparam->Time.date;
				iptparam->OilTime[4]=iptparam->Time.hour;		iptparam->OilTime[5]=iptparam->Time.minute;
				iptparam->OilTime[6]=iptparam->Time.second;
				memcpy(&iptparam->OilBill[IPT_OFFSET_TIME], iptparam->OilTime, 7);

				//szb_fj_20171120:已完成：卡应用号
				memcpy(&iptparam->OilBill[IPT_OFFSET_ASN], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 10);

				//szb_fj_20171120:待填充，余额，扣前，交易完成后填口后余额
				memcpy(&iptparam->OilBill[IPT_OFFSET_BALANCE], "\x00\x00\x00\x00", 4);

				//szb_fj_20171120:待填充，数额，交易完成后填口后余额。
				memcpy(&iptparam->OilBill[IPT_OFFSET_AMN], "\x00\x00\x00", 3);

				//szb_fj_20171120:已完成,卡交易序号
				memcpy(&iptparam->OilBill[IPT_OFFSET_CTC], "\x00\x00", 2);

				//szb_fj_20171120:带填充，电子签名，加油/补扣/补充时未TAC，逃卡时为GTAC
				memcpy(&iptparam->OilBill[IPT_OFFSET_TAC], "\x00\x00\x00\x00", 4);

				//szb_fj_20171120:待填充，解灰认证码4bytes，加油完成，PSAM计算GMAC后添加
				memcpy(&iptparam->OilBill[IPT_OFFSET_GMAC], "\x00\x00\x00\x00", 4);

				//szb_fj_20171120:待填充，PSAM灰锁签名4bytes,加油完成，PSAM计算GMAC后添加
				memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TAC], "\x00\x00\x00\x00", 4);

				//szb_fj_20171120:PSAM应用序列号10bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_ASN], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 10);

				//szb_fj_20171120:已完成，PSAM编号6bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_TID], "\x00\x00\x00\x00\x00\x00", 6);
				
				//szb_fj_20171120:已完成，PSAM终端交易序号4bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TTC], "\x00\x00\x00\x00", 4);

				//szb_fj_20171120:已完成，扣款来源1byte
				iptparam->OilBill[IPT_OFFSET_DS]=0;
				
				//szb_fj_20171120:已完成，结算单位/方式1byte
				iptparam->OilBill[IPT_OFFSET_UNIT]=0;
				
				//szb_fj_20171120:已完成，卡类1byte
				iptparam->OilBill[IPT_OFFSET_C_TYPE]=0;

				//szb_fj_20171120:已完成，卡版本1byte,b7~b4卡密钥索引号，b3~b0,卡密钥版本号
				iptparam->OilBill[IPT_OFFSET_VER]=0;

				//szb_fj_20171120:已完成，枪号1byte
				iptparam->OilBill[IPT_OFFSET_NZN]=iptparam->LogicNozzle;
				
				//szb_fj_20171120:已完成,油品代码2bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_G_CODE], iptparam->OilCode, 2);

				//szb_fj_20171120:升数3bytes,交易完成后实际升数
				dsp_buffer[0]=(char)(iptparam->VolumeUnselfSum>>16);	
				dsp_buffer[1]=(char)(iptparam->VolumeUnselfSum>>8);
				dsp_buffer[2]=(char)(iptparam->VolumeUnselfSum>>0);
				memcpy(&iptparam->OilBill[IPT_OFFSET_VOL], dsp_buffer, 3);

				//szb_fj_20171120:已完成：成交价格2bytes,根据累计金额及油量计算
				if((iptparam->MoneyUnselfSum*1000/iptparam->VolumeUnselfSum%10)<IPT_ROUNDING)	
					self_sum_price=iptparam->MoneyUnselfSum*100/iptparam->VolumeUnselfSum;
				else																		
					self_sum_price=iptparam->MoneyUnselfSum*100/iptparam->VolumeUnselfSum+1;
				iptparam->OilBill[IPT_OFFSET_PRC+0]=(char)(self_sum_price>>8);
				iptparam->OilBill[IPT_OFFSET_PRC+1]=(char)(self_sum_price>>0);

				//szb_fj_20171120:已完成：员工号1byte
				iptparam->OilBill[IPT_OFFSET_EMP]=iptparam->EMP;

				//szb_fj_20171120:升累计4bytes,完成交易后填实际总累（当前总累-本次加油升数）
				iptparam->OilBill[IPT_OFFSET_V_TOT+0]=(char)((volume_sum-volume)>>24);
				iptparam->OilBill[IPT_OFFSET_V_TOT+1]=(char)((volume_sum-volume)>>16);
				iptparam->OilBill[IPT_OFFSET_V_TOT+2]=(char)((volume_sum-volume)>>8);	
				iptparam->OilBill[IPT_OFFSET_V_TOT+3]=(char)((volume_sum-volume)>>0);

				//szb_fj_20171120:已完成备用部分
				memcpy(&iptparam->OilBill[IPT_OFFSET_RFU], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 11);

				//szb_fj_20171120:待填充：T-MAC 
				memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], "\x00\x00\x00\x00", 4);
						
				//szb_fj_20171120:已完成，物理枪号PhysicsGunId
				iptparam->OilBill[IPT_OFFSET_PHYGUN]=iptparam->PhysicalNozzle;

				//szb_fj_20171120:已完成:计量停机原因
				iptparam->OilBill[IPT_OFFSET_STOPNO]=0;

				//szb_fj_20171120:已完成，扣前余额
				memcpy(&iptparam->OilBill[IPT_OFFSET_BEFOR_BAL], "\x00\x00\x00\x00", 4);

				//szb_fj_20171120:账单状态 0:正常 1:未完成
				iptparam->OilBill[IPT_OFFSET_ZD_STATE]=1;

				//szb_fj_20171120:计量设备ID
				iptparam->OilBill[IPT_OFFSET_JLNOZZLE]=iptparam->JlNozzle;

				//szb_fj_20171120:计算账单校验值
				iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

				//szb_fj_20171120:保存账单机备份
				istate=framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
				istate=framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

				//szb_fj_20171120:提请保存账单
				iptparam->OilBillSave=1;
				framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_BILL_FLAG,&iptparam->OilBillSave , 1);

				//szb_fj_20171120:清除非卡加油累计
				iptparam->MoneyUnselfSum=0;	
				iptparam->VolumeUnselfSum=0;
			}

			//szb_fj_20171120:本次非卡加油数据
			iptparam->SumMoney=money_sum;
			iptparam->SumVolume=volume_sum;
			iptparam->MoneyUnself=money;
			iptparam->VolumeUnself=volume;

			//szb_fj_20171120:非卡加油状态设置为空闲
			iptparam->OilStateUnself=0;

			//szb_fj_20171120:计算非卡累计数据
			iptparam->MoneyUnselfSum+=iptparam->MoneyUnself;	
			iptparam->VolumeUnselfSum+=iptparam->VolumeUnself;

			//szb_fj_20171120:保存数据
			memset(dsp_buffer, 0, 32);
			dsp_buffer[0]=(char)(iptparam->MoneyUnself>>16);
			dsp_buffer[1]=(char)(iptparam->MoneyUnself>>8);		dsp_buffer[2]=(char)(iptparam->MoneyUnself>>0);
			dsp_buffer[3]=(char)(iptparam->VolumeUnself>>16);
			dsp_buffer[4]=(char)(iptparam->VolumeUnself>>8);		dsp_buffer[5]=(char)(iptparam->VolumeUnself>>0);
			dsp_buffer[6]=iptparam->OilStateUnself;
			dsp_buffer[7]=(char)(iptparam->MoneyUnselfSum>>16);
			dsp_buffer[8]=(char)(iptparam->MoneyUnselfSum>>8);			dsp_buffer[9]=(char)(iptparam->MoneyUnselfSum>>0);
			dsp_buffer[10]=(char)(iptparam->VolumeUnselfSum>>16);
			dsp_buffer[11]=(char)(iptparam->VolumeUnselfSum>>8);		dsp_buffer[12]=(char)(iptparam->VolumeUnselfSum>>0);
			dsp_buffer[13]=iptparam->OilOverTimes;
			crc_return=crc16Get(dsp_buffer, 30);
			dsp_buffer[30]=(char)(crc_return>>8);	dsp_buffer[31]=(char)(crc_return>>0);
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_UNSELF, dsp_buffer, 32);
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_UNSELF2, dsp_buffer, 32);
			iptparam->OilState=IPT_OIL_IDLE;//szb_fj_20171120:加油状态结束
			iptparam->OilEndTimer = 0;
		}
	
		iptMainInterface(iptparam);//转入待机过程
		break;

	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptIcStandby
*Description		:IPT待机状态处理
*Input				:None
*Output			:None
*Return				:None
*History			:2014-10-20,modified by syj  */

static void iptStandby(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	//iptparam->Mode = 1;  //fj:20170926
	unsigned char dsp_buffer[64]={0}, dsp_len=0; 
	int voice[16]={0};
	unsigned int data=0;
	unsigned long long bcd_data=0;
	int switch_state=0, switch_state_chg=0, istate=0;

	iptparam->EtcOilFlg=0;     //szb_fj_20171120:add
	iptparam->etc_touming_flg=0;
	iptparam->etc_limit_car=0;

	//szb_fj_20171120:存在OBU需要释放
	if((iptparam->EtcFreeflag==1 || iptparam->EtcFreeflag==2) && iptparam->EtcFreeObuflg==0)
	{
		iptparam->EtcFreeObuflg=1;
		iptparam->EtcFreeObuCi=0;
	}

	//检测到油机掉电时提示信息并禁止其它操作，如有插卡则退卡
	istate = powerStateRead();
	//printf("istate = %d,IsSuspend = %d\n",istate,iptparam->IsSuspend);
	if(0!=istate && iptparam->PowerStateTimer>=2*1000)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "油机掉电禁止操作", strlen("油机掉电禁止操作"));
		iptparam->PowerStateTimer = 0;
	}
	if(0!=istate && 0x30==iptparam->IcState.DeckStateS1)
	{
		jljRunLog("油机掉电禁止插卡!\n");
		ICShoot(iptparam->DEVIC);
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "油机掉电禁止插卡", strlen("油机掉电禁止插卡"));
		IPT_DSP_WAIT();
	}
	if(0!=istate)
	{
		return;
	}

	//printf("PowerStateTimer \n");

	//判断油机是否暂停使用，不允许插卡
	if(1 == iptparam->IsSuspend)
	{
		if(0x30==iptparam->IcState.DeckStateS1)	ICShoot(iptparam->DEVIC);	

		if(iptparam->OilDspTimer >= 5*1000)
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "加油机暂停使用", strlen("加油机暂停使用"));
			iptparam->OilDspTimer = 0;
		}
		return;
	}

	//printf("iptparam->IsSuspend\n");

	//*****************时钟显示处理，无预置值且有变化时显示当前时间*****************
	if(iptparam->LastTime.century!=iptparam->Time.century||iptparam->LastTime.year!=iptparam->Time.year||iptparam->LastTime.month!=iptparam->Time.month||\
		iptparam->LastTime.date!=iptparam->Time.date||iptparam->LastTime.hour!=iptparam->Time.hour||iptparam->LastTime.minute!=iptparam->Time.minute||iptparam->LastTime.second!=iptparam->Time.second)
	{
		iptparam->LastTime.century=iptparam->Time.century;	iptparam->LastTime.year=iptparam->Time.year;	iptparam->LastTime.month=iptparam->Time.month;	iptparam->LastTime.date=iptparam->Time.date;
		iptparam->LastTime.hour=iptparam->Time.hour;	iptparam->LastTime.minute=iptparam->Time.minute;	iptparam->LastTime.second=iptparam->Time.second;

		dsp_buffer[0]=iptparam->Time.century;	dsp_buffer[1]=iptparam->Time.year;
		dsp_buffer[2]=iptparam->Time.month;	dsp_buffer[3]=iptparam->Time.date;
		dsp_buffer[4]=iptparam->Time.hour;		dsp_buffer[5]=iptparam->Time.minute;
		dsp_buffer[6]=iptparam->Time.second;
		dsp_buffer[7]=iptparam->PcOnline;			dsp_buffer[8]=iptparam->WorkState;
		dsp_buffer[9]=iptparam->Mode;
		dsp_len=10;
		if(IPT_MODE_IC==iptparam->Mode || IPT_MODE_BARCODE==iptparam->Mode)	
			dsp(iptparam->DEVDsp, DSP_CARD_STANDBY, dsp_buffer, dsp_len);
		else		
			dsp(iptparam->DEVDsp, DSP_UNSELF_STANDBY, dsp_buffer, dsp_len);
	}

	//printf("time -- iptparam->IsSuspend\n");

	//银行卡处理，2016.09.12
	if(KB_BUTTON_SET2 == iptparam->Button)
	{
		memcpy(iptparam->IcPassword, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 12);	
		iptparam->IcPasswordLen = 0;
		
		dsp(iptparam->DEVDsp, DSP_BANK_PIN_INPUT, "\x00", 1);

		iptPidSet(iptparam, IPT_PID_BANK_PIN_INPUT);
		return;
	}

	//printf("iptparam->Button, = %d,DeckStateS1 = %d\n",iptparam->Button,iptparam->IcState.DeckStateS1);

	//*****************插卡处理*****************
	if(0x30==iptparam->IcState.DeckStateS1)
	{
	    printf("---------mode = %d,IPT_BILLUNLOAD_MAX = %d\n",iptparam->Mode,iptparam->FuelUnloadNumber);

		//iptparam->FuelUnloadNumber = 10; //20171215

		//插入无法识别卡提示错误并退卡
		if(IC_CARD_CPU!=iptparam->IcState.IcTypeS2 && IC_CARD_RF_TYPEB!=iptparam->IcState.IcTypeS2 && IC_CARD_RF_TYPEA!=iptparam->IcState.IcTypeS2)
		{
			ICShoot(iptparam->DEVIC);	
		
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "无法识别卡", 10);
			IPT_DSP_WAIT();
			iptMainInterface(iptparam);
		}
		//非卡机联动模式，不允许插卡
		else if(IPT_MODE_UNSELF==iptparam->Mode)
		{
			ICShoot(iptparam->DEVIC);
		
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "非卡模式禁止插卡", 16);
			IPT_DSP_WAIT();
			iptMainInterface(iptparam);
		}
		//账单溢出，不允许插卡
		else if(iptparam->FuelUnloadNumber>=IPT_BILLUNLOAD_MAX)
		{
			ICShoot(iptparam->DEVIC);	
		
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "账单溢出", 8);
			IPT_DSP_WAIT();
			iptMainInterface(iptparam);
		}
		//提枪状态，不允许插卡
		else if(IPT_GUN_PUTUP == iptparam->GunState)
		{
			ICShoot(iptparam->DEVIC);	
		
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "请先挂枪", 8);
			IPT_DSP_WAIT();
			iptMainInterface(iptparam);
		}
		//卡机联动或条码自助模式转入卡预处理过程
		else if(IPT_MODE_IC==iptparam->Mode || IPT_MODE_BARCODE==iptparam->Mode)
		{
			//清除卡密码输入
			memcpy(iptparam->IcPassword, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 12);	iptparam->IcPasswordLen=0;

			iptparam->PayUnit=IPT_PAYUNIT_MONEY;		//IC卡应用默认为电子油票
			iptparam->DS=IPT_PAYUNIT_MONEY;				//扣款来源默认为石油卡电子油票
			iptparam->Payment=IPT_PAYMENT_MONEY;	//结算方式默认为现金
			iptparam->C_TYPE=IPT_CARDTYPE_SINO;		//卡类型默认为石化规范卡
			iptparam->PriceDiscount = 0;							//价格折扣额
			iptparam->UserElecFlag = 0;

			//主用户设置为本支付终端用户
			iptMainUserSet(iptparam->UserID);

			//促销机通知平板油机状态
			if(1 == paramPromotionGet())
			{
				iptparam->TaState = IPT_STATE_CARD_PRETREAT;	iptparam->TaStateParamLength = 0;
				pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
			}

			//szb_fj_20171120:显示并转入卡预处理过程
			if(iptparam->DEVDsp==0)
				kbDspContrastSet(DEV_DSP_KEYA, iptparam->Contrast);
			else
				kbDspContrastSet(DEV_DSP_KEYB, iptparam->Contrast);

			//显示并转入卡预处理过程
			dsp(iptparam->DEVDsp, DSP_CARD_PRETREAT, "\x00", 0);
			iptPidSet(iptparam, IPT_PID_IC_PRETREAT);
			printf("mode = %d\n",iptparam->Mode);
		}
	}

	//*****************卡机联动模式处理*****************
	if(IPT_MODE_IC==iptparam->Mode)
	{
		//未插卡直接抬枪，语音提示"请插入IC卡"
		if(	0x30!=iptparam->IcState.DeckStateS1 && iptparam->VoiceVolume>0 &&\
			IPT_GUN_PUTUP==iptparam->GunState && 0!=iptparam->GunStateChg)
		{
			if(IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType)	
				voice[0]=SPKW_ICCARDIN;	//女声
			else																				
				voice[0]=SPKM_ICCARDIN;	//男声
			iptSpk(iptparam, voice, 1);
		}
	}

	//*****************条码自助模式处理，上班状态有效*****************
	if(IPT_MODE_BARCODE==iptparam->Mode && IPT_WORK_ONDUTY==iptparam->WorkState)
	{
		//扫描油品选择按钮状态
		switch_state=kbSwitchRead(iptparam->BarcodeSwitch, &switch_state_chg);

		//有按油品选择按钮的操作，账单溢出时提示信息
		if(0==switch_state && 0!=switch_state_chg && iptparam->FuelUnloadNumber>=IPT_BILLUNLOAD_MAX)
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "账单溢出", 8);
			IPT_DSP_WAIT();
			iptMainInterface(iptparam);
		}
		//有按油品选择按钮的操作或按确认键，进行扫描前的相应操作
		else if((0==switch_state && 0!=switch_state_chg) || KB_BUTTON_ACK == iptparam->Button)
		{
			iptPidSet(iptparam, IPT_PID_TM_PRETREAT);
#if 0
			//社会站联达加油站不使用内置卡，否则油品选择按键选择后通过复位内置卡判断内置卡是否正常
			if(1 == iptIsLianda(iptparam->Id))	istate = 0;
			else 														istate = ICReset(iptparam->DEVIC, iptparam->DEVICInternal);

			//转入条码扫描过程语音提示"请扫描条码"，女声
			if(0==istate && iptparam->VoiceVolume>0 && IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType)
			{
				voice[0]=SPKW_CODESCAN;
				iptSpk(iptparam, voice, 1);
			}
			//转入条码扫描过程语音提示"请扫描条码"，男声
			else if(0==istate && iptparam->VoiceVolume>0 && IPT_VOICE_TYPE_MAN==iptparam->VoiceType)
			{
				voice[0]=SPKM_CODESCAN;	
				iptSpk(iptparam, voice, 1);
			}
			//内置卡异常，语音提示"出现故障，请通知工作人员"，女声
			else if(0!=istate && iptparam->VoiceVolume>0 && IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType)
			{
				voice[0]=SPKW_FAULT;
				iptSpk(iptparam, voice, 1);
			}
			//内置卡异常，语音提示"出现故障，请通知工作人员"，男声
			else if(0!=istate && iptparam->VoiceVolume>0 && IPT_VOICE_TYPE_MAN==iptparam->VoiceType)
			{
				voice[0]=SPKM_FAULT;
				iptSpk(iptparam, voice, 1);
			}

			//内置卡正常则开始扫描并转入条码扫描过程
			if(0==istate)
			{
				iptparam->NousedTimer = 0;
				barScan(iptparam->DEVBarcode, iptparam->BarUserID);

				//2016-06-22修改为直接进入即可扫描也可输入的界面
				dsp(iptparam->DEVDsp, DSP_TM_SCAN, "\x00", 0);
				iptPidSet(iptparam, IPT_PID_TM_BAR_SCAN);
				///2016-06-22修改为直接进入即可扫描也可输入的界面
				memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
				dsp_buffer[0]=iptparam->SetButtonLen;	memcpy(&dsp_buffer[0], iptparam->SetButton, iptparam->SetButtonLen);
				dsp_len=1+iptparam->SetButtonLen;
				dsp(iptparam->DEVDsp, DSP_TM_SCAN_AND_INPUT, dsp_buffer, dsp_len);
				iptPidSet(iptparam, IPT_PID_TM_SCAN);

				//促销机通知平板油机状态
				if(1 == paramPromotionGet())
				{
					iptparam->TaState = IPT_STATE_TM_SCAN;	iptparam->TaStateParamLength = 0;
					*(iptparam->TaStateParam + 0) = 0;	iptparam->TaStateParamLength = 1;
					pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
				}
			}
			//内置卡异常，键盘提示故障
			else
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "出现故障，请通知工作人员", 24);
				IPT_DSP_WAIT();
				iptMainInterface(iptparam);
			}
#endif
		}
		//直接抬枪，提示语音""请插入IC卡或选择油品后扫描条码
		else if(IPT_GUN_PUTUP==iptparam->GunState && 0!=iptparam->GunStateChg && iptparam->VoiceVolume>0)
		{
			if(IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType)	voice[0]=SPKW_ICORCODE;	//女声
			else																				voice[0]=SPKM_ICORCODE;	//男声
			iptSpk(iptparam, voice, 1);
		}
	}

	//printf("iptparam mode = %d\n",iptparam->Mode);
	//*****************非卡机联动模式处理*****************
	if(IPT_MODE_UNSELF==iptparam->Mode)
	{
		//按数字键及定升数/定金额键转入加油预置界面
		if(	KB_BUTTON_0==iptparam->Button || KB_BUTTON_1==iptparam->Button ||\
			KB_BUTTON_2==iptparam->Button || KB_BUTTON_3==iptparam->Button ||\
			KB_BUTTON_4==iptparam->Button || KB_BUTTON_5==iptparam->Button ||\
			KB_BUTTON_6==iptparam->Button || KB_BUTTON_7==iptparam->Button ||\
			KB_BUTTON_8==iptparam->Button || KB_BUTTON_9==iptparam->Button ||\
			KB_BUTTON_MON==iptparam->Button || KB_BUTTON_VOL==iptparam->Button)
		{
			iptparam->IntegerBuffer[0]=iptparam->IntegerBuffer[1];	iptparam->IntegerBuffer[1]=iptparam->IntegerBuffer[2];
			iptparam->IntegerBuffer[2]=iptparam->IntegerBuffer[3];	iptparam->IntegerBuffer[3]=iptparam->IntegerBuffer[4];
			iptparam->IntegerBuffer[4]=iptparam->IntegerBuffer[5];
			if(KB_BUTTON_0==iptparam->Button)			iptparam->IntegerBuffer[5]='0';
			else if(KB_BUTTON_1==iptparam->Button)	iptparam->IntegerBuffer[5]='1';
			else if(KB_BUTTON_2==iptparam->Button)	iptparam->IntegerBuffer[5]='2';
			else if(KB_BUTTON_3==iptparam->Button)	iptparam->IntegerBuffer[5]='3';
			else if(KB_BUTTON_4==iptparam->Button)	iptparam->IntegerBuffer[5]='4';
			else if(KB_BUTTON_5==iptparam->Button)	iptparam->IntegerBuffer[5]='5';
			else if(KB_BUTTON_6==iptparam->Button)	iptparam->IntegerBuffer[5]='6';
			else if(KB_BUTTON_7==iptparam->Button)	iptparam->IntegerBuffer[5]='7';
			else if(KB_BUTTON_8==iptparam->Button)	iptparam->IntegerBuffer[5]='8';
			else if(KB_BUTTON_9==iptparam->Button)	iptparam->IntegerBuffer[5]='9';

			//如果按定升数键则为定升数，按定金额或只是按数字键为定金额
			if(KB_BUTTON_VOL==iptparam->Button)	iptparam->PresetMode=IPT_PRESET_VOLUME;
			else																iptparam->PresetMode=IPT_PRESET_MONEY;

			//计算预置值
			data=(iptparam->IntegerBuffer[0]&0x0f)*10000000+(iptparam->IntegerBuffer[1]&0x0f)*1000000+\
				(iptparam->IntegerBuffer[2]&0x0f)*100000+(iptparam->IntegerBuffer[3]&0x0f)*10000+\
				(iptparam->IntegerBuffer[4]&0x0f)*1000+(iptparam->IntegerBuffer[5]&0x0f)*100+\
				(iptparam->DecimalBuffer[0]&0x0f)*10+(iptparam->DecimalBuffer[1]&0x0f)*1;
			
			//显示预置界面
			dsp_buffer[0]=(char)(data>>24);	dsp_buffer[1]=(char)(data>>16);	dsp_buffer[2]=(char)(data>>8);	dsp_buffer[3]=(char)(data>>0);
			if(IPT_PRESET_VOLUME==iptparam->PresetMode)	dsp_buffer[4]=1;
			else																			dsp_buffer[4]=0;
			dsp_len=5;
			dsp(iptparam->DEVDsp, DSP_UNSELF_PRESET, dsp_buffer, dsp_len);

			printf("dsp fuction ------\n");

			//转入非自助预置过程
			iptPidSet(iptparam, IPT_PID_UNSELF_PRESET);
			return;
		}

		//间隔3秒提枪直接加油，如果是260大流量则以向下键启动加油
		if(iptparam->OilEndTimer >= (3*1000) &&\
			((0 == iptIsBig260(iptparam->Id) && IPT_GUN_PUTUP == iptparam->GunState && 0 != iptparam->GunStateChg)||\
			(1 == iptIsBig260(iptparam->Id) && KB_BUTTON_DOWN == iptparam->Button)))
		{		
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "加油启动中...", 13);
			iptPidSet(iptparam, IPT_PID_UNSELF_CHECK);
			return;
		}
	}

	//*****************按"设置"键转入操作密码输入界面*****************
	if(KB_BUTTON_SET==iptparam->Button)
	{
		dsp(iptparam->DEVDsp, DSP_PASSWORD_INPUT, "\x00", 1);

		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_OPERATE_PASS);

		printf("fj:keyboard set opt\n");

		return;
	}

	//*****************按"退卡+1"键转入其它操作密码输入界面*****************
	if(KB_BUTTON_BACK1 == iptparam->Button || KB_BUTTON_SET1 == iptparam->Button)
	{
		bcd_data=hex2Bcd(iptparam->PassTimer);
		iptparam->PassRandom[0]=(char)((bcd_data>>20)&0x0f);	iptparam->PassRandom[1]=(char)((bcd_data>>16)&0x0f);	
		iptparam->PassRandom[2]=(char)((bcd_data>>12)&0x0f);	iptparam->PassRandom[3]=(char)((bcd_data>>8)&0x0f);	
		iptparam->PassRandom[4]=(char)((bcd_data>>4)&0x0f);		iptparam->PassRandom[5]=(char)((bcd_data>>0)&0x0f);
		dsp_buffer[0]=((iptparam->PassRandom[0]&0x0f)<<4)|((iptparam->PassRandom[1]&0x0f)<<0);
		dsp_buffer[1]=((iptparam->PassRandom[2]&0x0f)<<4)|((iptparam->PassRandom[3]&0x0f)<<0);
		dsp_buffer[2]=((iptparam->PassRandom[4]&0x0f)<<4)|((iptparam->PassRandom[5]&0x0f)<<0);
		dsp_buffer[3]=0;	dsp_len=4;
		dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE_PASSSIN, dsp_buffer, dsp_len);

		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_OTH_PASS);

	    printf("fj:keyboard return the card + 1 \n");

		return;
	}

	//*****************按"退卡"键退卡*****************
	if(KB_BUTTON_BACK == iptparam->Button)
	{
		ICShoot(iptparam->DEVIC);
        printf("fj:keyboard return the card\n");
	}
    //szb_fj_20171120:add
	if(KB_BUTTON_SEL == iptparam->Button && iptparam->etc_set_flg==ETC_FUN_OK && iptparam->EtcFreeObuflg==0 )
	{
		if(IPT_WORK_ONDUTY!=iptparam->WorkState)
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "加油机下班",strlen("加油机下班"));
			IPT_DSP_WAIT();
			iptMainInterface(iptparam);
			return;
		}
		if((IPT_MODE_IC!=iptparam->Mode) && (IPT_MODE_BARCODE!=iptparam->Mode))
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "请选择联网模式",strlen("请选择联网模式"));
			IPT_DSP_WAIT();
			iptMainInterface(iptparam);
			return;
		}
		if(IPT_GUN_PUTUP == iptparam->GunState)
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "请先挂枪", strlen("枪先挂枪"));
			IPT_DSP_WAIT();
			iptMainInterface(iptparam);
			return;
		}
		if(KB_KEYLOCK_SET==iptparam->KeyLock)
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "请把钥匙打到加油位置", strlen("请把钥匙打到加油位置"));
			IPT_DSP_WAIT();
			iptMainInterface(iptparam);
			return;
		}
		iptparam->EtcOilFlg=1;
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "正在读取车辆信息", strlen("正在读取车辆信息"));
		iptPidSet(iptparam, ETC_PID_CARINF_READ);
	}
#if _IPT_DEBUG_
	//调试时，按"设置+2"转入卡座测试处理
	if(KB_BUTTON_SET2==iptparam->Button){

		IcPollLimit(iptparam->DEVIC);
		dsp(iptparam->DEVDsp, DSP_CARD_TEST, "\x00", 0);	iptPidSet(iptparam, IPT_PID_DEBUG_CARD_TEST);
	}

	//调试时，按"设置+5"切换自动或非自动加油
	if(KB_BUTTON_SET5==iptparam->Button){

		if(1==IsOilAtuo){

			IsOilAtuo=0;
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "非自动加油", 10);
		}
		else{

			IsOilAtuo=1;
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, " 自动加油 ", 10);
		}
		IPT_DSP_WAIT();

		framWrite(FM_ADDR_IPT_SINO, IptParamA.FMAddrBase+IPT_FM_OIL_ATUO, &IsOilAtuo, 1);
	}

#endif

	return;
}


/*******************************************************************
*Name				:iptIcPretreat
*Description		:IC卡预处理过程
*Input				:None
*Output			:None
*Return				:None
*History			:2014-10-22,modified by syj  */

static void iptIcPretreat(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char buffer[128]={0};
	int istate=0, apdu_len=0;
	unsigned char dsp_buffer[64]={0};

	switch(iptparam->Step)
	{
	case 0:	
		//IC卡复位
		istate=ICReset(iptparam->DEVIC, 0);

		//printf("ic reset = %d\n",istate);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate)
		{
			iptparam->IcOverTimes=0;	
			iptparam->Step++;
		}
		//操作失败则提示错误信息
		else if(ICSTATE_FAILED==istate)
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡复位失败", 12);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退出
		else if(ICSTATE_OVERTIME==istate)
		{
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3)
			{
				iptparam->IcOverTimes=0;

				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡复位超时", 12);
				IPT_DSP_WAIT();
				
				ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else
		{
			iptparam->IcOverTimes=0;
		
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡复位错误", 12);
			IPT_DSP_WAIT();
			
			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
		break;

	case 1:	
		//IC卡MF文件选择
		istate=ICMFSelect(iptparam->DEVIC, 0, buffer, 128);

	    //printf("ic mf SLECTE = %d\n",istate);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate)
		{
			iptparam->IcOverTimes=0;	
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
			{
				iptparam->Step++;
			}
			else
			{
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=14;	memcpy(&dsp_buffer[3], "IC卡MF选择失败", 14);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				IPT_DSP_WAIT();
				
				ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
			}
		}
		//操作失败则提示信息后退卡
		else if(ICSTATE_FAILED==istate)
		{
			iptparam->IcOverTimes=0;
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡MF选择失败", 14);
			IPT_DSP_WAIT();
			
			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else if(ICSTATE_OVERTIME==istate)
		{
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3)
			{
				iptparam->IcOverTimes=0;
				
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡MF选择超时", 14);
				IPT_DSP_WAIT();
			
				ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else
		{
			iptparam->IcOverTimes=0;
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡MF选择错误", 14);
			IPT_DSP_WAIT();
			
			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
		break;

	case 2:
		//IC卡应用选择
		if(IPT_PAYUNIT_MONEY==iptparam->PayUnit)	
			istate=ICAppSelect(iptparam->DEVIC, 0, buffer, 128, 0);
		else	
			istate=ICAppSelect(iptparam->DEVIC, 0, buffer, 128, 1);

		//printf("ic app select = %d\n",istate);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate)
		{
			iptparam->IcOverTimes=0;
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
			{
				iptparam->Step++;
			}
			else
			{
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=16;	memcpy(&dsp_buffer[3], "IC卡应用选择失败", 16);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				IPT_DSP_WAIT();
				
				ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
			}
		}
		//操作失败则提示信息后退卡
		else if(ICSTATE_FAILED==istate)
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡应用选择失败", 16);
			IPT_DSP_WAIT();
			
			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else if(ICSTATE_OVERTIME==istate)
		{
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3)
			{
				iptparam->IcOverTimes=0;

				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡应用选择超时", 16);
				IPT_DSP_WAIT();
				
				ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡应用选择错误", 16);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
		break;

	case 3:	
		//IC卡21文件读取
		istate=ICFile21Read(iptparam->DEVIC, 0, buffer, 128);

	     //printf("ic read 21 = %d\n",istate);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate)
		{
			iptparam->IcOverTimes=0;	
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
			{
				//保存卡信息
				memcpy(iptparam->IcIssuerMark, &buffer[2], 8);		//发卡方标识	
				iptparam->IcAppMatk=buffer[10];								//应用类型标识					
				iptparam->IcAppVersion=buffer[11];							//应用版本	
				memcpy(iptparam->IcAppId, &buffer[12], 10);			//应用序列号
				memcpy(iptparam->IcEnableTime, &buffer[22], 4);		//应用启用日期
				memcpy(iptparam->IcInvalidTime, &buffer[26], 4);		//应用有效截止日期
				iptparam->IcCodeVersion=buffer[30];							//指令集版本			
				iptparam->IcFile21Unused=0;										//21文件备用区域

				//ACT卡转入PSAM预处理过程
				if(0x50==iptparam->IcAppId[2])
				{
					printf("case 3 pasm pretreat\n");
					iptPidSet(iptparam, IPT_PID_PSAM_PRETREAT);
				}
				//RID卡转入卡合法性检查过程，不要复位PSAM
				else if(0x51==iptparam->IcAppId[2])
				{
					printf("case 3 psam IC CHECK:\n");
					iptPidSet(iptparam, IPT_PID_IC_CHECK);
				}
				//非ACT或RID卡则继续下一步
				else
				{
					iptparam->Step++;
				}
			}
			else
			{
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=16;	memcpy(&dsp_buffer[3], "IC卡读21文件失败", 16);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				IPT_DSP_WAIT();
				
				ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
			}
		}
		//操作失败则提示信息后退卡
		else if(ICSTATE_FAILED==istate)
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡读21文件失败", 16);
			IPT_DSP_WAIT();
				
			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else if(ICSTATE_OVERTIME==istate)
		{
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3)
			{
				iptparam->IcOverTimes=0;
				
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡读21文件超时", 16);
				IPT_DSP_WAIT();
					
				ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else
		{
			iptparam->IcOverTimes=0;
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡读21文件错误", 16);
			IPT_DSP_WAIT();
				
			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
		break;

	case 4:	
		//IC卡22文件读取
		istate=ICFile22Read(iptparam->DEVIC, 0, buffer, 128);

	    //printf("ic read 22 = %d\n",istate);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate)
		{
			iptparam->IcOverTimes=0;	
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
			{
				//保存卡信息
				iptparam->IcTypeMark=buffer[2];								//卡类型标识
				iptparam->IcStaffMark = buffer[3];								//本系统职工标识
				memcpy(iptparam->IcUserName, &buffer[4], 20);		//持卡人姓名
				memcpy(iptparam->IcUserIdeId, &buffer[24], 18);		//持卡人证件(identity)号码(ASCII)
				iptparam->IcUserIdeType=buffer[42];							//持卡人证件类型
				
				iptparam->Step++;
			}
			else
			{
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=16;	memcpy(&dsp_buffer[3], "IC卡读22文件失败", 16);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				IPT_DSP_WAIT();
				
				ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
			}
		}
		//操作失败则提示信息后退卡
		else if(ICSTATE_FAILED==istate)
		{
			iptparam->IcOverTimes=0;
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡读22文件失败", 16);
			IPT_DSP_WAIT();
				
			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else if(ICSTATE_OVERTIME==istate)
		{
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3)
			{
				iptparam->IcOverTimes=0;
				
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡读22文件超时", 16);
				IPT_DSP_WAIT();
					
				ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else
		{
			iptparam->IcOverTimes=0;
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡读22文件错误", 16);
			IPT_DSP_WAIT();
				
			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
		break;

		
	case 5:	
		//IC卡27文件读取
		istate=ICFile27Read(iptparam->DEVIC, 0, buffer, 128);

	    //printf("ic read 27 = %d\n",istate);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate)
		{
			iptparam->IcOverTimes=0;	
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
			{
				//保存卡信息
				iptparam->IcDefaultPassword=buffer[2];							//是否采用默认密码,00=使用默认密码，01=使用用户密码
				iptparam->IcStaffId=buffer[3];										//员工号(内部卡有效)
				memcpy(iptparam->IcStaffPassword, &buffer[4], 2);		//员工密码(内部卡有效)
				iptparam->IcDebitUnit = buffer[6];									//扣款单位(00H=元；01H=升；社会站卡结构有此字段)
				iptparam->IcDiscountFlag = buffer[7];								//是否折扣卡(00H=非折扣卡；01H=折扣卡；社会站卡结构有此字段)
				iptparam->IcAppType = buffer[8];									//卡片应用类型(社会站卡结构有此字段)

				iptparam->Step++;
			}
			else
			{
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=16;	memcpy(&dsp_buffer[3], "IC卡读27文件失败", 16);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				IPT_DSP_WAIT();

				ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
			}
		}
		//操作失败则提示信息后退卡
		else if(ICSTATE_FAILED==istate)
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡读27文件失败", 16);
			IPT_DSP_WAIT();
					
			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else if(ICSTATE_OVERTIME==istate)
		{
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3)
			{
				iptparam->IcOverTimes=0;

				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡读27文件超时", 16);
				IPT_DSP_WAIT();
					
				ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else
		{
			iptparam->IcOverTimes=0;
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡读22文件错误", 16);
			IPT_DSP_WAIT();
					
			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
		break;

	case 6:	
		//IC卡28文件读取
		istate=ICFile28Read(iptparam->DEVIC, 0, buffer, 128);

	    //printf("ic read 28 = %d\n",istate);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate)
		{
			iptparam->IcOverTimes=0;
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
			{
				//保存卡信息
				memcpy(iptparam->IcOilLimit, &buffer[2], 2);					//油品限制
				iptparam->IcRegionTypeLimit=buffer[4];							//限地区,油站加油方式
				memcpy(iptparam->IcRegionLimit, &buffer[5], 40);			//限地区,油站加油
				memcpy(iptparam->IcVolumeLimit, &buffer[45], 2);		//限每次加油量
				iptparam->IcTimesLimit=buffer[47];								//限每天加油次数
				memcpy(iptparam->IcMoneyDayLimit, &buffer[48], 4);	//限每天加油金额
				memcpy(iptparam->IcCarIdLimit, &buffer[52], 16);			//车牌号限制(ASCII)
			
				printf("case 6: start psam pretreat :\n");
				iptPidSet(iptparam, IPT_PID_PSAM_PRETREAT);
			}
			else
			{
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=16;	memcpy(&dsp_buffer[3], "IC卡读28文件失败", 16);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				IPT_DSP_WAIT();

				ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
			}
		}
		//操作失败则提示信息后退卡
		else if(ICSTATE_FAILED==istate)
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡读28文件失败", 16);
			IPT_DSP_WAIT();
					
			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else if(ICSTATE_OVERTIME==istate)
		{
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3)
			{
				iptparam->IcOverTimes=0;

				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡读28文件超时", 16);
				IPT_DSP_WAIT();
						
				ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡读28文件错误", 16);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
		break;

	default:
		break;
	}

	//按退卡键退卡
	if(KB_BUTTON_BACK==iptparam->Button)
	{
		iptparam->IcOverTimes=0;
		ICShoot(iptparam->DEVIC);	
		iptMainInterface(iptparam);
		//printf("退卡建\n");
	}

    //printf("icpretreat,Step = %d\n",iptparam->Step);

	return;
}


/*******************************************************************
*Name				:iptIcPsamPretreat
*Description		:PSAM预处理过程
*Input				:None
*Output			:None
*Return				:None
*History			:2014-10-22,modified by syj  */

static void iptIcPsamPretreat(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char buffer[128]={0}, dsp_buffer[64]={0}, dsp_len=0;
	int istate=0, apdu_len=0;

	//printf("psam pretreat,Step = %d\n",iptparam->Step);

	switch(iptparam->Step)
	{
	case 0:	
		//复位PSAM
		istate=PsamReset(iptparam->DEVIC, iptparam->DEVPsam);
		//printf("psam reset, state = %d\n",istate);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate)
		{
			iptparam->IcOverTimes=0;	iptparam->Step++;
		}
		//操作失败则提示错误信息
		else if(ICSTATE_FAILED==istate)
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM复位失败", 12);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退出
		else if(ICSTATE_OVERTIME==istate)
		{
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3)
			{
				iptparam->IcOverTimes=0;

				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM复位超时", 12);
				IPT_DSP_WAIT();

				ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM复位错误", 12);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
		break;

	case 1:	
		//选择ＭＦ文件(PSE SLECTE)	
		istate=PsamMFSelect(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128);
		//printf("psam mf select, state = %d\n",istate);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate)
		{
			iptparam->IcOverTimes=0;	
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
			{
				iptparam->Step++;
			}
			else
			{
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=14;	memcpy(&dsp_buffer[3], "PSAM选择MF失败", 14);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				IPT_DSP_WAIT();

				ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
			}
		}
		//操作失败则提示信息后退卡
		else if(ICSTATE_FAILED==istate)
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM选择MF失败", 14);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else if(ICSTATE_OVERTIME==istate)
		{
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3)
			{
				iptparam->IcOverTimes=0;

				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM选择MF超时", 14);
				IPT_DSP_WAIT();

				ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM选择MF错误", 14);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
		break;

		
	case 2:	
		//读PSAM卡片公共信息21文件
		istate=PsamFile21Read(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128);
	    //printf("psam read 21, state = %d\n",istate);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate)
		{
			iptparam->IcOverTimes=0;	
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
			{
				//保存PSAM信息
				memcpy(iptparam->PsamId, &buffer[2], 10);		//PSAM序列号
				iptparam->PsamVersion=buffer[12];					//PSAM版本号
				iptparam->PsamKeyType=buffer[13];					//PSAM密钥卡类型
				iptparam->PsamCodeVersion=buffer[14];			//PSAM指令集版本
				iptparam->PsamFCI=buffer[15];							//PSAM发卡方自定义FCI数据

				iptparam->Step++;
			}
			else
			{
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=16;	memcpy(&dsp_buffer[3], "PSAM读21文件失败", 16);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				IPT_DSP_WAIT();

				ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
			}
		}
		//操作失败则提示信息后退卡
		else if(ICSTATE_FAILED==istate)
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM读21文件失败", 16);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else if(ICSTATE_OVERTIME==istate)
		{
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3)
			{
				iptparam->IcOverTimes=0;

				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM读21文件超时", 16);
				IPT_DSP_WAIT();

				ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM读21文件错误", 16);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
		break;

		
	case 3:	
		//读PSAM终端信息22文件
		istate=PsamFile22Read(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128);
	    //printf("psam read 22, state = %d\n",istate);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate)
		{
			iptparam->IcOverTimes=0;	
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
			{
				//保存PSAM信息
				memcpy(iptparam->PsamTermId, &buffer[2], 6);	//PSAM终端机编号	
				
				iptparam->Step++;
			}
			else
			{
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=16;	memcpy(&dsp_buffer[3], "PSAM读22文件失败", 16);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				IPT_DSP_WAIT();

				ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
			}
		}
		//操作失败则提示信息后退卡
		else if(ICSTATE_FAILED==istate)
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM读22文件失败", 16);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else if(ICSTATE_OVERTIME==istate)
		{
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3)
			{
				iptparam->IcOverTimes=0;

				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM读22文件超时", 16);
				IPT_DSP_WAIT();

				ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else
		{
			iptparam->IcOverTimes=0;
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM读22文件错误", 16);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
		break;

		
	case 4:	
		//选择DF中石化应用1
		istate=PsamDFSelect(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, 1);
	    //printf("psam df select, state = %d\n",istate);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate)
		{
			iptparam->IcOverTimes=0;	
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
			{
				iptparam->Step++;
			}
			else
			{	
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=15;	memcpy(&dsp_buffer[3], "PSAM选择DF1失败", 15);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				IPT_DSP_WAIT();

				ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
			}
		}
		//操作失败则提示信息后退卡
		else if(ICSTATE_FAILED==istate)
		{
			iptparam->IcOverTimes=0;
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM选择DF1失败", 15);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else if(ICSTATE_OVERTIME==istate)
		{
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3)
			{
				iptparam->IcOverTimes=0;
			
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM选择DF1超时", 15);
				IPT_DSP_WAIT();

				ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else
		{
			iptparam->IcOverTimes=0;
						
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM选择DF1错误", 15);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
		break;

	case 5:	
		//读PSAM应用公共信息23文件
		istate=PsamFile23Read(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128);
	    //printf("psam read 23, state = %d\n",istate);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate)
		{
			iptparam->IcOverTimes=0;	
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
			{
				//保存PSAM信息
				iptparam->PsamKeyIndex=buffer[2];										//PSAM消费密钥索引号
				memcpy(iptparam->PsamIssuerMark, &buffer[3], 8);				//PSAM应用发卡方标识
				memcpy(iptparam->PsamRecipientsMark, &buffer[11], 8);		//PSAM应用接收者标识
				memcpy(iptparam->PsamAppStartTime, &buffer[19], 4);			//PSAM应用启用日期
				memcpy(iptparam->PsamAppEndTime, &buffer[23], 4);			//PSAM应用有效截止日期

                //printf("--case 5: IPT_PID_IC_CHECK \n");
				//转入卡合法性检查过程
				iptPidSet(iptparam, IPT_PID_IC_CHECK);
			}
			else
			{
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=16;	memcpy(&dsp_buffer[3], "PSAM读23文件失败", 16);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				IPT_DSP_WAIT();

				ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
			}
		}
		//操作失败则提示信息后退卡
		else if(ICSTATE_FAILED==istate)
		{
			iptparam->IcOverTimes=0;
						
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM读23文件失败", 16);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else if(ICSTATE_OVERTIME==istate)
		{
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3)
			{
				iptparam->IcOverTimes=0;
						
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM读23文件超时", 16);
				IPT_DSP_WAIT();

				ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else
		{
			iptparam->IcOverTimes=0;
						
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM读23文件错误", 16);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
		break;
	default:
		break;
	}

	//按退卡键退卡
	if(KB_BUTTON_BACK==iptparam->Button)
	{
		iptparam->IcOverTimes=0;
		ICShoot(iptparam->DEVIC);	
		iptMainInterface(iptparam);
	}

	return;
}


/*******************************************************************
*Name				:iptIcCheck
*Description		:IC卡合法性检查过程
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcCheck(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	int i=0, is_oil_limit=0, is_area_limit=0;
	unsigned char oil_code[4]={0}, oil_code_limit[4]={0};
	unsigned char rtime[7]={0}, buffer[128]={0};
	unsigned char dsp_buffer[64]={0};
	unsigned int dsp_len=0;
	int voice[16]={0};

	//当前时间
	rtime[0]=iptparam->Time.century;	rtime[1]=iptparam->Time.year;	rtime[2]=iptparam->Time.month;
	rtime[3]=iptparam->Time.date;		rtime[4]=iptparam->Time.hour;	rtime[5]=iptparam->Time.minute;
	rtime[6]=iptparam->Time.second;

	//判断PSAM终端机编号合法性
	for(i=0; i<6; i++)
	{
		if((((iptparam->PsamTermId[i]>>4)&0x0f)>9)||(((iptparam->PsamTermId[i]>>0)&0x0f)>9)){
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM终端编号非法", 16);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
			return;
		}
	}

	//判断PSAM应用发行者标识合法性
	if((((iptparam->PsamIssuerMark[0]>>4)&0x0f)>9)||(((iptparam->PsamIssuerMark[0]>>0)&0x0f)>9)||(0!=memcmp(&iptparam->PsamIssuerMark[1], "\xff\xff\xff\xff\xff\xff\xff", 7))){

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM发行者标识错", 16);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		return;
	}

	//判断PSAM应用接收者标识合法性
	if((((iptparam->PsamRecipientsMark[0]>>4)&0x0f)>9)||(((iptparam->PsamRecipientsMark[0]>>0)&0x0f)>9)||(0!=memcmp(&iptparam->PsamRecipientsMark[1], "\xff\xff\xff\xff\xff\xff\xff", 7))){
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM接收者标识错", 16);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		return;
	}

	//判断PSAM启用日期合法性
	if(0!=timeVerification(iptparam->PsamAppStartTime, 4)){

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM启用日期非法", 16);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		return;
	}
	
	//判断PSAM截止日期合法性
	if(0!=timeVerification(iptparam->PsamAppEndTime, 4)){
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM截止日期非法", 16);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		return;
	}

	//判断PSAM启用日期是否达到
	if(memcmp(rtime, iptparam->PsamAppStartTime, 4)<0){
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM启用日期未到", 16);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		return;
	}

	//判断PSAM有效日期是否已过
	if(memcmp(rtime, iptparam->PsamAppEndTime, 4)>0){
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM失效", 8);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		return;
	}

	//判断PSAM序列号合法性
	for(i=0; i<10; i++)
	{
		if((((iptparam->PsamId[i]>>4)&0x0f)>9)||(((iptparam->PsamId[i]>>0)&0x0f)>9)){
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM序列号非法", 14);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
			return;
		}
	}

	//判断IC卡启用日期是否达到
	if(memcmp(rtime, iptparam->IcEnableTime, 4)<0){
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡启用日期未到", 16);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		return;
	}
	
	//判断IC卡有效日期是否已过
	if(memcmp(rtime, iptparam->IcInvalidTime, 4)>0){

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "失效卡", 6);
		IPT_DSP_WAIT();


		//IC加油数据保存卡错账单，过有效期卡
		//待填充:POS_TTC
		memcpy(&iptparam->OilBill[IPT_OFFSET_TTC], "\x00\x00\x00\x00", 4);
		
		//待填充:交易类型设为卡错，后台/本地黑白名单，扣款签名无效，卡错拒绝
		iptparam->OilBill[IPT_OFFSET_T_TYPE]=(1<<7)|((iptparam->BlistSrc&1)<<6)|(0<<4)|(9<<0);;

		//已完成:交易日期及时间
		iptparam->OilBill[IPT_OFFSET_TIME+0]=iptparam->Time.century;	
		iptparam->OilBill[IPT_OFFSET_TIME+1]=iptparam->Time.year;
		iptparam->OilBill[IPT_OFFSET_TIME+2]=iptparam->Time.month;
		iptparam->OilBill[IPT_OFFSET_TIME+3]=iptparam->Time.date;
		iptparam->OilBill[IPT_OFFSET_TIME+4]=iptparam->Time.hour;		
		iptparam->OilBill[IPT_OFFSET_TIME+5]=iptparam->Time.minute;
		iptparam->OilBill[IPT_OFFSET_TIME+6]=iptparam->Time.second;

		//已完成:卡应用号
		memcpy(&iptparam->OilBill[IPT_OFFSET_ASN], iptparam->IcAppId, 10);

		//已完成:余额(扣前)，交易完成后填扣后余额
		memcpy(&iptparam->OilBill[IPT_OFFSET_BALANCE], "\x00\x00\x00\x00", 4);

		//已完成:数额，交易完成后填实际数额		
		memcpy(&iptparam->OilBill[IPT_OFFSET_AMN], "\x00\x00\x00", 3);

		//已完成:卡交易序号
		memcpy(&iptparam->OilBill[IPT_OFFSET_CTC], "\x00\x00", 2);

		//已完成:电子签名，加油/补扣/补充时未TAC，逃卡时为GTAC
		memcpy(&iptparam->OilBill[IPT_OFFSET_TAC], "\x00\x02\x00\x00", 4);

		//已完成:解灰认证码4bytes，加油完成，PSAM计算GMAC后添加
		memcpy(&iptparam->OilBill[IPT_OFFSET_GMAC], "\x00\x00\x00\x00", 4);

		//已完成:PSAM会所签名4bytes，加油完成，PSAM计算GMAC后添加
		memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TAC], "\x00\x00\x00\x00", 4);
		
		//已完成:PSAM应用号10bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_ASN], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 10);

		//已完成:PSAM编号6bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_TID], "\x00\x00\x00\x00\x00\x00", 6);

		//已完成:PSAM终端交易序号4bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TTC], "\x00\x00\x00\x00", 4);
	
		//已完成:扣款来源1byte
		iptparam->OilBill[IPT_OFFSET_DS]=iptparam->DS;
		
		//已完成:结算单位/方式1byte
		iptparam->OilBill[IPT_OFFSET_UNIT]=((iptparam->Payment&0x3f)<<4)|(iptparam->PayUnit&0x03);

		//已完成:卡类1byte
		iptparam->OilBill[IPT_OFFSET_C_TYPE]=iptparam->C_TYPE;

		//已完成:卡版本1byte，b7~b4卡密钥索引号；b3~b0卡密钥版本号
		iptparam->OilBill[IPT_OFFSET_VER]=0;

		//已完成:枪号1byte
		iptparam->OilBill[IPT_OFFSET_NZN]=0;

		//已完成:油品代码2bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_G_CODE], "\x00\x00", 2);

		//已完成:升数3bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_VOL], "\x00\x00\x00", 3);

		//已完成:成交价格2bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_PRC], "\x00\x00", 2);

		//已完成:员工号1byte
		iptparam->OilBill[IPT_OFFSET_EMP]=iptparam->EMP;

		//已完成:升累计4bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_V_TOT], "\x00\x00\x00\x00", 4);
		
		//已完成:备用部分11bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_RFU], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 11);

		//待填充:T-MAC	4bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], "\x00\x00\x00\x00", 4);
		
		//已完成:物理枪号PhysicsGunId
		iptparam->OilBill[IPT_OFFSET_PHYGUN]=iptparam->PhysicalNozzle;
		
		//已完成:计量停机代码
		iptparam->OilBill[IPT_OFFSET_STOPNO]=0;

		//已完成:扣前余额
		memcpy(&iptparam->OilBill[IPT_OFFSET_BEFOR_BAL], "\x00\x00\x00\x00", 4);

		//账单状态0=正常；1=未完成
		iptparam->OilBill[IPT_OFFSET_ZD_STATE]=1;

		//计量设备ID
		iptparam->OilBill[IPT_OFFSET_JLNOZZLE]=iptparam->JlNozzle;

		//计算账单校验值
		iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

		//保存账单及备份
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

		//弹卡转入账单TTC获取过程
		ICShoot(iptparam->DEVIC);
		iptPidSet(iptparam, IPT_PID_IC_TTC_GET);
		return;
	}

	//判断RID卡是否为佳力佳卡
	buffer[0]=((iptparam->IcAppId[3]<<4)&0xf0)|((iptparam->IcAppId[4]>>4)&0x0f);
	buffer[1]=((iptparam->IcAppId[4]<<4)&0xf0)|((iptparam->IcAppId[5]>>4)&0x0f);
	if((0x51==iptparam->IcAppId[2])&&(0!=memcmp(buffer, IPT_COMPANY_ID, 2))){

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "非本厂RID卡", 11);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		return;
	}

	//判断ACT/RID卡，转入ACT认证过程，对于ACT卡只判断启用/截止日期即可
	if((0x50==iptparam->IcAppId[2])||(0x51==iptparam->IcAppId[2]))
	{
		//memcpy(iptparam->IcPassword, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 12);	iptparam->IcPasswordLen=0;

		dsp_buffer[0]=iptparam->IcPasswordLen;	dsp_len=1;
		dsp(iptparam->DEVDsp, DSP_CARD_PASSIN, dsp_buffer, dsp_len);
		iptPidSet(iptparam, IPT_PID_IC_PIN_INPUT);
		return;
	}

	//判断下班状态，非员工卡退卡
	if(IPT_WORK_OFFDUTY==iptparam->WorkState && 0x04!=iptparam->IcAppId[2])
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "加油机已下班", 12);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		return;
	}

	//判断IC卡发卡方标识合法性:第一字节为BCD，后七字节为全F
	if((((iptparam->IcIssuerMark[0]>>4)&0x0f)>9)||(((iptparam->IcIssuerMark[0]>>0)&0x0f)>9)||(0!=memcmp(&iptparam->IcIssuerMark[1], "\xff\xff\xff\xff\xff\xff\xff", 7)))
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡发卡方标识错", 16);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		return;
	}

	//判断IC卡应用类型标识合法性
	if(0x11!=iptparam->IcAppMatk)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC应用类型标识错", 16);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		return;
	}

	//判断IC卡应用版本合法性
	if(0x01!=iptparam->IcAppVersion)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡应用版本错", 14);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		return;
	}

	//判断IC卡指令集版本合法性
	if(0x01!=iptparam->IcCodeVersion)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡指令集版本错", 16);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		return;
	}

	//IC卡应用序列号相关判断
	//判断行业标识码，固定为1
	if(1!=(iptparam->IcAppId[0]&0x0f))
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡行业标识错", 14);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		return;
	}
	//判断卡类型，只支持用户卡，管理卡，员工卡，验泵卡，维修卡
	if(	ICTYPE_USER!=iptparam->IcAppId[2] && ICTYPE_MANAGE!=iptparam->IcAppId[2] &&\
		ICTYPE_STAFF!=iptparam->IcAppId[2] && ICTYPE_PUMP!=iptparam->IcAppId[2] &&\
		ICTYPE_SERVICE!=iptparam->IcAppId[2] && ICTYPE_PSAM!=iptparam->IcAppId[2])
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡应用类型错", 14);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		return;
	}
	//判断批次号，固定为1
	if(0x01!=((iptparam->IcAppId[3]>>4)&0x0f))
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡批次号错", 12);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		return;
	}
	//判断地区号，不能有字母
	if(((iptparam->IcAppId[3]>>0)&0x0f)>9 || ((iptparam->IcAppId[4]>>4)&0x0f)>9)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡地区号错", 12);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		return;
	}
	//判断保留位，不能有字母
	if(((iptparam->IcAppId[4]>>0)&0x0f)>9 || ((iptparam->IcAppId[5]>>4)&0x0f)>9)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡保留位错", 12);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		return;
	}
	//判断顺序号，不能有字母
	if(((iptparam->IcAppId[5]>>0)&0x0f)>9 ||\
		((iptparam->IcAppId[6]>>4)&0x0f)>9 || ((iptparam->IcAppId[6]>>0)&0x0f)>9 ||\
		((iptparam->IcAppId[7]>>4)&0x0f)>9 || ((iptparam->IcAppId[7]>>0)&0x0f)>9 ||\
		((iptparam->IcAppId[8]>>4)&0x0f)>9 || ((iptparam->IcAppId[8]>>0)&0x0f)>9 ||\
		((iptparam->IcAppId[9]>>4)&0x0f)>9 || ((iptparam->IcAppId[9]>>0)&0x0f)>9)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡应用顺序号错", 16);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		return;
	}

	//判断限油品加油，自高位起与油品代码一一进行判断
	oil_code[0]=(iptparam->OilCode[0]>>4)&0x0f;	oil_code[1]=(iptparam->OilCode[0]>>0)&0x0f;
	oil_code[2]=(iptparam->OilCode[1]>>4)&0x0f;	oil_code[3]=(iptparam->OilCode[1]>>0)&0x0f;
	oil_code_limit[0]=(iptparam->IcOilLimit[0]>>4)&0x0f;	oil_code_limit[1]=(iptparam->IcOilLimit[0]>>0)&0x0f;
	oil_code_limit[2]=(iptparam->IcOilLimit[1]>>4)&0x0f;	oil_code_limit[3]=(iptparam->IcOilLimit[1]>>0)&0x0f;
	if(0!=memcmp(iptparam->IcOilLimit, "\xff\xff", 2))
	{
		//2017-02-13增加大油品号限制比如限制汽油,szb_fj_20171120,update
		//if(iptparam->IptOilLimitStyleTag!=IPT_SET_OILLIMIT_ZSH)
	    if(iptparam->IptOilLimitStyleTag!=IPT_SET_OILLIMIT_0)
		{
			for(i=3;i>=0;i--)
			{
				if(oil_code_limit[i]==0)
					oil_code_limit[i]=0x0f;
				else
					break;
			}

			for(i=0; i<4; i++)
			{
				//限制不为F即认为此位有限制，与油品代码对应位不一致时不允许加油
				if(oil_code_limit[i]!=oil_code[i] && 0x0f!=oil_code_limit[i])
				{
					is_oil_limit=1;
					break;
				}
			}
		}
		else if(iptparam->IptOilLimitStyleTag==IPT_SET_OILLIMIT_F)
		{
			for(i=0; i<4; i++)
			{
				//限制不为F即认为此位有限制，与油品代码对应位不一致时不允许加油
				if(oil_code_limit[i]!=oil_code[i] && 0x0f!=oil_code_limit[i])
				{
					is_oil_limit=1;
					break;
				}
			}
		}
		else if(iptparam->IptOilLimitStyleTag==IPT_SET_OILLIMIT_0F)
		{
			for(i=3;i>=0;i--)
			{
				if(oil_code_limit[i]==0)
					oil_code_limit[i]=0x0f;
				else
					break;
			}
			for(i=0; i<4; i++)
			{
				//限制不为F即认为此位有限制，与油品代码对应位不一致时不允许加油
				if(oil_code_limit[i]!=oil_code[i] && 0x0f!=oil_code_limit[i])
				{
					is_oil_limit=1;
					break;
				}
			}
		}
	}

	if(0!=is_oil_limit)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "限油品卡", 8);
		IPT_DSP_WAIT();

		//IC加油数据保存卡错账单，限油品卡试图跨油品加油
		//待填充:POS_TTC
		memcpy(&iptparam->OilBill[IPT_OFFSET_TTC], "\x00\x00\x00\x00", 4);
		
		//待填充:交易类型设为卡错，后台/本地黑白名单，扣款签名有效，卡错拒绝
		iptparam->OilBill[IPT_OFFSET_T_TYPE]=(1<<7)|((iptparam->BlistSrc&1)<<6)|(0<<4)|(9<<0);;

		//已完成:交易日期及时间
		iptparam->OilBill[IPT_OFFSET_TIME+0]=iptparam->Time.century;	
		iptparam->OilBill[IPT_OFFSET_TIME+1]=iptparam->Time.year;
		iptparam->OilBill[IPT_OFFSET_TIME+2]=iptparam->Time.month;
		iptparam->OilBill[IPT_OFFSET_TIME+3]=iptparam->Time.date;
		iptparam->OilBill[IPT_OFFSET_TIME+4]=iptparam->Time.hour;		
		iptparam->OilBill[IPT_OFFSET_TIME+5]=iptparam->Time.minute;
		iptparam->OilBill[IPT_OFFSET_TIME+6]=iptparam->Time.second;

		//已完成:卡应用号
		memcpy(&iptparam->OilBill[IPT_OFFSET_ASN], iptparam->IcAppId, 10);

		//已完成:余额(扣前)，交易完成后填扣后余额
		memcpy(&iptparam->OilBill[IPT_OFFSET_BALANCE], "\x00\x00\x00\x00", 4);

		//已完成:数额，交易完成后填实际数额		
		memcpy(&iptparam->OilBill[IPT_OFFSET_AMN], "\x00\x00\x00", 3);

		//已完成:卡交易序号
		memcpy(&iptparam->OilBill[IPT_OFFSET_CTC], "\x00\x00", 2);

		//已完成:电子签名，加油/补扣/补充时未TAC，逃卡时为GTAC
		memcpy(&iptparam->OilBill[IPT_OFFSET_TAC], "\x10\x01\x00\x00", 4);

		//已完成:解灰认证码4bytes，加油完成，PSAM计算GMAC后添加
		memcpy(&iptparam->OilBill[IPT_OFFSET_GMAC], "\x00\x00\x00\x00", 4);

		//已完成:PSAM会所签名4bytes，加油完成，PSAM计算GMAC后添加
		memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TAC], "\x00\x00\x00\x00", 4);
		
		//已完成:PSAM应用号10bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_ASN], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 10);

		//已完成:PSAM编号6bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_TID], "\x00\x00\x00\x00\x00\x00", 6);

		//已完成:PSAM终端交易序号4bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TTC], "\x00\x00\x00\x00", 4);
	
		//已完成:扣款来源1byte
		iptparam->OilBill[IPT_OFFSET_DS]=iptparam->DS;
		
		//已完成:结算单位/方式1byte
		iptparam->OilBill[IPT_OFFSET_UNIT]=((iptparam->Payment&0x3f)<<4)|(iptparam->PayUnit&0x03);

		//已完成:卡类1byte
		iptparam->OilBill[IPT_OFFSET_C_TYPE]=iptparam->C_TYPE;

		//已完成:卡版本1byte，b7~b4卡密钥索引号；b3~b0卡密钥版本号
		iptparam->OilBill[IPT_OFFSET_VER]=0;

		//已完成:枪号1byte
		iptparam->OilBill[IPT_OFFSET_NZN]=0;
		
		//已完成:油品代码2bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_G_CODE], "\x00\x00", 2);

		//已完成:升数3bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_VOL], "\x00\x00\x00", 3);

		//已完成:成交价格2bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_PRC], "\x00\x00", 2);

		//已完成:员工号1byte
		iptparam->OilBill[IPT_OFFSET_EMP]=iptparam->EMP;

		//已完成:升累计4bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_V_TOT], "\x00\x00\x00\x00", 4);
		
		//已完成:备用部分11bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_RFU], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 11);

		//待填充:T-MAC	4bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], "\x00\x00\x00\x00", 4);
		
		//已完成:物理枪号PhysicsGunId
		iptparam->OilBill[IPT_OFFSET_PHYGUN]=iptparam->PhysicalNozzle;
		
		//已完成:计量停机代码
		iptparam->OilBill[IPT_OFFSET_STOPNO]=0;

		//已完成:扣前余额
		memcpy(&iptparam->OilBill[IPT_OFFSET_BEFOR_BAL], "\x00\x00\x00\x00", 4);

		//账单状态0=正常；1=未完成
		iptparam->OilBill[IPT_OFFSET_ZD_STATE]=1;

		//计量设备ID
		iptparam->OilBill[IPT_OFFSET_JLNOZZLE]=iptparam->JlNozzle;

		//计算账单校验值
		iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

		//保存账单及备份
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

		//转入账单TTC获取过程
		ICShoot(iptparam->DEVIC);
		iptPidSet(iptparam, IPT_PID_IC_TTC_GET);
		return;
	}

	//判断限地区、油站加油方式，限省加油，只有在限制与本地一致才可加油
	if(0x01==iptparam->IcRegionTypeLimit && IptPcInfo.SInfo.Province!=iptparam->IcRegionLimit[0]){

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "限省加油卡", 10);
		IPT_DSP_WAIT();
		is_area_limit=1;
	}
	else if(0x02==iptparam->IcRegionTypeLimit && (IptPcInfo.SInfo.Province!=iptparam->IcRegionLimit[0]||IptPcInfo.SInfo.City!=iptparam->IcRegionLimit[1])){
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "限地市加油卡", 12);
		IPT_DSP_WAIT();
		is_area_limit=1;
	}
	else if(0x03==iptparam->IcRegionTypeLimit && 0!=memcmp(IptPcInfo.SInfo.Superior, iptparam->IcRegionLimit, 4)){
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "限上级单位加油卡", 16);
		IPT_DSP_WAIT();
		is_area_limit=1;
	}
	else if( 0x04==iptparam->IcRegionTypeLimit &&\
				0!=memcmp(IptPcInfo.SInfo.S_ID, &iptparam->IcRegionLimit[0], 4)	&&\
				0!=memcmp(IptPcInfo.SInfo.S_ID, &iptparam->IcRegionLimit[4], 4)	&&\
				0!=memcmp(IptPcInfo.SInfo.S_ID, &iptparam->IcRegionLimit[8], 4)	&&\
				0!=memcmp(IptPcInfo.SInfo.S_ID, &iptparam->IcRegionLimit[12], 4)	&&\
				0!=memcmp(IptPcInfo.SInfo.S_ID, &iptparam->IcRegionLimit[16], 4)	&&\
				0!=memcmp(IptPcInfo.SInfo.S_ID, &iptparam->IcRegionLimit[20], 4)	&&\
				0!=memcmp(IptPcInfo.SInfo.S_ID, &iptparam->IcRegionLimit[24], 4)	&&\
				0!=memcmp(IptPcInfo.SInfo.S_ID, &iptparam->IcRegionLimit[28], 4)	&&\
				0!=memcmp(IptPcInfo.SInfo.S_ID, &iptparam->IcRegionLimit[32], 4)	&&\
				0!=memcmp(IptPcInfo.SInfo.S_ID, &iptparam->IcRegionLimit[36], 4)){
	
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "限油站加油卡", 12);
		IPT_DSP_WAIT();
		is_area_limit=1;
	}

	//IC加油数据保存卡错账单，限地区卡试图跨地区加油
	if(0!=is_area_limit){

		//待填充:POS_TTC
		memcpy(&iptparam->OilBill[IPT_OFFSET_TTC], "\x00\x00\x00\x00", 4);
		
		//待填充:交易类型设为卡错，后台/本地黑白名单，扣款签名有效，卡错拒绝
		iptparam->OilBill[IPT_OFFSET_T_TYPE]=(1<<7)|((iptparam->BlistSrc&1)<<6)|(0<<4)|(9<<0);;

		//已完成:交易日期及时间
		iptparam->OilBill[IPT_OFFSET_TIME+0]=iptparam->Time.century;	
		iptparam->OilBill[IPT_OFFSET_TIME+1]=iptparam->Time.year;
		iptparam->OilBill[IPT_OFFSET_TIME+2]=iptparam->Time.month;
		iptparam->OilBill[IPT_OFFSET_TIME+3]=iptparam->Time.date;
		iptparam->OilBill[IPT_OFFSET_TIME+4]=iptparam->Time.hour;		
		iptparam->OilBill[IPT_OFFSET_TIME+5]=iptparam->Time.minute;
		iptparam->OilBill[IPT_OFFSET_TIME+6]=iptparam->Time.second;

		//已完成:卡应用号
		memcpy(&iptparam->OilBill[IPT_OFFSET_ASN], iptparam->IcAppId, 10);

		//已完成:余额(扣前)，交易完成后填扣后余额
		memcpy(&iptparam->OilBill[IPT_OFFSET_BALANCE], "\x00\x00\x00\x00", 4);

		//已完成:数额，交易完成后填实际数额		
		memcpy(&iptparam->OilBill[IPT_OFFSET_AMN], "\x00\x00\x00", 3);

		//已完成:卡交易序号
		memcpy(&iptparam->OilBill[IPT_OFFSET_CTC], "\x00\x00", 2);

		//已完成:电子签名，加油/补扣/补充时未TAC，逃卡时为GTAC
		memcpy(&iptparam->OilBill[IPT_OFFSET_TAC], "\x10\x02\x00\x00", 4);

		//已完成:解灰认证码4bytes，加油完成，PSAM计算GMAC后添加
		memcpy(&iptparam->OilBill[IPT_OFFSET_GMAC], "\x00\x00\x00\x00", 4);

		//已完成:PSAM会所签名4bytes，加油完成，PSAM计算GMAC后添加
		memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TAC], "\x00\x00\x00\x00", 4);
		
		//已完成:PSAM应用号10bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_ASN], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 10);

		//已完成:PSAM编号6bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_TID], "\x00\x00\x00\x00\x00\x00", 6);

		//已完成:PSAM终端交易序号4bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TTC], "\x00\x00\x00\x00", 4);

		//已完成:扣款来源1byte
		iptparam->OilBill[IPT_OFFSET_DS]=iptparam->DS;

		//已完成:结算单位/方式1byte
		iptparam->OilBill[IPT_OFFSET_UNIT]=((iptparam->Payment&0x3f)<<4)|(iptparam->PayUnit&0x03);

		//已完成:卡类1byte
		iptparam->OilBill[IPT_OFFSET_C_TYPE]=iptparam->C_TYPE;

		//已完成:卡版本1byte，b7~b4卡密钥索引号；b3~b0卡密钥版本号
		iptparam->OilBill[IPT_OFFSET_VER]=0;

		//已完成:枪号1byte
		iptparam->OilBill[IPT_OFFSET_NZN]=0;
		
		//已完成:油品代码2bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_G_CODE], "\x00\x00", 2);

		//已完成:升数3bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_VOL], "\x00\x00\x00", 3);

		//已完成:成交价格2bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_PRC], "\x00\x00", 2);

		//已完成:员工号1byte
		iptparam->OilBill[IPT_OFFSET_EMP]=iptparam->EMP;

		//已完成:升累计4bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_V_TOT], "\x00\x00\x00\x00", 4);
		
		//已完成:备用部分11bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_RFU], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 11);

		//待填充:T-MAC	4bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], "\x00\x00\x00\x00", 4);
		
		//已完成:物理枪号PhysicsGunId
		iptparam->OilBill[IPT_OFFSET_PHYGUN]=iptparam->PhysicalNozzle;
		
		//已完成:计量停机代码
		iptparam->OilBill[IPT_OFFSET_STOPNO]=0;

		//已完成:扣前余额
		memcpy(&iptparam->OilBill[IPT_OFFSET_BEFOR_BAL], "\x00\x00\x00\x00", 4);

		//账单状态0=正常；1=未完成
		iptparam->OilBill[IPT_OFFSET_ZD_STATE]=1;

		//计量设备ID
		iptparam->OilBill[IPT_OFFSET_JLNOZZLE]=iptparam->JlNozzle;

		//计算账单校验值
		iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

		//保存账单及备份
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

		//转入账单TTC获取过程
		ICShoot(iptparam->DEVIC);
		iptPidSet(iptparam, IPT_PID_IC_TTC_GET);
		return;
	}

	//判断密码类型
	if(0!=iptparam->IcDefaultPassword && 1!=iptparam->IcDefaultPassword)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡密码类型错", 14);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		return;
	}

	if(iptparam->etc_touming_flg==1) //szb_fj_20171120:add
	{
		EtcCardCarHandle(iptparam->Id);
		return;
	}

	//选择积分应用则直接以已保存的密码进行验证
	if(IPT_PAYUNIT_LOYALTY==iptparam->PayUnit)
	{
        if(iptparam->EtcOilFlg==1)//szb_fj_20171120:ETC加油选择积分
		{
			if((0==iptparam->IcDefaultPassword) && ((iptparam->EtcSelCardInf[22]&0x10)==0x10))
			{
				memcpy(iptparam->IcPassword, "\x39\x39\x39\x39", 4);	iptparam->IcPasswordLen=4;
				iptPidSet(iptparam, IPT_PID_IC_PIN_CHECK);
			}
			else if((0==iptparam->IcDefaultPassword) && ((iptparam->EtcSelCardInf[22]&0x10)==0))
			{
				iptPidSet(iptparam,ETC_PID_PIN_CHECK);
			}
			else if((0!=iptparam->IcDefaultPassword) && ((iptparam->EtcSelCardInf[22]&0x10)==0x10))
			{				
				iptPidSet(iptparam, IPT_PID_IC_PIN_CHECK);
			}
			else if((0!=iptparam->IcDefaultPassword) && ((iptparam->EtcSelCardInf[22]&0x10)==0))
			{
				iptPidSet(iptparam,ETC_PID_PIN_CHECK);
			}
		}
		else
		{
		    iptPidSet(iptparam, IPT_PID_IC_PIN_CHECK);
		}
		return;
	}

#if 0//2017-01-22加油中逃卡无法解扣
	//联达加油系统申请本次加油信息申请过程
	if(MODEL_LIANDA == paramModelGet())
	{
		iptPidSet(iptparam, IPT_PID_IC_DISCOUNT_ASK);
		return;
	}
#endif

	//合法转入密码输入界面0=使用默认密码(默认密码9999)；1=使用用户密码
	if(0==iptparam->IcDefaultPassword)
	{
		//szb_fj_20171120:update
     	if((iptparam->EtcOilFlg!=0) && ((iptparam->EtcSelCardInf[22]&0x10)==0x10))
		{
			memcpy(iptparam->IcPassword, "\x39\x39\x39\x39", 4);	iptparam->IcPasswordLen=4;
			iptPidSet(iptparam, IPT_PID_IC_PIN_CHECK);
		}
		else if((iptparam->EtcOilFlg!=0) && ((iptparam->EtcSelCardInf[22]&0x10)==0))
		{
			iptPidSet(iptparam,ETC_PID_PIN_CHECK);
		}
		else if(iptparam->EtcOilFlg==0)
		{
			memcpy(iptparam->IcPassword, "\x39\x39\x39\x39", 4);	iptparam->IcPasswordLen=4;
			iptPidSet(iptparam,IPT_PID_IC_PIN_CHECK);
		}

	    printf("ic check,IPT_PID_IC_PIN_CHECK\n");
	}
	else
	{
		memcpy(iptparam->IcPassword, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 12);	iptparam->IcPasswordLen=0;
		dsp_buffer[0]=iptparam->IcPasswordLen;
		dsp_len=1;
     
		//szb_fj_20171120,update
		if((iptparam->EtcOilFlg!=0) && ((iptparam->EtcSelCardInf[22]&0x10)==0x10))
		{
			dsp(iptparam->DEVDsp, DSP_CARD_PASSIN, dsp_buffer, dsp_len);
			iptPidSet(iptparam,IPT_PID_IC_PIN_INPUT);
			//szb_fj_20171120,播放语音“请输入卡密码”
			if(iptparam->VoiceVolume>0)
			{
				if(IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType)
					voice[0]=SPKW_PASSIN;	//女声
				else	
					voice[0]=SPKM_PASSIN;	//男声
				iptSpk(iptparam, voice, 1);
			}

			//szb_fj_20171120:促销机通知平板电脑输入卡密码
			if(1 == paramPromotionGet())
			{
				iptparam->TaState = IPT_STATE_CARD_PASSIN;	iptparam->TaStateParamLength = 0;
				*(iptparam->TaStateParam + 0) = iptparam->IcPasswordLen;	
				iptparam->TaStateParamLength = 1;
				pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
			}
			
		}
		else if((iptparam->EtcOilFlg!=0) && ((iptparam->EtcSelCardInf[22]&0x10)==0))
		{
			iptPidSet(iptparam,ETC_PID_PIN_CHECK);
		}
		else if(iptparam->EtcOilFlg==0)
		{
			dsp(iptparam->DEVDsp, DSP_CARD_PASSIN, dsp_buffer, dsp_len);
			iptPidSet(iptparam,IPT_PID_IC_PIN_INPUT);
			//szb_fj_20171120:播放语音“请输入卡密码”
			if(iptparam->VoiceVolume>0)
			{
				if(IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType)
					voice[0]=SPKW_PASSIN;	//女声
				else	
					voice[0]=SPKM_PASSIN;	//男声
				iptSpk(iptparam, voice, 1);
			}
			//促销机通知平板电脑输入卡密码
			if(1 == paramPromotionGet())
			{
				iptparam->TaState = IPT_STATE_CARD_PASSIN;	iptparam->TaStateParamLength = 0;
				*(iptparam->TaStateParam + 0) = iptparam->IcPasswordLen;	
				iptparam->TaStateParamLength = 1;
				pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
			}
		}
	    printf("ic check,IPT_PID_IC_PIN_INPUT\n");
	}


	//printf("ic check,return\n");

	return;
}


/*******************************************************************
*Name				:iptIcDiscountAsk
*Description		:向后台申请折扣额
*Input				:None
*Output			:None
*Return				:None
*History			:2016-03-31,modified by syj  */

static void iptIcDiscountAsk(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	char tx_buffer[128]={0};
	int tx_len=0, i=0, pprice = 0;
	int ihandle = 0;

	char dsp_buffer[64] = {0};
	int dsp_len = 0;

	int voice[16] = {0};


	//向后台申请本次加油数据，申请成功后开始加油，申请失败时提示客户失败，经客户人工确认后可继续以非折扣价格加油
	if(IPT_2PCD_UNUSED==iptparam->PcdTxFlag)
	{
		tx_buffer[0]=++iptparam->PcdTxFrame;
		tx_buffer[1]=pcdMboardIDRead();
		tx_buffer[2]=iptparam->Id;
		tx_buffer[3]=iptparam->PhysicalNozzle;
		tx_buffer[4]=IPT_CMD_DISCOUNT_ASK;
		tx_buffer[5]=iptparam->LogicNozzle;
		memcpy(tx_buffer+6, iptparam->IcAppId, 10);
		tx_len=16;
		//msgQSend((MSG_Q_ID)pcdMsgIdRead(), tx_buffer, tx_len, NO_WAIT, MSG_PRI_NORMAL);

		struct msg_struct msg_stIptSend;  //fj:20170918
		msg_stIptSend.msgType = 1;
		memcpy(msg_stIptSend.msgBuffer,tx_buffer,tx_len);
		msgsnd(pcdMsgIdRead(),&msg_stIptSend,tx_len,IPC_NOWAIT);

		iptparam->PcdTxFlag=IPT_2PCD_OILPROCESS;	iptparam->PcdTxTimer=0;
	}
	//接收到正确的返回后判断折扣是否合法，非法则提示错误并禁止加油
	else if(IPT_2PCD_OILPROCESS==iptparam->PcdTxFlag && msg_len>0 && IPT_CMD_DISCOUNT_ASK==msg_buffer[4] &&\
		iptparam->LogicNozzle==msg_buffer[5] && 0==memcmp(&msg_buffer[6], iptparam->IcAppId, 10))
	{
		if(0x01 == iptparam->IcDiscountFlag)
		{
			iptparam->PriceDiscount = (msg_buffer[16]<<8)|(msg_buffer[17]<<0);
		}
		else
		{
			iptparam->PriceDiscount = 0;
		}
		iptparam->InvoiceType = msg_buffer[18];
		memcpy(iptparam->StationName, &msg_buffer[19], 30);
		memcpy(iptparam->OilName, &msg_buffer[49], 16);

		jljRunLog("申请加油数据成功[折扣额=%d]!\n", iptparam->PriceDiscount);

		ihandle = 1;

		iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdOverTimes=0;
	}
	//申请折扣超时超过3次，提示失败并转入用户操作过程
	else if(IPT_2PCD_OILPROCESS==iptparam->PcdTxFlag && iptparam->PcdTxTimer>=(5*ONE_SECOND))
	{
		iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdOverTimes++;
		if(iptparam->PcdOverTimes>=3)
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "申请加油数据失败", 16);
			ICShoot(iptparam->DEVIC);
			IPT_DSP_WAIT();
			iptMainInterface(iptparam);
		
			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdOverTimes=0;
		}
	}


	//申请折扣价格操作完毕
	if(1 == ihandle)
	{
		//合法转入密码输入界面0=使用默认密码(默认密码9999)；1=使用用户密码
		if(0 == iptparam->IcDefaultPassword)
		{
			memcpy(iptparam->IcPassword, "\x39\x39\x39\x39", 4);	iptparam->IcPasswordLen=4;
			iptPidSet(iptparam, IPT_PID_IC_PIN_CHECK);
		}
		else
		{
			memcpy(iptparam->IcPassword, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 12);	iptparam->IcPasswordLen=0;
			iptPidSet(iptparam, IPT_PID_IC_PIN_INPUT);

			dsp_buffer[0]=iptparam->IcPasswordLen;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_CARD_PASSIN, dsp_buffer, dsp_len);

			//播放语音"请输入卡密码"
			if(iptparam->VoiceVolume>0)
			{
				if(IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType)	voice[0]=SPKW_PASSIN;	//女声
				else																					voice[0]=SPKM_PASSIN;	//男声
				iptSpk(iptparam, voice, 1);
			}

			//促销机通知平板油机状态
			if(1 == paramPromotionGet())
			{
				iptparam->TaState = IPT_STATE_CARD_PASSIN;	iptparam->TaStateParamLength = 0;
				*(iptparam->TaStateParam + 0) = iptparam->IcPasswordLen;
				iptparam->TaStateParamLength = 1;
				pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
			}
		}
	}
	
	return;
}


/*******************************************************************
*Name				:iptIcPinInput
*Description		:IC卡密码输入过程
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcPinInput(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char dsp_buffer[64]={0}, dsp_len=0, button=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0==button)	button='0';
	case KB_BUTTON_1:
		if(0==button)	button='1';
	case KB_BUTTON_2:
		if(0==button)	button='2';
	case KB_BUTTON_3:
		if(0==button)	button='3';
	case KB_BUTTON_4:
		if(0==button)	button='4';
	case KB_BUTTON_5:
		if(0==button)	button='5';
	case KB_BUTTON_6:
		if(0==button)	button='6';
	case KB_BUTTON_7:
		if(0==button)	button='7';
	case KB_BUTTON_8:
		if(0==button)	button='8';
	case KB_BUTTON_9:
		if(0==button)	button='9';

		//记录输入的密码
		if(iptparam->IcPasswordLen<12)
		{
			iptparam->IcPassword[iptparam->IcPasswordLen++]=button;

			dsp_buffer[0]=iptparam->IcPasswordLen;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_CARD_PASSIN, dsp_buffer, dsp_len);
		}

		//促销机通知平板油机状态
		if(1 == paramPromotionGet())
		{
			iptparam->TaState = IPT_STATE_CARD_PASSIN;	iptparam->TaStateParamLength = 0;
			*(iptparam->TaStateParam + 0) = iptparam->IcPasswordLen;
			iptparam->TaStateParamLength = 1;
			pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
		}
		break;

	case KB_BUTTON_CHG:
		//清除输入的密码，
		memcpy(iptparam->IcPassword, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 12);	iptparam->IcPasswordLen=0;

		dsp_buffer[0]=iptparam->IcPasswordLen;	dsp_len=1;
		dsp(iptparam->DEVDsp, DSP_CARD_PASSIN, dsp_buffer, dsp_len);

		//促销机通知平板油机状态
		if(1 == paramPromotionGet())
		{
			iptparam->TaState = IPT_STATE_CARD_PASSIN;	iptparam->TaStateParamLength = 0;
			*(iptparam->TaStateParam + 0) = iptparam->IcPasswordLen;
			iptparam->TaStateParamLength = 1;
			pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
		}
		break;

	case KB_BUTTON_ACK:
		//判断密码位数4~12位
		if(iptparam->IcPasswordLen<4 || iptparam->IcPasswordLen>12)
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "密码位数错", 10);
			IPT_DSP_WAIT();

			memcpy(iptparam->IcPassword, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 12);	iptparam->IcPasswordLen=0;
			dsp_buffer[0]=iptparam->IcPasswordLen;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_CARD_PASSIN, dsp_buffer, dsp_len);
			break;
		}
		
		//确认密码校验
		iptPidSet(iptparam, IPT_PID_IC_PIN_CHECK);

		//促销机通知平板油机状态
		if(1 == paramPromotionGet())
		{
			iptparam->TaState = IPT_STATE_CARD_PRETREAT;	iptparam->TaStateParamLength = 0;
			pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
		}
		break;

	case KB_BUTTON_BACK:
		//退卡键退卡并返回待机界面
		ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		break;

	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptIcPinCheck
*Description		:IC卡密码验证过程
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcPinCheck(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char buffer[128]={0};
	int apdu_len=0, istate=0;
	int i = 0;
	unsigned char dsp_buffer[64]={0}, dsp_len=0;
	int voice[16]={0};
	unsigned char CardInf[16]={0};

	//IC卡密码验证
	istate=ICPinCheck(iptparam->DEVIC, 0, buffer, 128, iptparam->IcPassword, iptparam->IcPasswordLen);

	//操作成功则继续下一步
	if(ICSTATE_OK==istate)
	{
		iptparam->IcOverTimes=0;	
		apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
		if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
		{
			if(0x50==iptparam->IcAppId[2])
			{
				//ACT卡转入ACT认证过程
				iptPidSet(iptparam, IPT_PID_ACT_AUTHEN);
			}
			else if(0x51==iptparam->IcAppId[2])
			{
				//RID卡转入RID认证过程
				iptPidSet(iptparam, IPT_PID_RID_AUTHEN);
			}
			else
			{
				//加油卡判断限车号转入员工密码输入过程，否则转入卡明细查询界面
				if(0!=memcmp(iptparam->IcCarIdLimit, "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff", 16))
				{
					//szb_fj_20171120:update
					memcpy(CardInf,iptparam->IcCarIdLimit,16);
					for(i=15;i>=0;i--)
					{
						if(CardInf[i]==0xFF)
							CardInf[i]=0x00;
						else
							break;
					}

					if(iptparam->EtcOilFlg==1)//ETC加油 
					{
						if(memcmp(CardInf,iptparam->EtcSelCardInf,16)==0)//车牌一致直接跳过员工输入密码
						{
							//								goto NoCard;
							//车牌一致强制输入员工密码
							iptparam->etc_limit_car=1;
							goto YG_input3;
						}
						else//报错
						{
							dsp(iptparam->DEVDsp,DSP_CAR_NOYIZHI,dsp_buffer,0);
							IPT_DSP_WAIT();
							iptMainInterface(iptparam);
						}
					}
					else
					{
YG_input3:
						memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
						iptPidSet(iptparam, IPT_PID_IC_STAF_PASSIN);

						//促销机通知平板电脑限车号卡输入员工密码
						if(1 == paramPromotionGet())
						{
							iptparam->TaState = IPT_STATE_CARD_PLATE;	iptparam->TaStateParamLength = 0;
							strcpy(iptparam->TaStateParam + 0, iptparam->IcCarIdLimit);
							if(strlen(iptparam->IcCarIdLimit) < 16)	memset(iptparam->TaStateParam + strlen(iptparam->IcCarIdLimit), '\xFF', 16 - strlen(iptparam->IcCarIdLimit));
							*(iptparam->TaStateParam + 16) = 0;
							iptparam->TaStateParamLength = 16 + 1;
							pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
						}

						memcpy(&dsp_buffer[0], iptparam->IcCarIdLimit, 16);
						dsp_buffer[16]=iptparam->SetButtonLen;	dsp_len=17;
						dsp(iptparam->DEVDsp, DSP_CARD_CARLIMIT, dsp_buffer, dsp_len);
						return;
					}
				}
				else
				{
					iptparam->IcRecordNumber=0;
					dsp(iptparam->DEVDsp, DSP_CARD_PRETREAT, "\x00", 0);
					iptPidSet(iptparam, IPT_PID_IC_NOTES);
				}
			}
		}
		else
		if((0x63==buffer[2+apdu_len-2])&&(0xc0==(buffer[2+apdu_len-1]&0xf0)))
		{
			//非默认密码提示"密码错误，请重新输入"
			if(0!=iptparam->IcDefaultPassword && iptparam->VoiceVolume>0)
			{
				if(IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType)	voice[0]=SPKW_PASERR;	//女声
				else																				voice[0]=SPKM_PASERR;	//男声
				iptSpk(iptparam, voice, 1);
			}

			//促销机通知平板电脑错误信息
			if(1 == paramPromotionGet())
			{
				iptparam->TaState = IPT_STATE_ERROR_INFO;	iptparam->TaStateParamLength = 0;
				memcpy(iptparam->TaStateParam + 0, "密码错误,剩余", 13);
				*(iptparam->TaStateParam + 13) = (buffer[2+apdu_len-1]&0x0f)+0x30;
				memcpy(iptparam->TaStateParam + 14, "次机会", 6);
				iptparam->TaStateParamLength = 20;
				pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
			}

			//个人密码验证失败，提示错误
			memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
			dsp_buffer[2]=20;	
			memcpy(&dsp_buffer[3], "密码错误,剩余", 13);
			dsp_buffer[16]=(buffer[2+apdu_len-1]&0x0f)+0x30;
			memcpy(&dsp_buffer[17], "次机会", 6);
			dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
			IPT_DSP_WAIT();

			//剩余次数为0或使用默认密码(默认密码9999)，直接退卡
			if(0==(buffer[2+apdu_len-1]&0x0f) || 0==iptparam->IcDefaultPassword)
			{
				ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
			}
			//1=使用用户密码，维持错误提示一段时间后转到密码输入界面
			else
			{
				memcpy(iptparam->IcPassword, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 12);	iptparam->IcPasswordLen=0;

				dsp_buffer[0]=iptparam->IcPasswordLen;	dsp_len=1;
				dsp(iptparam->DEVDsp, DSP_CARD_PASSIN, dsp_buffer, dsp_len);
				iptPidSet(iptparam, IPT_PID_IC_PIN_INPUT);

				//促销机通知平板油机状态
				if(1 == paramPromotionGet())
				{
					iptparam->TaState = IPT_STATE_CARD_PASSIN;	iptparam->TaStateParamLength = 0;
					*(iptparam->TaStateParam + 0) = iptparam->IcPasswordLen;
					iptparam->TaStateParamLength = 1;
					pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
				}
			}
		}
		else if(0==memcmp(&buffer[2+apdu_len-2], "\x69\x83", 2))
		{
			//密码锁定
			memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
			dsp_buffer[2]=12;	memcpy(&dsp_buffer[3], "个人密码锁定", 12);
			dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
			IPT_DSP_WAIT();
			
			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
		else
		{
			//密码验证其它错误
			memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
			dsp_buffer[2]=12;	memcpy(&dsp_buffer[3], "个人密码错误", 12);
			dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
			IPT_DSP_WAIT();
			
			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
	}
	//操作失败则提示信息后退卡
	else if(ICSTATE_FAILED==istate)
	{
		iptparam->IcOverTimes=0;	
	
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "个人密码验证失败", 16);
		IPT_DSP_WAIT();
			
		ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
	}
	//操作超时
	else if(ICSTATE_OVERTIME==istate)
	{
		iptparam->IcOverTimes=0;	
	
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "个人密码验证超时", 16);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
	}
	//未定义错误
	else
	{
		iptparam->IcOverTimes=0;	
	
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "个人密码验证错误", 16);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
	}

	return;
}


/*******************************************************************
*Name				:iptIcStaffPinInput
*Description		:限车号卡员工密码输入
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcStaffPinInput(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char button=0, password[4]={0};
	unsigned char dsp_buffer[64]={0}, dsp_len=0;
	unsigned char buffer[128]={0};

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0==button)	button='0';
	case KB_BUTTON_1:
		if(0==button)	button='1';
	case KB_BUTTON_2:
		if(0==button)	button='2';
	case KB_BUTTON_3:
		if(0==button)	button='3';
	case KB_BUTTON_4:
		if(0==button)	button='4';
	case KB_BUTTON_5:
		if(0==button)	button='5';
	case KB_BUTTON_6:
		if(0==button)	button='6';
	case KB_BUTTON_7:
		if(0==button)	button='7';
	case KB_BUTTON_8:
		if(0==button)	button='8';
	case KB_BUTTON_9:
		if(0==button)	button='9';
		
		if(iptparam->SetButtonLen<4)
		{
			iptparam->SetButton[iptparam->SetButtonLen++]=button;

			memcpy(&dsp_buffer[0], iptparam->IcCarIdLimit, 16);
			dsp_buffer[16]=iptparam->SetButtonLen;	dsp_len=17;
			dsp(iptparam->DEVDsp, DSP_CARD_CARLIMIT, dsp_buffer, dsp_len);
		}

		//促销机通知平板电脑限车号卡输入员工密码
		if(1 == paramPromotionGet())
		{
			iptparam->TaState = IPT_STATE_CARD_PLATE;	iptparam->TaStateParamLength = 0;
			strcpy(iptparam->TaStateParam + 0, iptparam->IcCarIdLimit);
			if(strlen(iptparam->IcCarIdLimit) < 16)	memset(iptparam->TaStateParam + strlen(iptparam->IcCarIdLimit), '\xFF', 16 - strlen(iptparam->IcCarIdLimit));
			*(iptparam->TaStateParam + 16) = iptparam->SetButtonLen;
			iptparam->TaStateParamLength = 16 + 1;
			pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
		}
		break;

	case KB_BUTTON_CHG:
		//清除密码输入
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;

		memcpy(&dsp_buffer[0], iptparam->IcCarIdLimit, 16);
		dsp_buffer[16]=iptparam->SetButtonLen;	dsp_len=17;
		dsp(iptparam->DEVDsp, DSP_CARD_CARLIMIT, dsp_buffer, dsp_len);

		//促销机通知平板电脑限车号卡输入员工密码
		if(1 == paramPromotionGet())
		{
			iptparam->TaState = IPT_STATE_CARD_PLATE;	iptparam->TaStateParamLength = 0;
			strcpy(iptparam->TaStateParam + 0, iptparam->IcCarIdLimit);
			if(strlen(iptparam->IcCarIdLimit) < 16)	memset(iptparam->TaStateParam + strlen(iptparam->IcCarIdLimit), '\xFF', 16 - strlen(iptparam->IcCarIdLimit));
			*(iptparam->TaStateParam + 16) = iptparam->SetButtonLen;
			iptparam->TaStateParamLength = 16 + 1;
			pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
		}
		break;

	case KB_BUTTON_ACK:
		password[0]=((iptparam->EMPPassword[0]>>4)&0x0f)+0x30;	password[1]=((iptparam->EMPPassword[0]>>0)&0x0f)+0x30;
		password[2]=((iptparam->EMPPassword[1]>>4)&0x0f)+0x30;	password[3]=((iptparam->EMPPassword[1]>>0)&0x0f)+0x30;
		//密码错误则提示密码错误，保存卡错账单并退卡
		if(!((4==iptparam->SetButtonLen)&&(0==memcmp(password, iptparam->SetButton, 4))))
		{
			//促销机通知平板电脑错误信息
			if(1 == paramPromotionGet())
			{
				iptparam->TaState = IPT_STATE_ERROR_INFO;	iptparam->TaStateParamLength = 0;
				memcpy(iptparam->TaStateParam + 0, "员工密码错误", 12);
				iptparam->TaStateParamLength = 12;
				pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
			}
		
			//提示错误信息
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "员工密码错误", 12);
			IPT_DSP_WAIT();

			//IC加油数据保存卡错账单
			//待填充:POS_TTC
			memcpy(&iptparam->OilBill[IPT_OFFSET_TTC], "\x00\x00\x00\x00", 4);
			
			//待填充:交易类型设为卡错，后台/本地黑白名单，扣款签名无效，卡错拒绝
			iptparam->OilBill[IPT_OFFSET_T_TYPE]=(1<<7)|((iptparam->BlistSrc&1)<<6)|(0<<4)|(9<<0);;

			//已完成:交易日期及时间
			iptparam->OilBill[IPT_OFFSET_TIME+0]=iptparam->Time.century;	
			iptparam->OilBill[IPT_OFFSET_TIME+1]=iptparam->Time.year;
			iptparam->OilBill[IPT_OFFSET_TIME+2]=iptparam->Time.month;
			iptparam->OilBill[IPT_OFFSET_TIME+3]=iptparam->Time.date;
			iptparam->OilBill[IPT_OFFSET_TIME+4]=iptparam->Time.hour;		
			iptparam->OilBill[IPT_OFFSET_TIME+5]=iptparam->Time.minute;
			iptparam->OilBill[IPT_OFFSET_TIME+6]=iptparam->Time.second;

			//已完成:卡应用号
			memcpy(&iptparam->OilBill[IPT_OFFSET_ASN], iptparam->IcAppId, 10);

			//已完成:余额(扣前)，交易完成后填扣后余额
			memcpy(&iptparam->OilBill[IPT_OFFSET_BALANCE], "\x00\x00\x00\x00", 4);

			//已完成:数额，交易完成后填实际数额		
			memcpy(&iptparam->OilBill[IPT_OFFSET_AMN], "\x00\x00\x00", 3);

			//已完成:卡交易序号
			memcpy(&iptparam->OilBill[IPT_OFFSET_CTC], "\x00\x00", 2);

			//已完成:电子签名，加油/补扣/补充时未TAC，逃卡时为GTAC
			memcpy(&iptparam->OilBill[IPT_OFFSET_TAC], "\x10\x06\x00\x00", 4);

			//已完成:解灰认证码4bytes，加油完成，PSAM计算GMAC后添加
			memcpy(&iptparam->OilBill[IPT_OFFSET_GMAC], "\x00\x00\x00\x00", 4);

			//已完成:PSAM会所签名4bytes，加油完成，PSAM计算GMAC后添加
			memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TAC], "\x00\x00\x00\x00", 4);
			
			//已完成:PSAM应用号10bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_ASN], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 10);

			//已完成:PSAM编号6bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_TID], "\x00\x00\x00\x00\x00\x00", 6);

			//已完成:PSAM终端交易序号4bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TTC], "\x00\x00\x00\x00", 4);
		
			//已完成:扣款来源1byte
			iptparam->OilBill[IPT_OFFSET_DS]=iptparam->DS;
			
			//已完成:结算单位/方式1byte
			iptparam->OilBill[IPT_OFFSET_UNIT]=((iptparam->Payment&0x3f)<<4)|(iptparam->PayUnit&0x03);

			//已完成:卡类1byte
			iptparam->OilBill[IPT_OFFSET_C_TYPE]=iptparam->C_TYPE;

			//已完成:卡版本1byte，b7~b4卡密钥索引号；b3~b0卡密钥版本号
			iptparam->OilBill[IPT_OFFSET_VER]=0;

			//已完成:枪号1byte
			iptparam->OilBill[IPT_OFFSET_NZN]=0;
			
			//已完成:油品代码2bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_G_CODE], "\x00\x00", 2);

			//已完成:升数3bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_VOL], "\x00\x00\x00", 3);

			//已完成:成交价格2bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_PRC], "\x00\x00", 2);

			//已完成:员工号1byte
			iptparam->OilBill[IPT_OFFSET_EMP]=iptparam->EMP;

			//已完成:升累计4bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_V_TOT], "\x00\x00\x00\x00", 4);
			
			//已完成:备用部分11bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_RFU], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 11);

			//待填充:T-MAC	4bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], "\x00\x00\x00\x00", 4);
			
			//已完成:物理枪号PhysicsGunId
			iptparam->OilBill[IPT_OFFSET_PHYGUN]=iptparam->PhysicalNozzle;
			
			//已完成:计量停机代码
			iptparam->OilBill[IPT_OFFSET_STOPNO]=0;

			//已完成:扣前余额
			memcpy(&iptparam->OilBill[IPT_OFFSET_BEFOR_BAL], "\x00\x00\x00\x00", 4);

			//账单状态0=正常；1=未完成
			iptparam->OilBill[IPT_OFFSET_ZD_STATE]=1;

			//计量设备ID
			iptparam->OilBill[IPT_OFFSET_JLNOZZLE]=iptparam->JlNozzle;

			//计算账单校验值
			iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

			//保存账单及备份
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

			//转入账单TTC获取过程
			ICShoot(iptparam->DEVIC);
			iptPidSet(iptparam, IPT_PID_IC_TTC_GET);
			break;
		}

		//促销机通知平板油机状态
		if(1 == paramPromotionGet())
		{
			iptparam->TaState = IPT_STATE_CARD_PRETREAT;	iptparam->TaStateParamLength = 0;
			pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
		}

		//员工密码正确则转入卡明细读取过程
		dsp(iptparam->DEVDsp, DSP_CARD_PRETREAT, "\x00", 0);
		if(iptparam->etc_touming_flg==0)
		{
			iptparam->IcRecordNumber=0;
			iptPidSet(iptparam, IPT_PID_IC_NOTES);
		}
		else
		{
			iptPidSet(iptparam, IPT_PID_IC_NOTES_CHECK);
		}
		break;
	case KB_BUTTON_BACK:
		//退卡键退卡并返回待机过程
		ICShoot(iptparam->DEVIC);
		iptMainInterface(iptparam);
		break;
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptIcNotesRead
*Description		:IC卡历史交易明细读取过程
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcNotesRead(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char buffer[128]={0};
	int apdu_len=0, istate=0;
	unsigned char dsp_buffer[64]={0}, dsp_len=0;

	//IC卡交易明细读取
	istate=ICNotesRead(iptparam->DEVIC, 0, buffer, 128, iptparam->IcRecordNumber+1);

	//操作成功则继续下一步
	if(ICSTATE_OK==istate)
	{
		iptparam->IcOverTimes=0;
		apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
		if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
		{
			//记录交易明细数据
			memcpy(iptparam->IcRecord[iptparam->IcRecordNumber].TTC, &buffer[2], 2);
			memcpy(iptparam->IcRecord[iptparam->IcRecordNumber].Limit, &buffer[4], 3);
			memcpy(iptparam->IcRecord[iptparam->IcRecordNumber].Money, &buffer[7], 4);
			memcpy(&iptparam->IcRecord[iptparam->IcRecordNumber].Type, &buffer[11], 1);
			memcpy(iptparam->IcRecord[iptparam->IcRecordNumber].TermID, &buffer[12], 6);
			memcpy(iptparam->IcRecord[iptparam->IcRecordNumber].Time, &buffer[18], 7);

			//交易条数累加
			iptparam->IcRecordNumber++;

			//条数达到最多的十条转入交易明细检查过程
			if(iptparam->IcRecordNumber>=10)
			{
				iptPidSet(iptparam, IPT_PID_IC_NOTES_CHECK);
			}
		}
		//没有该记录表示明细记录已读取完毕，转入明细检查过程
		else if(0==memcmp(&buffer[2+apdu_len-2], "\x6a\x83", 2))
		{
			iptPidSet(iptparam, IPT_PID_IC_NOTES_CHECK);
		}
		//读交易明细失败
		else
		{
			memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
			dsp_buffer[2]=16;	memcpy(&dsp_buffer[3], "读卡交易明细失败", 16);
			dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);
			iptMainInterface(iptparam);
		}
	}
	//操作失败则提示信息后退卡
	else if(ICSTATE_FAILED==istate)
	{
		iptparam->IcOverTimes=0;

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "读卡交易明细失败", 16);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);
		iptMainInterface(iptparam);
	}
	//操作超时，不足三次再次操作，超过三次退卡
	else if(ICSTATE_OVERTIME==istate)
	{
		iptparam->IcOverTimes++;
		if(iptparam->IcOverTimes>=3)
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "读卡交易明细超时", 16);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);
			iptMainInterface(iptparam);
		}
	}
	//未定义错误
	else
	{
		iptparam->IcOverTimes=0;

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "读卡交易明细错误", 16);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);
		iptMainInterface(iptparam);
	}

	//按退卡键退卡
	if(KB_BUTTON_BACK==iptparam->Button)
	{
		iptparam->IcOverTimes=0;
		ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
	}

	return;
}


/*******************************************************************
*Name				:iptIcNotesCheck
*Description		:IC卡交易记录明细检查
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcNotesCheck(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned int moneysum=0, moneylimit=0, i=0, oil_times_sum=0;
	unsigned char time[7]={0}, buffer[128]={0};
	unsigned char dsp_buffer[64]={0}, dsp_len=0;

	//计算当天ET加油金额及加油次数
	time[0]=iptparam->Time.century;	time[1]=iptparam->Time.year;	time[2]=iptparam->Time.month;	time[3]=iptparam->Time.date;
	for(i=0; (i<iptparam->IcRecordNumber)&&(i<10); i++)
	{
		if(0==memcmp(time,iptparam->IcRecord[i].Time, 4) && (0x93==iptparam->IcRecord[i].Type || 0x95==iptparam->IcRecord[i].Type || 0x05==iptparam->IcRecord[i].Type)){

			oil_times_sum++;
			moneysum=moneysum+((iptparam->IcRecord[i].Money[0]<<24)|(iptparam->IcRecord[i].Money[1]<<16)|(iptparam->IcRecord[i].Money[2]<<8)|(iptparam->IcRecord[i].Money[3]<<0));
		}
	}

	//判断限每天加油次数
	if(0xff!=iptparam->IcTimesLimit && oil_times_sum>=(iptparam->IcTimesLimit&0x0f)){

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "限每天加油次数卡", 16);
		IPT_DSP_WAIT();

		//IC加油数据保存卡错账单，限每天加油次数试图超出使用
		//待填充:POS_TTC
		memcpy(&iptparam->OilBill[IPT_OFFSET_TTC], "\x00\x00\x00\x00", 4);
			
		//待填充:交易类型设为卡错，后台/本地黑白名单，扣款签名无效，卡错拒绝
		iptparam->OilBill[IPT_OFFSET_T_TYPE]=(1<<7)|((iptparam->BlistSrc&1)<<6)|(0<<4)|(9<<0);;

		//已完成:交易日期及时间
		iptparam->OilBill[IPT_OFFSET_TIME+0]=iptparam->Time.century;	
		iptparam->OilBill[IPT_OFFSET_TIME+1]=iptparam->Time.year;
		iptparam->OilBill[IPT_OFFSET_TIME+2]=iptparam->Time.month;
		iptparam->OilBill[IPT_OFFSET_TIME+3]=iptparam->Time.date;
		iptparam->OilBill[IPT_OFFSET_TIME+4]=iptparam->Time.hour;		
		iptparam->OilBill[IPT_OFFSET_TIME+5]=iptparam->Time.minute;
		iptparam->OilBill[IPT_OFFSET_TIME+6]=iptparam->Time.second;

		//已完成:卡应用号
		memcpy(&iptparam->OilBill[IPT_OFFSET_ASN], iptparam->IcAppId, 10);

		//已完成:余额(扣前)，交易完成后填扣后余额
		memcpy(&iptparam->OilBill[IPT_OFFSET_BALANCE], "\x00\x00\x00\x00", 4);

		//已完成:数额，交易完成后填实际数额		
		memcpy(&iptparam->OilBill[IPT_OFFSET_AMN], "\x00\x00\x00", 3);

		//已完成:卡交易序号
		memcpy(&iptparam->OilBill[IPT_OFFSET_CTC], "\x00\x00", 2);

		//已完成:电子签名，加油/补扣/补充时未TAC，逃卡时为GTAC
		memcpy(&iptparam->OilBill[IPT_OFFSET_TAC], "\x10\x03\x00\x00", 4);

		//已完成:解灰认证码4bytes，加油完成，PSAM计算GMAC后添加
		memcpy(&iptparam->OilBill[IPT_OFFSET_GMAC], "\x00\x00\x00\x00", 4);

		//已完成:PSAM会所签名4bytes，加油完成，PSAM计算GMAC后添加
		memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TAC], "\x00\x00\x00\x00", 4);
			
		//已完成:PSAM应用号10bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_ASN], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 10);

		//已完成:PSAM编号6bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_TID], "\x00\x00\x00\x00\x00\x00", 6);

		//已完成:PSAM终端交易序号4bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TTC], "\x00\x00\x00\x00", 4);
		
		//已完成:扣款来源1byte
		iptparam->OilBill[IPT_OFFSET_DS]=iptparam->DS;
			
		//已完成:结算单位/方式1byte
		iptparam->OilBill[IPT_OFFSET_UNIT]=((iptparam->Payment&0x3f)<<4)|(iptparam->PayUnit&0x03);

		//已完成:卡类1byte
		iptparam->OilBill[IPT_OFFSET_C_TYPE]=iptparam->C_TYPE;

		//已完成:卡版本1byte，b7~b4卡密钥索引号；b3~b0卡密钥版本号
		iptparam->OilBill[IPT_OFFSET_VER]=0;

		//已完成:枪号1byte
		iptparam->OilBill[IPT_OFFSET_NZN]=0;
			
		//已完成:油品代码2bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_G_CODE], "\x00\x00", 2);

		//已完成:升数3bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_VOL], "\x00\x00\x00", 3);

		//已完成:成交价格2bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_PRC], "\x00\x00", 2);

		//已完成:员工号1byte
		iptparam->OilBill[IPT_OFFSET_EMP]=iptparam->EMP;

		//已完成:升累计4bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_V_TOT], "\x00\x00\x00\x00", 4);
			
		//已完成:备用部分11bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_RFU], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 11);

		//待填充:T-MAC	4bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], "\x00\x00\x00\x00", 4);
			
		//已完成:物理枪号PhysicsGunId
		iptparam->OilBill[IPT_OFFSET_PHYGUN]=iptparam->PhysicalNozzle;
			
		//已完成:计量停机代码
		iptparam->OilBill[IPT_OFFSET_STOPNO]=0;

		//已完成:扣前余额
		memcpy(&iptparam->OilBill[IPT_OFFSET_BEFOR_BAL], "\x00\x00\x00\x00", 4);

		//账单状态0=正常；1=未完成
		iptparam->OilBill[IPT_OFFSET_ZD_STATE]=1;

		//计量设备ID
		iptparam->OilBill[IPT_OFFSET_JLNOZZLE]=iptparam->JlNozzle;

		//计算账单校验值
		iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

		//保存账单及备份
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

		//转入账单TTC获取过程
		ICShoot(iptparam->DEVIC);
		iptPidSet(iptparam, IPT_PID_IC_TTC_GET);
		return;
	}

	//判断限每天加油金额卡是否超限
	moneylimit=(iptparam->IcMoneyDayLimit[0]<<24)|(iptparam->IcMoneyDayLimit[1]<<16)|(iptparam->IcMoneyDayLimit[2]<<8)|(iptparam->IcMoneyDayLimit[3]<<0);
	if(0xffffffff!=moneylimit && moneysum>=moneylimit){

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "限每天加油金额卡", 16);
		IPT_DSP_WAIT();

		//IC加油数据保存卡错账单，限每天加油金额试图超出使用
		//待填充:POS_TTC
		memcpy(&iptparam->OilBill[IPT_OFFSET_TTC], "\x00\x00\x00\x00", 4);
			
		//待填充:交易类型设为卡错，后台/本地黑白名单，扣款签名有效，卡错拒绝
		iptparam->OilBill[IPT_OFFSET_T_TYPE]=(1<<7)|((iptparam->BlistSrc&1)<<6)|(1<<4)|(9<<0);;

		//已完成:交易日期及时间
		iptparam->OilBill[IPT_OFFSET_TIME+0]=iptparam->Time.century;	
		iptparam->OilBill[IPT_OFFSET_TIME+1]=iptparam->Time.year;
		iptparam->OilBill[IPT_OFFSET_TIME+2]=iptparam->Time.month;
		iptparam->OilBill[IPT_OFFSET_TIME+3]=iptparam->Time.date;
		iptparam->OilBill[IPT_OFFSET_TIME+4]=iptparam->Time.hour;		
		iptparam->OilBill[IPT_OFFSET_TIME+5]=iptparam->Time.minute;
		iptparam->OilBill[IPT_OFFSET_TIME+6]=iptparam->Time.second;

		//已完成:卡应用号
		memcpy(&iptparam->OilBill[IPT_OFFSET_ASN], iptparam->IcAppId, 10);

		//已完成:余额(扣前)，交易完成后填扣后余额
		memcpy(&iptparam->OilBill[IPT_OFFSET_BALANCE], "\x00\x00\x00\x00", 4);

		//已完成:数额，交易完成后填实际数额		
		memcpy(&iptparam->OilBill[IPT_OFFSET_AMN], "\x00\x00\x00", 3);

		//已完成:卡交易序号
		memcpy(&iptparam->OilBill[IPT_OFFSET_CTC], "\x00\x00", 2);

		//已完成:电子签名，加油/补扣/补充时未TAC，逃卡时为GTAC
		memcpy(&iptparam->OilBill[IPT_OFFSET_TAC], "\x10\x04\x00\x00", 4);

		//已完成:解灰认证码4bytes，加油完成，PSAM计算GMAC后添加
		memcpy(&iptparam->OilBill[IPT_OFFSET_GMAC], "\x00\x00\x00\x00", 4);

		//已完成:PSAM会所签名4bytes，加油完成，PSAM计算GMAC后添加
		memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TAC], "\x00\x00\x00\x00", 4);
			
		//已完成:PSAM应用号10bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_ASN], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 10);

		//已完成:PSAM编号6bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_TID], "\x00\x00\x00\x00\x00\x00", 6);

		//已完成:PSAM终端交易序号4bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TTC], "\x00\x00\x00\x00", 4);
		
		//已完成:扣款来源1byte
		iptparam->OilBill[IPT_OFFSET_DS]=iptparam->DS;
			
		//已完成:结算单位/方式1byte
		iptparam->OilBill[IPT_OFFSET_UNIT]=((iptparam->Payment&0x3f)<<4)|(iptparam->PayUnit&0x03);

		//已完成:卡类1byte
		iptparam->OilBill[IPT_OFFSET_C_TYPE]=iptparam->C_TYPE;

		//已完成:卡版本1byte，b7~b4卡密钥索引号；b3~b0卡密钥版本号
		iptparam->OilBill[IPT_OFFSET_VER]=0;

		//已完成:枪号1byte
		iptparam->OilBill[IPT_OFFSET_NZN]=0;
			
		//已完成:油品代码2bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_G_CODE], "\x00\x00", 2);

		//已完成:升数3bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_VOL], "\x00\x00\x00", 3);

		//已完成:成交价格2bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_PRC], "\x00\x00", 2);

		//已完成:员工号1byte
		iptparam->OilBill[IPT_OFFSET_EMP]=iptparam->EMP;

		//已完成:升累计4bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_V_TOT], "\x00\x00\x00\x00", 4);
			
		//已完成:备用部分11bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_RFU], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 11);

		//待填充:T-MAC	4bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], "\x00\x00\x00\x00", 4);
			
		//已完成:物理枪号PhysicsGunId
		iptparam->OilBill[IPT_OFFSET_PHYGUN]=iptparam->PhysicalNozzle;
			
		//已完成:计量停机代码
		iptparam->OilBill[IPT_OFFSET_STOPNO]=0;

		//已完成:扣前余额
		memcpy(&iptparam->OilBill[IPT_OFFSET_BEFOR_BAL], "\x00\x00\x00\x00", 4);

		//账单状态0=正常；1=未完成
		iptparam->OilBill[IPT_OFFSET_ZD_STATE]=1;

		//计量设备ID
		iptparam->OilBill[IPT_OFFSET_JLNOZZLE]=iptparam->JlNozzle;

		//计算账单校验值
		iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

		//保存账单及备份
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

		//转入账单TTC获取过程
		ICShoot(iptparam->DEVIC);
		iptPidSet(iptparam, IPT_PID_IC_TTC_GET);
		return;
	}

	//非限制卡、电子油票应用转入黑/白名单查询过程，非电子油票应用转入灰锁信息状态查询
	if(IPT_PAYUNIT_MONEY==iptparam->PayUnit)	iptPidSet(iptparam, IPT_PID_IC_BL_CHECK);
	else 																		iptPidSet(iptparam, IPT_PID_IC_LOCK_INFO);

	return;
}


/*******************************************************************
*Name				:iptIcBLCheck
*Description		:IC卡黑/白名单查询过程
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcBLCheck(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char tx_buffer[128]={0}, tx_len=0;
	unsigned char dsp_buffer[64]={0}, dsp_len=0;
	unsigned char buffer[128]={0};

	//发送PCD查询黑/白名单命令，包括最近一次加油时间
	if(IPT_2PCD_UNUSED==iptparam->PcdTxFlag)
	{
		tx_buffer[0]=++iptparam->PcdTxFrame;
		tx_buffer[1]=pcdMboardIDRead();
		tx_buffer[2]=iptparam->Id;
		tx_buffer[3]=iptparam->PhysicalNozzle;
		tx_buffer[4]=IPT_CMD_LIST;
		memcpy(&tx_buffer[5], iptparam->IcAppId, 10);
		if(iptparam->IcRecordNumber>0)	
			memcpy(&tx_buffer[15], iptparam->IcRecord[0].Time, 4);
		tx_len=19;
		//msgQSend((MSG_Q_ID)pcdMsgIdRead(), tx_buffer, tx_len, NO_WAIT, MSG_PRI_NORMAL);

		struct msg_struct msg_stIptSend;  //fj:20170928
		msg_stIptSend.msgType = 1;
		memcpy(msg_stIptSend.msgBuffer,tx_buffer,tx_len);
		msgsnd(pcdMsgIdRead(),&msg_stIptSend,tx_len,IPC_NOWAIT);

		iptparam->PcdTxFlag=IPT_2PCD_OILPROCESS;	
		iptparam->PcdTxTimer=0;

		printf("ICBLCheck: IPT_2PCD_UNUSED\n");
	}
	//判断为名单查询命令且查询成功则根据结果处理
	else if(IPT_2PCD_OILPROCESS==iptparam->PcdTxFlag && msg_len>0 && IPT_CMD_LIST==msg_buffer[4] && 0==msg_buffer[5] && 0==memcmp(&msg_buffer[8], iptparam->IcAppId, 10))
	{
		//查询源
		iptparam->BlistSrc=msg_buffer[6];

		//查询成功，根据查询结果处理
		if((0==msg_buffer[5])&&(0x01==iptparam->IcAppId[2])&&(0==msg_buffer[7]))
		{
			//发送错误密码锁PIN
			ICPinCheck(iptparam->DEVIC, 0, buffer, 128, "\x12\x34\x33", iptparam->IcPasswordLen);
			ICPinCheck(iptparam->DEVIC, 0, buffer, 128, "\x22\x34\x33", iptparam->IcPasswordLen);
			ICPinCheck(iptparam->DEVIC, 0, buffer, 128, "\x32\x34\x33", iptparam->IcPasswordLen);
			ICPinCheck(iptparam->DEVIC, 0, buffer, 128, "\x42\x34\x33", iptparam->IcPasswordLen);

			//提示"挂失卡"
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "挂失卡", 6);
			IPT_DSP_WAIT();

			//IC加油数据保存卡错账单，限每天加油金额试图超出使用
			//待填充:POS_TTC
			memcpy(&iptparam->OilBill[IPT_OFFSET_TTC], "\x00\x00\x00\x00", 4);

			//待填充:交易类型设为卡错，后台/本地黑白名单，扣款签名无效，卡错拒绝
			iptparam->OilBill[IPT_OFFSET_T_TYPE]=(1<<7)|((iptparam->BlistSrc&1)<<6)|(0<<4)|(9<<0);;

			//已完成:交易日期及时间
			iptparam->OilBill[IPT_OFFSET_TIME+0]=iptparam->Time.century;	
			iptparam->OilBill[IPT_OFFSET_TIME+1]=iptparam->Time.year;
			iptparam->OilBill[IPT_OFFSET_TIME+2]=iptparam->Time.month;
			iptparam->OilBill[IPT_OFFSET_TIME+3]=iptparam->Time.date;
			iptparam->OilBill[IPT_OFFSET_TIME+4]=iptparam->Time.hour;		
			iptparam->OilBill[IPT_OFFSET_TIME+5]=iptparam->Time.minute;
			iptparam->OilBill[IPT_OFFSET_TIME+6]=iptparam->Time.second;

			//已完成:卡应用号
			memcpy(&iptparam->OilBill[IPT_OFFSET_ASN], iptparam->IcAppId, 10);

			//已完成:余额(扣前)，交易完成后填扣后余额
			memcpy(&iptparam->OilBill[IPT_OFFSET_BALANCE], "\x00\x00\x00\x00", 4);

			//已完成:数额，交易完成后填实际数额		
			memcpy(&iptparam->OilBill[IPT_OFFSET_AMN], "\x00\x00\x00", 3);

			//已完成:卡交易序号
			memcpy(&iptparam->OilBill[IPT_OFFSET_CTC], "\x00\x00", 2);

			//已完成:电子签名，加油/补扣/补充时未TAC，逃卡时为GTAC
			memcpy(&iptparam->OilBill[IPT_OFFSET_TAC], "\x00\x01\x00\x00", 4);

			//已完成:解灰认证码4bytes，加油完成，PSAM计算GMAC后添加
			memcpy(&iptparam->OilBill[IPT_OFFSET_GMAC], "\x00\x00\x00\x00", 4);

			//已完成:PSAM会所签名4bytes，加油完成，PSAM计算GMAC后添加
			memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TAC], "\x00\x00\x00\x00", 4);
				
			//已完成:PSAM应用号10bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_ASN], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 10);

			//已完成:PSAM编号6bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_TID], "\x00\x00\x00\x00\x00\x00", 6);

			//已完成:PSAM终端交易序号4bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TTC], "\x00\x00\x00\x00", 4);
			
			//已完成:扣款来源1byte
			iptparam->OilBill[IPT_OFFSET_DS]=iptparam->DS;
				
			//已完成:结算单位/方式1byte
			iptparam->OilBill[IPT_OFFSET_UNIT]=((iptparam->Payment&0x3f)<<4)|(iptparam->PayUnit&0x03);

			//已完成:卡类1byte
			iptparam->OilBill[IPT_OFFSET_C_TYPE]=iptparam->C_TYPE;

			//已完成:卡版本1byte，b7~b4卡密钥索引号；b3~b0卡密钥版本号
			iptparam->OilBill[IPT_OFFSET_VER]=0;

			//已完成:枪号1byte
			iptparam->OilBill[IPT_OFFSET_NZN]=0;
				
			//已完成:油品代码2bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_G_CODE], "\x00\x00", 2);

			//已完成:升数3bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_VOL], "\x00\x00\x00", 3);

			//已完成:成交价格2bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_PRC], "\x00\x00", 2);

			//已完成:员工号1byte
			iptparam->OilBill[IPT_OFFSET_EMP]=iptparam->EMP;

			//已完成:升累计4bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_V_TOT], "\x00\x00\x00\x00", 4);
				
			//已完成:备用部分11bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_RFU], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 11);

			//待填充:T-MAC	4bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], "\x00\x00\x00\x00", 4);
				
			//已完成:物理枪号PhysicsGunId
			iptparam->OilBill[IPT_OFFSET_PHYGUN]=iptparam->PhysicalNozzle;
				
			//已完成:计量停机代码
			iptparam->OilBill[IPT_OFFSET_STOPNO]=0;

			//已完成:扣前余额
			memcpy(&iptparam->OilBill[IPT_OFFSET_BEFOR_BAL], "\x00\x00\x00\x00", 4);

			//账单状态0=正常；1=未完成
			iptparam->OilBill[IPT_OFFSET_ZD_STATE]=1;

			//计量设备ID
			iptparam->OilBill[IPT_OFFSET_JLNOZZLE]=iptparam->JlNozzle;

			//计算账单校验值
			iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

			//保存账单及备份
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

			//转入账单TTC获取过程
			ICShoot(iptparam->DEVIC);
			iptPidSet(iptparam, IPT_PID_IC_TTC_GET);

			printf("yyyyyyyyyyyy\n");
		}
		else if(0==msg_buffer[5] && 0x02==iptparam->IcAppId[2] && 0!=msg_buffer[7])
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "非本站管理卡", 12);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);
			iptMainInterface(iptparam);
		}
		else if(0==msg_buffer[5] && 0x04==iptparam->IcAppId[2] && 0!=msg_buffer[7])
		{	
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "非本站员工卡", 12);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);
			iptMainInterface(iptparam);
		}
		else if(0==msg_buffer[5] && 0x05==iptparam->IcAppId[2] && 0!=msg_buffer[7])
		{	
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "非本站验泵卡", 12);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);
			iptMainInterface(iptparam);
		}
		else if(0==msg_buffer[5] && 0x06==iptparam->IcAppId[2] && 0!=msg_buffer[7])
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "非本站维修卡", 12);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);
			iptMainInterface(iptparam);
		}
		else if((0x01==iptparam->IcAppId[2] && 0!=msg_buffer[7])||(0x01!=iptparam->IcAppId[2] && 0==msg_buffer[7]))
		{	
			//szb_fj_20171120,update
			if(iptparam->etc_touming_flg==0)
		    {
				iptPidSet(iptparam, IPT_PID_IC_LOCK_INFO);//转入卡灰锁状态查询过程
			}
			else
			{
				EtcCardYuehanlde(iptparam->Id);
			}
		}
		else
		{
			//查询失败
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "查询黑白名单失败", 16);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);
			iptMainInterface(iptparam);
		}

		iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	
		iptparam->PcdOverTimes=0;
		printf("ICBLCheck:IPT_2PCD_OILPROCESS\n");
	}
	else if(IPT_2PCD_OILPROCESS==iptparam->PcdTxFlag && msg_len>0 && IPT_CMD_LIST==msg_buffer[4] && 0!=msg_buffer[5] && 0==memcmp(&msg_buffer[8], iptparam->IcAppId, 10))
	{
		if(1==iptparam->IcAppId[2])
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "需联机查询黑名单", 16);
		else	
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "需联机查询白名单", 16);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);
		iptMainInterface(iptparam);

		iptparam->PcdTxFlag=IPT_2PCD_UNUSED;
		iptparam->PcdOverTimes=0;
	}
	else if(IPT_2PCD_OILPROCESS==iptparam->PcdTxFlag && iptparam->PcdTxTimer>=(2*ONE_SECOND))
	{
		//通讯超时重发，3次超时失败提示信息后退卡
		iptparam->PcdTxFlag=IPT_2PCD_UNUSED;
		iptparam->PcdOverTimes++;
		if(iptparam->PcdOverTimes>=3)
		{
			iptparam->PcdOverTimes=0;
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "查询黑白名单超时", 16);
			IPT_DSP_WAIT();
		
			ICShoot(iptparam->DEVIC);
			iptMainInterface(iptparam);

			printf("ICBLCheck:time out!\n");
		}
	}

	//按退卡键退卡
	if(KB_BUTTON_BACK==iptparam->Button)
	{
		iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdOverTimes=0;
		ICShoot(iptparam->DEVIC);
		iptMainInterface(iptparam);
	}

	//printf("iptIcBLCheck,\n");

	return;
}


/*******************************************************************
*Name				:iptIcLockInfo
*Description		:IC卡灰锁信息读取过程
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcLockInfo(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char buffer[128]={0};
	int apdu_len=0, istate=0;
	unsigned char dsp_buffer[64]={0}, dsp_len=0;

	//IC卡灰锁信息读取
	istate=ICGreyInfoRead(iptparam->DEVIC, 0, buffer, 128);

	//操作成功则继续下一步
	if(ICSTATE_OK==istate)
	{
		iptparam->IcOverTimes=0;
		apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
		if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
		{
			//卡插入时的状态
			iptparam->ICStateFirst=buffer[2];
		
			//保存灰锁信息
			iptparam->IcLockMark=buffer[2];								//状态字:0x00=无灰锁；0x01=已灰锁；0x10=TAC未读
			iptparam->IcLockType=buffer[3];								//上次发生解扣或灰锁交易的交易类型标识
			iptparam->IcLockET=buffer[4];									//上次发生解扣或灰锁交易为ET
			memcpy(iptparam->IcLockBalance, &buffer[5], 4);		//上次发生解扣或灰锁的有效余额
			memcpy(iptparam->IcLockCTC, &buffer[9], 2);			//上次发生解扣或灰锁的交易序号
			memcpy(iptparam->IcLockTermId, &buffer[11], 6);		//上次发生解扣或灰锁的终端编号
			memcpy(iptparam->IcLockTime, &buffer[17], 7);		//上次发生解扣或灰锁的日期时间
			memcpy(iptparam->IcLockMoney, &buffer[24], 4);		//上次发生解扣或灰锁的交易金额
			memcpy(iptparam->IcLockGTAC, &buffer[28], 4);		//上次发生解扣或灰锁的GTAC或TAC或MAC3

			if(0x00==iptparam->IcLockMark)
			{
				//正常，转入余额读取过程
				iptPidSet(iptparam, IPT_PID_IC_BAL_READ);
			}
			else if(0x01==iptparam->IcLockMark)
			{
				//灰卡，转入灰记录查询过程
				dsp(iptparam->DEVDsp, DSP_CARD_UNLOCK_FINISH, "\x00", 0);
				iptPidSet(iptparam, IPT_PID_IC_LOCKRECORD);
			}
			else if(0x10==iptparam->IcLockMark)
			{
				//转入TAC清除过程
				dsp(iptparam->DEVDsp, DSP_CARD_TACCLR_FINISH, "\x00", 0);
				iptPidSet(iptparam, IPT_PID_IC_TAC_CLEAR);
			}
			else
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "灰锁状态字错", 12);
				IPT_DSP_WAIT();

				ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
			}
		}
		
		//新卡无灰记录
		else if(0==memcmp(&buffer[2+apdu_len-2], "\x69\x85", 2))
		{
			iptparam->IcLockMark=0;																			//状态字:0x00=无灰锁；0x01=已灰锁；0x10=TAC未读
			iptparam->IcLockType=0;																			//上次发生解扣或灰锁交易的交易类型标识
			iptparam->IcLockET=0;																				//上次发生解扣或灰锁交易为ET
			memcpy(iptparam->IcLockBalance, "\x00\x00\x00\x00", 4);						//上次发生解扣或灰锁的有效余额
			memcpy(iptparam->IcLockCTC, "\x00\x00", 2);											//上次发生解扣或灰锁的交易序号
			memcpy(iptparam->IcLockTermId, "\x00\x00\x00\x00\x00\x00", 6);		//上次发生解扣或灰锁的终端编号
			memcpy(iptparam->IcLockTime, "\x00\x00\x00\x00\x00\x00\x00", 7);	//上次发生解扣或灰锁的日期时间
			memcpy(iptparam->IcLockMoney, "\x00\x00\x00\x00", 4);						//上次发生解扣或灰锁的交易金额
			memcpy(iptparam->IcLockGTAC, "\x00\x00\x00\x00", 4);							//上次发生解扣或灰锁的GTAC或TAC或MAC3

			iptPidSet(iptparam, IPT_PID_IC_BAL_READ);
		}
		
		//读灰锁信息失败
		else
		{
			memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
			dsp_buffer[2]=16;	memcpy(&dsp_buffer[3], "读卡灰锁信息失败", 16);
			dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
	}
	//操作失败则提示信息后退卡
	else if(ICSTATE_FAILED==istate)
	{
		iptparam->IcOverTimes=0;

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "读卡灰锁信息失败", 16);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);
		iptMainInterface(iptparam);
	}
	//操作超时，不足三次再次操作，超过三次退卡
	else if(ICSTATE_OVERTIME==istate)
	{
		iptparam->IcOverTimes++;
		if(iptparam->IcOverTimes>=3)
		{
			iptparam->IcOverTimes=0;
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "读卡灰锁信息超时", 16);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);
			iptMainInterface(iptparam);
		}
	}
	//未定义错误
	else
	{
		iptparam->IcOverTimes=0;

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "读卡灰锁信息错误", 16);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);
		iptMainInterface(iptparam);
	}

	return;
}


/*******************************************************************
*Name				:iptLockRecordGet
*Description		:查询灰锁交易记录
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptLockRecordGet(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char tx_buffer[64]={0}, tmp_buffer[32]={0}, buffer[128]={0};
	int tx_len=0;
	unsigned char dsp_buffer[64]={0}, dsp_len=0,i=0;

	if(IPT_2PCD_UNUSED==iptparam->PcdTxFlag){

		//发送PCD查询黑/白名单命令
		tx_buffer[0]=++iptparam->PcdTxFrame;
		tx_buffer[1]=pcdMboardIDRead();
		tx_buffer[2]=iptparam->Id;
		tx_buffer[3]=iptparam->PhysicalNozzle;
		tx_buffer[4]=IPT_CMD_GREYINFO;
		memcpy(&tx_buffer[5], iptparam->IcAppId, 10);				//卡应用号
		memcpy(&tx_buffer[15], iptparam->IcLockBalance, 4);	//余额
		memcpy(&tx_buffer[19], iptparam->IcLockCTC, 2);		//CTC
		tx_buffer[21]=iptparam->DS;											//扣款来源
		//2016-01-22 社会站联达系统加油中逃卡不能解扣的问题
		if(1 == iptIsLianda(iptparam->Id) && 0 == iptparam->Payment)
		{
			tx_buffer[21] = 0x94;iptparam->DS=0x94;
		}
		if(1 == iptIsLianda(iptparam->Id) && 0 != iptparam->Payment)
		{
			tx_buffer[21] = 0x95;iptparam->DS=0x95;
		}
		memcpy(&tx_buffer[22], iptparam->IcLockTime, 7);		//日期及时间
		tx_len=29;
		//msgQSend((MSG_Q_ID)pcdMsgIdRead(), tx_buffer, tx_len, NO_WAIT, MSG_PRI_NORMAL);

		struct msg_struct msg_stIptSend;  //fj:20170918
		msg_stIptSend.msgType = 1;
		memcpy(msg_stIptSend.msgBuffer,tx_buffer,tx_len);
		msgsnd(pcdMsgIdRead(),&msg_stIptSend,tx_len,IPC_NOWAIT);

		iptparam->PcdTxFlag=IPT_2PCD_OILPROCESS;	iptparam->PcdTxTimer=0;
	}
	else
	if((IPT_2PCD_OILPROCESS==iptparam->PcdTxFlag)&&(msg_len>0)&&(IPT_CMD_GREYINFO==msg_buffer[4])&&\
		(0==msg_buffer[6])&&\
		(0==memcmp(&msg_buffer[7], iptparam->IcAppId, 10))&&(0==memcmp(&msg_buffer[17], iptparam->IcLockBalance, 4))&&\
		(0==memcmp(&msg_buffer[24], iptparam->IcLockCTC, 2))&&(msg_buffer[26]==iptparam->DS)&&(0==memcmp(&msg_buffer[27], iptparam->IcLockTime, 7)))
	{
		iptparam->PcdTxFlag=IPT_2PCD_UNUSED;
		iptparam->PcdOverTimes=0;

		//保存灰锁交易数据:金额，GMAC，PsamTermId, 
		iptparam->unlockMoney=(msg_buffer[21]<<16)|(msg_buffer[22]<<8)|(msg_buffer[23]<<0);
		memcpy(iptparam->unlockCTC, &msg_buffer[24], 2);
		memcpy(iptparam->unlockGMAC, &msg_buffer[34], 4);
		//memcpy(iptparam->unlockPsamTID,  &msg_buffer[38], 6);
		memcpy(iptparam->unlockPsamTTC, &msg_buffer[44], 4);

		printf("iptLockRecordGet,unlockMoney = %d\n",iptparam->unlockMoney);

		//转入扣款过程
		iptPidSet(iptparam, IPT_PID_IC_UNLOCK);
	}
	else
	if((IPT_2PCD_OILPROCESS==iptparam->PcdTxFlag)&&(msg_len>0)&&(IPT_CMD_GREYINFO==msg_buffer[4])&&\
		(0!=msg_buffer[6])&&\
		(0==memcmp(&msg_buffer[7], iptparam->IcAppId, 10))&&(0==memcmp(&msg_buffer[17], iptparam->IcLockBalance, 4))&&\
		(0==memcmp(&msg_buffer[24], iptparam->IcLockCTC, 2))&&(msg_buffer[26]==iptparam->DS)&&(0==memcmp(&msg_buffer[27], iptparam->IcLockTime, 7)))
	{
		iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdOverTimes=0;
	
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "无法解灰", 8);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);
		iptMainInterface(iptparam);
	}
	else
	if((IPT_2PCD_OILPROCESS==iptparam->PcdTxFlag)&&(iptparam->PcdTxTimer>=(5*ONE_SECOND)))
	{
		//通讯超时重发，3次超时失败提示信息后退卡
		iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdOverTimes++;
		
		if(iptparam->PcdOverTimes>=3)
		{
			iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "查询灰记录超时", 14);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);
			iptMainInterface(iptparam);
		}
	}

	return;
}


/*******************************************************************
*Name				:iptIcBalanceRead
*Description		:IC卡余额读取过程
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcBalanceRead(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	int voice[16]={0};
	unsigned char buffer[128]={0};
	int apdu_len=0, istate=0;
	unsigned char dsp_buffer[64]={0};
	unsigned int dsp_len=0;
	PCOilInfoType oilinfo;
	PCCardInfoType cardinfo;
	PCCardRecordType cardrecord[10];
	int i = 0, appselect = 0;

	char tx_buffer[128]={0};
	int tx_len=0;
	int ihandle = 0;
	unsigned int voice_len=0;

	//2017-01-22中燃联达加油中逃卡无法解扣
	if(1 == iptIsLianda(iptparam->Id))
		{
			//向后台申请本次加油数据，申请成功后开始加油，申请失败时提示客户失败，经客户人工确认后可继续以非折扣价格加油
			if(IPT_2PCD_UNUSED==iptparam->PcdTxFlag)
			{
				tx_buffer[0]=++iptparam->PcdTxFrame;
				tx_buffer[1]=pcdMboardIDRead();
				tx_buffer[2]=iptparam->Id;
				tx_buffer[3]=iptparam->PhysicalNozzle;
				tx_buffer[4]=IPT_CMD_DISCOUNT_ASK;
				tx_buffer[5]=iptparam->LogicNozzle;
				memcpy(tx_buffer+6, iptparam->IcAppId, 10);
				tx_len=16;
				//msgQSend((MSG_Q_ID)pcdMsgIdRead(), tx_buffer, tx_len, NO_WAIT, MSG_PRI_NORMAL);

				struct msg_struct msg_stIptSend;  //fj:20170918
				msg_stIptSend.msgType = 1;
				memcpy(msg_stIptSend.msgBuffer,tx_buffer,tx_len);
				msgsnd(pcdMsgIdRead(),&msg_stIptSend,tx_len,IPC_NOWAIT);

				iptparam->PcdTxFlag=IPT_2PCD_OILPROCESS;	iptparam->PcdTxTimer=0;
			}
			//接收到正确的返回后判断折扣是否合法，非法则提示错误并禁止加油
			else if(IPT_2PCD_OILPROCESS==iptparam->PcdTxFlag && msg_len>0 && IPT_CMD_DISCOUNT_ASK==msg_buffer[4] &&\
				iptparam->LogicNozzle==msg_buffer[5] && 0==memcmp(&msg_buffer[6], iptparam->IcAppId, 10))
			{
				if(0x01 == iptparam->IcDiscountFlag)
				{
					iptparam->PriceDiscount = (msg_buffer[16]<<8)|(msg_buffer[17]<<0);
				}
				else
				{
					iptparam->PriceDiscount = 0;
				}
				iptparam->InvoiceType = msg_buffer[18];
				memcpy(iptparam->StationName, &msg_buffer[19], 30);
				memcpy(iptparam->OilName, &msg_buffer[49], 16);

				jljRunLog("申请加油数据成功[折扣额=%d]!\n", iptparam->PriceDiscount);

				ihandle = 1;

				iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdOverTimes=0;
			}
			//申请折扣超时超过3次，提示失败并转入用户操作过程
			else if(IPT_2PCD_OILPROCESS==iptparam->PcdTxFlag && iptparam->PcdTxTimer>=(5*ONE_SECOND))
			{
				iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdOverTimes++;
				if(iptparam->PcdOverTimes>=3)
				{
					dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "申请加油数据失败", 16);
					ICShoot(iptparam->DEVIC);
					IPT_DSP_WAIT();
					iptMainInterface(iptparam);
				
					memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
					iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdOverTimes=0;
				}
			}

			//申请折扣价格操作完毕
			if(1 != ihandle)
				return;
		}
	
	//IC卡密码验证
	istate=ICBalanceRead(iptparam->DEVIC, 0, buffer, 128);

	//操作成功则继续下一步
	if(ICSTATE_OK==istate)
	{
		iptparam->IcOverTimes=0;
		apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
		if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
		{
			if(iptparam->EtcOilFlg==1) //szb_fj_20171120,add
			{
				//卡已读出余额
				iptparam->IcValid=1;

				//结算方式默认为现金
				iptparam->Payment=IPT_PAYMENT_MONEY;

				//卡余额信息
				memcpy(iptparam->IcBalance, &buffer[2], 4);

				EtcOilNameCourse(iptparam->Id);
				if(memcmp(iptparam->EtcSelCardInf+ETCCARDLEN-3,"\xff\xff",2)==0 || \
						memcmp(iptparam->etc_now_oil,iptparam->etc_recnet_oil,10)==0)//还未加过油或者油品号相同
				{

					//初始化预置数据
					memset(iptparam->IntegerBuffer, 0, sizeof(iptparam->IntegerBuffer));		iptparam->IntegerLen=0;
					iptparam->Point=0;
					memset(iptparam->DecimalBuffer, 0, sizeof(iptparam->DecimalBuffer));	iptparam->DecimalLen=0;
					iptparam->PresetMode=IPT_PRESET_NO;	iptparam->PresetVolume=0;	iptparam->PresetMoney=0;

					memset(iptparam->SetButton,0,sizeof(iptparam->SetButton));
					iptparam->SetButtonLen=0;
					if(iptparam->etc_limit_car==1)
					{
						//枪号正使用限车号卡加油
						if(IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType)	
						{
							if(iptparam->LogicNozzle/10==0)
								voice[voice_len++]=iptparam->LogicNozzle;
							else if((iptparam->LogicNozzle/10)!=0)
							{
								if((iptparam->LogicNozzle%10)==0)
								{
									if((iptparam->LogicNozzle/10)==1)
									{
										voice[voice_len++]=SPKW_TEN;
									}
									else
									{
										voice[voice_len++]=(iptparam->LogicNozzle/10);
										voice[voice_len++]=SPKW_TEN;
									}
								}
								else
								{
									if((iptparam->LogicNozzle/10)==1)
									{
										voice[voice_len++]=SPKW_TEN;
										voice[voice_len++]=(iptparam->LogicNozzle%10);
									}
									else
									{
										voice[voice_len++]=(iptparam->LogicNozzle/10);
										voice[voice_len++]=SPKW_TEN;
										voice[voice_len++]=(iptparam->LogicNozzle%10);
									}
								}
							}
							voice[voice_len++]=SPKW_LIMIT_CAR;

						}

						iptSpk(iptparam, voice, voice_len);
					}
					else
					{
						//请提枪加油或以定量方式加油
						if(iptparam->VoiceVolume > 0 && IPT_PAYUNIT_LOYALTY != iptparam->PayUnit)
						{
							if(IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType)	voice[0]=SPKW_OILPLEASE;	 //女声
							else												voice[0]=SPKM_OILPLEASE; //男生	
							iptSpk(iptparam, voice, 1);
						}
					}
					iptIcBalanceDsp(iptparam->Id);
					iptPidSet(iptparam, IPT_PID_IC_BALANCE);

					//促销机通知平板油机状态
					if(1 == paramPromotionGet())
					{
						iptparam->TaState = IPT_STATE_CARD_BALANCE;	iptparam->TaStateParamLength = 0;
						memcpy(iptparam->TaStateParam + 0, iptparam->IcAppId, 10);
						memcpy(iptparam->TaStateParam + 10, iptparam->IcBalance, 4);
						if(IPT_PAYUNIT_MONEY == iptparam->PayUnit)	*(iptparam->TaStateParam + 14) = 0;
						else																			*(iptparam->TaStateParam + 14) = 1;
						*(iptparam->TaStateParam + 15) = (char)(0>>24);	*(iptparam->TaStateParam + 16) = (char)(0>>16);
						*(iptparam->TaStateParam + 17) = (char)(0>>8);		*(iptparam->TaStateParam + 18) = (char)(0>>0);
						if(IPT_PRESET_VOLUME == iptparam->PresetMode)	*(iptparam->TaStateParam + 19) = 1;
						else																					*(iptparam->TaStateParam + 19) = 0;
						*(iptparam->TaStateParam + 20) = 0x01;
						iptparam->TaStateParamLength = 21;
						pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
					}

					return;
				}
				else
				{
					memcpy(dsp_buffer,iptparam->etc_recnet_oil,10);
					memcpy(dsp_buffer+10,iptparam->etc_now_oil,10);
					dsp(iptparam->DEVDsp,DSP_ETC_OILCR,dsp_buffer,20);
					iptPidSet(iptparam, ETC_PID_OIL_SURE);
					return;
				}
			}					

			//卡已读出余额
			iptparam->IcValid=1;

			//结算方式默认为现金
			iptparam->Payment=IPT_PAYMENT_MONEY;

			//卡余额信息
			memcpy(iptparam->IcBalance, &buffer[2], 4);

			//初始化预置数据
			memset(iptparam->IntegerBuffer, 0, sizeof(iptparam->IntegerBuffer));		iptparam->IntegerLen=0;
			iptparam->Point=0;
			memset(iptparam->DecimalBuffer, 0, sizeof(iptparam->DecimalBuffer));	iptparam->DecimalLen=0;
			iptparam->PresetMode=IPT_PRESET_NO;	iptparam->PresetVolume=0;	iptparam->PresetMoney=0;

			//下班状态，转入上班处理过程，前面已判断下班状态不允许用户卡插卡
			if(IPT_WORK_OFFDUTY==iptparam->WorkState)
			{
				memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;

				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "上班?", 5);
				iptPidSet(iptparam, IPT_PID_IC_LOGIN);
			}
			//用户卡，非促销机，转入按确认键释放静电的过程
			else if(ICTYPE_USER==iptparam->IcAppId[2] && 1 != paramPromotionGet())
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "按确认键显示余额", 16);
				iptPidSet(iptparam, IPT_PID_IC_USER_ACK);
			}
			//用户卡，促销机,非油品确认，转入按确认键释放静电的过程
			else if(ICTYPE_USER==iptparam->IcAppId[2] && 1 == paramPromotionGet()&&iptparam->TabletGradeTag==PC_FUN_GRADE_NO)
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "按确认键显示余额", 16);
				iptPidSet(iptparam, IPT_PID_IC_USER_ACK);
			}
			//上班状态，其它类型卡直接显示卡余额
			else
			{
				if(ICTYPE_USER==iptparam->IcAppId[2] && 0 == iptparam->UserElecFlag && iptparam->VoiceVolume > 0)
				{
					if(IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType)	voice[0]=SPKW_OILPLEASE;	//女声
					else																				voice[0]=SPKM_OILPLEASE;	//男声
					iptSpk(iptparam, voice, 1);
					iptparam->UserElecFlag = 1;
				}
			
				iptIcBalanceDsp(iptparam->Id);
				iptPidSet(iptparam, IPT_PID_IC_BALANCE);

				//促销机通知平板油机状态
				if(1 == paramPromotionGet())
				{
					iptparam->TaState = IPT_STATE_CARD_BALANCE;	iptparam->TaStateParamLength = 0;
					memcpy(iptparam->TaStateParam + 0, iptparam->IcAppId, 10);
					memcpy(iptparam->TaStateParam + 10, iptparam->IcBalance, 4);
					if(IPT_PAYUNIT_MONEY == iptparam->PayUnit)	*(iptparam->TaStateParam + 14) = 0;
					else																			*(iptparam->TaStateParam + 14) = 1;
					*(iptparam->TaStateParam + 15) = (char)(0>>24);	*(iptparam->TaStateParam + 16) = (char)(0>>16);
					*(iptparam->TaStateParam + 17) = (char)(0>>8);		*(iptparam->TaStateParam + 18) = (char)(0>>0);
					if(IPT_PRESET_VOLUME == iptparam->PresetMode)	*(iptparam->TaStateParam + 19) = 1;
					else																					*(iptparam->TaStateParam + 19) = 0;
					*(iptparam->TaStateParam + 20) = 0x01;
					iptparam->TaStateParamLength = 21;
					pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
				}
			}

			//如果是促销机则通知平板电脑有卡插入，保存卡信息、卡交易记录信息
			if(1 == paramPromotionGet())
			{
				if(IPT_PAYUNIT_MONEY==iptparam->PayUnit)	appselect = 0;	//电子油票
				else																		appselect = 1;	//积分应用

				memset(&cardinfo, 0, sizeof(PCCardInfoType));
				cardinfo.IcValid = 1;																						//有有效卡信息
				cardinfo.IcAppSelect = appselect;																	//账户类型
				memcpy(cardinfo.IcAppId, iptparam->IcAppId, 10);										//应用序列号
				memcpy(cardinfo.IcEnableTime, iptparam->IcEnableTime, 4);						//应用启用日期
				memcpy(cardinfo.IcInvalidTime, iptparam->IcInvalidTime, 4);						//应用有效截止日期
				memcpy(cardinfo.IcUserName, iptparam->IcUserName, 20);						//持卡人姓名
				memcpy(cardinfo.IcUserIdeId, iptparam->IcUserIdeId, 18);							//持卡人证件(identity)号码(ASCII)
				memcpy(&cardinfo.IcUserIdeType, &iptparam->IcUserIdeType, 1);				//持卡人证件类型
				memcpy(cardinfo.IcOilLimit, iptparam->IcOilLimit, 2);									//油品限制
				memcpy(&cardinfo.IcRegionTypeLimit, &iptparam->IcRegionTypeLimit, 1);	//限地区,油站加油方式
				memcpy(cardinfo.IcRegionLimit, iptparam->IcRegionLimit, 40);					//限地区,油站加油
				memcpy(cardinfo.IcVolumeLimit, iptparam->IcVolumeLimit, 2);					//限每次加油量
				memcpy(&cardinfo.IcTimesLimit, &iptparam->IcTimesLimit, 1);					//限每天加油次数
				memcpy(cardinfo.IcMoneyDayLimit, iptparam->IcMoneyDayLimit, 4);			//限每天加油金额
				memcpy(cardinfo.IcCarIdLimit, iptparam->IcCarIdLimit, 16);						//车牌号限制(ASCII)
				pcCardInfoWrite(iptparam->TabletPanel, iptparam->LogicNozzle, cardinfo);

				for(i = 0; i < iptparam->IcRecordNumber && i < 10; i++)
				{
					memcpy(cardrecord[i].TTC, iptparam->IcRecord[i].TTC, 2);						//ET联机或脱机交易序号
					memcpy(cardrecord[i].Limit, iptparam->IcRecord[i].Limit, 3);					//透支限额
					memcpy(cardrecord[i].Money, iptparam->IcRecord[i].Money, 4);			//交易金额
					memcpy(&cardrecord[i].Type, &iptparam->IcRecord[i].Type, 1);				//交易类型标识
					memcpy(cardrecord[i].TermID, iptparam->IcRecord[i].TermID, 6);			//终端机编号
					memcpy(cardrecord[i].Time, iptparam->IcRecord[i].Time, 7);					//交易时间
				}
				
				pcCardRecordWrite(iptparam->TabletPanel, iptparam->LogicNozzle, cardrecord, iptparam->IcRecordNumber, appselect);
			}

			//打印卡插入信息
			memset(dsp_buffer, 0, sizeof(dsp_buffer));
			hex2Ascii(iptparam->IcAppId, 10, dsp_buffer, 20);	
			dsp_len = (iptparam->IcBalance[0]<<24)|(iptparam->IcBalance[1]<<16)|(iptparam->IcBalance[2]<<8)|(iptparam->IcBalance[3]<<0);
			jljRunLog("有卡插入:[主板号=%d][面板号=%d][卡号=%s][余额=%u].\n", pcdMboardIDRead(), iptparam->Id, dsp_buffer, dsp_len);
		}
		
		//读卡余额失败
		else
		{
			memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
			dsp_buffer[2]=12;	memcpy(&dsp_buffer[3], "读卡余额失败", 12);
			dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);iptMainInterface(iptparam);
		}
	}
	//操作失败则提示信息后退卡
	else
	if(ICSTATE_FAILED==istate)
	{
		iptparam->IcOverTimes=0;

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "读卡余额失败", 12);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);iptMainInterface(iptparam);
	}
	//操作超时，不足三次再次操作，超过三次退卡
	else
	if(ICSTATE_OVERTIME==istate)
	{
		iptparam->IcOverTimes++;
		if(iptparam->IcOverTimes>=3)
		{
			iptparam->IcOverTimes=0;
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "读卡余额超时", 12);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);iptMainInterface(iptparam);
		}
	}
	//未定义错误
	else
	{
		iptparam->IcOverTimes=0;
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "读卡余额错误", 12);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);iptMainInterface(iptparam);
	}

	return;
}


/*******************************************************************
*Name				:iptIcBalanceUserAck
*Description		:IC卡余额显示用户确认界面
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcBalanceUserAck(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char dsp_buffer[64]={0}, dsp_len=0;
	int voice[16]={0};

	//退卡
	if(KB_BUTTON_BACK == iptparam->Button)
	{
		ICShoot(iptparam->DEVIC);
		iptMainInterface(iptparam);
		return;
	}

	//如果插卡后已经通过按确认键的操作则直接转入余额界面
	if(0 != iptparam->UserElecFlag)
	{
		iptIcBalanceDsp(iptparam->Id);
		iptPidSet(iptparam, IPT_PID_IC_BALANCE);
		return;
	}

	//客户按键或积分应用(插卡时默认的电子油票应用已有按键)，语音提示"请提枪加油或以定量方式加油"并转入余额界面
	if(KB_BUTTON_NO!=iptparam->Button || IPT_PAYUNIT_LOYALTY==iptparam->PayUnit)
	{
		if(iptparam->VoiceVolume > 0 && IPT_PAYUNIT_LOYALTY != iptparam->PayUnit)
		{
			if(IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType)	voice[0]=SPKW_OILPLEASE;	//女声
			else																				voice[0]=SPKM_OILPLEASE;	//男声
			iptSpk(iptparam, voice, 1);
		}

		iptparam->UserElecFlag = 1;

		iptIcBalanceDsp(iptparam->Id);
		iptPidSet(iptparam, IPT_PID_IC_BALANCE);

		//促销机通知平板油机状态
		if(1 == paramPromotionGet())
		{
			iptparam->TaState = IPT_STATE_CARD_BALANCE;	iptparam->TaStateParamLength = 0;
			memcpy(iptparam->TaStateParam + 0, iptparam->IcAppId, 10);
			memcpy(iptparam->TaStateParam + 10, iptparam->IcBalance, 4);
			if(IPT_PAYUNIT_MONEY == iptparam->PayUnit)	*(iptparam->TaStateParam + 14) = 0;
			else																		*(iptparam->TaStateParam + 14) = 1;
			*(iptparam->TaStateParam + 15) = (char)(0>>24);	*(iptparam->TaStateParam + 16) = (char)(0>>16);
			*(iptparam->TaStateParam + 17) = (char)(0>>8);		*(iptparam->TaStateParam + 18) = (char)(0>>0);
			if(IPT_PRESET_VOLUME == iptparam->PresetMode)	*(iptparam->TaStateParam + 19) = 1;
			else																				*(iptparam->TaStateParam + 19) = 0;
			*(iptparam->TaStateParam + 20) = 0x01;
			iptparam->TaStateParamLength = 21;
			pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
		}
		
		return;
	}

	return;
}


/*******************************************************************
*Name				:iptIcBalance
*Description		:IC卡余额界面处理过程
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcBalance(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	int voice[16] = {0};
	unsigned char button = 0;
	unsigned int data = 0;
	unsigned char dsp_buffer[64] = {0}, dsp_len = 0;

	//按键处理
	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0==button)	button='0';
	case KB_BUTTON_1:
		if(0==button)	button='1';
	case KB_BUTTON_2:
		if(0==button)	button='2';
	case KB_BUTTON_3:
		if(0==button)	button='3';
	case KB_BUTTON_4:
		if(0==button)	button='4';
	case KB_BUTTON_5:
		if(0==button)	button='5';
	case KB_BUTTON_6:
		if(0==button)	button='6';
	case KB_BUTTON_7:
		if(0==button)	button='7';
	case KB_BUTTON_8:
		if(0==button)	button='8';
	case KB_BUTTON_9:
		if(0==button)	button='9';
	case KB_BUTTON_CZ:
		if(0==button)	button='.';

		//记录小数点
		if('.'==button)
		{
			iptparam->Point='.';
		}
		//前一刻无小数点按键操作，记录按键值为整数，260升大流量最多允许6位整数输入，普通机最多允许四位整数
		else if(0==iptparam->Point)
		{
			if(1 == iptIsBig260(iptparam->Id))
			{
				iptparam->IntegerBuffer[0]=iptparam->IntegerBuffer[1];	iptparam->IntegerBuffer[1]=iptparam->IntegerBuffer[2];
			}
			else
			{
				iptparam->IntegerBuffer[0] = '0';	iptparam->IntegerBuffer[1] = '0';
			}
			iptparam->IntegerBuffer[2]=iptparam->IntegerBuffer[3];	iptparam->IntegerBuffer[3]=iptparam->IntegerBuffer[4];	
			iptparam->IntegerBuffer[4]=iptparam->IntegerBuffer[5];	iptparam->IntegerBuffer[5]=button;
		}
		//前一刻有小数点按键操作，记录按键值为小数
		else if(0!=iptparam->Point && iptparam->DecimalLen<2)
		{
			iptparam->DecimalBuffer[iptparam->DecimalLen++]=button;	
		}

		//非预置模式默认为预置金额
		if(IPT_PRESET_NO==iptparam->PresetMode)	iptparam->PresetMode=IPT_PRESET_MONEY;

		//计算预置值
		data=(iptparam->IntegerBuffer[0]&0x0f)*10000000+(iptparam->IntegerBuffer[1]&0x0f)*1000000+\
			(iptparam->IntegerBuffer[2]&0x0f)*100000+(iptparam->IntegerBuffer[3]&0x0f)*10000+\
			(iptparam->IntegerBuffer[4]&0x0f)*1000+(iptparam->IntegerBuffer[5]&0x0f)*100+\
			(iptparam->DecimalBuffer[0]&0x0f)*10+(iptparam->DecimalBuffer[1]&0x0f)*1;

		//显示预置界面
		dsp_buffer[0]=(char)(data>>24);	dsp_buffer[1]=(char)(data>>16);
		dsp_buffer[2]=(char)(data>>8);	dsp_buffer[3]=(char)(data>>0);
		if(IPT_PRESET_VOLUME==iptparam->PresetMode)		dsp_buffer[4]=1;
		else	if(IPT_PAYUNIT_MONEY==iptparam->PayUnit)	dsp_buffer[4]=0;
		else	if(IPT_PAYUNIT_LOYALTY==iptparam->PayUnit)	dsp_buffer[4]=2;
		dsp_len=5;
		dsp(iptparam->DEVDsp, DSP_CARD_PRESET, dsp_buffer, dsp_len);

		//促销机通知平板电脑状态
		if(1 == paramPromotionGet())
		{
			iptparam->TaState = IPT_STATE_CARD_BALANCE;	iptparam->TaStateParamLength = 0;
			memcpy(iptparam->TaStateParam + 0, iptparam->IcAppId, 10);
			memcpy(iptparam->TaStateParam + 10, iptparam->IcBalance, 4);
			if(IPT_PAYUNIT_MONEY == iptparam->PayUnit)	*(iptparam->TaStateParam + 14) = 0;
			else																		*(iptparam->TaStateParam + 14) = 1;
			*(iptparam->TaStateParam + 15) = (char)(data>>24);	*(iptparam->TaStateParam + 16) = (char)(data>>16);
			*(iptparam->TaStateParam + 17) = (char)(data>>8);	*(iptparam->TaStateParam + 18) = (char)(data>>0);
			if(IPT_PRESET_VOLUME == iptparam->PresetMode)	*(iptparam->TaStateParam + 19) = 1;
			else																				*(iptparam->TaStateParam + 19) = 0;
			*(iptparam->TaStateParam + 20) = 0x01;
			iptparam->TaStateParamLength = 21;
			pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
		}
		break;

	case KB_BUTTON_MON:
	case KB_BUTTON_VOL:
		//计算预置值
		data=(iptparam->IntegerBuffer[0]&0x0f)*10000000+(iptparam->IntegerBuffer[1]&0x0f)*1000000+\
			(iptparam->IntegerBuffer[2]&0x0f)*100000+(iptparam->IntegerBuffer[3]&0x0f)*10000+\
			(iptparam->IntegerBuffer[4]&0x0f)*1000+(iptparam->IntegerBuffer[5]&0x0f)*100+\
			(iptparam->DecimalBuffer[0]&0x0f)*10+(iptparam->DecimalBuffer[1]&0x0f)*1;

		//更改预置方式
		if(KB_BUTTON_MON==iptparam->Button)	iptparam->PresetMode=IPT_PRESET_MONEY;
		else																	iptparam->PresetMode=IPT_PRESET_VOLUME;
		dsp_buffer[0]=(char)(data>>24);	dsp_buffer[1]=(char)(data>>16);
		dsp_buffer[2]=(char)(data>>8);		dsp_buffer[3]=(char)(data>>0);
		if(IPT_PRESET_VOLUME==iptparam->PresetMode)		dsp_buffer[4]=1;
		else	if(IPT_PAYUNIT_MONEY==iptparam->PayUnit)	dsp_buffer[4]=0;
		else	if(IPT_PAYUNIT_LOYALTY==iptparam->PayUnit)	dsp_buffer[4]=2;
		dsp_len=5;
		dsp(iptparam->DEVDsp, DSP_CARD_PRESET, dsp_buffer, dsp_len);

		//促销机通知平板电脑状态
		if(1 == paramPromotionGet())
		{
			iptparam->TaState = IPT_STATE_CARD_BALANCE;	iptparam->TaStateParamLength = 0;
			memcpy(iptparam->TaStateParam + 0, iptparam->IcAppId, 10);
			memcpy(iptparam->TaStateParam + 10, iptparam->IcBalance, 4);
			if(IPT_PAYUNIT_MONEY == iptparam->PayUnit)	*(iptparam->TaStateParam + 14) = 0;
			else																		*(iptparam->TaStateParam + 14) = 1;
			*(iptparam->TaStateParam + 15) = (char)(data>>24);	*(iptparam->TaStateParam + 16) = (char)(data>>16);
			*(iptparam->TaStateParam + 17) = (char)(data>>8);	*(iptparam->TaStateParam + 18) = (char)(data>>0);
			if(IPT_PRESET_VOLUME == iptparam->PresetMode)	*(iptparam->TaStateParam + 19) = 1;
			else																				*(iptparam->TaStateParam + 19) = 0;
			iptparam->TaStateParamLength = 20;
			pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
		}
		break;

	case KB_BUTTON_CHG:
		//计算预置值
		data=(iptparam->IntegerBuffer[0]&0x0f)*10000000+(iptparam->IntegerBuffer[1]&0x0f)*1000000+\
			(iptparam->IntegerBuffer[2]&0x0f)*100000+(iptparam->IntegerBuffer[3]&0x0f)*10000+\
			(iptparam->IntegerBuffer[4]&0x0f)*1000+(iptparam->IntegerBuffer[5]&0x0f)*100+\
			(iptparam->DecimalBuffer[0]&0x0f)*10+(iptparam->DecimalBuffer[1]&0x0f)*1;

		//如果预置量为0显示卡余额界面，否则清空预置量
		if(0==data)
		{
			iptIcBalanceDsp(iptparam->Id);
		}
		else
		{
			dsp_buffer[0]=(char)(0>>24);	dsp_buffer[1]=(char)(0>>16);
			dsp_buffer[2]=(char)(0>>8);	dsp_buffer[3]=(char)(0>>0);
			if(IPT_PRESET_VOLUME==iptparam->PresetMode)		dsp_buffer[4]=1;
			else	if(IPT_PAYUNIT_MONEY==iptparam->PayUnit)	dsp_buffer[4]=0;
			else	if(IPT_PAYUNIT_LOYALTY==iptparam->PayUnit)	dsp_buffer[4]=2;
			dsp_len=5;
			dsp(iptparam->DEVDsp, DSP_CARD_PRESET, dsp_buffer, dsp_len);
		}

		//清空预置数据
		memset(iptparam->IntegerBuffer, 0, sizeof(iptparam->IntegerBuffer));		iptparam->IntegerLen=0;
		iptparam->Point=0;
		memset(iptparam->DecimalBuffer, 0, sizeof(iptparam->DecimalBuffer));	iptparam->DecimalLen=0;
		iptparam->PresetMode=IPT_PRESET_NO;

		//促销机通知平板电脑状态
		if(1 == paramPromotionGet())
		{
			iptparam->TaState = IPT_STATE_CARD_BALANCE;	iptparam->TaStateParamLength = 0;
			memcpy(iptparam->TaStateParam + 0, iptparam->IcAppId, 10);
			memcpy(iptparam->TaStateParam + 10, iptparam->IcBalance, 4);
			if(IPT_PAYUNIT_MONEY == iptparam->PayUnit)	*(iptparam->TaStateParam + 14) = 0;
			else																		*(iptparam->TaStateParam + 14) = 1;
			*(iptparam->TaStateParam + 15) = (char)(0>>24);	*(iptparam->TaStateParam + 16) = (char)(0>>16);
			*(iptparam->TaStateParam + 17) = (char)(0>>8);		*(iptparam->TaStateParam + 18) = (char)(0>>0);
			if(IPT_PRESET_VOLUME == iptparam->PresetMode)	*(iptparam->TaStateParam + 19) = 1;
			else																				*(iptparam->TaStateParam + 19) = 0;
			iptparam->TaStateParamLength = 20;
			pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
		}
		break;

	case KB_BUTTON_ACK:
		//判断是否为输入"凑整/."+"确认"
		if(!('.'==iptparam->Point &&\
			0==memcmp(iptparam->IntegerBuffer, "\x00\x00\x00\x00", 4) &&\
			0==memcmp(iptparam->DecimalBuffer, "\x00\x00", 2)))
		{
			break;
		}
		
		//确认，如果前一刻有且仅有按键"."，该卡为上班员工卡或验泵卡则转入下班确认过程
		if(0x05==iptparam->IcAppId[2]||\
			(0x04==iptparam->IcAppId[2]&&iptparam->EMP==iptparam->IcStaffId)||\
			0==memcmp(iptparam->IcAppId, iptparam->EMPCardID, 10))
		{
			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "下班?", 5);
			iptPidSet(iptparam, IPT_PID_IC_LOGOUT);
			break;
		}
		break;

	case KB_BUTTON_SEL:
		//用户卡选择结算单位电子油票，中燃联达不允许用户卡选择其它应用
		if(1 == iptparam->IcAppId[2] && 1 != iptIsLianda(iptparam->Id))
		{
			//清空预置数据
			memset(iptparam->IntegerBuffer, 0, sizeof(iptparam->IntegerBuffer));		iptparam->IntegerLen=0;
			iptparam->Point=0;
			memset(iptparam->DecimalBuffer, 0, sizeof(iptparam->DecimalBuffer));	iptparam->DecimalLen=0;
			iptparam->PresetMode=IPT_PRESET_NO;
		
			dsp(iptparam->DEVDsp, DSP_CARD_UNIT_SELECT, "\x00", 0);
			iptPidSet(iptparam, IPT_PID_IC_PAY_UNIT);
			break;
		}

		//员工卡选择结算方式
		if(4==iptparam->IcAppId[2])
		{
			//清空预置数据
			memset(iptparam->IntegerBuffer, 0, sizeof(iptparam->IntegerBuffer));		iptparam->IntegerLen=0;
			iptparam->Point=0;
			memset(iptparam->DecimalBuffer, 0, sizeof(iptparam->DecimalBuffer));	iptparam->DecimalLen=0;
			iptparam->PresetMode=IPT_PRESET_NO;

			dsp(iptparam->DEVDsp, DSP_CARD_SETTLE_SELECT, "\x00", 0);
			iptPidSet(iptparam, IPT_PID_IC_PAY_MODE);
			break;
		}
		break;

	case KB_BUTTON_BACK:
		//退卡
		memset(iptparam->IntegerBuffer, 0, sizeof(iptparam->IntegerBuffer));		iptparam->IntegerLen=0;
		iptparam->Point=0;
		memset(iptparam->DecimalBuffer, 0, sizeof(iptparam->DecimalBuffer));	iptparam->DecimalLen=0;
		iptparam->PresetMode=IPT_PRESET_NO;

		ICShoot(iptparam->DEVIC);
		iptMainInterface(iptparam);
		break;
	default:
		break;
	}

	//促销机外部预置数据
	if(1 == paramPromotionGet() && 1 == iptparam->CardPresetAsk)
	{
		data = iptparam->CardPresetValue;
		iptparam->IntegerBuffer[0] = (char)(data/10000000%10) + 0x30;
		iptparam->IntegerBuffer[1] = (char)(data/1000000%10) + 0x30;
		iptparam->IntegerBuffer[2] = (char)(data/100000%10) + 0x30;
		iptparam->IntegerBuffer[3] = (char)(data/10000%10) + 0x30;
		iptparam->IntegerBuffer[4] = (char)(data/1000%10) + 0x30;
		iptparam->IntegerBuffer[5] = (char)(data/100%10) + 0x30;
		if(0 != data%100) iptparam->Point = 1;
		iptparam->DecimalBuffer[0] = (char)(data/10%10) + 0x30;
		iptparam->DecimalBuffer[1] = (char)(data/1%10) + 0x30;

		
		if(0 == iptparam->CardPresetMode)	iptparam->PresetMode = IPT_PRESET_VOLUME;
		else														iptparam->PresetMode = IPT_PRESET_MONEY;
		dsp_buffer[0]=(char)(data>>24);	dsp_buffer[1]=(char)(data>>16);
		dsp_buffer[2]=(char)(data>>8);	dsp_buffer[3]=(char)(data>>0);
		if(IPT_PRESET_VOLUME==iptparam->PresetMode)		dsp_buffer[4]=1;
		else	if(IPT_PAYUNIT_MONEY==iptparam->PayUnit)	dsp_buffer[4]=0;
		else	if(IPT_PAYUNIT_LOYALTY==iptparam->PayUnit)	dsp_buffer[4]=2;
		dsp_len=5;
		dsp(iptparam->DEVDsp, DSP_CARD_PRESET, dsp_buffer, dsp_len);


		iptparam->CardPresetAsk = 0xFF;	iptparam->CardPresetRep = 0;


		iptparam->TaState = IPT_STATE_CARD_BALANCE;	iptparam->TaStateParamLength = 0;
		memcpy(iptparam->TaStateParam + 0, iptparam->IcAppId, 10);
		memcpy(iptparam->TaStateParam + 10, iptparam->IcBalance, 4);
		if(IPT_PAYUNIT_MONEY == iptparam->PayUnit)	*(iptparam->TaStateParam + 14) = 0;
		else																		*(iptparam->TaStateParam + 14) = 1;
		*(iptparam->TaStateParam + 15) = (char)(data>>24);	*(iptparam->TaStateParam + 16) = (char)(data>>16);
		*(iptparam->TaStateParam + 17) = (char)(data>>8);	*(iptparam->TaStateParam + 18) = (char)(data>>0);
		if(IPT_PRESET_VOLUME == iptparam->PresetMode)	*(iptparam->TaStateParam + 19) = 1;
		else																				*(iptparam->TaStateParam + 19) = 0;
		iptparam->TaStateParamLength = 20;
		pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
	}

	//促销机外部弹卡请求
	if(1 == paramPromotionGet() && 1 == iptparam->CardShootAsk)
	{
		ICShoot(iptparam->DEVIC);
		iptMainInterface(iptparam);
	
		iptparam->CardShootAsk = 0xFF;	iptparam->CardShootRep = 0;
		return;
	}

	//卡被拔出则返回待机状态,szb_fj_20171120,update
	if((0x30!=iptparam->IcState.DeckStateS1) && iptparam->EtcOilFlg == 0)
	{
		iptMainInterface(iptparam);
		return;
	}

	//断电后退卡并返回待机状态
	if(POWER_STATE_OK!=powerStateRead())
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "油机掉电", 8);
		ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
		iptMainInterface(iptparam);
		return;
	}

#if _IPT_DEBUG_
	//调试状态提枪状态则以预置100元开始启动加油
	if(1==IsOilAtuo && IPT_GUN_PUTUP==iptparam->GunState)
	{
		iptparam->IntegerBuffer[0]='0';	iptparam->IntegerBuffer[1]='0';
		iptparam->IntegerBuffer[2]='0';	iptparam->IntegerBuffer[3]='1';
		iptparam->IntegerBuffer[4]='0';	iptparam->IntegerBuffer[5]='0';
		iptparam->DecimalBuffer[0]='0';	iptparam->DecimalBuffer[1]='0';
		iptparam->PresetMode=IPT_PRESET_MONEY;

		iptPidSet(iptparam, IPT_PID_IC_OILCHECK);
		return;
	}
	else if(1!=IsOilAtuo && IPT_GUN_PUTUP==iptparam->GunState && 0!=iptparam->GunStateChg)
	{
		iptPidSet(iptparam, IPT_PID_IC_OILCHECK);
		return;
	}
#else	//else	_IPT_DEBUG_
	//260升大流量程序按向下键转入下一步；
	//非260升大流量程序提枪转入下一步；
	//	促销机提示并转入确认油品的界面；
	//	非促销机转入加油数据检查过程；
	
	if((1 == iptIsBig260(iptparam->Id) && KB_BUTTON_DOWN == iptparam->Button)||\
		(1 != iptIsBig260(iptparam->Id) && IPT_GUN_PUTUP == iptparam->GunState && 0 != iptparam->GunStateChg))
	{
		if(1 == paramPromotionGet())
		{
			if(iptparam->TabletGradeTag==PC_FUN_GRADE_OK)
				{
					pcYPLightTurnOn(iptparam->TabletPanel, iptparam->LogicNozzle);
				
					memset(dsp_buffer, 0, sizeof(dsp_buffer));	strcpy(dsp_buffer, iptparam->OilName);
					pcOilConfirm(iptparam->TabletPanel, iptparam->LogicNozzle, 1, dsp_buffer);
				}

			//语音提示"此油枪加注XX，泵码已回零，请确认"
			if(iptparam->VoiceVolume>0 && IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType)
			{
				voice[0]=SPKW_OILFILL;															//此油枪加注
																												//油品语音代码
				if(0==memcmp(iptparam->OilVoice, "\x00\x00\x00\x00", 4))
					voice[1]=iptOilVoiceIdGet(iptparam, iptparam->OilCode);
				else
					voice[1]=((iptparam->OilVoice[0]&0x0f)<<12)|((iptparam->OilVoice[1]&0x0f)<<8)|\
									((iptparam->OilVoice[2]&0x0f)<<4)|((iptparam->OilVoice[3]&0x0f)<<0);
				voice[2]=SPKW_ACK;															//泵码已回零，请确认
				iptSpk(iptparam, voice, 3);
			}
			else if(iptparam->VoiceVolume>0 && IPT_VOICE_TYPE_MAN==iptparam->VoiceType)
			{
				voice[0]=SPKM_OILFILL;															//此油枪加注
																												//油品语音代码
				if(0==memcmp(iptparam->OilVoice, "\x00\x00\x00\x00", 4))
					voice[1]=iptOilVoiceIdGet(iptparam, iptparam->OilCode);
				else
					voice[1]=((iptparam->OilVoice[0]&0x0f)<<12)|((iptparam->OilVoice[1]&0x0f)<<8)|\
									((iptparam->OilVoice[2]&0x0f)<<4)|((iptparam->OilVoice[3]&0x0f)<<0);
				voice[2]=SPKM_ACK;															//泵码已回零，请确认
				iptSpk(iptparam, voice, 3);
			}
			if(iptparam->TabletGradeTag==PC_FUN_GRADE_OK)
				{
					iptparam->YPSelect = 0;
					dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "按PLAY键确认油品或确认键确认油品", strlen("按PLAY键确认油品或确认键确认油品"));
					iptPidSet(iptparam, IPT_PID_IC_OIL_ACK);
				}
			else
				{
					iptPidSet(iptparam, IPT_PID_IC_OILCHECK);
				}
		}
		else
		{
			iptPidSet(iptparam, IPT_PID_IC_OILCHECK);
		}
		
		return;
	}
#endif	//end	_IPT_DEBUG_

	return;
}


/*******************************************************************
*Name				:iptIcUnitSelect
*Description		:结算单位选择
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcPayUnitSelect(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char dsp_buffer[64]={0}, dsp_len=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_1:
		//
		//	选择"电子油票"，当前为电子油票返回卡余界面，
		//	否则更改支付方式并进行卡处理
		
		if(IPT_PAYUNIT_MONEY==iptparam->PayUnit)
		{
			iptIcBalanceDsp(iptparam->Id);
			iptPidSet(iptparam, IPT_PID_IC_BALANCE);
		}
		else
		{
			iptparam->PayUnit=IPT_PAYUNIT_MONEY;	iptparam->DS=IPT_PAYUNIT_MONEY;

			//促销机通知平板油机状态
			if(1 == paramPromotionGet())
			{
				iptparam->TaState = IPT_STATE_CARD_PRETREAT;	iptparam->TaStateParamLength = 0;
				pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
			}

			dsp(iptparam->DEVDsp, DSP_CARD_PRETREAT, "\x00", 0);
			iptPidSet(iptparam, IPT_PID_IC_PRETREAT);

			iptparam->etc_touming_flg=0;
			iptparam->Step=1;
		}
		break;
		
	case KB_BUTTON_2:
		//
		//	选择"积分应用"，当前为积分应用返回卡余界面，
		//	否则更改支付方式并进行卡处理
		
		if(IPT_PAYUNIT_LOYALTY==iptparam->PayUnit)
		{
			iptIcBalanceDsp(iptparam->Id);
			iptPidSet(iptparam, IPT_PID_IC_BALANCE);
		}
		else
		{
			iptparam->PayUnit=IPT_PAYUNIT_LOYALTY;	iptparam->DS=IPT_PAYUNIT_LOYALTY;

			dsp(iptparam->DEVDsp, DSP_CARD_PRETREAT, "\x00", 0);
			iptPidSet(iptparam, IPT_PID_IC_PRETREAT);

			iptparam->etc_touming_flg=0;
			iptparam->Step=1;
		}
		break;

	case KB_BUTTON_CHG:
		//按"更改"键返回卡余额界面
		iptIcBalanceDsp(iptparam->Id);
		iptPidSet(iptparam, IPT_PID_IC_BALANCE);
		break;
		
	case KB_BUTTON_BACK:
		//按"退卡"键退卡
		ICShoot(iptparam->DEVIC);
		iptMainInterface(iptparam);
		break;
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptIcPayModeSelect
*Description		:结算方式选择
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcPayModeSelect(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char dsp_buffer[64]={0}, dsp_len=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_1:	//选择现金
	case KB_BUTTON_2:	//选择油票
	case KB_BUTTON_3:	//选择提油凭证
	case KB_BUTTON_4:	//选择银行卡
	case KB_BUTTON_5:	//选择其它一
	case KB_BUTTON_6:	//选择其它二
		//选择结算方式后显示并返回余额界面
		if(KB_BUTTON_1==iptparam->Button)	iptparam->Payment=IPT_PAYMENT_MONEY;
		if(KB_BUTTON_2==iptparam->Button)	iptparam->Payment=IPT_PAYMENT_OILTICKET;
		if(KB_BUTTON_3==iptparam->Button)	iptparam->Payment=IPT_PAYMENT_OILCHECK;
		if(KB_BUTTON_4==iptparam->Button)	iptparam->Payment=IPT_PAYMENT_BANK;
		if(KB_BUTTON_5==iptparam->Button)	iptparam->Payment=IPT_PAYMENT_OTHER1;
		if(KB_BUTTON_6==iptparam->Button)	iptparam->Payment=IPT_PAYMENT_OTHER2;				

		iptIcBalanceDsp(iptparam->Id);
		iptPidSet(iptparam, IPT_PID_IC_BALANCE);
		break;

	case KB_BUTTON_CHG:
		//按"更改"键返回卡余额界面
		iptIcBalanceDsp(iptparam->Id);
		iptPidSet(iptparam, IPT_PID_IC_BALANCE);
		break;

	case KB_BUTTON_BACK:
		//按"退卡"键退卡
		ICShoot(iptparam->DEVIC);
		iptMainInterface(iptparam);
		break;
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptIcLogin
*Description		:员工上班登陆确认
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcLogin(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	switch(iptparam->Button)
	{
	case KB_BUTTON_BACK:
		//选择退卡
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		ICShoot(iptparam->DEVIC);
		iptMainInterface(iptparam);
		break;

	case KB_BUTTON_CZ:
		//按"凑整/."键
		if(0==iptparam->SetButtonLen)	iptparam->SetButton[iptparam->SetButtonLen++]='.';
		break;
	case KB_BUTTON_ACK:
		//选择"."+"确认"上班，否则退卡
		if('.'==iptparam->SetButton[0]){

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_CARD_STAFF_PASSIN, "\x00", 1);
			iptPidSet(iptparam, IPT_PID_IC_LOG_PASSIN);
		}
		else{

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			ICShoot(iptparam->DEVIC);
			iptMainInterface(iptparam);
		}
		break;

	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptIcLogPassin
*Description		:员工上班登陆密码输入界面
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcLogPassin(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char password[8]={0}, buffer[128]={0}, tmp_buffer[16]={0}, tmp_buffer2[16]={0};
	unsigned char dsp_buffer[64]={0}, dsp_len=0, button=0;
	unsigned long long money_sum=0, volume_sum=0;
	int istate=0;
	
	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0==button)	button='0';
	case KB_BUTTON_1:
		if(0==button)	button='1';
	case KB_BUTTON_2:
		if(0==button)	button='2';
	case KB_BUTTON_3:
		if(0==button)	button='3';
	case KB_BUTTON_4:
		if(0==button)	button='4';
	case KB_BUTTON_5:
		if(0==button)	button='5';
	case KB_BUTTON_6:
		if(0==button)	button='6';
	case KB_BUTTON_7:
		if(0==button)	button='7';
	case KB_BUTTON_8:
		if(0==button)	button='8';
	case KB_BUTTON_9:
		if(0==button)	button='9';

		//保存输入的密码
		if(iptparam->SetButtonLen<4)
		{
			iptparam->SetButton[iptparam->SetButtonLen++]=button;
			dsp_buffer[0]=iptparam->SetButtonLen;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_CARD_STAFF_PASSIN, dsp_buffer, dsp_len);
		}
		break;

	case KB_BUTTON_CHG:
		//选择更改，清除输入的密码
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_CARD_STAFF_PASSIN, "\x00", 1);
		break;
		
	case KB_BUTTON_BACK:
		//选择退卡，退卡后转入待机界面
		ICShoot(iptparam->DEVIC);
		iptMainInterface(iptparam);
		break;

	case KB_BUTTON_ACK:
		//选择确认，进行密码验证
		password[0]=((iptparam->IcStaffPassword[0]>>4)&0x0f)+0x30;password[1]=((iptparam->IcStaffPassword[0]>>0)&0x0f)+0x30;
		password[2]=((iptparam->IcStaffPassword[1]>>4)&0x0f)+0x30;password[3]=((iptparam->IcStaffPassword[1]>>0)&0x0f)+0x30;

		//员工密码错误，重新输入
		if((0!=memcmp(password, iptparam->SetButton, 4))||(4!=iptparam->SetButtonLen))
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "密码错误", 8);
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp_buffer[0]=0;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_CARD_STAFF_PASSIN, dsp_buffer, dsp_len);
			break;
		}

		//清除输入
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;

		//保存上班信息，上班状态(1byte)，员工号(1byte)，员工密码(2bytes)，员工卡号(10bytes)
		memcpy(&buffer[0], "\x01", 1);		memcpy(&buffer[1], &iptparam->IcStaffId, 1);
		memcpy(&buffer[2], iptparam->IcStaffPassword, 2);	memcpy(&buffer[4], iptparam->IcAppId, 10);
		if(0==iptparam->Id)		istate=paramSetupWrite(IPT0_DUTY_INFO, buffer, 14);
		else									istate=paramSetupWrite(IPT1_DUTY_INFO, buffer, 14);

		//保存信息失败则提示后退卡
		if(0!=istate)
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "保存上班信息失败", 16);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);
			iptMainInterface(iptparam);
			break;
		}

		//更新内存中上班信息
		iptparam->WorkState=IPT_WORK_ONDUTY;	iptparam->EMP=iptparam->IcStaffId;	
		memcpy(iptparam->EMPPassword, iptparam->IcStaffPassword, 2);
		memcpy(iptparam->EMPCardID, iptparam->IcAppId,10);
				
		//IC加油数据保存上班账单
		//待填充:POS_TTC
		memcpy(&iptparam->OilBill[IPT_OFFSET_TTC], "\x00\x00\x00\x00", 4);

		//已完成:交易类型设为无卡错，后台/本地黑白名单，扣款签名无效，上班
		iptparam->OilBill[IPT_OFFSET_T_TYPE]=(0<<7)|((iptparam->BlistSrc&1)<<6)|(0<<4)|(5<<0);

		//已完成:交易日期及时间
		iptparam->OilBill[IPT_OFFSET_TIME+0]=iptparam->Time.century;	
		iptparam->OilBill[IPT_OFFSET_TIME+1]=iptparam->Time.year;
		iptparam->OilBill[IPT_OFFSET_TIME+2]=iptparam->Time.month;
		iptparam->OilBill[IPT_OFFSET_TIME+3]=iptparam->Time.date;
		iptparam->OilBill[IPT_OFFSET_TIME+4]=iptparam->Time.hour;
		iptparam->OilBill[IPT_OFFSET_TIME+5]=iptparam->Time.minute;
		iptparam->OilBill[IPT_OFFSET_TIME+6]=iptparam->Time.second;
		
		//已完成:卡应用号
		memcpy(&iptparam->OilBill[IPT_OFFSET_ASN], iptparam->IcAppId, 10);
		
		//已完成:余额(扣前)，交易完成后填扣后余额
		memcpy(&iptparam->OilBill[IPT_OFFSET_BALANCE], iptparam->IcBalance, 4);
		
		//已完成:数额，交易完成后填实际数额
		memcpy(&iptparam->OilBill[IPT_OFFSET_AMN], "\x00\x00\x00", 3);
		
		//已完成:卡交易序号
		memcpy(&iptparam->OilBill[IPT_OFFSET_CTC], "\x00\x00", 2);
		
		//已完成:电子签名，加油/补扣/补充时未TAC，逃卡时为GTAC	
		memcpy(&iptparam->OilBill[IPT_OFFSET_TAC], "\x00\x00\x00\x00", 4);
		
		//已完成:解灰认证码4bytes，加油完成，PSAM计算GMAC后添加
		memcpy(&iptparam->OilBill[IPT_OFFSET_GMAC], "\x00\x00\x00\x00", 4);

		//已完成:PSAM会所签名4bytes，加油完成，PSAM计算GMAC后添加
		memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TAC], "\x00\x00\x00\x00", 4);
		
		//已完成:PSAM应用号10bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_ASN], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 10);

		//已完成:PSAM编号6bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_TID], "\x00\x00\x00\x00\x00\x00", 6);

		//已完成:PSAM终端交易序号4bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TTC], "\x00\x00\x00\x00", 4);

		//已完成:扣款来源1byte
		iptparam->OilBill[IPT_OFFSET_DS]=0;

		//已完成:结算单位/方式1byte
		iptparam->OilBill[IPT_OFFSET_UNIT]=0;
		
		//已完成:卡类1byte
		iptparam->OilBill[IPT_OFFSET_C_TYPE]=0;
		
		//已完成:卡版本1byte，b7~b4卡密钥索引号；b3~b0卡密钥版本号
		iptparam->OilBill[IPT_OFFSET_VER]=0;
		
		//已完成:枪号1byte
		iptparam->OilBill[IPT_OFFSET_NZN]=iptparam->LogicNozzle;
		
		//已完成:油品代码2bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_G_CODE], iptparam->OilCode, 2);
		
		//已完成:升数3bytes，交易完成后填实际升数
		memcpy(&iptparam->OilBill[IPT_OFFSET_VOL], "\x00\x00\x00", 3);
		
		//已完成:成交价格2bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_PRC], "\x00\x00", 2);
		
		//已完成:员工号1byte
		iptparam->OilBill[IPT_OFFSET_EMP]=iptparam->EMP;

		//已完成:升累计4bytes，交易完成后填实际总累
		jlSumRead(iptparam->Id, &volume_sum, &money_sum); //fj:
		iptparam->OilBill[IPT_OFFSET_V_TOT+0]=(char)(volume_sum>>24);
		iptparam->OilBill[IPT_OFFSET_V_TOT+1]=(char)(volume_sum>>16);
		iptparam->OilBill[IPT_OFFSET_V_TOT+2]=(char)(volume_sum>>8);	
		iptparam->OilBill[IPT_OFFSET_V_TOT+3]=(char)(volume_sum>>0);

		//已完成:备用部分11bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_RFU], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 11);

		//待填充:T-MAC	4bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], "\x00\x00\x00\x00", 4);
				
		//已完成:物理枪号PhysicsGunId
		iptparam->OilBill[IPT_OFFSET_PHYGUN]=iptparam->PhysicalNozzle;
				
		//已完成:计量停机原因
		iptparam->OilBill[IPT_OFFSET_STOPNO]=0;

		//已完成:扣前余额
		memcpy(&iptparam->OilBill[IPT_OFFSET_BEFOR_BAL], iptparam->IcBalance, 4);
				
		//账单状态:0=正常；1=未完成
		iptparam->OilBill[IPT_OFFSET_ZD_STATE]=1;

		//计量设备ID
		iptparam->OilBill[IPT_OFFSET_JLNOZZLE]=iptparam->JlNozzle;

		//计算账单校验值
		iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

		//保存账单及备份
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

		//转入TTC申请过程
		iptPidSet(iptparam, IPT_PID_IC_TTC_GET);
		break;

	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptIcWorkOff
*Description		:员工下班
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcWorkOff(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	switch(iptparam->Button)
	{
	case KB_BUTTON_CHG:
	case KB_BUTTON_BACK:
		//选择退卡
		ICShoot(iptparam->DEVIC);
		iptMainInterface(iptparam);
		break;

	case KB_BUTTON_ACK:
		//选择确认
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_CARD_STAFF_PASSIN, "\x00", 1);
		iptPidSet(iptparam, IPT_PID_IC_LOGOUT_PASSIN);
		break;

	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptIcWorkOffPassin
*Description		:加油机下班密码输入界面
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcWorkOffPassin(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char password[8]={0}, buffer[128]={0}, tmp_buffer[16]={0}, tmp_buffer2[16]={0};
	unsigned char dsp_buffer[128]={0}, dsp_len=0, button=0;
	unsigned long long volume_sum=0, money_sum=0;
	int istate=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0==button)	button='0';
	case KB_BUTTON_1:
		if(0==button)	button='1';
	case KB_BUTTON_2:
		if(0==button)	button='2';
	case KB_BUTTON_3:
		if(0==button)	button='3';
	case KB_BUTTON_4:
		if(0==button)	button='4';
	case KB_BUTTON_5:
		if(0==button)	button='5';
	case KB_BUTTON_6:
		if(0==button)	button='6';
	case KB_BUTTON_7:
		if(0==button)	button='7';
	case KB_BUTTON_8:
		if(0==button)	button='8';
	case KB_BUTTON_9:
		if(0==button)	button='9';

		//保存输入的密码
		if(iptparam->SetButtonLen<4)
		{
			iptparam->SetButton[iptparam->SetButtonLen++]=button;
			dsp_buffer[0]=iptparam->SetButtonLen;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_CARD_STAFF_PASSIN, dsp_buffer, dsp_len);
		}
		break;

	case KB_BUTTON_CHG:
		//选择更改，清除输入的密码
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_CARD_STAFF_PASSIN, "\x00", 1);
		break;

	case KB_BUTTON_BACK:
		//选择退卡，退卡后转入待机界面
		ICShoot(iptparam->DEVIC);
		iptMainInterface(iptparam);
		break;

	case KB_BUTTON_ACK:
		//选择确认，进行密码验证
		password[0]=((iptparam->IcStaffPassword[0]>>4)&0x0f)+0x30;password[1]=((iptparam->IcStaffPassword[0]>>0)&0x0f)+0x30;
		password[2]=((iptparam->IcStaffPassword[1]>>4)&0x0f)+0x30;password[3]=((iptparam->IcStaffPassword[1]>>0)&0x0f)+0x30;

		//员工密码错误，重新输入
		if((0!=memcmp(password, iptparam->SetButton, 4))||(4!=iptparam->SetButtonLen))
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "密码错误", 16);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);
			iptMainInterface(iptparam);
			break;
		}

		//清除输入
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;

		//保存下班信息，下班状态(1byte)，员工号(1byte)，员工密码(2bytes)，员工卡号(10bytes)
		memcpy(&buffer[0], "\x00", 1);		memcpy(&buffer[1], &iptparam->IcStaffId, 1);
		memcpy(&buffer[2], iptparam->IcStaffPassword, 2);	memcpy(&buffer[4], iptparam->IcAppId, 10);
		if(0==iptparam->Id)		istate=paramSetupWrite(IPT0_DUTY_INFO, buffer, 14);
		else									istate=paramSetupWrite(IPT1_DUTY_INFO, buffer, 14);

		//保存信息失败则提示后退卡
		if(0!=istate)
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "保存下班信息失败", 16);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);
			iptMainInterface(iptparam);
			break;
		}

		//更新内存中下班信息
		iptparam->WorkState=IPT_WORK_OFFDUTY;	iptparam->EMP=iptparam->IcStaffId;	
		memcpy(iptparam->EMPPassword, iptparam->IcStaffPassword, 2);
		memcpy(iptparam->EMPCardID, iptparam->IcAppId,10);
				
		//IC加油数据保存下班账单
		//待填充:POS_TTC
		memcpy(&iptparam->OilBill[IPT_OFFSET_TTC], "\x00\x00\x00\x00", 4);

		//已完成:交易类型设为无卡错，后台/本地黑白名单，扣款签名无效，下班
		iptparam->OilBill[IPT_OFFSET_T_TYPE]=(0<<7)|((iptparam->BlistSrc&1)<<6)|(0<<4)|(6<<0);

		//已完成:交易日期及时间
		iptparam->OilBill[IPT_OFFSET_TIME+0]=iptparam->Time.century;
		iptparam->OilBill[IPT_OFFSET_TIME+1]=iptparam->Time.year;
		iptparam->OilBill[IPT_OFFSET_TIME+2]=iptparam->Time.month;
		iptparam->OilBill[IPT_OFFSET_TIME+3]=iptparam->Time.date;
		iptparam->OilBill[IPT_OFFSET_TIME+4]=iptparam->Time.hour;
		iptparam->OilBill[IPT_OFFSET_TIME+5]=iptparam->Time.minute;
		iptparam->OilBill[IPT_OFFSET_TIME+6]=iptparam->Time.second;

		//已完成:卡应用号
		memcpy(&iptparam->OilBill[IPT_OFFSET_ASN], iptparam->IcAppId, 10);
		
		//已完成:余额(扣前)，交易完成后填扣后余额
		memcpy(&iptparam->OilBill[IPT_OFFSET_BALANCE], iptparam->IcBalance, 4);
		
		//已完成:数额，交易完成后填实际数额		
		memcpy(&iptparam->OilBill[IPT_OFFSET_AMN], "\x00\x00\x00", 3);
		
		//已完成:卡交易序号
		memcpy(&iptparam->OilBill[IPT_OFFSET_CTC], "\x00\x00", 2);
		
		//已完成:电子签名，加油/补扣/补充时未TAC，逃卡时为GTAC	
		memcpy(&iptparam->OilBill[IPT_OFFSET_TAC], "\x00\x00\x00\x00", 4);
		
		//已完成:解灰认证码4bytes，加油完成，PSAM计算GMAC后添加
		memcpy(&iptparam->OilBill[IPT_OFFSET_GMAC], "\x00\x00\x00\x00", 4);

		//已完成:PSAM会所签名4bytes，加油完成，PSAM计算GMAC后添加
		memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TAC], "\x00\x00\x00\x00", 4);
		
		//已完成:PSAM应用号10bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_ASN], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 10);

		//已完成:PSAM编号6bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_TID], "\x00\x00\x00\x00\x00\x00", 6);

		//已完成:PSAM终端交易序号4bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TTC], "\x00\x00\x00\x00", 4);

		//已完成:扣款来源1byte
		iptparam->OilBill[IPT_OFFSET_DS]=0;

		//已完成:结算单位/方式1byte
		iptparam->OilBill[IPT_OFFSET_UNIT]=0;
		
		//已完成:卡类1byte
		iptparam->OilBill[IPT_OFFSET_C_TYPE]=0;
		
		//已完成:卡版本1byte，b7~b4卡密钥索引号；b3~b0卡密钥版本号
		iptparam->OilBill[IPT_OFFSET_VER]=0;
		
		//已完成:枪号1byte
		iptparam->OilBill[IPT_OFFSET_NZN]=iptparam->LogicNozzle;
		
		//已完成:油品代码2bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_G_CODE], iptparam->OilCode, 2);
		
		//已完成:升数3bytes，交易完成后填实际升数
		memcpy(&iptparam->OilBill[IPT_OFFSET_VOL], "\x00\x00\x00", 3);
		
		//已完成:成交价格2bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_PRC], "\x00\x00", 2);
		
		//已完成:员工号1byte
		iptparam->OilBill[IPT_OFFSET_EMP]=iptparam->EMP;

		//已完成:升累计4bytes，交易完成后填实际总累
		jlSumRead(iptparam->JlNozzle, &volume_sum, &money_sum); //fj:
		iptparam->OilBill[IPT_OFFSET_V_TOT+0]=(char)(volume_sum>>24);
		iptparam->OilBill[IPT_OFFSET_V_TOT+1]=(char)(volume_sum>>16);
		iptparam->OilBill[IPT_OFFSET_V_TOT+2]=(char)(volume_sum>>8);	
		iptparam->OilBill[IPT_OFFSET_V_TOT+3]=(char)(volume_sum>>0);

		//已完成:备用部分11bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_RFU], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 11);

		//待填充:T-MAC	4bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], "\x00\x00\x00\x00", 4);
				
		//已完成:物理枪号PhysicsGunId
		iptparam->OilBill[IPT_OFFSET_PHYGUN]=iptparam->PhysicalNozzle;
				
		//已完成:计量停机原因
		iptparam->OilBill[IPT_OFFSET_STOPNO]=0;

		//已完成:扣前余额
		memcpy(&iptparam->OilBill[IPT_OFFSET_BEFOR_BAL], iptparam->IcBalance, 4);
				
		//账单状态:0=正常；1=未完成
		iptparam->OilBill[IPT_OFFSET_ZD_STATE]=1;

		//计量设备ID
		iptparam->OilBill[IPT_OFFSET_JLNOZZLE]=iptparam->JlNozzle;

		//计算账单校验值
		iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

		//保存账单及备份
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

		//转入TTC申请过程
		iptPidSet(iptparam, IPT_PID_IC_TTC_GET);
		break;

	default:
		break;
	}

	return;
}
	

/*******************************************************************
*Name				:iptIcOilAck
*Description		:油品确认界面
*Input				:None
*Output			:None
*Return				:None
*History			:2016-01-29,modified by syj  */

static void iptIcOilAck(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	//按PLAY键或确认键确认油品
	//	关闭PLAY按钮灯
	//	通知平板电脑退出油品确认界面
	//	通知转入加油数据检查过程
	
	if(KB_BUTTON_ACK == iptparam->Button || 1 == iptparam->YPSelect)
	{
		iptparam->YPSelect = 0;
	
		pcYPLightTurnOff(iptparam->TabletPanel, iptparam->LogicNozzle);
	
		pcOilConfirm(iptparam->TabletPanel, iptparam->LogicNozzle, 3, "\x00");

		iptPidSet(iptparam, IPT_PID_IC_OILCHECK);
		return;
	}

	//按取消键或挂枪放弃此次操作
	//	关闭PLAY按钮灯
	//	通知平板电脑退出油品确认界面
	//	返回余额界面
	
	if(KB_BUTTON_CHG == iptparam->Button || IPT_GUN_PUTDOWN == iptparam->GunState)
	{
		pcYPLightTurnOff(iptparam->TabletPanel, iptparam->LogicNozzle);
	
		pcOilConfirm(iptparam->TabletPanel, iptparam->LogicNozzle, 2, "\x00");

		iptIcBalanceDsp(iptparam->Id);

		iptPidSet(iptparam, IPT_PID_IC_BALANCE);
		return;
	}

	//按退卡键退卡并退出界面
	if(KB_BUTTON_BACK == iptparam->Button)
	{
		pcYPLightTurnOff(iptparam->TabletPanel, iptparam->LogicNozzle);
	
		pcOilConfirm(iptparam->TabletPanel, iptparam->LogicNozzle, 2, "\x00");

		ICShoot(iptparam->DEVIC);
		
		iptMainInterface(iptparam);
		return;
	}

	return;
}


/*******************************************************************
*Name				:iptIcOilCheck
*Description		:加油数据检查过程
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcOilCheck(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned int data=0, i=0;
	unsigned int ibalance = 0;				//卡余额
	unsigned int msum_today=0;		//限加油总金额卡，当天总计加油金额
	unsigned int mbalance_today=0;	//限加油总金额卡，当天剩余允许加油金额
	unsigned int money_limit=0;		//单次限制金额
	unsigned int volume_limit=0;		//单次限制升数
	unsigned char unit_limit=0;			//单次限制方式
	unsigned char province=0;			//加油卡地区号
	unsigned char tmp_buffer[64]={0}, dsp_buffer[64]={0}, dsp_len=0;
	unsigned int pmoney_max = JL_MONEY_MAX, pvolume_max = JL_VOLUME_MAX, ppreset_mode = 0;
	unsigned long long money_sum=0, volume_sum=0;

	//清除上一次单次过冲数据，不清除累计过充数据
	memset(tmp_buffer, 0, 32);	iptparam->MoneyUnself=0;	iptparam->VolumeUnself=0;
	tmp_buffer[0]=(char)(iptparam->MoneyUnself>>16);
	tmp_buffer[1]=(char)(iptparam->MoneyUnself>>8);	tmp_buffer[2]=(char)(iptparam->MoneyUnself>>0);
	tmp_buffer[3]=(char)(iptparam->VolumeUnself>>16);
	tmp_buffer[4]=(char)(iptparam->VolumeUnself>>8);	tmp_buffer[5]=(char)(iptparam->VolumeUnself>>0);
	tmp_buffer[6]=0;
	tmp_buffer[7]=(char)(iptparam->MoneyUnselfSum>>16);	
	tmp_buffer[8]=(char)(iptparam->MoneyUnselfSum>>8);	tmp_buffer[9]=(char)(iptparam->MoneyUnselfSum>>0);
	tmp_buffer[10]=(char)(iptparam->VolumeUnselfSum>>16);	
	tmp_buffer[11]=(char)(iptparam->VolumeUnselfSum>>8);	tmp_buffer[12]=(char)(iptparam->VolumeUnselfSum>>0);
	tmp_buffer[13]=iptparam->OilOverTimes;
	data=crc16Get(tmp_buffer, 30);
	tmp_buffer[30]=(char)(data>>8);	tmp_buffer[31]=(char)(data>>0);
	framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_UNSELF, tmp_buffer, 32);
	framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_UNSELF2, tmp_buffer, 32);

//调试时每加油100次提示一下此信息
#if _IPT_DEBUG_
	if(0==(iptparam->testOilTimes%100))	jljRunLog("启动加油前的检查__[%d]\n", iptparam->testOilTimes);
	iptparam->testOilTimes++;
#endif


	//判断电源状态
	if(POWER_STATE_OK!=powerStateRead())
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "油机电源状态异常", 16);
		ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "加油启动失败，油机电源状态异常!");
		iptMainInterface(iptparam);
		return;
	}

	//iptparam->FuelUnloadNumber = 10; //fj:20171020,fj:20171215
	//判断账单是否溢出
	if(iptparam->FuelUnloadNumber>=IPT_BILLUNLOAD_MAX)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "账单溢出", 8);
		ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "加油启动失败，账单溢出!");
		iptMainInterface(iptparam);
		return;
	}

	//判断员工卡禁止加油
	if(0!=iptparam->CardStaffLimit && ICTYPE_STAFF==iptparam->IcAppId[2])
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "员工卡禁止加油", 14);
		ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "加油启动失败，员工卡禁止加油!");
		iptMainInterface(iptparam);
		return;
	}

	//判断获取单价结果,fj:
	if(0!=jlPriceRead(iptparam->JlNozzle, &iptparam->OilPrice))
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "获取单价失败", 12);
		ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
    
		jljOilErrLogWrite(iptparam->Id, "加油启动失败，获取计量单价失败!");
		iptMainInterface(iptparam);
		return;
	}

	if(iptparam->JlErr_BianJia!=0)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "变价失败", 8);
		ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "加油启动失败!变价失败");
		iptMainInterface(iptparam);
		return;
	}

	//判断单价合法性
	if((iptparam->OilPrice<IPT_PRICE_MIN)||(iptparam->OilPrice>IPT_PRICE_MAX))
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "单价非法", 8);
		ICShoot(iptparam->DEVIC);IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "加油启动失败，单价非法!");
		iptMainInterface(iptparam);
		return;
	}

	//判断销售锁定
	if(IPT_SELL_UNLOCK!=iptparam->SellLock)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "加油启动锁定", 12);
		ICShoot(iptparam->DEVIC);IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "加油启动失败，加油启动锁定!");
		iptMainInterface(iptparam);
		return;
	}

	//判断夜间锁定
	if(IPT_NIGHT_UNLOCK!=iptparam->NightLock)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "夜间锁定", 8);
		ICShoot(iptparam->DEVIC);IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "加油启动失败，夜间锁定!");
		iptMainInterface(iptparam);
		return;
	}

	//判断钥匙状态
	if(KB_KEYLOCK_OIL!=iptparam->KeyLock)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "请把钥匙打到加油位置", strlen("请把钥匙打到加油位置"));
		ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "加油启动失败，钥匙在设置位置!");
		iptMainInterface(iptparam);
		return;
	}

	//判断时间合法性
	tmp_buffer[0]=iptparam->Time.century;	tmp_buffer[1]=iptparam->Time.year;	tmp_buffer[2]=iptparam->Time.month;	tmp_buffer[3]=iptparam->Time.date;
	tmp_buffer[4]=iptparam->Time.hour;tmp_buffer[5]=iptparam->Time.minute;tmp_buffer[6]=iptparam->Time.second;
	if(0!=timeVerification(tmp_buffer, 7))
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "油机时间非法", 12);
		ICShoot(iptparam->DEVIC);IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "加油启动失败，油机时间非法!");
		iptMainInterface(iptparam);
		return;
	}

	//判断物理枪号合法性
	if((iptparam->PhysicalNozzle<1)||(iptparam->PhysicalNozzle>6))
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "物理枪号非法", 12);
		ICShoot(iptparam->DEVIC);IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "加油启动失败，物理枪号非法!物理枪号=%s.", iptparam->PhysicalNozzle);
		iptMainInterface(iptparam);
		return;
	}

	//判断PCD连接状态
	if(1!=iptparam->PcdState)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "与PCD连接断开", 13);
		ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "加油启动失败，与PCD连接断开!");
		iptMainInterface(iptparam);
		return;
	}

	//判断PCD异常状态
	if(0!=iptparam->PcdErrNO)
	{
		memcpy(&dsp_buffer[0], "PCD状态异常", 11);
		dsp_buffer[11]=(iptparam->PcdErrNO>>4)&0x0f+0x30;
		dsp_buffer[12]=(iptparam->PcdErrNO>>0)&0x0f+0x30;
		dsp_len=13;
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);
		ICShoot(iptparam->DEVIC);IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "加油启动失败，PCD状态异常!错误代码=%x.", iptparam->PcdErrNO);
		iptMainInterface(iptparam);
		return;
	}

	//判断通用信息版本合法性
	if(IPT_MODE_UNSELF!=iptparam->Mode && 0==IptPcInfo.SInfo.Version)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "通用信息版本非法", 16);
		ICShoot(iptparam->DEVIC);IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "加油启动失败，通用信息版本非法!版本=%d.", IptPcInfo.SInfo.Version);
		iptMainInterface(iptparam);
		return;
	}

	//判断油品油价版本
	if(IPT_MODE_UNSELF!=iptparam->Mode && 0==IptPcInfo.OilInfo.Version)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "油品油价版本非法", 16);
		ICShoot(iptparam->DEVIC);IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "加油启动失败，油品油价版本非法!版本=%d.", IptPcInfo.OilInfo.Version);
		iptMainInterface(iptparam);
		return;
	}

	//判断逻辑枪号合法性
	if(IPT_MODE_UNSELF!=iptparam->Mode && 0==iptparam->LogicNozzle)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "逻辑枪号非法", 12);
		ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "加油启动失败，逻辑枪号非法!逻辑枪号=%d.", iptparam->LogicNozzle);
		iptMainInterface(iptparam);
		return;
	}

	//判断加油机是否下班
	if(IPT_MODE_UNSELF!=iptparam->Mode && IPT_WORK_ONDUTY!=iptparam->WorkState)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "加油机下班", 12);
		ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "加油启动失败，加油机下班!");
		iptMainInterface(iptparam);
		return;
	}

	//判断非本省卡禁止积分加油
	province=((iptparam->IcAppId[3]&0x0f)<<4)|((iptparam->IcAppId[4]&0xf0)>>4);
	if(IPT_PAYUNIT_LOYALTY==iptparam->PayUnit && province!=IptPcInfo.SInfo.Province)
	{
		memcpy(&dsp_buffer[0], "非本省卡，      ", 16);	memcpy(&dsp_buffer[16], "    禁止积分加油", 16);
		dsp_len=32;
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);
		ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "加油启动失败，非本省卡，禁止积分加油!");
		iptMainInterface(iptparam);
		return;
	}

	//中燃联达加油系统，不允许主卡加油
	if(1 == iptIsLianda(iptparam->Id) && (0x21 == iptparam->IcAppType || 0x22 == iptparam->IcAppType))
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "主卡不允许加油", strlen("主卡不允许加油"));
		ICShoot(iptparam->DEVIC);
		IPT_DSP_WAIT();

		iptMainInterface(iptparam);
		return;
	}

#if 0
	//
	//计算预置量，未经过卡片限制计算得出预置量，第一次计算:
	//预置量为零或非预置即默认为任意加油；
	//定升数加油，通过升数计算预置金额；
	//定金额加油，通过金额计算预置升数；
	//任意加油，以最大允许金额为预置金额，并计算预置升数；
	//需注意，在以下判断限制信息及卡余额时可能会重新预置；
	
	data=(iptparam->IntegerBuffer[0]&0x0f)*10000000+(iptparam->IntegerBuffer[1]&0x0f)*1000000+\
			(iptparam->IntegerBuffer[2]&0x0f)*100000+(iptparam->IntegerBuffer[3]&0x0f)*10000+\
			(iptparam->IntegerBuffer[4]&0x0f)*1000+(iptparam->IntegerBuffer[5]&0x0f)*100+\
			(iptparam->DecimalBuffer[0]&0x0f)*10+(iptparam->DecimalBuffer[1]&0x0f)*1;
	if((0==data)||((IPT_PRESET_VOLUME!=iptparam->PresetMode)&&(IPT_PRESET_MONEY!=iptparam->PresetMode)))
	{
		iptparam->PresetMoney=JL_MONEY_MAX;	iptparam->PresetMode=IPT_PRESET_NO;
		if((iptparam->PresetMoney*1000/iptparam->OilPrice%10)<IPT_ROUNDING)	iptparam->PresetVolume=iptparam->PresetMoney*100/iptparam->OilPrice;
		else																														iptparam->PresetVolume=iptparam->PresetMoney*100/iptparam->OilPrice+1;
	}
	else if(IPT_PRESET_VOLUME==iptparam->PresetMode)
	{
		iptparam->PresetVolume=data;
		if((iptparam->PresetVolume*iptparam->OilPrice/10%10)<IPT_ROUNDING)	iptparam->PresetMoney=iptparam->PresetVolume*iptparam->OilPrice/100;
		else																													iptparam->PresetMoney=iptparam->PresetVolume*iptparam->OilPrice/100+1;
	}
	else if(IPT_PRESET_MONEY==iptparam->PresetMode)
	{
		iptparam->PresetMoney=data;
		if((iptparam->PresetMoney*1000/iptparam->OilPrice%10)<IPT_ROUNDING)	iptparam->PresetVolume=iptparam->PresetMoney*100/iptparam->OilPrice;
		else																														iptparam->PresetVolume=iptparam->PresetMoney*100/iptparam->OilPrice+1;
	}

	//判断卡余额，任意加油时若卡内余额小于最大允许量则以卡内余额做预置金额加油
	data=(iptparam->IcBalance[0]<<24)|(iptparam->IcBalance[1]<<16)|(iptparam->IcBalance[2]<<8)|(iptparam->IcBalance[3]<<0);
	if(IPT_PRESET_NO==iptparam->PresetMode && iptparam->PresetMoney>data)
	{
		iptparam->PresetMoney = data;
		if((iptparam->PresetMoney*1000/iptparam->OilPrice%10)<IPT_ROUNDING)	iptparam->PresetVolume=iptparam->PresetMoney*100/iptparam->OilPrice;
		else																														iptparam->PresetVolume=iptparam->PresetMoney*100/iptparam->OilPrice+1;
	}
	else if(IPT_PRESET_NO!=iptparam->PresetMode && iptparam->PresetMoney>data)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "卡余额不足", 10);
		ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "加油启动失败，卡余额不足!卡余额=%d；预置量=%d；预置方式=iptparam->PresetMode.", data, iptparam->PresetMoney, iptparam->PresetMode);
		iptMainInterface(iptparam);
		return;
	}

	//判断卡余额不足IPT_VOLUME_MIN升时提示余额不足
	data=(iptparam->IcBalance[0]<<24)|(iptparam->IcBalance[1]<<16)|(iptparam->IcBalance[2]<<8)|(iptparam->IcBalance[3]<<0);
	if(data<(IPT_VOLUME_MIN/100*iptparam->OilPrice))
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "卡余额不足", 10);
		ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "加油启动失败，卡余额不足!卡余额=%d.", data);
		iptMainInterface(iptparam);
		return;
	}

	//判断卡限制信息:限每日加油总金额
	if(0!=memcmp(iptparam->IcMoneyDayLimit, "\xff\xff\xff\xff", 4))
	{
		//计算当天加油金额累计
		tmp_buffer[0]=iptparam->Time.century;	tmp_buffer[1]=iptparam->Time.year;	
		tmp_buffer[2]=iptparam->Time.month;	tmp_buffer[3]=iptparam->Time.date;
		for(i=0; (i<iptparam->IcRecordNumber)&&(i<10); i++)
		{
			if(0==memcmp(tmp_buffer,iptparam->IcRecord[i].Time, 4) && (0x93==iptparam->IcRecord[i].Type || 0x95==iptparam->IcRecord[i].Type || 0x05==iptparam->IcRecord[i].Type))
			{
				msum_today=msum_today+((iptparam->IcRecord[i].Money[0]<<24)|(iptparam->IcRecord[i].Money[1]<<16)|(iptparam->IcRecord[i].Money[2]<<8)|(iptparam->IcRecord[i].Money[3]<<0));
			}
		}

		//计算允许当天加油总金额
		data=((iptparam->IcMoneyDayLimit[0]&0x0f)<<24)|(iptparam->IcMoneyDayLimit[1]<<16)|(iptparam->IcMoneyDayLimit[2]<<8)|(iptparam->IcMoneyDayLimit[3]<<0);

		//计算当天剩余允许加油金额
		mbalance_today=data-msum_today;

		//满足以下条件不允许再次加油:
		//	当天加油总金额不小于当天剩余允许金额；
		//	非任意加油且预置金额大于当天剩余允许金额；
		
		if(msum_today>=data || (IPT_PRESET_NO!=iptparam->PresetMode && iptparam->PresetMoney>mbalance_today))
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "限每天加油金额卡", 16);
			ICShoot(iptparam->DEVIC);IPT_DSP_WAIT();

			//IC加油数据保存卡错账单，限每天加油金额试图超出使用
			//待填充:POS_TTC
			memcpy(&iptparam->OilBill[IPT_OFFSET_TTC], "\x00\x00\x00\x00", 4);
				
			//待填充:交易类型设为卡错，后台/本地黑白名单，扣款签名无效，卡错拒绝
			iptparam->OilBill[IPT_OFFSET_T_TYPE]=(1<<7)|((iptparam->BlistSrc&1)<<6)|(0<<4)|(9<<0);;

			//已完成:交易日期及时间
			iptparam->OilBill[IPT_OFFSET_TIME+0]=iptparam->Time.century;	
			iptparam->OilBill[IPT_OFFSET_TIME+1]=iptparam->Time.year;
			iptparam->OilBill[IPT_OFFSET_TIME+2]=iptparam->Time.month;
			iptparam->OilBill[IPT_OFFSET_TIME+3]=iptparam->Time.date;
			iptparam->OilBill[IPT_OFFSET_TIME+4]=iptparam->Time.hour;		
			iptparam->OilBill[IPT_OFFSET_TIME+5]=iptparam->Time.minute;
			iptparam->OilBill[IPT_OFFSET_TIME+6]=iptparam->Time.second;

			//已完成:卡应用号
			memcpy(&iptparam->OilBill[IPT_OFFSET_ASN], iptparam->IcAppId, 10);

			//已完成:余额(扣前)，交易完成后填扣后余额
			memcpy(&iptparam->OilBill[IPT_OFFSET_BALANCE], "\x00\x00\x00\x00", 4);

			//已完成:数额，交易完成后填实际数额		
			memcpy(&iptparam->OilBill[IPT_OFFSET_AMN], "\x00\x00\x00", 3);

			//已完成:卡交易序号
			memcpy(&iptparam->OilBill[IPT_OFFSET_CTC], "\x00\x00", 2);

			//已完成:电子签名，加油/补扣/补充时未TAC，逃卡时为GTAC
			memcpy(&iptparam->OilBill[IPT_OFFSET_TAC], "\x10\x04\x00\x00", 4);

			//已完成:解灰认证码4bytes，加油完成，PSAM计算GMAC后添加
			memcpy(&iptparam->OilBill[IPT_OFFSET_GMAC], "\x00\x00\x00\x00", 4);

			//已完成:PSAM会所签名4bytes，加油完成，PSAM计算GMAC后添加
			memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TAC], "\x00\x00\x00\x00", 4);
				
			//已完成:PSAM应用号10bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_ASN], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 10);

			//已完成:PSAM编号6bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_TID], "\x00\x00\x00\x00\x00\x00", 6);

			//已完成:PSAM终端交易序号4bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TTC], "\x00\x00\x00\x00", 4);
			
			//已完成:扣款来源1byte
			iptparam->OilBill[IPT_OFFSET_DS]=iptparam->DS;
				
			//已完成:结算单位/方式1byte
			iptparam->OilBill[IPT_OFFSET_UNIT]=((iptparam->Payment&0x3f)<<4)|(iptparam->PayUnit&0x03);

			//已完成:卡类1byte
			iptparam->OilBill[IPT_OFFSET_C_TYPE]=iptparam->C_TYPE;

			//已完成:卡版本1byte，b7~b4卡密钥索引号；b3~b0卡密钥版本号
			iptparam->OilBill[IPT_OFFSET_VER]=0;

			//已完成:枪号1byte
			iptparam->OilBill[IPT_OFFSET_NZN]=0;
				
			//已完成:油品代码2bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_G_CODE], "\x00\x00", 2);

			//已完成:升数3bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_VOL], "\x00\x00\x00", 3);

			//已完成:成交价格2bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_PRC], "\x00\x00", 2);

			//已完成:员工号1byte
			iptparam->OilBill[IPT_OFFSET_EMP]=iptparam->EMP;

			//已完成:升累计4bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_V_TOT], "\x00\x00\x00\x00", 4);
				
			//已完成:备用部分11bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_RFU], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 11);

			//待填充:T-MAC	4bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], "\x00\x00\x00\x00", 4);
				
			//已完成:物理枪号PhysicsGunId
			iptparam->OilBill[IPT_OFFSET_PHYGUN]=iptparam->PhysicalNozzle;
				
			//已完成:计量停机代码
			iptparam->OilBill[IPT_OFFSET_STOPNO]=0;

			//已完成:扣前余额
			memcpy(&iptparam->OilBill[IPT_OFFSET_BEFOR_BAL], "\x00\x00\x00\x00", 4);

			//账单状态0=正常；1=未完成
			iptparam->OilBill[IPT_OFFSET_ZD_STATE]=1;

			//计量设备ID
			iptparam->OilBill[IPT_OFFSET_JLNOZZLE]=iptparam->JlNozzle;

			//计算账单校验值
			iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

			//保存账单及备份
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

			//转入账单TTC获取过程
			jljOilErrLogWrite(iptparam->Id, "加油启动失败，限每天加油金额卡!当天剩余允许加油金额=%d.", mbalance_today);
			iptPidSet(iptparam, IPT_PID_IC_TTC_GET);
			return;
		}

		//任意加油，允许金额大于当天剩余允许金额以较小者重新计算预置量
		if(IPT_PRESET_NO==iptparam->PresetMode && iptparam->PresetMoney>mbalance_today)
		{
			iptparam->PresetMoney=mbalance_today;
			if((iptparam->PresetMoney*1000/iptparam->OilPrice%10)<IPT_ROUNDING)	iptparam->PresetVolume=iptparam->PresetMoney*100/iptparam->OilPrice;
			else																														iptparam->PresetVolume=iptparam->PresetMoney*100/iptparam->OilPrice+1;	
		}
	}
	
	//判断卡限制信息:限每次加油量
	if(0!=memcmp(iptparam->IcVolumeLimit, "\xff\xff", 2))
	{
		//计算限制方式及限制量
		unit_limit=(iptparam->IcVolumeLimit[0]>>4)&0x0f;
		data=((iptparam->IcVolumeLimit[0]>>0)&0x0f)*100+((iptparam->IcVolumeLimit[1]>>4)&0x0f)*10+((iptparam->IcVolumeLimit[1]>>0)&0x0f)*1;
		if(0==unit_limit)	money_limit=data*100;
		else						volume_limit=data*100;

		//任意加油，限每次加油金额时以允许金额与限制金额较小者重新计算允许值
		if(IPT_PRESET_NO==iptparam->PresetMode && 0==unit_limit && iptparam->PresetMoney>money_limit)
		{
			iptparam->PresetMoney=money_limit;
			if((iptparam->PresetMoney*1000/iptparam->OilPrice%10)<IPT_ROUNDING)	iptparam->PresetVolume=iptparam->PresetMoney*100/iptparam->OilPrice;
			else																														iptparam->PresetVolume=iptparam->PresetMoney*100/iptparam->OilPrice+1;	
		}
		//任意加油，限每次加油升数时以允许升数与限制升数较小者重新计算允许值
		else if(IPT_PRESET_NO==iptparam->PresetMode && 0!=unit_limit && iptparam->PresetVolume>volume_limit)
		{
			iptparam->PresetVolume=volume_limit;
			if((iptparam->PresetVolume*iptparam->OilPrice/10%10)<IPT_ROUNDING)	iptparam->PresetMoney=iptparam->PresetVolume*iptparam->OilPrice/100;
			else																													iptparam->PresetMoney=iptparam->PresetVolume*iptparam->OilPrice/100+1;
		}
		//预置加油，预置量超过限制量时提示错误并退卡
		else if(	IPT_PRESET_NO!=iptparam->PresetMode &&\
					((0==unit_limit && iptparam->PresetMoney>money_limit)||(0!=unit_limit && iptparam->PresetVolume>volume_limit)))
		{
			if(0==unit_limit)	dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "限每次加油金额卡", 16);
			else						dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "限每次加油升数卡", 16);
			ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();

			if(0==unit_limit)	jljOilErrLogWrite(iptparam->Id, "加油启动失败，限每次加油金额卡!每次允许加油金额=%d.", money_limit);
			else						jljOilErrLogWrite(iptparam->Id, "加油启动失败，限每次加油升数卡!每次允许加油升数=%d.", volume_limit);
			iptMainInterface(iptparam);
			return;
		}
	}

#endif

	//
	//计算预置量，未经过卡片限制计算得出预置量，第一次计算:
	//预置量为零或非预置即默认为任意加油；
	//定升数加油，通过升数计算预置金额；
	//定金额加油，通过金额计算预置升数；
	//任意加油，以最大允许金额为预置金额，并计算预置升数；
	//需注意，在以下判断限制信息及卡余额时可能会重新预置；
	
	data=(iptparam->IntegerBuffer[0]&0x0f)*10000000+(iptparam->IntegerBuffer[1]&0x0f)*1000000+\
			(iptparam->IntegerBuffer[2]&0x0f)*100000+(iptparam->IntegerBuffer[3]&0x0f)*10000+\
			(iptparam->IntegerBuffer[4]&0x0f)*1000+(iptparam->IntegerBuffer[5]&0x0f)*100+\
			(iptparam->DecimalBuffer[0]&0x0f)*10+(iptparam->DecimalBuffer[1]&0x0f)*1;
	if((0==data)||((IPT_PRESET_VOLUME!=iptparam->PresetMode)&&(IPT_PRESET_MONEY!=iptparam->PresetMode)))
	{
		iptparam->PresetMoney = JL_MONEY_MAX;	iptparam->PresetMode=IPT_PRESET_NO;
	}
	else if(IPT_PRESET_VOLUME==iptparam->PresetMode)
	{
		iptparam->PresetVolume = data;
	}
	else if(IPT_PRESET_MONEY==iptparam->PresetMode)
	{
		iptparam->PresetMoney = data;
	}
	tmp_buffer[0] = (char)(pmoney_max>>24);						tmp_buffer[1] = (char)(pmoney_max>>16);
	tmp_buffer[2] = (char)(pmoney_max>>8);							tmp_buffer[3] = (char)(pmoney_max>>0);
	tmp_buffer[4] = (char)(pvolume_max>>24);						tmp_buffer[5] = (char)(pvolume_max>>16);
	tmp_buffer[6] = (char)(pvolume_max>>8);							tmp_buffer[7] = (char)(pvolume_max>>0);
	tmp_buffer[8] = (char)(iptparam->PresetMoney>>24);		tmp_buffer[9] = (char)(iptparam->PresetMoney>>16);
	tmp_buffer[10] = (char)(iptparam->PresetMoney>>8);		tmp_buffer[11] = (char)(iptparam->PresetMoney>>0);
	tmp_buffer[12] = (char)(iptparam->PresetVolume>>24);	tmp_buffer[13] = (char)(iptparam->PresetVolume>>16);
	tmp_buffer[14] = (char)(iptparam->PresetVolume>>8);		tmp_buffer[15] = (char)(iptparam->PresetVolume>>0);
	tmp_buffer[16] = (char)(iptparam->OilPrice>>24);				tmp_buffer[17] = (char)(iptparam->OilPrice>>16);
	tmp_buffer[18] = (char)(iptparam->OilPrice>>8);				tmp_buffer[19] = (char)(iptparam->OilPrice>>0);
	tmp_buffer[20] = iptparam->PresetMode;
	jlPresetAmountCalculate(iptparam->JlNozzle, tmp_buffer); //fj:
	iptparam->PresetMoney = (tmp_buffer[8]<<24)|(tmp_buffer[9]<<16)|(tmp_buffer[10]<<8)|(tmp_buffer[11]<<0);
	iptparam->PresetVolume = (tmp_buffer[12]<<24)|(tmp_buffer[13]<<16)|(tmp_buffer[14]<<8)|(tmp_buffer[15]<<0);
//printf("[%s][%d]money=%d; volume=%d; price=%d; mode=%d.\n", __FUNCTION__, __LINE__, (unsigned int)iptparam->PresetMoney, (unsigned int)iptparam->PresetVolume, (unsigned int)iptparam->OilPrice,  iptparam->PresetMode);//myDEBUG

	//判断卡余额，卡余额小于预置金额、或小于IPT_VOLUME_MIN升需要的金额时提示余额不足并退卡
	//	中燃联达加油系统记账卡不判断卡余额!
	//	中燃联达加油系统代储卡判断卡余额以预置升数处理!
	
	ibalance = (iptparam->IcBalance[0]<<24)|(iptparam->IcBalance[1]<<16)|(iptparam->IcBalance[2]<<8)|(iptparam->IcBalance[3]<<0);
	if(1 == iptIsLianda(iptparam->Id) && (IPT_LIANDA_APPTYPE_JIZHANG == iptparam->IcAppType||IPT_LIANDA_APPTYPE_ZIYONG == iptparam->IcAppType||IPT_LIANDA_APPTYPE_DIAOBO == iptparam->IcAppType||IPT_LIANDA_APPTYPE_GUOBIAO == iptparam->IcAppType))
	{
		;
	}
	else if(1 == iptIsLianda(iptparam->Id) &&\
		(IPT_LIANDA_APPTYPE_DAICHU == iptparam->IcAppType || IPT_LIANDA_APPTYPE_DAICHUSIJI == iptparam->IcAppType) &&\
		ibalance >= IPT_VOLUME_MIN && ibalance >= iptparam->PresetVolume)
	{
		;
	}
	else if((IPT_PRESET_NO != iptparam->PresetMode && iptparam->PresetMoney > ibalance)||\
		(ibalance < (IPT_VOLUME_MIN/100*iptparam->OilPrice)))
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "卡余额不足", 10);
		ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();

		iptMainInterface(iptparam);
		return;
	}

	//判断卡限制信息:限每日加油总金额
	if(0!=memcmp(iptparam->IcMoneyDayLimit, "\xff\xff\xff\xff", 4))
	{
		//计算当天加油金额累计
		tmp_buffer[0]=iptparam->Time.century;	tmp_buffer[1]=iptparam->Time.year;	
		tmp_buffer[2]=iptparam->Time.month;	tmp_buffer[3]=iptparam->Time.date;
		for(i=0; (i<iptparam->IcRecordNumber)&&(i<10); i++)
		{
			if(0==memcmp(tmp_buffer,iptparam->IcRecord[i].Time, 4) && (0x93==iptparam->IcRecord[i].Type || 0x95==iptparam->IcRecord[i].Type || 0x05==iptparam->IcRecord[i].Type))
			{
				msum_today=msum_today+((iptparam->IcRecord[i].Money[0]<<24)|(iptparam->IcRecord[i].Money[1]<<16)|(iptparam->IcRecord[i].Money[2]<<8)|(iptparam->IcRecord[i].Money[3]<<0));
			}
		}

		//计算允许当天加油总金额
		data=((iptparam->IcMoneyDayLimit[0]&0x0f)<<24)|(iptparam->IcMoneyDayLimit[1]<<16)|(iptparam->IcMoneyDayLimit[2]<<8)|(iptparam->IcMoneyDayLimit[3]<<0);

		//计算当天剩余允许加油金额
		if(data > msum_today)	mbalance_today = data - msum_today;
		else								mbalance_today = 0;

		//满足以下条件不允许再次加油:
		//	当天加油总金额不小于当天剩余允许金额；
		//	非任意加油且预置金额大于当天剩余允许金额；
		
		if(msum_today>=data || (IPT_PRESET_NO!=iptparam->PresetMode && iptparam->PresetMoney>mbalance_today))
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "限每天加油金额卡", 16);
			ICShoot(iptparam->DEVIC);IPT_DSP_WAIT();

			//IC加油数据保存卡错账单，限每天加油金额试图超出使用
			//待填充:POS_TTC
			memcpy(&iptparam->OilBill[IPT_OFFSET_TTC], "\x00\x00\x00\x00", 4);
				
			//待填充:交易类型设为卡错，后台/本地黑白名单，扣款签名无效，卡错拒绝
			iptparam->OilBill[IPT_OFFSET_T_TYPE]=(1<<7)|((iptparam->BlistSrc&1)<<6)|(0<<4)|(9<<0);;

			//已完成:交易日期及时间
			iptparam->OilBill[IPT_OFFSET_TIME+0]=iptparam->Time.century;	
			iptparam->OilBill[IPT_OFFSET_TIME+1]=iptparam->Time.year;
			iptparam->OilBill[IPT_OFFSET_TIME+2]=iptparam->Time.month;
			iptparam->OilBill[IPT_OFFSET_TIME+3]=iptparam->Time.date;
			iptparam->OilBill[IPT_OFFSET_TIME+4]=iptparam->Time.hour;		
			iptparam->OilBill[IPT_OFFSET_TIME+5]=iptparam->Time.minute;
			iptparam->OilBill[IPT_OFFSET_TIME+6]=iptparam->Time.second;

			//已完成:卡应用号
			memcpy(&iptparam->OilBill[IPT_OFFSET_ASN], iptparam->IcAppId, 10);

			//已完成:余额(扣前)，交易完成后填扣后余额
			memcpy(&iptparam->OilBill[IPT_OFFSET_BALANCE], "\x00\x00\x00\x00", 4);

			//已完成:数额，交易完成后填实际数额
			memcpy(&iptparam->OilBill[IPT_OFFSET_AMN], "\x00\x00\x00", 3);

			//已完成:卡交易序号
			memcpy(&iptparam->OilBill[IPT_OFFSET_CTC], "\x00\x00", 2);

			//已完成:电子签名，加油/补扣/补充时未TAC，逃卡时为GTAC
			memcpy(&iptparam->OilBill[IPT_OFFSET_TAC], "\x10\x04\x00\x00", 4);

			//已完成:解灰认证码4bytes，加油完成，PSAM计算GMAC后添加
			memcpy(&iptparam->OilBill[IPT_OFFSET_GMAC], "\x00\x00\x00\x00", 4);

			//已完成:PSAM会所签名4bytes，加油完成，PSAM计算GMAC后添加
			memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TAC], "\x00\x00\x00\x00", 4);
				
			//已完成:PSAM应用号10bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_ASN], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 10);

			//已完成:PSAM编号6bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_TID], "\x00\x00\x00\x00\x00\x00", 6);

			//已完成:PSAM终端交易序号4bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TTC], "\x00\x00\x00\x00", 4);
			
			//已完成:扣款来源1byte
			iptparam->OilBill[IPT_OFFSET_DS]=iptparam->DS;
				
			//已完成:结算单位/方式1byte
			iptparam->OilBill[IPT_OFFSET_UNIT]=((iptparam->Payment&0x3f)<<4)|(iptparam->PayUnit&0x03);

			//已完成:卡类1byte
			iptparam->OilBill[IPT_OFFSET_C_TYPE]=iptparam->C_TYPE;

			//已完成:卡版本1byte，b7~b4卡密钥索引号；b3~b0卡密钥版本号
			iptparam->OilBill[IPT_OFFSET_VER]=0;

			//已完成:枪号1byte
			iptparam->OilBill[IPT_OFFSET_NZN]=0;
				
			//已完成:油品代码2bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_G_CODE], "\x00\x00", 2);

			//已完成:升数3bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_VOL], "\x00\x00\x00", 3);

			//已完成:成交价格2bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_PRC], "\x00\x00", 2);

			//已完成:员工号1byte
			iptparam->OilBill[IPT_OFFSET_EMP]=iptparam->EMP;

			//已完成:升累计4bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_V_TOT], "\x00\x00\x00\x00", 4);
				
			//已完成:备用部分11bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_RFU], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 11);

			//待填充:T-MAC	4bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], "\x00\x00\x00\x00", 4);
				
			//已完成:物理枪号PhysicsGunId
			iptparam->OilBill[IPT_OFFSET_PHYGUN]=iptparam->PhysicalNozzle;
				
			//已完成:计量停机代码
			iptparam->OilBill[IPT_OFFSET_STOPNO]=0;

			//已完成:扣前余额
			memcpy(&iptparam->OilBill[IPT_OFFSET_BEFOR_BAL], "\x00\x00\x00\x00", 4);

			//账单状态0=正常；1=未完成
			iptparam->OilBill[IPT_OFFSET_ZD_STATE]=1;

			//计量设备ID
			iptparam->OilBill[IPT_OFFSET_JLNOZZLE]=iptparam->JlNozzle;

			//计算账单校验值
			iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

			//保存账单及备份
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

			//转入账单TTC获取过程
			jljOilErrLogWrite(iptparam->Id, "加油启动失败，限每天加油金额卡!当天剩余允许加油金额=%d.", mbalance_today);
			iptPidSet(iptparam, IPT_PID_IC_TTC_GET);
			return;
		}
	}
	
	//判断卡限制信息:限每次加油量
	if(0!=memcmp(iptparam->IcVolumeLimit, "\xff\xff", 2))
	{
		//计算限制方式及限制量
		unit_limit=(iptparam->IcVolumeLimit[0]>>4)&0x0f;
		data=((iptparam->IcVolumeLimit[0]>>0)&0x0f)*100+((iptparam->IcVolumeLimit[1]>>4)&0x0f)*10+((iptparam->IcVolumeLimit[1]>>0)&0x0f)*1;
		if(0==unit_limit)	money_limit=data*100;
		else						volume_limit=data*100;

		//预置加油，预置量超过限制量时提示错误并退卡
		if(	IPT_PRESET_NO!=iptparam->PresetMode &&\
			((0==unit_limit && iptparam->PresetMoney>money_limit)||(0!=unit_limit && iptparam->PresetVolume>volume_limit)))
		{
			if(0==unit_limit)	dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "限每次加油金额卡", 16);
			else						dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "限每次加油升数卡", 16);
			ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();

			if(0==unit_limit)	jljOilErrLogWrite(iptparam->Id, "加油启动失败，限每次加油金额卡!每次允许加油金额=%d.", money_limit);
			else						jljOilErrLogWrite(iptparam->Id, "加油启动失败，限每次加油升数卡!每次允许加油升数=%d.", volume_limit);
			iptMainInterface(iptparam);
			return;
		}
	}

	//判断卡余额，预置金额
	//	中燃联达加油系统记账卡不判断卡余额!
	
	ppreset_mode = iptparam->PresetMode;
	if(1 == iptIsLianda(iptparam->Id) && (IPT_LIANDA_APPTYPE_JIZHANG == iptparam->IcAppType||IPT_LIANDA_APPTYPE_ZIYONG == iptparam->IcAppType||IPT_LIANDA_APPTYPE_DIAOBO == iptparam->IcAppType||IPT_LIANDA_APPTYPE_GUOBIAO == iptparam->IcAppType))
	{
		;
	}
	else if(1 == iptIsLianda(iptparam->Id) &&\
		(IPT_LIANDA_APPTYPE_DAICHU == iptparam->IcAppType || IPT_LIANDA_APPTYPE_DAICHUSIJI == iptparam->IcAppType) &&\
		IPT_PRESET_NO == ppreset_mode)
	{
		if(ibalance < pvolume_max)	iptparam->PresetVolume = ibalance;	
		else											iptparam->PresetVolume = pvolume_max;
		ppreset_mode = IPT_PRESET_VOLUME;
		iptparam->PresetMode = IPT_PRESET_VOLUME;
	}
	else if(IPT_PRESET_NO == ppreset_mode && ibalance < pmoney_max)
	{
		pmoney_max = ibalance;
	}
	//判断卡限制信息:限每日加油总金额
	if(IPT_PRESET_NO == ppreset_mode && 0 != memcmp(iptparam->IcMoneyDayLimit, "\xff\xff\xff\xff", 4) && mbalance_today < pmoney_max)
	{
		pmoney_max = mbalance_today;
	}
	//判断卡限制信息:限每次加油量
	if(IPT_PRESET_NO == ppreset_mode && 0 != memcmp(iptparam->IcVolumeLimit, "\xff\xff", 2) && 0 == unit_limit && money_limit < pmoney_max)
	{
		pmoney_max = money_limit;
	}
	if(IPT_PRESET_NO == ppreset_mode && 0 != memcmp(iptparam->IcVolumeLimit, "\xff\xff", 2) && 0 != unit_limit && volume_limit < pvolume_max)
	{
		pvolume_max = volume_limit;
	}
	//计算预置量，经过卡片限制计算得出预置量，最后一次计算
	tmp_buffer[0] = (char)(pmoney_max>>24);					tmp_buffer[1] = (char)(pmoney_max>>16);
	tmp_buffer[2] = (char)(pmoney_max>>8);						tmp_buffer[3] = (char)(pmoney_max>>0);
	tmp_buffer[4] = (char)(pvolume_max>>24);					tmp_buffer[5] = (char)(pvolume_max>>16);
	tmp_buffer[6] = (char)(pvolume_max>>8);						tmp_buffer[7] = (char)(pvolume_max>>0);
	tmp_buffer[8] = (char)(iptparam->PresetMoney>>24);		tmp_buffer[9] = (char)(iptparam->PresetMoney>>16);
	tmp_buffer[10] = (char)(iptparam->PresetMoney>>8);		tmp_buffer[11] = (char)(iptparam->PresetMoney>>0);
	tmp_buffer[12] = (char)(iptparam->PresetVolume>>24);	tmp_buffer[13] = (char)(iptparam->PresetVolume>>16);
	tmp_buffer[14] = (char)(iptparam->PresetVolume>>8);		tmp_buffer[15] = (char)(iptparam->PresetVolume>>0);
	tmp_buffer[16] = (char)(iptparam->OilPrice>>24);				tmp_buffer[17] = (char)(iptparam->OilPrice>>16);
	tmp_buffer[18] = (char)(iptparam->OilPrice>>8);				tmp_buffer[19] = (char)(iptparam->OilPrice>>0);
	tmp_buffer[20] = iptparam->PresetMode;
	jlPresetAmountCalculate(iptparam->JlNozzle, tmp_buffer); //fj:
	iptparam->PresetMoney = (tmp_buffer[8]<<24)|(tmp_buffer[9]<<16)|(tmp_buffer[10]<<8)|(tmp_buffer[11]<<0);
	iptparam->PresetVolume = (tmp_buffer[12]<<24)|(tmp_buffer[13]<<16)|(tmp_buffer[14]<<8)|(tmp_buffer[15]<<0);


	//判断预置量是否过小，不小于1升
	if(iptparam->PresetMoney<iptparam->OilPrice || iptparam->PresetMoney<IPT_MONEY_MIN || iptparam->PresetVolume<IPT_VOLUME_MIN)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "预置量太小", 10);
		ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "加油启动失败，预置量太小!");
		iptMainInterface(iptparam);
		return;
	}

	//判断预置量是否过大
	if(iptparam->PresetMoney>JL_MONEY_MAX || iptparam->PresetVolume>JL_VOLUME_MAX)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "预置量太大", 10);
		ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "加油启动失败，预置量太大!");
		iptMainInterface(iptparam);
		return;
	}

	//记录加油时间，初始化本次加油数据
	iptparam->OilTime[0]=iptparam->Time.century;	iptparam->OilTime[1]=iptparam->Time.year;
	iptparam->OilTime[2]=iptparam->Time.month;		iptparam->OilTime[3]=iptparam->Time.date;
	iptparam->OilTime[4]=iptparam->Time.hour;		iptparam->OilTime[5]=iptparam->Time.minute;
	iptparam->OilTime[6]=iptparam->Time.second;
	iptparam->OilMoney=0;	iptparam->OilVolume=0;		iptparam->OilPrice=iptparam->OilPrice;
	if(1 == iptIsLianda(iptparam->Id) )iptparam->OilMoneyDiscount=0;//2017-01-22解决中燃联达税控启动失败IC卡会自动扣上一笔的加油数据的bug
	//jlSumRead(iptparam->JlNozzle, &volume_sum, &money_sum);//fj:
	GetjlSumRead(iptparam->JlNozzle,&volume_sum,&money_sum);  //fj:20171023
	iptparam->SumMoney=money_sum;	iptparam->SumVolume=volume_sum;
	iptparam->OilRound=0;

	//促销机通知平板电脑状态
	if(1 == paramPromotionGet())
	{
		iptparam->TaState = IPT_STATE_CARD_OILSTART;	iptparam->TaStateParamLength = 0;
		pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
	}

	//进入卡处理过程
	dsp(iptparam->DEVDsp, DSP_CARD_OIL_START, "\x00", 0);
	if(0==iptparam->DESAuthen)	iptPidSet(iptparam, IPT_PID_IC_OIL_AUTHEN);
	else												iptPidSet(iptparam, IPT_PID_IC_LOCK_INIT);

//printf("[%s][%d]money=%d; volume=%d; mode=%d; iptparam->IcDebitUnit = %x.\n", __FUNCTION__, __LINE__, (unsigned int)(iptparam->PresetMoney), (unsigned int)(iptparam->PresetVolume),  iptparam->PresetMode, iptparam->IcDebitUnit);//myDEBUG
	return;
}


/*******************************************************************
*Name				:iptIcOilAuthen
*Description		:IC卡加油启动认证
*Input				:None
*Output			:None
*Return				:None
*History			:2014-04-17,modified by syj  */

static void iptIcOilAuthen(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char buffer[128]={0}, dsp_buffer[64]={0}, dsp_len=0;
	unsigned char irandom[8]={0};
	int istate=0, apdu_len=0, i=0;

	switch(iptparam->Step)
	{
	case 0:	
		//判断安全提升状态
		istate=PsamGetAPProof(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate)
		{
			iptparam->IcOverTimes=0;
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
			{
				iptparam->PsamProofTimes=buffer[2];	iptparam->Step++;
			}
			else if(0==memcmp(&buffer[2+apdu_len-2], "\x6D\x00", 2) || 0==memcmp(&buffer[2+apdu_len-2], "\x9B\x01", 2) )
			{
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=12;	memcpy(&dsp_buffer[3], "请更换PSAM卡", 12);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
			}
			else if(0==memcmp(&buffer[2+apdu_len-2], "\x9B\x02", 2))
			{
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=10;	memcpy(&dsp_buffer[3], "芯片未注册", 10);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
			}
			else if(0==memcmp(&buffer[2+apdu_len-2], "\x9B\x03", 2))
			{
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=29;	memcpy(&dsp_buffer[3], "安全锁定,请更换PSAM或重新绑定", 29);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
			}
			else
			{
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=20;	memcpy(&dsp_buffer[3], "获取安全提升状态失败", 20);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
			}

			//认证失败，组织出错信息
			if(0!=memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2)){

				memcpy(&iptparam->ErrInfo[0], "#*1122*#", 8);				//报文分类
				memcpy(&iptparam->ErrInfo[8], IPT_COMPANY_ID, 2);		//厂商编号
				memcpy(&iptparam->ErrInfo[10], PCD_VERSION_DSP, 4);	//软件版本
																											//时间
				iptparam->ErrInfo[14]=((iptparam->Time.century>>4)&0x0f)+0x30;
				iptparam->ErrInfo[15]=((iptparam->Time.century>>0)&0x0f)+0x30;
				iptparam->ErrInfo[16]=((iptparam->Time.year>>4)&0x0f)+0x30;
				iptparam->ErrInfo[17]=((iptparam->Time.year>>0)&0x0f)+0x30;
				iptparam->ErrInfo[18]=((iptparam->Time.month>>4)&0x0f)+0x30;
				iptparam->ErrInfo[19]=((iptparam->Time.month>>0)&0x0f)+0x30;
				iptparam->ErrInfo[20]=((iptparam->Time.date>>4)&0x0f)+0x30;
				iptparam->ErrInfo[21]=((iptparam->Time.date>>0)&0x0f)+0x30;
				iptparam->ErrInfo[22]=((iptparam->Time.hour>>4)&0x0f)+0x30;
				iptparam->ErrInfo[23]=((iptparam->Time.hour>>0)&0x0f)+0x30;
				iptparam->ErrInfo[24]=((iptparam->Time.minute>>4)&0x0f)+0x30;
				iptparam->ErrInfo[25]=((iptparam->Time.minute>>0)&0x0f)+0x30;
				iptparam->ErrInfo[26]=((iptparam->Time.second>>4)&0x0f)+0x30;
				iptparam->ErrInfo[27]=((iptparam->Time.second>>0)&0x0f)+0x30;
				for(i=0; i<8; i++){																//计量芯片ID

					iptparam->ErrInfo[28+i*2+0]=((MboardID[i]>>4)&0x0f)+0x30;
					iptparam->ErrInfo[28+i*2+1]=((MboardID[i]>>0)&0x0f)+0x30;
				}
																											//厂商自定义
				memcpy(&iptparam->ErrInfo[44], "001111111111", 12);
				iptparam->ErrInfo[56]=((buffer[2+apdu_len-2]>>4)&0x0f)+0x30;
				iptparam->ErrInfo[57]=((buffer[2+apdu_len-2]>>0)&0x0f)+0x30;
				iptparam->ErrInfo[58]=((buffer[2+apdu_len-1]>>4)&0x0f)+0x30;
				iptparam->ErrInfo[59]=((buffer[2+apdu_len-1]>>0)&0x0f)+0x30;
				for(i=0; i<10; i++){																//PSAM卡号

					iptparam->ErrInfo[60+i*2+0]=((iptparam->PsamId[i]>>4)&0x0f)+0x30;
					iptparam->ErrInfo[60+i*2+1]=((iptparam->PsamId[i]>>0)&0x0f)+0x30;
				}
				//转入错误信息计算TMAC过程
				iptPidSet(iptparam, IPT_PID_ERRINFO_TMAC);
			}
		}
		//操作失败则提示错误信息
		else if(ICSTATE_FAILED==istate){
			
			iptparam->IcOverTimes=0;
		
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "获取安全提升状态失败", 20);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退出
		else if(ICSTATE_OVERTIME==istate){
			
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3)
			{
				iptparam->IcOverTimes=0;
				
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "获取安全提升状态超时", 20);
				IPT_DSP_WAIT();

				ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else
		{
			iptparam->IcOverTimes=0;
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "获取安全提升状态错误", 20);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
		break;
		
	case 1:	
		//向PSAM申请随机数
		istate=PsamGetRandom(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate){
			
			iptparam->IcOverTimes=0;
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2)){
	
				memcpy(&irandom[0], &buffer[2], 4);					//随机数
				memcpy(&irandom[4], "\x00\x00\x00\x00", 4);	//随机数后补0
				des_en3(Key, irandom, 8, iptparam->DESCiphertext);

				iptparam->Step++;
			}
			else{
				
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=22;	memcpy(&dsp_buffer[3], "安全提升申请随机数失败", 22);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				IPT_DSP_WAIT();

				ICShoot(iptparam->DEVIC);iptMainInterface(iptparam);
			}
		}
		//操作失败则提示错误信息
		else if(ICSTATE_FAILED==istate){
			
			iptparam->IcOverTimes=0;
		
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "安全提升申请随机数失败", 22);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退出
		else if(ICSTATE_OVERTIME==istate){
			
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3){
				
				iptparam->IcOverTimes=0;

				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "安全提升申请随机数超时", 22);
				IPT_DSP_WAIT();

				ICShoot(iptparam->DEVIC);
				iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "安全提升申请随机数错误", 22);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
		break;

	case 2:	
		//向PSAM进行安全提升认证 ANTI-PLAGIAREZE AUTHENTICATION
		istate=PsamAPAuthen(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, iptparam->DESCiphertext);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate)
		{
			iptparam->IcOverTimes=0;
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2)){
		
				iptPidSet(iptparam, IPT_PID_IC_LOCK_INIT);
			}
			else if(0x6B==buffer[2+apdu_len-2]){
	
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=22;
				memcpy(&dsp_buffer[3], "认证失败,剩余", 13);
				dsp_buffer[16]=(buffer[2+apdu_len-1]/100)+0x30;			if('0'==dsp_buffer[16])	dsp_buffer[16]=' ';
				dsp_buffer[17]=(buffer[2+apdu_len-1]%100/10)+0x30;	if('0'==dsp_buffer[17])	dsp_buffer[17]=' ';
				dsp_buffer[18]=(buffer[2+apdu_len-1]%10/1)+0x30;
				memcpy(&dsp_buffer[19], "次机会", 6);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
			}
			else{

				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=12;	memcpy(&dsp_buffer[3], "安全认证失败", 12);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
			}

			//认证失败，组织出错信息
			if(0!=memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2)){

				memcpy(&iptparam->ErrInfo[0], "#*1122*#", 8);				//报文分类
				memcpy(&iptparam->ErrInfo[8], IPT_COMPANY_ID, 2);		//厂商编号
				memcpy(&iptparam->ErrInfo[10], PCD_VERSION_DSP, 4);	//软件版本
																											//时间
				iptparam->ErrInfo[14]=((iptparam->Time.century>>4)&0x0f)+0x30;
				iptparam->ErrInfo[15]=((iptparam->Time.century>>0)&0x0f)+0x30;
				iptparam->ErrInfo[16]=((iptparam->Time.year>>4)&0x0f)+0x30;
				iptparam->ErrInfo[17]=((iptparam->Time.year>>0)&0x0f)+0x30;
				iptparam->ErrInfo[18]=((iptparam->Time.month>>4)&0x0f)+0x30;
				iptparam->ErrInfo[19]=((iptparam->Time.month>>0)&0x0f)+0x30;
				iptparam->ErrInfo[20]=((iptparam->Time.date>>4)&0x0f)+0x30;
				iptparam->ErrInfo[21]=((iptparam->Time.date>>0)&0x0f)+0x30;
				iptparam->ErrInfo[22]=((iptparam->Time.hour>>4)&0x0f)+0x30;
				iptparam->ErrInfo[23]=((iptparam->Time.hour>>0)&0x0f)+0x30;
				iptparam->ErrInfo[24]=((iptparam->Time.minute>>4)&0x0f)+0x30;
				iptparam->ErrInfo[25]=((iptparam->Time.minute>>0)&0x0f)+0x30;
				iptparam->ErrInfo[26]=((iptparam->Time.second>>4)&0x0f)+0x30;
				iptparam->ErrInfo[27]=((iptparam->Time.second>>0)&0x0f)+0x30;
				for(i=0; i<8; i++){																//计量芯片ID

					iptparam->ErrInfo[28+i*2+0]=((MboardID[i]>>4)&0x0f)+0x30;
					iptparam->ErrInfo[28+i*2+1]=((MboardID[i]>>0)&0x0f)+0x30;
				}
																											//厂商自定义
				if(0x6B==buffer[2+apdu_len-2]){

					iptparam->ErrInfo[44]=(buffer[2+apdu_len-1]%100/10)+0x30;
					iptparam->ErrInfo[45]=(buffer[2+apdu_len-1]%10/1)+0x30;
					memcpy(&iptparam->ErrInfo[46], "11111111111111", 14);
				}
				else{
					
					memcpy(&iptparam->ErrInfo[44], "001111111111", 12);
					iptparam->ErrInfo[56]=((buffer[2+apdu_len-2]>>4)&0x0f)+0x30;
					iptparam->ErrInfo[57]=((buffer[2+apdu_len-2]>>0)&0x0f)+0x30;
					iptparam->ErrInfo[58]=((buffer[2+apdu_len-1]>>4)&0x0f)+0x30;
					iptparam->ErrInfo[59]=((buffer[2+apdu_len-1]>>0)&0x0f)+0x30;
				}
				for(i=0; i<10; i++){																//PSAM卡号

					iptparam->ErrInfo[60+i*2+0]=((iptparam->PsamId[i]>>4)&0x0f)+0x30;
					iptparam->ErrInfo[60+i*2+1]=((iptparam->PsamId[i]>>0)&0x0f)+0x30;
				}
				//转入错误信息计算TMAC过程
				iptPidSet(iptparam, IPT_PID_ERRINFO_TMAC);
			}
		}
		//操作失败则提示错误信息
		else if(ICSTATE_FAILED==istate)
		{
			iptparam->IcOverTimes=0;
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "安全认证失败", 12);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退出
		else if(ICSTATE_OVERTIME==istate)
		{
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3)
			{
				iptparam->IcOverTimes=0;
				
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "安全认证超时", 12);
				IPT_DSP_WAIT();

				ICShoot(iptparam->DEVIC);iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else
		{
			iptparam->IcOverTimes=0;
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "安全认证错误", 12);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);iptMainInterface(iptparam);
		}
		break;

	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptIcLockInit
*Description		:IC卡灰锁初始化过程
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcLockInit(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char buffer[128]={0}, dsp_buffer[64]={0}, dsp_len=0;
	int istate=0, apdu_len=0;

	//发送IC卡灰锁初始化命令
	istate=ICLockInit(iptparam->DEVIC, 0, buffer, 128, iptparam->PsamKeyIndex, iptparam->PsamTermId);

	//操作成功则继续下一步
	if(ICSTATE_OK==istate)
	{
		iptparam->IcOverTimes=0;
		apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
		if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
		{
			memcpy(iptparam->IcLockInitBalance, &buffer[2], 4);		//灰锁初始化返回卡余额		
			memcpy(iptparam->IcLockInitCTC, &buffer[6], 2);			//灰锁初始化返回脱机交易序号
			memcpy(iptparam->IcLockInitOverdraw, &buffer[8], 3);	//灰锁初始化返回透支限额
			iptparam->IcLockInitKeysVersion=buffer[11];					//灰锁初始化返回密钥版本号		
			iptparam->IcLockInitArithmetic=buffer[12];						//灰锁初始化返回算法标识	
			memcpy(iptparam->IcLockInitRandom, &buffer[13], 4);	//灰锁初始化返回伪随机数

			iptPidSet(iptparam, IPT_PID_IC_MAC1);							//转入PSAM灰锁初始化计算MAC1过程
		}
		else
		{
			memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
			dsp_buffer[2]=14;	memcpy(&dsp_buffer[3], "灰锁初始化失败", 14);
			dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);iptMainInterface(iptparam);
		}
	}
	//操作失败则提示错误信息
	else
	if(ICSTATE_FAILED==istate)
	{
		iptparam->IcOverTimes=0;
			
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "灰锁初始化失败", 14);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);iptMainInterface(iptparam);
	}
	//操作超时，不足三次再次操作，超过三次退出
	else
	if(ICSTATE_OVERTIME==istate)
	{
		iptparam->IcOverTimes++;
		if(iptparam->IcOverTimes>=3)
		{
			iptparam->IcOverTimes=0;
					
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "灰锁初始化超时", 14);
			IPT_DSP_WAIT();
			
			ICShoot(iptparam->DEVIC);iptMainInterface(iptparam);
		}
	}
	//未定义错误
	else
	{
		iptparam->IcOverTimes=0;
					
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "灰锁初始化错误", 14);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);iptMainInterface(iptparam);
	}

	return;
}


/*******************************************************************
*Name				:iptIcMac1
*Description		:PSAM灰锁初始化计算MAC1过程
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcMac1(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char buffer[128]={0}, dsp_buffer[64]={0}, dsp_len=0;
	int istate=0, apdu_len=0;

	//发送PSAM卡灰锁初始化命令
	istate=PsamLockInit(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, iptparam->IcLockInitRandom, iptparam->IcLockInitCTC, iptparam->IcLockInitBalance, iptparam->OilTime, iptparam->IcLockInitKeysVersion, iptparam->IcLockInitArithmetic, &iptparam->IcAppId[2],  iptparam->IcIssuerMark);

	//操作成功则继续下一步
	if(ICSTATE_OK==istate)
	{
		iptparam->IcOverTimes=0;
		apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
		if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
		{
			memcpy(iptparam->IcPsamTTC, &buffer[2], 4);			//PSAM返回终端交易序号
			memcpy(iptparam->IcPsamRandom, &buffer[6], 4);	//PSAM返回终端随机数
			memcpy(iptparam->IcPsamMAC1, &buffer[10], 4);		//PSAM返回MAC1

			iptPidSet(iptparam, IPT_PID_IC_LOCK);						//转入IC卡灰锁过程
		}
		else
		{
			memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
			dsp_buffer[2]=12;	memcpy(&dsp_buffer[3], "计算MAC1失败", 12);
			dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);iptMainInterface(iptparam);
		}
	}
	//操作失败则提示错误信息
	else
	if(ICSTATE_FAILED==istate)
	{
		iptparam->IcOverTimes=0;
	
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "计算MAC1失败", 12);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);
		iptMainInterface(iptparam);
	}
	//操作超时，不足三次再次操作，超过三次退出
	else
	if(ICSTATE_OVERTIME==istate)
	{
		iptparam->IcOverTimes++;
		if(iptparam->IcOverTimes>=3)
		{
			iptparam->IcOverTimes=0;
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "计算MAC1超时", 12);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);iptMainInterface(iptparam);
		}
	}
	//未定义错误
	else
	{
		iptparam->IcOverTimes=0;
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "计算MAC1错误", 12);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);iptMainInterface(iptparam);
	}

	return;
}


/*******************************************************************
*Name				:iptIcLock
*Description		:IC卡灰锁过程
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcLock(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char buffer[128]={0}, dsp_buffer[64]={0}, dsp_len=0;
	int istate=0, apdu_len=0;
	unsigned int ttc_value=0;

	//发送IC卡灰锁命令
	istate=ICGreyLock(iptparam->DEVIC, 0, buffer, 128, iptparam->IcPsamTTC, iptparam->IcPsamRandom, iptparam->OilTime, iptparam->IcPsamMAC1);

	//操作成功则继续下一步
	if(ICSTATE_OK==istate)
	{
		iptparam->IcOverTimes=0;
		apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
		if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
		{
			//保存数据
			memcpy(iptparam->IcGTAC, &buffer[2], 4);	//IC灰锁返回GTAC
			memcpy(iptparam->IcMAC2, &buffer[6], 4);	//IC灰锁返回MAC2

			//灰锁成功后脱机交易序号自加一位
			ttc_value=(iptparam->IcLockInitCTC[0]<<8)|(iptparam->IcLockInitCTC[1]<<0);
			ttc_value++;
			iptparam->IcLockInitCTC[0]=(unsigned char)(ttc_value>>8);	iptparam->IcLockInitCTC[1]=(unsigned char)(ttc_value>>0);

			//转入逃卡账单产生过程
			iptPidSet(iptparam, IPT_PID_IC_ZD_ESCAPE);
		}
		else
		{
			memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
			dsp_buffer[2]=12;	memcpy(&dsp_buffer[3], "IC卡灰锁失败", 12);
			dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
	}
	//操作失败则提示错误信息
	else if(ICSTATE_FAILED==istate)
	{
		iptparam->IcOverTimes=0;

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡灰锁失败", 12);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
	}
	//操作超时，转入读取灰锁状态
	else if(ICSTATE_OVERTIME==istate)
	{
		iptPidSet(iptparam, IPT_PID_IC_LOCK_GREYINFO);
	}
	//未定义错误
	else
	{
		iptparam->IcOverTimes=0;
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡灰锁错误", 12);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
	}

	return;
}


/*******************************************************************
*Name				:iptIcOilLockInfo
*Description		:加油灰锁超时读取卡灰锁信息以确定是否灰锁成功
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcOilLockInfo(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char buffer[128]={0};
	int apdu_len=0, istate=0;
	unsigned char dsp_buffer[64]={0}, dsp_len=0;

	//IC卡灰锁信息读取
	istate=ICGreyInfoRead(iptparam->DEVIC, 0, buffer, 128);

	//操作成功则继续下一步
	if(ICSTATE_OK==istate)
	{
		apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
		if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
		{
			//状态字为0x01已灰锁，则认为加油卡灰锁成功，否则继续执行灰锁
			if(0x01==buffer[2])
			{
				memcpy(iptparam->IcLockInitCTC, &buffer[9], 2);	//被灰锁的ET脱机交易序号
				memcpy(iptparam->IcMAC2, &buffer[24], 4);			//灰锁时的MAC2
				memcpy(iptparam->IcGTAC, &buffer[28], 4);			//灰锁时的GTAC

				iptparam->IcOverTimes=0;
				iptPidSet(iptparam, IPT_PID_IC_ZD_ESCAPE);
			}
			else if(iptparam->IcOverTimes < 3)
			{
				iptparam->IcOverTimes ++;
				iptPidSet(iptparam, IPT_PID_IC_LOCK);
			}
			else if(iptparam->IcOverTimes >= 3)
			{
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=16;	memcpy(&dsp_buffer[3], "加油卡灰锁失败! ", 16);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				IPT_DSP_WAIT();

				iptparam->IcOverTimes=0;
				ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
			}
		}
		//读灰锁信息失败
		else
		{
			memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
			dsp_buffer[2]=16;	memcpy(&dsp_buffer[3], "读卡灰锁信息失败", 16);
			dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
			IPT_DSP_WAIT();

			iptparam->IcOverTimes=0;
			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
	}
	//操作失败则提示信息后退卡
	else if(ICSTATE_FAILED==istate)
	{
		iptparam->IcOverTimes=0;

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "读卡灰锁信息失败", 16);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
	}
	//操作超时，不足三次再次操作，超过三次退卡
	else if(ICSTATE_OVERTIME==istate)
	{
		iptparam->IcOverTimes++;
		if(iptparam->IcOverTimes<3)
		{
			iptPidSet(iptparam, IPT_PID_IC_LOCK);
		}
		else
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "读卡灰锁信息超时", 16);
			IPT_DSP_WAIT();

			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
	}
	//未定义错误
	else
	{
		iptparam->IcOverTimes=0;

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "读卡灰锁信息错误", 16);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
	}

	return;
}


/*******************************************************************
*Name				:iptIcZDEscape
*Description		:加油产生逃卡账单
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcZDEscape(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	int istate=0;
	unsigned long long volume_sum=0, money_sum=0;

	if(iptparam->EtcOilFlg==1)
	{
		iptparam->EtcFreeflag=2;   //释放OBU退出车辆列表
		if(iptparam->Id==IPT_NOZZLE_1)
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+FM_ETC_FREE_FLG_A, &iptparam->EtcFreeflag, 1);
		else
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+FM_ETC_FREE_FLG_B, &iptparam->EtcFreeflag, 1);
	}

	//IC加油数据保存逃卡账单
	//待填充:POS_TTC
	memcpy(&iptparam->OilBill[IPT_OFFSET_TTC], "\x00\x00\x00\x00", 4);

	//待填充:交易类型设为无卡错，后台/本地黑白名单，扣款签名无效，逃卡
	iptparam->OilBill[IPT_OFFSET_T_TYPE]=(0<<7)|((iptparam->BlistSrc&1)<<6)|(0<<4)|(1<<0);

	//已完成:交易日期及时间
	memcpy(&iptparam->OilBill[IPT_OFFSET_TIME], iptparam->OilTime, 7);

	//已完成:卡应用号
	memcpy(&iptparam->OilBill[IPT_OFFSET_ASN], iptparam->IcAppId, 10);

	//待填充:余额(扣前)，交易完成后填扣后余额
	memcpy(&iptparam->OilBill[IPT_OFFSET_BALANCE], iptparam->IcBalance, 4);

	//待填充:数额，交易完成后填实际数额
	memcpy(&iptparam->OilBill[IPT_OFFSET_AMN], "\x00\x00\x00", 3);

	//已完成:卡交易序号
	memcpy(&iptparam->OilBill[IPT_OFFSET_CTC], iptparam->IcLockInitCTC, 2);

	//待填充:电子签名，加油/补扣/补充时为TAC，逃卡时为GTAC
	memcpy(&iptparam->OilBill[IPT_OFFSET_TAC], iptparam->IcGTAC, 4);

	//待填充:解灰认证码4bytes，加油完成，PSAM计算GMAC后添加
	memcpy(&iptparam->OilBill[IPT_OFFSET_GMAC], "\x00\x00\x00\x00", 4);

	//待填充:PSAM会所签名4bytes，加油完成，PSAM计算GMAC后添加
	memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TAC], "\x00\x00\x00\x00", 4);

	//已完成:PSAM应用号10bytes
	memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_ASN], iptparam->PsamId, 10);

	//已完成:PSAM编号6bytes
	memcpy(&iptparam->OilBill[IPT_OFFSET_TID], iptparam->PsamTermId, 6);

	//已完成:PSAM终端交易序号4bytes
	memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TTC], iptparam->IcPsamTTC, 4);

	//已完成:扣款来源1byte
	iptparam->OilBill[IPT_OFFSET_DS]=iptparam->DS;

	//社会站联达加油站系统，根据支付方式重新填充扣款来源字段, 修改于2016-04-28，by SYJ
	if(1 == iptIsLianda(iptparam->Id) && 0 == iptparam->Payment)
	{
		iptparam->OilBill[IPT_OFFSET_DS] = 0x94;
	}
	if(1 == iptIsLianda(iptparam->Id) && 0 != iptparam->Payment)
	{
		iptparam->OilBill[IPT_OFFSET_DS] = 0x95;
	}

	//已完成:结算单位/方式1byte
	iptparam->OilBill[IPT_OFFSET_UNIT]=((iptparam->Payment&0x3f)<<4)|(iptparam->PayUnit&0x03);
			
	//已完成:卡类1byte
	iptparam->OilBill[IPT_OFFSET_C_TYPE]=iptparam->C_TYPE;

	//已完成:卡版本1byte，b7~b4卡密钥索引号；b3~b0卡密钥版本号
	iptparam->OilBill[IPT_OFFSET_VER]=((iptparam->PsamKeyIndex&0x0f)<<4)|((iptparam->IcLockInitKeysVersion&0x0f)<<0);

	//已完成:枪号1byte
	iptparam->OilBill[IPT_OFFSET_NZN]=iptparam->LogicNozzle;
			
	//已完成:油品代码2bytes
	memcpy(&iptparam->OilBill[IPT_OFFSET_G_CODE], iptparam->OilCode, 2);
			
	//升数3bytes，交易完成后填实际升数
	memcpy(&iptparam->OilBill[IPT_OFFSET_VOL], "\x00\x00\x00", 3);
			
	//已完成:成交价格2bytes
	iptparam->OilBill[IPT_OFFSET_PRC+0]=(char)(iptparam->OilPrice>>8);	
	iptparam->OilBill[IPT_OFFSET_PRC+1]=(char)(iptparam->OilPrice>>0);

	//已完成:员工号1byte
	iptparam->OilBill[IPT_OFFSET_EMP]=iptparam->EMP;
			
	//已完成:升累计4bytes，交易完成后填实际总累
	//jlSumRead(iptparam->JlNozzle, &volume_sum, &money_sum); //fj:
	GetjlSumRead(iptparam->JlNozzle,&volume_sum,&money_sum);  //fj:20171023
	iptparam->OilBill[IPT_OFFSET_V_TOT+0]=(char)(volume_sum>>24);
	iptparam->OilBill[IPT_OFFSET_V_TOT+1]=(char)(volume_sum>>16);
	iptparam->OilBill[IPT_OFFSET_V_TOT+2]=(char)(volume_sum>>8);	
	iptparam->OilBill[IPT_OFFSET_V_TOT+3]=(char)(volume_sum>>0);

	//已完成:备用部分11bytes
	memcpy(&iptparam->OilBill[IPT_OFFSET_RFU], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 11);

	//联达加油系统本次加油信息
	if(1 == iptIsLianda(iptparam->Id))
	{
		iptparam->OilBill[IPT_OFFSET_DISCOUNT+0] = (char)(iptparam->PriceDiscount>>8);
		iptparam->OilBill[IPT_OFFSET_DISCOUNT+1] = (char)(iptparam->PriceDiscount>>0);

		iptparam->OilBill[IPT_OFFSET_INVOICE_TYPE] = iptparam->InvoiceType;
	}

	//待填充:T-MAC	4bytes
	memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], "\x00\x00\x00\x00", 4);
					
	//已完成:物理枪号PhysicsGunId
	iptparam->OilBill[IPT_OFFSET_PHYGUN]=iptparam->PhysicalNozzle;
					
	//已完成:计量停机原因
	iptparam->OilBill[IPT_OFFSET_STOPNO]=0;

	//已完成:扣前余额
	memcpy(&iptparam->OilBill[IPT_OFFSET_BEFOR_BAL], iptparam->IcBalance, 4);

	//账单状态:0=正常；1=未完成
	iptparam->OilBill[IPT_OFFSET_ZD_STATE]=1;

	//计量设备ID
	iptparam->OilBill[IPT_OFFSET_JLNOZZLE]=iptparam->JlNozzle;

	//计算账单校验值
	iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

	//保存账单及备份
	istate=framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
	istate=framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

	//转入MAC2计算过程
	iptPidSet(iptparam, IPT_PID_IC_MAC2);

	return;
}


/*******************************************************************
*Name				:iptIcMac2
*Description		:PSAM验证MAC2
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcMac2(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char buffer[128]={0}, dsp_buffer[64]={0}, dsp_len=0;
	int istate=0, apdu_len=0;

	//发送PSAM卡验证MAC2命令
	istate=PsamMAC2Check(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, iptparam->IcMAC2);

	//操作成功则继续下一步
	if(ICSTATE_OK==istate)
	{
		iptparam->IcOverTimes=0;
		apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
		if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
		{
			iptPidSet(iptparam, IPT_PID_IC_OILSTART);
		}
		else
		{
			memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
			dsp_buffer[2]=12;	memcpy(&dsp_buffer[3], "验证MAC2失败", 12);
			dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
			IPT_DSP_WAIT();

			dsp(iptparam->DEVDsp, DSP_CARD_OIL_FINISH, "\x00", 0);
			iptPidSet(iptparam, IPT_PID_IC_PSAM_GMAC);
		}
	}
	//操作失败则提示错误信息
	else
	if(ICSTATE_FAILED==istate)
	{
		iptparam->IcOverTimes=0;

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "验证MAC2失败", 12);
		IPT_DSP_WAIT();

		dsp(iptparam->DEVDsp, DSP_CARD_OIL_FINISH, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_IC_PSAM_GMAC);
	}
	//操作超时，不足三次再次操作，超过三次退出
	else
	if(ICSTATE_OVERTIME==istate)
	{
		iptparam->IcOverTimes++;
		if(iptparam->IcOverTimes>=3)
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "验证MAC2超时", 12);
			IPT_DSP_WAIT();

			dsp(iptparam->DEVDsp, DSP_CARD_OIL_FINISH, "\x00", 0);
			iptPidSet(iptparam, IPT_PID_IC_PSAM_GMAC);
		}
	}
	//未定义错误
	else
	{
		iptparam->IcOverTimes=0;

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "验证MAC2错误", 12);
		IPT_DSP_WAIT();

		dsp(iptparam->DEVDsp, DSP_CARD_OIL_FINISH, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_IC_PSAM_GMAC);
	}
	
	return;
}


/*******************************************************************
*Name				:iptIcOilStart
*Description		:IC卡加油开始过程
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcOilStart(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	int voice[16]={0};
	int i=0, istate=0;
	PCOilInfoType info;
	unsigned char dsp_buffer[256]={0}, dsp_len=0;
	unsigned char dsp_data[4]={0};
	int pspeed = 0;

	//for(i=0; i<3; i++)
	for(i = 0; i < 1; i++)  //fj:20171122
	{
		//向税控申请加油，预置升数以升数为预置量，否则以金额为预置量
		if(IPT_PRESET_VOLUME==iptparam->PresetMode)
		{
         	printf("IC oiling:read preset volum add oil,volume = %lld,Price = %lld\n",iptparam->PresetVolume,iptparam->OilPrice);
			istate=jlOilStart(iptparam->JlNozzle, iptparam->PresetVolume, iptparam->OilPrice, iptparam->PresetMode);
		}
		else
		{
            printf("IC oiling: read preset money add oil,money = %lld,Price = %lld\n",iptparam->PresetMoney,iptparam->OilPrice);
			istate=jlOilStart(iptparam->JlNozzle, iptparam->PresetMoney, iptparam->OilPrice, iptparam->PresetMode);    
		}
		//2017-02-13主板直接掉电卡解扣
		if(1 == iptIsLianda(iptparam->Id))
			{
				dsp_data[0]=iptparam->IcDebitUnit;
				dsp_data[1]=iptparam->IcDiscountFlag;
				dsp_data[2]=(iptparam->PriceDiscount>>8);
				dsp_data[3]=(iptparam->PriceDiscount>>0);
				framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_LDPowerData, dsp_data, 4);
			}
		//计量启动成功不再申请
		if(0==istate)	break;

		//启动失败，下次启动之前先做延时释放
		if(0!=istate)	usleep(1000);
	}

	//税控申请失败
	if(0!=istate)
	{
		memset(dsp_buffer, 0, sizeof(dsp_buffer));
		memcpy(dsp_buffer, "计量启动失败    ", 16);
		i=((char)(istate>>4)&0x0f)*10+((char)(istate>>0)&0x0f)*1;
		//memcpy(dsp_buffer+strlen(dsp_buffer), jlStartFiledReson[i], strlen(jlStartFiledReson[i])); //fj:会导致位段错误
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, strlen(dsp_buffer));
		IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "%s", dsp_buffer); //fj:

		dsp(iptparam->DEVDsp, DSP_CARD_OIL_FINISH, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_IC_PSAM_GMAC);
		return;
	}

	//语音提示"此油枪加注XX，泵码已回零，请确认"
	if(0 == paramPromotionGet() && iptparam->VoiceVolume>0 && IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType)
	{
		voice[0]=SPKW_OILFILL;															//此油枪加注
																										//油品语音代码
		if(0==memcmp(iptparam->OilVoice, "\x00\x00\x00\x00", 4))
			voice[1]=iptOilVoiceIdGet(iptparam, iptparam->OilCode);
		else
			voice[1]=((iptparam->OilVoice[0]&0x0f)<<12)|((iptparam->OilVoice[1]&0x0f)<<8)|\
							((iptparam->OilVoice[2]&0x0f)<<4)|((iptparam->OilVoice[3]&0x0f)<<0);
		voice[2]=SPKW_OILACK;															//泵码已回零，请确认
		iptSpk(iptparam, voice, 3);
	}
	else if(0 == paramPromotionGet() && iptparam->VoiceVolume>0 && IPT_VOICE_TYPE_MAN==iptparam->VoiceType)
	{
		voice[0]=SPKM_OILFILL;															//此油枪加注
																										//油品语音代码
		if(0==memcmp(iptparam->OilVoice, "\x00\x00\x00\x00", 4))
			voice[1]=iptOilVoiceIdGet(iptparam, iptparam->OilCode);
		else
			voice[1]=((iptparam->OilVoice[0]&0x0f)<<12)|((iptparam->OilVoice[1]&0x0f)<<8)|\
							((iptparam->OilVoice[2]&0x0f)<<4)|((iptparam->OilVoice[3]&0x0f)<<0);
		voice[2]=SPKM_OILACK;															//泵码已回零，请确认
		iptSpk(iptparam, voice, 3);
	}

	//参数根据状态初始化
	iptparam->VoiceFlag=0;
	iptparam->OilState=IPT_OIL_FUELLING;

	//显示加油中界面
	memcpy(&dsp_buffer[0], iptparam->IcAppId, 10);
	memcpy(&dsp_buffer[10], iptparam->IcBalance, 4);
	dsp_buffer[14]=iptparam->PayUnit;
	if(IPT_PRESET_VOLUME==iptparam->PresetMode)
	{
		dsp_buffer[15]=(char)(iptparam->PresetVolume>>24);	dsp_buffer[16]=(char)(iptparam->PresetVolume>>16);
		dsp_buffer[17]=(char)(iptparam->PresetVolume>>8);	dsp_buffer[18]=(char)(iptparam->PresetVolume>>0);
		dsp_buffer[19]=1;
	}
	else
	{
		dsp_buffer[15]=(char)(iptparam->PresetMoney>>24);	dsp_buffer[16]=(char)(iptparam->PresetMoney>>16);
		dsp_buffer[17]=(char)(iptparam->PresetMoney>>8);		dsp_buffer[18]=(char)(iptparam->PresetMoney>>0);
		if(IPT_PAYUNIT_MONEY==iptparam->PayUnit)			dsp_buffer[4]=0;
		else	if(IPT_PAYUNIT_LOYALTY==iptparam->PayUnit)	dsp_buffer[4]=2;
	}
	dsp_buffer[20]=iptparam->OilRound;
	if(1 == iptIsLianda(iptparam->Id) && 1 == iptparam->IcDiscountFlag)
	{
		dsp_buffer[21] = (char)((iptparam->OilPrice - iptparam->PriceDiscount)>>8);
		dsp_buffer[22] = (char)((iptparam->OilPrice - iptparam->PriceDiscount)>>0);
	}
	if(1 == iptIsLianda(iptparam->Id))	dsp_buffer[23] = iptparam->IcAppType;
	else															dsp_buffer[23] = 0xff;
	dsp_len=24;
	dsp(iptparam->DEVDsp, DSP_CARD_OILLING, dsp_buffer, dsp_len);

	//促销机通知平板电脑状态
	if(1 == paramPromotionGet())
	{
		iptparam->TaState = IPT_STATE_CARD_OILLING;	iptparam->TaStateParamLength = 0;
		*(iptparam->TaStateParam + 0) = 0;	*(iptparam->TaStateParam + 1) = 0;
		*(iptparam->TaStateParam + 2) = 0;	*(iptparam->TaStateParam + 3) = 0;
		*(iptparam->TaStateParam + 4) = 0;	*(iptparam->TaStateParam + 5) = 0;
		*(iptparam->TaStateParam + 6) = 0;	*(iptparam->TaStateParam + 7) = 0;
		memcpy(iptparam->TaStateParam + 8, iptparam->IcAppId, 10);
		memcpy(iptparam->TaStateParam + 18, iptparam->IcBalance, 4);
		if(IPT_PAYUNIT_MONEY == iptparam->PayUnit)	*(iptparam->TaStateParam + 22) = 0;
		else																		*(iptparam->TaStateParam + 22) = 1;
		if(IPT_PRESET_VOLUME == iptparam->PresetMode)	
		{
			*(iptparam->TaStateParam + 23) = (char)(iptparam->PresetVolume>>24);
			*(iptparam->TaStateParam + 24) = (char)(iptparam->PresetVolume>>16);
			*(iptparam->TaStateParam + 25) = (char)(iptparam->PresetVolume>>8);
			*(iptparam->TaStateParam + 26) = (char)(iptparam->PresetVolume>>0);
			*(iptparam->TaStateParam + 27) = 1;
		}
		else
		{
			*(iptparam->TaStateParam + 23) = (char)(iptparam->PresetMoney>>24);
			*(iptparam->TaStateParam + 24) = (char)(iptparam->PresetMoney>>16);
			*(iptparam->TaStateParam + 25) = (char)(iptparam->PresetMoney>>8);
			*(iptparam->TaStateParam + 26) = (char)(iptparam->PresetMoney>>0);
			*(iptparam->TaStateParam + 27) = 0;
		}
		//pspeed = jlSpeedRead(iptparam->JlNozzle); //fj:
		if(ERROR == pspeed) pspeed = 0;
		else								pspeed = pspeed * 60;
		*(iptparam->TaStateParam + 28) = (char)(pspeed >> 8);
		*(iptparam->TaStateParam + 29) = (char)(pspeed >> 0);
		iptparam->TaStateParamLength = 30;
		pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
	}

	//记录加油过程
	memset(dsp_buffer, 0, sizeof(dsp_buffer));
	sprintf(dsp_buffer+strlen(dsp_buffer), "[主板号=%d]", pcdMboardIDRead());
	sprintf(dsp_buffer+strlen(dsp_buffer), "[面板号=%d]", iptparam->Id);
	sprintf(dsp_buffer+strlen(dsp_buffer), "IC卡加油启动:预置金额=%d,", iptparam->PresetMoney);
	sprintf(dsp_buffer+strlen(dsp_buffer), "预置升数=%d,", iptparam->PresetVolume);
	sprintf(dsp_buffer+strlen(dsp_buffer), "预置方式=%d.", iptparam->PresetMode);
	//jljUserLog("%s\n", dsp_buffer);
	//jljUserLog("[主板号=%d][面板号=%d]IC卡加油启动:预置金额=%d,预置升数=%d,预置方式=%d.\n", \
	//	pcdMboardIDRead(), iptparam->Id, iptparam->PresetMoney, iptparam->PresetVolume, iptparam->PresetMode);

	//转入加油过程
	iptPidSet(iptparam, IPT_PID_IC_OILLING);

	return;
}


/*******************************************************************
*Name				:iptIcOilling
*Description		:IC卡加油中
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcOilling(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	int voice[16]={0};
	unsigned int i=0, balance=0, money_sum=0, volume_sum=0, money=0, volume=0, price=0;
	long long balance_bcd=0;
	unsigned char dsp_buffer[64]={0}, dsp_len=0, tmp_buffer[16]={0}, hex_data=0, jl_stop_no=0;
	unsigned char buffer[128]={0};
	int istate=0;
	int pdiscount = 0, money_discount = 0;
	int pspeed = 0;
	PCOilInfoType info;

	//static int nNumCount = 0;
	//static int nTime = 0;

	if((iptparam->EtcOilFlg!=0) && iptparam->etc_update_flag==0)
		EtcUpdateGrade(iptparam->Id);//szb_fj_20171120,OBU更新油品号

	//读取实时加油量,fj:
	istate=jlOilRead(iptparam->JlNozzle, &money, &volume, &price, &jl_stop_no);

	//if(nNumCount > 100)
	//{
	//	printf("nTime = %d\n",nTime);
	//	nTime++;
	//	nNumCount = 0;
	//}

	//nNumCount++;

	if(iptparam->OilDspTimer >= ONE_SECOND)
	{
		//获取实时加油数据，加油数据改变时进行存储
		if(0==istate && volume!=iptparam->OilVolume)
		{
			iptparam->OilVolume=volume;		iptparam->OilMoney=money;		iptparam->OilPrice=price;
			
			//油量
			iptparam->OilBill[IPT_OFFSET_VOL+0]=(char)(iptparam->OilVolume>>16);	
			iptparam->OilBill[IPT_OFFSET_VOL+1]=(char)(iptparam->OilVolume>>8);	
			iptparam->OilBill[IPT_OFFSET_VOL+2]=(char)(iptparam->OilVolume>>0);
			//金额
			iptparam->OilBill[IPT_OFFSET_AMN+0]=(char)(iptparam->OilMoney>>16);	
			iptparam->OilBill[IPT_OFFSET_AMN+1]=(char)(iptparam->OilMoney>>8);	
			iptparam->OilBill[IPT_OFFSET_AMN+2]=(char)(iptparam->OilMoney>>0);
			//单价
			iptparam->OilBill[IPT_OFFSET_PRC+0]=(char)(iptparam->OilPrice>>8);		
			iptparam->OilBill[IPT_OFFSET_PRC+1]=(char)(iptparam->OilPrice>>0);
			
			//计算账单校验值
			iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

			//保存账单及备份
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);
		}

		//计算余额
		balance=(iptparam->IcBalance[0]<<24)|(iptparam->IcBalance[1]<<16)|(iptparam->IcBalance[2]<<8)|(iptparam->IcBalance[3]<<0);
		//中燃联达加油机记账卡不扣款
		if(1 == iptIsLianda(iptparam->Id) && (IPT_LIANDA_APPTYPE_JIZHANG == iptparam->IcAppType||IPT_LIANDA_APPTYPE_ZIYONG == iptparam->IcAppType||IPT_LIANDA_APPTYPE_DIAOBO == iptparam->IcAppType||IPT_LIANDA_APPTYPE_GUOBIAO == iptparam->IcAppType))
		{}
		//如果有单价折扣则计算折扣额
		else if(1 == iptIsLianda(iptparam->Id) && 0x01 == iptparam->IcDiscountFlag)
		{
			pdiscount = iptDiscountCompute(iptparam->Id, volume, iptparam->PriceDiscount);
			money_discount = iptparam->OilMoney - pdiscount;
			if(balance >= money_discount)	balance = balance - money_discount;
			else												balance=0;
		}
		//中燃联达加油机扣款单位为升时以升数扣款
		else if(1==iptIsLianda(iptparam->Id) && 1==iptparam->IcDebitUnit)
		{
			if(balance>=iptparam->OilVolume)	balance=balance-iptparam->OilVolume;
			else														balance=0;
		}
		else
		{
			if(balance>=iptparam->OilMoney)	balance=balance-iptparam->OilMoney;
			else													balance=0;
		}
		
		//送显
		memcpy(&dsp_buffer[0], iptparam->IcAppId, 10);
		dsp_buffer[10]=(char)(balance>>24);	dsp_buffer[11]=(char)(balance>>16);
		dsp_buffer[12]=(char)(balance>>8);		dsp_buffer[13]=(char)(balance>>0);
		if(1==iptIsLianda(iptparam->Id) && 1==iptparam->IcDebitUnit)	dsp_buffer[14] = 2;
		else if(1==iptparam->PayUnit)														dsp_buffer[14] = 1;
		else																									dsp_buffer[14] = 0;
		if(IPT_PRESET_VOLUME==iptparam->PresetMode)
		{
			dsp_buffer[15]=(char)(iptparam->PresetVolume>>24);	dsp_buffer[16]=(char)(iptparam->PresetVolume>>16);
			dsp_buffer[17]=(char)(iptparam->PresetVolume>>8);	dsp_buffer[18]=(char)(iptparam->PresetVolume>>0);
			dsp_buffer[19]=1;
		}
		else
		{
			dsp_buffer[15]=(char)(iptparam->PresetMoney>>24);	dsp_buffer[16]=(char)(iptparam->PresetMoney>>16);
			dsp_buffer[17]=(char)(iptparam->PresetMoney>>8);		dsp_buffer[18]=(char)(iptparam->PresetMoney>>0);

			if(IPT_PAYUNIT_MONEY==iptparam->PayUnit)			dsp_buffer[19]=0;
			else	if(IPT_PAYUNIT_LOYALTY==iptparam->PayUnit)	dsp_buffer[19]=2;
		}
		dsp_buffer[20]=iptparam->OilRound;
		if(1 == iptIsLianda(iptparam->Id) && 1 == iptparam->IcDiscountFlag)
		{
			dsp_buffer[21] = (char)((iptparam->OilPrice - iptparam->PriceDiscount)>>8);
			dsp_buffer[22] = (char)((iptparam->OilPrice - iptparam->PriceDiscount)>>0);
		}
		if(1 == iptIsLianda(iptparam->Id))	dsp_buffer[23] = iptparam->IcAppType;
		else														dsp_buffer[23] = 0xff;
		dsp_len=24;
		dsp(iptparam->DEVDsp, DSP_CARD_OILLING, dsp_buffer, dsp_len);

		iptparam->TabletTxElement++;
		if(1 == paramPromotionGet() && iptparam->TabletTxElement >= 2)
		{
			iptparam->TaState = IPT_STATE_CARD_OILLING;	iptparam->TaStateParamLength = 0;
			*(iptparam->TaStateParam + 0) = (char)(iptparam->OilMoney>>24);	
			*(iptparam->TaStateParam + 1) = (char)(iptparam->OilMoney>>16);
			*(iptparam->TaStateParam + 2) = (char)(iptparam->OilMoney>>8);	
			*(iptparam->TaStateParam + 3) = (char)(iptparam->OilMoney>>0);
			*(iptparam->TaStateParam + 4) = (char)(iptparam->OilVolume>>24);	
			*(iptparam->TaStateParam + 5) = (char)(iptparam->OilVolume>>16);
			*(iptparam->TaStateParam + 6) = (char)(iptparam->OilVolume>>8);	
			*(iptparam->TaStateParam + 7) = (char)(iptparam->OilVolume>>0);
			memcpy(iptparam->TaStateParam + 8, iptparam->IcAppId, 10);
			*(iptparam->TaStateParam + 18) = (char)(balance>>24);
			*(iptparam->TaStateParam + 19) = (char)(balance>>16);
			*(iptparam->TaStateParam + 20) = (char)(balance>>8);
			*(iptparam->TaStateParam + 21) = (char)(balance>>0);
			if(IPT_PAYUNIT_MONEY == iptparam->PayUnit)	*(iptparam->TaStateParam + 22) = 0;
			else																		*(iptparam->TaStateParam + 22) = 1;
			if(IPT_PRESET_VOLUME == iptparam->PresetMode)	
			{
				*(iptparam->TaStateParam + 23) = (char)(iptparam->PresetVolume>>24);
				*(iptparam->TaStateParam + 24) = (char)(iptparam->PresetVolume>>16);
				*(iptparam->TaStateParam + 25) = (char)(iptparam->PresetVolume>>8);
				*(iptparam->TaStateParam + 26) = (char)(iptparam->PresetVolume>>0);
				*(iptparam->TaStateParam + 27) = 1;
			}
			else
			{
				*(iptparam->TaStateParam + 23) = (char)(iptparam->PresetMoney>>24);
				*(iptparam->TaStateParam + 24) = (char)(iptparam->PresetMoney>>16);
				*(iptparam->TaStateParam + 25) = (char)(iptparam->PresetMoney>>8);
				*(iptparam->TaStateParam + 26) = (char)(iptparam->PresetMoney>>0);
				*(iptparam->TaStateParam + 27) = 0;
			}
			//pspeed = jlSpeedRead(iptparam->JlNozzle); //fj:
			if(ERROR == pspeed) pspeed = 0;
			else								pspeed = pspeed * 60;
			*(iptparam->TaStateParam + 28) = (char)(pspeed >> 8);
			*(iptparam->TaStateParam + 29) = (char)(pspeed >> 0);
			iptparam->TaStateParamLength = 30;
			pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);

			iptparam->TabletTxElement = 0;
		}

		iptparam->OilDspTimer=0;
	}


	//凑整，默认金额凑整
	if(KB_BUTTON_CZ==iptparam->Button || KB_BUTTON_R4==iptparam->Button)
	{
	     if(0==jlOilCZ(iptparam->Id, 0))	iptparam->OilRound=1;
		; //fj:
	}

	//加油达到预置量未挂枪时播报语音提示
	if(0==iptparam->VoiceFlag && 2==jl_stop_no && IPT_GUN_PUTUP==iptparam->GunState && iptparam->VoiceVolume>0)
	{
		if(IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType)	voice[0]=SPKW_OILEND;
		else																				voice[0]=SPKM_OILEND;
		iptSpk(iptparam, voice, 1);

		iptparam->VoiceFlag=1;
	}

#if _IPT_DEBUG_
	//自动加油过程中
	if(1==IsOilAtuo && (2==jl_stop_no || POWER_STATE_OK!=powerStateRead())){

		dsp(iptparam->DEVDsp, DSP_CARD_OIL_FINISH, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_IC_OILFINISH);
		return;
	}

	//卡被拔出，挂枪，计量状态异常(非达到预置量)，油机掉电，过冲则结束加油状态
	balance=(iptparam->IcBalance[0]<<24)|(iptparam->IcBalance[1]<<16)|(iptparam->IcBalance[2]<<8)|(iptparam->IcBalance[3]<<0);
	if(1!=IsOilAtuo && (0x30!=iptparam->IcState.DeckStateS1	||	1==iptparam->GunState	||	(0==istate && 0!=jl_stop_no && 2!=jl_stop_no)	||	POWER_STATE_OK!=powerStateRead()	||	iptparam->OilMoney>balance))
	{
		dsp(iptparam->DEVDsp, DSP_CARD_OIL_FINISH, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_IC_OILFINISH);
		return;
	}
#else
	//卡被拔出，挂枪，计量状态异常(非达到预置量)，油机掉电，过冲则结束加油状态
	//	中燃联达加油系统记账卡不判断卡余额
	
	balance=(iptparam->IcBalance[0]<<24)|(iptparam->IcBalance[1]<<16)|(iptparam->IcBalance[2]<<8)|(iptparam->IcBalance[3]<<0);
	if(	((0x30!=iptparam->IcState.DeckStateS1) && (iptparam->EtcOilFlg == 0))	||\
		(0 == iptIsBig260(iptparam->Id) && IPT_GUN_PUTDOWN == iptparam->GunState)	||\
		(1 == iptIsBig260(iptparam->Id) && KB_BUTTON_ACK == iptparam->Button)	||\
		(0==istate && 0!=jl_stop_no && 2!=jl_stop_no)	||\
		POWER_STATE_OK!=powerStateRead()	||\
		(iptparam->OilMoney > balance && (!(1 == iptIsLianda(iptparam->Id) && (IPT_LIANDA_APPTYPE_JIZHANG == iptparam->IcAppType||IPT_LIANDA_APPTYPE_ZIYONG == iptparam->IcAppType||IPT_LIANDA_APPTYPE_DIAOBO == iptparam->IcAppType||IPT_LIANDA_APPTYPE_GUOBIAO == iptparam->IcAppType||IPT_LIANDA_APPTYPE_DAICHU == iptparam->IcAppType||IPT_LIANDA_APPTYPE_DAICHUSIJI == iptparam->IcAppType)))))
	{
		if((0x30!=iptparam->IcState.DeckStateS1) && (iptparam->EtcOilFlg == 0))	
			jljOilErrLogWrite(iptparam->Id, "IC卡加油结束!卡被拔出!");
	
		if(IPT_GUN_PUTDOWN==iptparam->GunState)	
			jljRunLog("面板号=%d:IC卡加油结束!挂枪!\n", iptparam->Id);

		//printf("jlOilRead,ready jlOilFinish!\n");
		
		if(0==istate && 0!=jl_stop_no && 2!=jl_stop_no)	 
		{
			i=((char)(jl_stop_no>>4)&0x0f)*10+((char)(jl_stop_no>>0)&0x0f)*1;
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, (unsigned char *)jlStopReason[i], strlen(jlStopReason[i]));
			IPT_DSP_WAIT();
			jljOilErrLogWrite(iptparam->Id, "IC卡加油结束!计量停止加油[%s]!", jlStopReason[i]);

	        //printf("-------jlOilRead,ready jlOilFinish!,jl_stop_no = %d,i = %d,strlen = %d,%s\n",jl_stop_no,i,strlen(jlStopReason[i]),jlStopReason[i]);
            //char* pchTest[] = {"中文字符测试aaaa","我是bbbbb",};
			//printf("--------%s,%s\n",pchTest[0],pchTest[1]);
		}

		if(POWER_STATE_OK!=powerStateRead())			    jljOilErrLogWrite(iptparam->Id, "IC卡加油结束!油机掉电!");
		if(iptparam->OilMoney>balance)						jljOilErrLogWrite(iptparam->Id, "IC卡加油结束!过冲![金额=%d][卡余额=%d]!", iptparam->OilMoney, balance);

		//促销机通知平板电脑状态
		if(1 == paramPromotionGet())
		{
			iptparam->TaState = IPT_STATE_CARD_OILFINISHING;	iptparam->TaStateParamLength = 0;
			pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
		}

		dsp(iptparam->DEVDsp, DSP_CARD_OIL_FINISH, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_IC_OILFINISH);
		return;
	}
#endif

	return;
}


/*******************************************************************
*Name				:iptIcOilFinish
*Description		:申请计量加油结束
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcOilFinish(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned int balance=0, money=0, volume=0, price=0, crc_return=0;
	unsigned long long money_sum=0, volume_sum=0;
	unsigned char stop_no=0, bill_buffer[64]={0};
	int istate=0;
	PCOilInfoType info;
	unsigned int pdiscount = 0,suanfa = 0,state = 0;
    //fj:
	istate=jlOilFinish(iptparam->JlNozzle, &money_sum, &volume_sum, &money, &volume, &price, &stop_no);

	iptAbnormalStopHandle(iptparam,stop_no,money);//szb_fj_20171120:add

	if(0==istate)
	{
		//如果有单价折扣则计算折扣额
		if(1 == iptIsLianda(iptparam->Id) && 0x01 == iptparam->IcDiscountFlag)
		{
			pdiscount = iptDiscountCompute(iptparam->Id, volume, iptparam->PriceDiscount);
		}

		//加油金额大于卡余额，以卡余额为卡支付账单金额，差额为非卡加油累计
		balance=(iptparam->IcBalance[0]<<24)|(iptparam->IcBalance[1]<<16)|(iptparam->IcBalance[2]<<8)|(iptparam->IcBalance[3]<<0);
		if(money <= balance || (1 == iptIsLianda(iptparam->Id) && (IPT_LIANDA_APPTYPE_JIZHANG == iptparam->IcAppType||IPT_LIANDA_APPTYPE_ZIYONG == iptparam->IcAppType||IPT_LIANDA_APPTYPE_DIAOBO == iptparam->IcAppType||IPT_LIANDA_APPTYPE_GUOBIAO == iptparam->IcAppType||IPT_LIANDA_APPTYPE_DAICHU == iptparam->IcAppType||IPT_LIANDA_APPTYPE_DAICHUSIJI == iptparam->IcAppType)))
		{
			iptparam->SumMoney=money_sum;	iptparam->SumVolume=volume_sum;
			iptparam->OilMoney=money;	iptparam->OilVolume=volume;	iptparam->OilPrice=price;	iptparam->JlStopNO=stop_no;

			//清除过充数据
			memset(bill_buffer, 0, 32);	iptparam->MoneyUnself=0;	iptparam->VolumeUnself=0;
			iptparam->MoneyUnselfSum=0;	iptparam->VolumeUnselfSum=0;	iptparam->OilOverTimes=0;
			bill_buffer[0]=(char)(iptparam->MoneyUnself>>16);
			bill_buffer[1]=(char)(iptparam->MoneyUnself>>8);		bill_buffer[2]=(char)(iptparam->MoneyUnself>>0);
			bill_buffer[3]=(char)(iptparam->VolumeUnself>>16);
			bill_buffer[4]=(char)(iptparam->VolumeUnself>>8);	bill_buffer[5]=(char)(iptparam->VolumeUnself>>0);
			bill_buffer[6]=stop_no;
			bill_buffer[7]=(char)(iptparam->MoneyUnselfSum>>16);	
			bill_buffer[8]=(char)(iptparam->MoneyUnselfSum>>8);		bill_buffer[9]=(char)(iptparam->MoneyUnselfSum>>0);
			bill_buffer[10]=(char)(iptparam->VolumeUnselfSum>>16);	
			bill_buffer[11]=(char)(iptparam->VolumeUnselfSum>>8);	bill_buffer[12]=(char)(iptparam->VolumeUnselfSum>>0);
			bill_buffer[13]=iptparam->OilOverTimes;
			crc_return=crc16Get(bill_buffer, 30);
			bill_buffer[30]=(char)(crc_return>>8);	bill_buffer[31]=(char)(crc_return>>0);
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_UNSELF, bill_buffer, 32);
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_UNSELF2, bill_buffer, 32);
		}
		else
		{
			//以卡余额为本次卡账单加油金额
			iptparam->OilMoney=balance;	iptparam->OilPrice=price;
			iptparam->JlStopNO=stop_no;
			state=jlAlgorithmRead(iptparam->JlNozzle,&suanfa);
			if(state!=0)
				suanfa=JL_ALGORITHM_45;
			if(suanfa!=JL_ALGORITHM_45)
			{
				if(((iptparam->OilMoney*100)%iptparam->OilPrice)>0)
					iptparam->OilVolume=iptparam->OilMoney*100/iptparam->OilPrice+1;
				else
					iptparam->OilVolume=iptparam->OilMoney*100/iptparam->OilPrice;
			}
			else if((iptparam->OilMoney*1000/iptparam->OilPrice%10)<JL_ROUNDING)	
				iptparam->OilVolume=iptparam->OilMoney*100/iptparam->OilPrice;
			else	
				iptparam->OilVolume=iptparam->OilMoney*100/iptparam->OilPrice+1;

			//计算过充金额及油量
			iptparam->MoneyUnself=money-iptparam->OilMoney;
			iptparam->VolumeUnself=volume-iptparam->OilVolume;

			//计算卡加油账单总累
			iptparam->SumMoney=money_sum-iptparam->MoneyUnself;	
			iptparam->SumVolume=volume_sum-iptparam->VolumeUnself;

			//计算过冲累计
			iptparam->MoneyUnselfSum+=iptparam->MoneyUnself;
			iptparam->VolumeUnselfSum+=iptparam->VolumeUnself;

			//过冲次数累加
			iptparam->OilOverTimes++;

			//存储过冲数据
			memset(bill_buffer, 0, 32);
			bill_buffer[0]=(char)(iptparam->MoneyUnself>>16);
			bill_buffer[1]=(char)(iptparam->MoneyUnself>>8);		bill_buffer[2]=(char)(iptparam->MoneyUnself>>0);
			bill_buffer[3]=(char)(iptparam->VolumeUnself>>16);	
			bill_buffer[4]=(char)(iptparam->VolumeUnself>>8);	bill_buffer[5]=(char)(iptparam->VolumeUnself>>0);
			bill_buffer[6]=stop_no;
			bill_buffer[7]=(char)(iptparam->MoneyUnselfSum>>16);	
			bill_buffer[8]=(char)(iptparam->MoneyUnselfSum>>8);		bill_buffer[9]=(char)(iptparam->MoneyUnselfSum>>0);
			bill_buffer[10]=(char)(iptparam->VolumeUnselfSum>>16);	
			bill_buffer[11]=(char)(iptparam->VolumeUnselfSum>>8);	bill_buffer[12]=(char)(iptparam->VolumeUnselfSum>>0);
			bill_buffer[13]=iptparam->OilOverTimes;
			crc_return=crc16Get(bill_buffer, 30);
			bill_buffer[30]=(char)(crc_return>>8);	bill_buffer[31]=(char)(crc_return>>0);
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_UNSELF, bill_buffer, 32);
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_UNSELF2, bill_buffer, 32);
		}

		//油量
		iptparam->OilBill[IPT_OFFSET_VOL+0]=(char)(iptparam->OilVolume>>16);	
		iptparam->OilBill[IPT_OFFSET_VOL+1]=(char)(iptparam->OilVolume>>8);	
		iptparam->OilBill[IPT_OFFSET_VOL+2]=(char)(iptparam->OilVolume>>0);
		//金额
		iptparam->OilBill[IPT_OFFSET_AMN+0]=(char)(iptparam->OilMoney>>16);	
		iptparam->OilBill[IPT_OFFSET_AMN+1]=(char)(iptparam->OilMoney>>8);	
		iptparam->OilBill[IPT_OFFSET_AMN+2]=(char)(iptparam->OilMoney>>0);

		//printf("jlOilFinish  : IPT_OFFSET_AMN = %d\n",iptparam->OilMoney);

		//单价
		iptparam->OilBill[IPT_OFFSET_PRC+0]=(char)(iptparam->OilPrice>>8);		
		iptparam->OilBill[IPT_OFFSET_PRC+1]=(char)(iptparam->OilPrice>>0);
		//总累
		iptparam->OilBill[IPT_OFFSET_V_TOT+0]=(char)(iptparam->SumVolume>>24);
		iptparam->OilBill[IPT_OFFSET_V_TOT+1]=(char)(iptparam->SumVolume>>16);
		iptparam->OilBill[IPT_OFFSET_V_TOT+2]=(char)(iptparam->SumVolume>>8);
		iptparam->OilBill[IPT_OFFSET_V_TOT+3]=(char)(iptparam->SumVolume>>0);
		//计量停机代码
		iptparam->OilBill[IPT_OFFSET_STOPNO]=(char)(iptparam->JlStopNO);

		//社会站联达加油站系统添加的字段，在这里计算并添加折扣后的金额、折扣额，如果折扣额过大则以无折扣的原始数据计算
		//	如果是代储卡则"数额"、"折扣金额"字段以升数替换，扣款按升数扣款
		
		if(1 == iptIsLianda(iptparam->Id))
		{
			if(1 == iptparam->IcDebitUnit)
			{
				iptparam->OilMoneyDiscount = iptparam->OilVolume;
				//数额字段以升数替换
				iptparam->OilBill[IPT_OFFSET_AMN+0]=(char)(iptparam->OilVolume>>16);	
				iptparam->OilBill[IPT_OFFSET_AMN+1]=(char)(iptparam->OilVolume>>8);	
				iptparam->OilBill[IPT_OFFSET_AMN+2]=(char)(iptparam->OilVolume>>0);
			}
			else if(iptparam->OilMoney >= pdiscount)
			{
				iptparam->OilMoneyDiscount = iptparam->OilMoney - pdiscount;
			}
			else
			{
				iptparam->OilMoneyDiscount = iptparam->OilMoney;
			}
			//折扣后的金额(代储卡时为升数)
			iptparam->OilBill[IPT_OFFSET_MONEY_DISCOUNT+0] = (char)(iptparam->OilMoneyDiscount>>16);
			iptparam->OilBill[IPT_OFFSET_MONEY_DISCOUNT+1] = (char)(iptparam->OilMoneyDiscount>>8);
			iptparam->OilBill[IPT_OFFSET_MONEY_DISCOUNT+2] = (char)(iptparam->OilMoneyDiscount>>0);
			//价格折扣
			//iptparam->OilBill[IPT_OFFSET_DISCOUNT+0] = (char)(iptparam->PriceDiscount>>8);
			//iptparam->OilBill[IPT_OFFSET_DISCOUNT+1] = (char)(iptparam->PriceDiscount>>0);
		}

		//计算账单校验值
		iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

		//保存账单及备份
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

		//转入GMAC计算过程
		iptPidSet(iptparam, IPT_PID_IC_PSAM_GMAC);
	}

	return;
}


/*******************************************************************
*Name				:iptIcPsamGMAC
*Description		:IC卡解灰过程PSAM计算GMAC
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcPsamGMAC(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char buffer[128]={0}, dsp_buffer[64]={0}, dsp_len=0;
	int istate=0, apdu_len=0;
	unsigned int data=0, pmoney = 0;

	//
	//	@1	
	//	计算GMAC，计算成功转入解扣过程，计算失败继续执行@2；
	//	@2
	//	计算GMAC失败，读取GMAC查看是否实际计算成功，失败继续执行@3；
	//	@3
	//	复位PSAM；
	//	@4
	//	选择应用1；
	//	@5
	//	验证MAC2；
	//	@6
	//	第二次计算GMAC，操作完成后转入扣款过程；
	
	//@1	计算GMAC
	//中燃联达加油站系统记账卡0扣款；
	//	中燃联达加油站系统以折扣金额计算GMAC；
	//	其它则以实际金额计算GMAC
	if(1 == iptIsLianda(iptparam->Id) && (IPT_LIANDA_APPTYPE_JIZHANG == iptparam->IcAppType||IPT_LIANDA_APPTYPE_ZIYONG == iptparam->IcAppType||IPT_LIANDA_APPTYPE_DIAOBO == iptparam->IcAppType||IPT_LIANDA_APPTYPE_GUOBIAO == iptparam->IcAppType))	pmoney = 0;
	else if(1 == iptIsLianda(iptparam->Id))	pmoney = iptparam->OilMoneyDiscount;
	else																pmoney = iptparam->OilMoney;
	istate=PsamGMAC(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, &iptparam->IcAppId[2], iptparam->IcLockInitCTC, pmoney);
	//istate=PsamGMAC(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, &iptparam->IcAppId[2], iptparam->IcLockInitCTC, iptparam->OilMoney);

	if(ICSTATE_OK==istate)
	{
		apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
		if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
		{
			//卡座操作返回成功
			memcpy(iptparam->IcPsamGMAC, &buffer[2], 4);	//PSAM返回GMAC
			memcpy(iptparam->IcPsamTAC, &buffer[6], 4);		//PSAM返回TAC

			//解灰认证码4bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_GMAC], iptparam->IcPsamGMAC, 4);

			//PSAM灰锁签名4bytes，加油完成，PSAM计算GMAC后添加
			memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TAC], iptparam->IcPsamTAC, 4);
				
			//计算账单校验值
			iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

			//保存账单及备份
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

			//有卡转入解扣过程，逃卡转入TTC申请过程
			if(0x30==iptparam->IcState.DeckStateS1 || iptparam->EtcOilFlg == 1) //szb_fj_20171120,update
				iptPidSet(iptparam, IPT_PID_IC_UNLOCK);
			else
				iptPidSet(iptparam, IPT_PID_IC_TTC_GET);

			return;
		}
	}

	//@2	读取GMAC
	data=(iptparam->IcPsamTTC[0]<<24)|(iptparam->IcPsamTTC[1]<<16)|(iptparam->IcPsamTTC[2]<<8)|(iptparam->IcPsamTTC[3]<<0);
	data++;
	iptparam->IcPsamTTC[0]=(char)(data>>24);	iptparam->IcPsamTTC[1]=(char)(data>>16);
	iptparam->IcPsamTTC[2]=(char)(data>>8);	iptparam->IcPsamTTC[3]=(char)(data>>0);
	istate=PsamGMACRead(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, iptparam->IcPsamTTC);
	if(ICSTATE_OK==istate)
	{
		apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
		if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
		{
			//卡座操作返回成功
			memcpy(iptparam->IcPsamGMAC, &buffer[2], 4);	//PSAM返回GMAC
			memcpy(iptparam->IcPsamTAC, &buffer[6], 4);		//PSAM返回TAC

			//解灰认证码4bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_GMAC], iptparam->IcPsamGMAC, 4);

			//PSAM灰锁签名4bytes，加油完成，PSAM计算GMAC后添加
			memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TAC], iptparam->IcPsamTAC, 4);
				
			//计算账单校验值
			iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

			//保存账单及备份
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

			//有卡转入解扣过程，逃卡转入TTC申请过程
			if(0x30==iptparam->IcState.DeckStateS1 || iptparam->EtcOilFlg == 1)	
				iptPidSet(iptparam, IPT_PID_IC_UNLOCK);
			else
				iptPidSet(iptparam, IPT_PID_IC_TTC_GET);

			return;
		}
	}
	
	//@3	复位PSAM
	istate=PsamReset(iptparam->DEVIC, iptparam->DEVPsam);

	//@4	选择应用1
	istate=PsamDFSelect(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, 1);

	//@5	验证MAC2
	istate=PsamMAC2Check(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, iptparam->IcMAC2);

	//@6	计算GMAC
PSAM_GMAC_AGAIN:
	istate=PsamGMAC(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, &iptparam->IcAppId[2], iptparam->IcLockInitCTC, pmoney);
	//istate=PsamGMAC(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, &iptparam->IcAppId[2], iptparam->IcLockInitCTC, iptparam->OilMoney);
	if(ICSTATE_OK==istate)
	{
		iptparam->IcOverTimes=0;
		apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
		if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
		{
			//卡座操作返回成功
			memcpy(iptparam->IcPsamGMAC, &buffer[2], 4);	//PSAM返回GMAC
			memcpy(iptparam->IcPsamTAC, &buffer[6], 4);		//PSAM返回TAC

			//解灰认证码4bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_GMAC], iptparam->IcPsamGMAC, 4);

			//PSAM灰锁签名4bytes，加油完成，PSAM计算GMAC后添加
			memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TAC], iptparam->IcPsamTAC, 4);
			
			//计算账单校验值
			iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

			//保存账单及备份
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

			//有卡转入解扣过程，逃卡转入TTC申请过程
			if(0x30==iptparam->IcState.DeckStateS1 || iptparam->EtcOilFlg == 1)	
				iptPidSet(iptparam, IPT_PID_IC_UNLOCK);
			else
				iptPidSet(iptparam, IPT_PID_IC_TTC_GET);
		}
		else
		{
			memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
			dsp_buffer[2]=16;	memcpy(&dsp_buffer[3], "PSAM计算GMAC失败", 16);
			dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
			IPT_DSP_WAIT();

			iptPidSet(iptparam, IPT_PID_IC_TTC_GET);
		}
	}
	else if(ICSTATE_FAILED==istate)
	{
		iptparam->IcOverTimes=0;

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM计算GMAC失败", 16);
		IPT_DSP_WAIT();

		iptPidSet(iptparam, IPT_PID_IC_TTC_GET);
	}
	else if(ICSTATE_OVERTIME==istate)
	{
		iptparam->IcOverTimes=0;
	
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM计算GMAC超时", 16);
		IPT_DSP_WAIT();

		iptPidSet(iptparam, IPT_PID_IC_TTC_GET);
	}
	else
	{
		iptparam->IcOverTimes=0;

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM计算GMAC错误", 16);
		IPT_DSP_WAIT();

		iptPidSet(iptparam, IPT_PID_IC_TTC_GET);
	}

	return;
}


/*******************************************************************
*Name				:iptIcUnlock
*Description		:IC卡解扣
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcUnlock(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char buffer[128]={0}, dsp_buffer[64]={0}, dsp_len=0, t_type=0;
	int istate=0, apdu_len=0, itimes=0, apdu_result = 0;
	unsigned int balance=0, bill_type=0;
	int card_state=0;	//解扣结果:1=成功；非1=失败

	unsigned int pmoney = 0;
	char pCTC[2] = {0};
	char pPsamTermID[6] = {0};
	char pPsamTTC[4] = {0};
	char pOilTime[7] = {0};
	char pPsamGMAC[4] = {0};

	if(iptparam->EtcOilFlg==1) //szb_fj_20171120,add
	{
		iptparam->EtcFreeflag=2;//释放OBU退出车辆列表
		if(iptparam->Id==IPT_NOZZLE_1)
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+FM_ETC_FREE_FLG_A, &iptparam->EtcFreeflag, 1);
		else
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+FM_ETC_FREE_FLG_B, &iptparam->EtcFreeflag, 1);
	}

	//
	//	解扣操作，本操作最多允许执行两次；
	//	执行解扣操作有返回时根据返回结果进行提示并进行下一步操作，
	//	超时无返回时则需要读取一次灰锁信息以确定是否解扣成功
	//	读灰锁信息确定已解扣时继续执行下一步(TAC清除)，灰锁信息结果
	//	为卡仍未解扣则执行第二次解扣，第二次解扣失败则不再进行解扣操作
	
	for(itimes=0; itimes<2; itimes++)
	{
IPT_IC_UNLOCK:
		//发送IC卡解扣命令，补扣操作以灰锁信息进行扣款
		//if(0x01==iptparam->ICStateFirst)	istate=ICGreyUnlock(iptparam->DEVIC, 0, buffer, 128, iptparam->unlockMoney, iptparam->IcLockCTC, iptparam->IcLockTermId, iptparam->unlockPsamTTC, iptparam->IcLockTime, iptparam->unlockGMAC);
		//else													istate=ICGreyUnlock(iptparam->DEVIC, 0, buffer, 128, iptparam->OilMoney, iptparam->IcLockInitCTC, iptparam->PsamTermId, iptparam->IcPsamTTC, iptparam->OilTime, iptparam->IcPsamGMAC);
		
	
		//解析扣款数据
		//	补扣时以卡内数据为扣款数据，正常扣款则以本次加油数据为扣款数据；
		//	中燃联达加油站系统记账卡进行0扣款；
		//	中燃联达加油站系统折扣卡折扣后金额为扣款金额；
		
		if(0x01==iptparam->ICStateFirst)
		{
			pmoney = iptparam->unlockMoney;
			memcpy(pCTC, iptparam->IcLockCTC, 2);
			memcpy(pPsamTermID, iptparam->IcLockTermId, 6);
			memcpy(pPsamTTC, iptparam->unlockPsamTTC, 4);
			memcpy(pOilTime, iptparam->IcLockTime, 7);
			memcpy(pPsamGMAC, iptparam->unlockGMAC, 4);

			printf("pmoney = %d\n",pmoney);
			printf("pCTC = %02x%02x\n",pCTC[0],pCTC[1]);
			printf("pPsamTermID = "); PrintH(6,pPsamTermID);
			printf("pPsamTTC = ");    PrintH(4,pPsamTTC);
			printf("pOilTime = ");    PrintH(7,pOilTime);
			printf("pPsamGMAC = ");   PrintH(4,pPsamGMAC);

		}
		else
		{
			if(1 == iptIsLianda(iptparam->Id) && (IPT_LIANDA_APPTYPE_JIZHANG == iptparam->IcAppType||IPT_LIANDA_APPTYPE_ZIYONG == iptparam->IcAppType||IPT_LIANDA_APPTYPE_DIAOBO == iptparam->IcAppType||IPT_LIANDA_APPTYPE_GUOBIAO == iptparam->IcAppType))	pmoney = 0;
			else if(1 == iptIsLianda(iptparam->Id))	pmoney = iptparam->OilMoneyDiscount;
			else																	pmoney = iptparam->OilMoney;
			memcpy(pCTC, iptparam->IcLockInitCTC, 2);
			memcpy(pPsamTermID, iptparam->PsamTermId, 6);
			memcpy(pPsamTTC, iptparam->IcPsamTTC, 4);
			memcpy(pOilTime, iptparam->OilTime, 7);
			memcpy(pPsamGMAC, iptparam->IcPsamGMAC, 4);
		}
		istate=ICGreyUnlock(iptparam->DEVIC, 0, buffer, 128, pmoney, pCTC, pPsamTermID, pPsamTTC, pOilTime, pPsamGMAC);

		//操作成功，继续执行下一步
		if(ICSTATE_OK==istate)
		{
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(apdu_len>0)	apdu_result = 1;
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
			{
				//解扣成功
				card_state=1;

				//卡座操作成功返回，转入下一步
				memcpy(iptparam->IcTac, &buffer[2], 4);		//IC解扣返回:TAC

				//转入TAC清除过程
				iptPidSet(iptparam, IPT_PID_IC_TAC_CLEAR);
			}
			else
			{
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=12;	memcpy(&dsp_buffer[3], "IC卡解扣失败", 12);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				IPT_DSP_WAIT();

				//该卡执行补扣操作失败直接退卡，其它则继续保存账单
				if(0x01==iptparam->ICStateFirst)	{ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);}
				else													{iptPidSet(iptparam, IPT_PID_IC_TTC_GET);}
			}

			break;
		}

IPT_IC_UNLOCK_GREYINFO:
		//未知的失败或超时，无法判断操作结果，则读取灰锁信息以确认结果
		istate=ICGreyInfoRead(iptparam->DEVIC, 0, buffer, 128);

		//操作成功且非灰卡状态时继续下一步
		if(ICSTATE_OK==istate)
		{
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(apdu_len>0)	apdu_result = 1;
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2) && 0x01!=buffer[2])
			{
				//解扣成功
				card_state=1;

				//卡座操作成功返回，转入下一步
				memcpy(iptparam->IcTac, &buffer[28], 4);		//上次解扣的TAC

				//退出操作
				break;
			}
			else if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2) && 0x01==buffer[2] && itimes>=1)
			{
				//第二次解扣失败，退出
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "解扣操作失败", 12);
				IPT_DSP_WAIT();

				//该卡执行补扣操作失败直接退卡，其它则继续保存账单
				if(0x01==iptparam->ICStateFirst)	{ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);}
				else													{iptPidSet(iptparam, IPT_PID_IC_TTC_GET);}

				//退出操作
				break;
			}
			else if(0!=memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2) && itimes>=1)
			{
				//第二次解扣失败，退出
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=12;	memcpy(&dsp_buffer[3], "解扣操作失败", 12);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				IPT_DSP_WAIT();

				//该卡执行补扣操作失败直接退卡，其它则继续保存账单
				if(0x01==iptparam->ICStateFirst)	{ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);}
				else													{iptPidSet(iptparam, IPT_PID_IC_TTC_GET);}

				//退出操作
				break;
			}
		}
		//操作失败则提示错误信息
		else if(ICSTATE_FAILED==istate && itimes>=1)
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "解扣操作失败!", 13);
			IPT_DSP_WAIT();
				
			//该卡执行补扣操作失败直接退卡，其它则继续保存账单
			if(0x01==iptparam->ICStateFirst)	{ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);}
			else													{iptPidSet(iptparam, IPT_PID_IC_TTC_GET);}

			//退出操作
			break;
		}
		//操作超时，不足2次再次操作，超过2次退出
		else if(ICSTATE_OVERTIME==istate && itimes>=1)
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "解扣操作超时!", 13);
			IPT_DSP_WAIT();
					
			//该卡执行补扣操作失败直接退卡，其它则继续保存账单
			if(0x01==iptparam->ICStateFirst)	{ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);}
			else													{iptPidSet(iptparam, IPT_PID_IC_TTC_GET);}

			//退出操作
			break;
		}
		//未定义错误
		else if(itimes>=1)
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "解扣操作错误!", 13);
			IPT_DSP_WAIT();

			//该卡执行补扣操作失败直接退卡，其它则继续保存账单
			if(0x01==iptparam->ICStateFirst)	{ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);}
			else													{iptPidSet(iptparam, IPT_PID_IC_TTC_GET);}

			//退出操作
			break;
		}

IPT_IC_UNLOCK_RESET:
		//卡片无APDU数据返回而只有卡座返回的操作结果时，认为卡片可能处于掉电状态而对卡片进行复位操作
		if(0 == apdu_result)
		{
			istate=ICReset(iptparam->DEVIC, 0);
			istate=ICMFSelect(iptparam->DEVIC, 0, buffer, 128);
			if(IPT_PAYUNIT_MONEY==iptparam->PayUnit)	istate=ICAppSelect(iptparam->DEVIC, 0, buffer, 128, 0);
			else																		istate=ICAppSelect(iptparam->DEVIC, 0, buffer, 128, 1);
			istate=ICPinCheck(iptparam->DEVIC, 0, buffer, 128, iptparam->IcPassword, iptparam->IcPasswordLen);
		}
	}

	//解扣成功
	if(1==card_state)
	{
		//卡插入时初始状态为灰锁则本处为补扣成功，产生补扣交易
		if(0x01==iptparam->ICStateFirst)
		{
			//初始状态转为正常
			iptparam->ICStateFirst=0;

			//IC加油数据保存补扣账单
			//待填充:POS_TTC
			memcpy(&iptparam->OilBill[IPT_OFFSET_TTC], "\x00\x00\x00\x00", 4);
			//已完成:交易类型设为无卡错，后台/本地黑白名单，扣款签名无效，补扣
			iptparam->OilBill[IPT_OFFSET_T_TYPE]=(0<<7)|((iptparam->BlistSrc&1)<<6)|(0<<4)|(IPT_BILLTYPE_UNLOCK<<0);
			//已完成:交易日期及时间，补扣时以逃卡时间为账单时间
			memcpy(&iptparam->OilBill[IPT_OFFSET_TIME], iptparam->IcLockTime, 7);
			//已完成:卡应用号
			memcpy(&iptparam->OilBill[IPT_OFFSET_ASN], iptparam->IcAppId, 10);					
			//已完成:余额(扣前)，交易完成后填扣后余额
			memcpy(&iptparam->OilBill[IPT_OFFSET_BALANCE], iptparam->IcLockBalance, 4);
			//已完成:数额，以上次加油的数额为当前数额
			iptparam->OilBill[IPT_OFFSET_AMN+0]=(char)(pmoney>>16);
			iptparam->OilBill[IPT_OFFSET_AMN+1]=(char)(pmoney>>8);
			iptparam->OilBill[IPT_OFFSET_AMN+2]=(char)(pmoney>>0);
			//iptparam->OilBill[IPT_OFFSET_AMN+0]=(char)(iptparam->unlockMoney>>16);
			//iptparam->OilBill[IPT_OFFSET_AMN+1]=(char)(iptparam->unlockMoney>>8);
			//iptparam->OilBill[IPT_OFFSET_AMN+2]=(char)(iptparam->unlockMoney>>0);					
			//已完成:卡交易序号					
			memcpy(&iptparam->OilBill[IPT_OFFSET_CTC], iptparam->IcLockCTC, 2);
			//已完成:电子签名，加油/补扣/补充时为TAC，逃卡时为GTAC
			memcpy(&iptparam->OilBill[IPT_OFFSET_TAC], iptparam->IcLockGTAC, 4);
			//已完成:解灰认证码4bytes，加油完成，PSAM计算GMAC后添加
			memcpy(&iptparam->OilBill[IPT_OFFSET_GMAC], "\x00\x00\x00\x00", 4);
			//已完成:PSAM灰锁签名4bytes，加油完成，PSAM计算GMAC后添加
			memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TAC], "\x00\x00\x00\x00", 4);						
			//已完成:PSAM应用号10bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_ASN], iptparam->PsamId, 10);				
			//已完成:PSAM编号6bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_TID], iptparam->IcLockTermId, 6);
			//已完成:PSAM终端交易序号4bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TTC], iptparam->unlockPsamTTC, 4);
			//已完成:扣款来源1byte
			iptparam->OilBill[IPT_OFFSET_DS]=iptparam->DS;				
			//已完成:结算单位/方式1byte
			iptparam->OilBill[IPT_OFFSET_UNIT]=0;			
			//已完成:卡类1byte
			iptparam->OilBill[IPT_OFFSET_C_TYPE]=iptparam->C_TYPE;					
			//已完成:卡版本1byte，b7~b4卡密钥索引号；b3~b0卡密钥版本号
			iptparam->OilBill[IPT_OFFSET_VER]=((iptparam->PsamKeyIndex&0x0f)<<4)|(1<<0);
			//已完成:枪号1byte
			iptparam->OilBill[IPT_OFFSET_NZN]=0;						
			//已完成:油品代码2bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_G_CODE], "\x00\x00", 2);
			//已完成:升数3bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_VOL], "\x00\x00\x00", 3);						
			//已完成:成交价格2bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_PRC], "\x00\x00", 2);
			//已完成:员工号1byte
			iptparam->OilBill[IPT_OFFSET_EMP]=iptparam->EMP;
			//已完成:升累计4bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_V_TOT], "\x00\x00\x00\x00", 4);			
			//已完成:备用部分11bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_RFU], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 11);
			//待填充:T-MAC	4bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], "\x00\x00\x00\x00", 4);					
			//已完成:物理枪号PhysicsGunId
			iptparam->OilBill[IPT_OFFSET_PHYGUN]=iptparam->PhysicalNozzle;						
			//已完成:计量停机原因
			iptparam->OilBill[IPT_OFFSET_STOPNO]=0;
			//已完成:扣前余额
			memcpy(&iptparam->OilBill[IPT_OFFSET_BEFOR_BAL], iptparam->IcLockBalance, 4);			
			//账单状态:0=正常；1=未完成
			iptparam->OilBill[IPT_OFFSET_ZD_STATE]=1;
			//计量设备ID
			iptparam->OilBill[IPT_OFFSET_JLNOZZLE]=iptparam->JlNozzle;
			//计算账单校验值
			iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

			//计算扣后余额
			balance=(iptparam->IcLockBalance[0]<<24)|(iptparam->IcLockBalance[1]<<16)|(iptparam->IcLockBalance[2]<<8)|(iptparam->IcLockBalance[3]<<0);
			balance=balance-iptparam->unlockMoney;
			iptparam->IcBalance[0]=(char)(balance>>24);	iptparam->IcBalance[1]=(char)(balance>>16);
			iptparam->IcBalance[2]=(char)(balance>>8);		iptparam->IcBalance[3]=(char)(balance>>0);
		}
		else
		{
			//账单类型更改为正常
			iptparam->OilBill[IPT_OFFSET_T_TYPE]=(0<<7)|((iptparam->BlistSrc&1)<<6)|(0<<4)|(0<<0);

			//计算扣后余额
			balance=(iptparam->IcBalance[0]<<24)|(iptparam->IcBalance[1]<<16)|(iptparam->IcBalance[2]<<8)|(iptparam->IcBalance[3]<<0);
			balance=balance-pmoney;
			iptparam->IcBalance[0]=(char)(balance>>24);	iptparam->IcBalance[1]=(char)(balance>>16);
			iptparam->IcBalance[2]=(char)(balance>>8);		iptparam->IcBalance[3]=(char)(balance>>0);
		}

		//卡余额(扣后)
		memcpy(&iptparam->OilBill[IPT_OFFSET_BALANCE], iptparam->IcBalance, 4);
		//电子签名，加油/补扣/补充时为TAC，逃卡时为GTAC
		memcpy(&iptparam->OilBill[IPT_OFFSET_TAC], iptparam->IcTac, 4);
		//解灰认证码4bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_GMAC], "\x00\x00\x00\x00", 4);
		//PSAM灰锁签名4bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TAC], "\x00\x00\x00\x00", 4);
		//计算账单校验值
		iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);
		//保存账单及备份
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

		//转入TAC清除过程
		iptPidSet(iptparam, IPT_PID_IC_TAC_CLEAR);
	}
	else
	{
		//该卡执行补扣操作失败直接退卡，其它则继续保存账单
		if(0x01==iptparam->ICStateFirst)	{ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);}
		else														{iptPidSet(iptparam, IPT_PID_IC_TTC_GET);}
	}

	return;
}


/*******************************************************************
*Name				:iptIcTACClear
*Description		:IC卡TAC清除
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcTACClear(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char buffer[128]={0}, dsp_buffer[64]={0}, dsp_len=0, t_type=0;
	int istate=0, apdu_len=0, itimes=0;
	int card_state=0;	//解扣结果:1=成功；非1=失败

	if(iptparam->EtcOilFlg==1)  //szb_fj_20171120,add
	{
		iptparam->EtcFreeflag=2;//释放OBU退出车辆列表
		if(iptparam->Id==IPT_NOZZLE_1)
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+FM_ETC_FREE_FLG_A, &iptparam->EtcFreeflag, 1);
		else
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+FM_ETC_FREE_FLG_B, &iptparam->EtcFreeflag, 1);
	}

	//
	//	TAC清除操作，本操作最多允许执行两次；
	//	执行TAC清除操作有返回时根据返回结果进行提示并进行下一步操作，
	//	超时无返回时则需要读取一次灰锁信息以确定是否TAC清除成功
	//	读灰锁信息确定已TAC清除时继续执行下一步(申请TTC)，灰锁信息结果
	//	为卡仍未TAC清除则执行第二次TAC清除，第二次TAC清除失败则不再进行TAC清除操作
	
	for(itimes=0; itimes<2; itimes++)
	{
IPT_IC_UNLOCK:
		//发送IC卡TAC清除命令
		istate=ICTacClr(iptparam->DEVIC, 0, buffer, 128);
		
		//操作成功，继续执行下一步
		if(ICSTATE_OK==istate)
		{
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
			{
				//清除TAC成功
				card_state=1;

				//转入继续执行TTC申请
				iptPidSet(iptparam, IPT_PID_IC_TTC_GET);
			}
			else
			{
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=15;	memcpy(&dsp_buffer[3], "IC卡TAC清除失败", 15);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				IPT_DSP_WAIT();

				//卡执行补充操作失败直接退卡，其它操作继续保存账单
				if(0x10==iptparam->ICStateFirst)	{ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);}
				else													{iptPidSet(iptparam, IPT_PID_IC_TTC_GET);}
			}

			break;
		}

IPT_IC_UNLOCK_GREYINFO:
		//未知的失败或超时，无法判断操作结果，则读取灰锁信息以确认结果
		istate=ICGreyInfoRead(iptparam->DEVIC, 0, buffer, 128);

		//操作成功且非灰卡状态时继续下一步
		if(ICSTATE_OK==istate)
		{
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2) && 0x10!=buffer[2])
			{
				//清除TAC成功
				card_state=1;

				//转入继续执行TTC申请
				iptPidSet(iptparam, IPT_PID_IC_TTC_GET);

				//退出操作
				break;
			}
			else if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2) && 0x10==buffer[2] && itimes>=1)
			{
				//第二次清除TAC失败，退出
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "TAC清除操作失败", 15);
				IPT_DSP_WAIT();

				//卡执行补充操作失败直接退卡，其它操作继续保存账单
				if(0x10==iptparam->ICStateFirst)	{ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);}
				else													{iptPidSet(iptparam, IPT_PID_IC_TTC_GET);}

				//退出操作
				break;
			}
			else if(0!=memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2) && itimes>=1)
			{
				//第二次解扣失败，退出
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=15;	memcpy(&dsp_buffer[3], "TAC清除操作失败", 15);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				IPT_DSP_WAIT();

				//卡执行补充操作失败直接退卡，其它操作继续保存账单
				if(0x10==iptparam->ICStateFirst)	{ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);}
				else													{iptPidSet(iptparam, IPT_PID_IC_TTC_GET);}

				//退出操作
				break;
			}
		}
		//操作失败则提示错误信息
		else if(ICSTATE_FAILED==istate && itimes>=1)
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "TAC清除操作失败!", 16);
			IPT_DSP_WAIT();
				
			//卡执行补充操作失败直接退卡，其它操作继续保存账单
			if(0x10==iptparam->ICStateFirst)	{ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);}
			else													{iptPidSet(iptparam, IPT_PID_IC_TTC_GET);}

			//退出操作
			break;
		}
		//操作超时，不足2次再次操作，超过2次退出
		else if(ICSTATE_OVERTIME==istate && itimes>=1)
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "TAC清除操作超时!", 16);
			IPT_DSP_WAIT();
					
			//卡执行补充操作失败直接退卡，其它操作继续保存账单
			if(0x10==iptparam->ICStateFirst)	{ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);}
			else													{iptPidSet(iptparam, IPT_PID_IC_TTC_GET);}

			//退出操作
			break;
		}
		//未定义错误
		else if(itimes>=1)
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "TAC清除操作错误!", 16);
			IPT_DSP_WAIT();

			//卡执行补充操作失败直接退卡，其它操作继续保存账单
			if(0x10==iptparam->ICStateFirst)	{ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);}
			else													{iptPidSet(iptparam, IPT_PID_IC_TTC_GET);}

			//退出操作
			break;
		}
	}

	//操作成功
	if(1==card_state)
	{
		//补充操作补充操作时产生一笔补充账单
		if(0x10==iptparam->ICStateFirst)
		{
			iptparam->ICStateFirst=0;

			//IC加油数据保存补充账单
			//待填充:POS_TTC
			memcpy(&iptparam->OilBill[IPT_OFFSET_TTC], "\x00\x00\x00\x00", 4);

			//已完成:交易类型设为无卡错，后台/本地黑白名单，扣款签名有效，补充
			iptparam->OilBill[IPT_OFFSET_T_TYPE]=(0<<7)|((iptparam->BlistSrc&1)<<6)|(1<<4)|(4<<0);

			//已完成:交易日期及时间
			iptparam->OilBill[IPT_OFFSET_TIME+0]=iptparam->Time.century;	
			iptparam->OilBill[IPT_OFFSET_TIME+1]=iptparam->Time.year;
			iptparam->OilBill[IPT_OFFSET_TIME+2]=iptparam->Time.month;
			iptparam->OilBill[IPT_OFFSET_TIME+3]=iptparam->Time.date;
			iptparam->OilBill[IPT_OFFSET_TIME+4]=iptparam->Time.hour;
			iptparam->OilBill[IPT_OFFSET_TIME+5]=iptparam->Time.minute;
			iptparam->OilBill[IPT_OFFSET_TIME+6]=iptparam->Time.second;

			//已完成:卡应用号
			memcpy(&iptparam->OilBill[IPT_OFFSET_ASN], iptparam->IcAppId, 10);
				
			//已完成:余额(扣前)，交易完成后填扣后余额
			memcpy(&iptparam->OilBill[IPT_OFFSET_BALANCE], iptparam->IcLockBalance, 4);
				
			//已完成:数额，以上次解扣的数额为当前数额
			memcpy(&iptparam->OilBill[IPT_OFFSET_AMN], &iptparam->IcLockMoney[1], 3);
				
			//已完成:卡交易序号
			memcpy(&iptparam->OilBill[IPT_OFFSET_CTC], iptparam->IcLockCTC, 2);
				
			//已完成:电子签名，加油/补扣/补充时为TAC，逃卡时为GTAC
			memcpy(&iptparam->OilBill[IPT_OFFSET_TAC], iptparam->IcLockGTAC, 4);

			//已完成:解灰认证码4bytes，加油完成，PSAM计算GMAC后添加
			memcpy(&iptparam->OilBill[IPT_OFFSET_GMAC], "\x00\x00\x00\x00", 4);

			//已完成:PSAM灰锁签名4bytes，加油完成，PSAM计算GMAC后添加
			memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TAC], "\x00\x00\x00\x00", 4);
				
			//已完成:PSAM应用号10bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_ASN], iptparam->PsamId, 10);
			
			//已完成:PSAM编号6bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_TID], iptparam->IcLockTermId, 6);

			//已完成:PSAM终端交易序号4bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TTC], "\x00\x00\x00\x00", 4);

			//已完成:扣款来源1byte
			iptparam->OilBill[IPT_OFFSET_DS]=iptparam->DS;
			
			//已完成:结算单位/方式1byte
			iptparam->OilBill[IPT_OFFSET_UNIT]=0;
		
			//已完成:卡类1byte
			iptparam->OilBill[IPT_OFFSET_C_TYPE]=iptparam->C_TYPE;
				
			//已完成:卡版本1byte，b7~b4卡密钥索引号；b3~b0卡密钥版本号
			iptparam->OilBill[IPT_OFFSET_VER]=((iptparam->PsamKeyIndex&0x0f)<<4)|(1<<0);

			//已完成:枪号1byte
			iptparam->OilBill[IPT_OFFSET_NZN]=0;
			
			//已完成:油品代码2bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_G_CODE], "\x00\x00", 2);

			//已完成:升数3bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_VOL], "\x00\x00\x00", 3);
				
			//已完成:成交价格2bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_PRC], "\x00\x00", 2);

			//已完成:员工号1byte
			iptparam->OilBill[IPT_OFFSET_EMP]=iptparam->EMP;

			//已完成:升累计4bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_V_TOT], "\x00\x00\x00\x00", 4);
				
			//已完成:备用部分11bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_RFU], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 11);

			//待填充:T-MAC	4bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], "\x00\x00\x00\x00", 4);
				
			//已完成:物理枪号PhysicsGunId
			iptparam->OilBill[IPT_OFFSET_PHYGUN]=iptparam->PhysicalNozzle;
				
			//已完成:计量停机原因
			iptparam->OilBill[IPT_OFFSET_STOPNO]=0;

			//已完成:扣前余额
			memcpy(&iptparam->OilBill[IPT_OFFSET_BEFOR_BAL], iptparam->IcLockBalance, 4);
				
			//账单状态:0=正常；1=未完成
			iptparam->OilBill[IPT_OFFSET_ZD_STATE]=1;

			//计量设备ID
			iptparam->OilBill[IPT_OFFSET_JLNOZZLE]=iptparam->JlNozzle;

			//计算账单校验值
			iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

			//保存账单及备份
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);
		}
		else
		{
			//已完成:交易类型设为无卡错，后台/本地黑白名单，扣款签名置为有效
			iptparam->OilBill[IPT_OFFSET_T_TYPE]|=(1<<4);
		}

		iptPidSet(iptparam, IPT_PID_IC_TTC_GET);
	}
	else
	{
		//卡执行补充操作失败直接退卡，其它操作继续保存账单
		if(0x10==iptparam->ICStateFirst)	{ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);}
		else													{iptPidSet(iptparam, IPT_PID_IC_TTC_GET);}
	}

	return;
}


/*******************************************************************
*Name				:iptIcTTCGet
*Description		:IC卡加油完成向PCD申请POS_TTC
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcTTCGet(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char tx_buffer[256]={0}, tx_len=0;
	unsigned char dsp_buffer[64]={0}, dsp_len=0;

	if(IPT_2PCD_UNUSED==iptparam->PcdTxFlag)
	{
		//发送PCD获取TTC命令
		tx_buffer[0]=++iptparam->PcdTxFrame;
		tx_buffer[1]=pcdMboardIDRead();
		tx_buffer[2]=iptparam->Id;
		tx_buffer[3]=iptparam->PhysicalNozzle;
		tx_buffer[4]=IPT_CMD_FORTTC;
		memcpy(&tx_buffer[5], iptparam->OilBill, IPT_BILL_SIZE);
		tx_len=133;
		//msgQSend((MSG_Q_ID)pcdMsgIdRead(), tx_buffer, tx_len, NO_WAIT, MSG_PRI_NORMAL);	

		struct msg_struct msg_stIptSend;  //fj:20170918
		msg_stIptSend.msgType = 1;
		memcpy(msg_stIptSend.msgBuffer,tx_buffer,tx_len);
		msgsnd(pcdMsgIdRead(),&msg_stIptSend,tx_len,IPC_NOWAIT);

		iptparam->PcdTxFlag=IPT_2PCD_OILPROCESS;	
		iptparam->PcdTxTimer=0;
	}
	else
	if(IPT_2PCD_OILPROCESS==iptparam->PcdTxFlag && msg_len>0 && iptparam->PhysicalNozzle==msg_buffer[3] && IPT_CMD_FORTTC==msg_buffer[4] && 0==msg_buffer[5])
	{
		iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdOverTimes=0;
	
		//申请TTC成功
		memcpy(&iptparam->OilBill[IPT_OFFSET_TTC], &msg_buffer[6], 4);

		//计算账单校验值
		iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

		//保存账单及备份
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

		//转入T_MAC计算过程
		iptPidSet(iptparam, IPT_PID_IC_TMAC);
	}
	else
	if((IPT_2PCD_OILPROCESS==iptparam->PcdTxFlag)&&(iptparam->PcdTxTimer>=(2000*ONE_MILLI_SECOND)))
	{
		//通讯超时重发，3次超时失败提示信息后转入选择ADF2过程
		iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdOverTimes++;
		if(iptparam->PcdOverTimes>=3)
		{
			iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "申请TTC超时", 11);
			IPT_DSP_WAIT();

			iptPidSet(iptparam, IPT_PID_IC_LASTSTEP);
		}
	}

	return;
}


/*******************************************************************
*Name				:iptIcTTCGet
*Description		:计算账单TMAC
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcTMAC(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	int istate=0, i=0;
	unsigned char tmac_buffer[4]={0}, apdu_buffer[2]={0}, dsp_buffer[64]={0}, dsp_len=0;

	//计算账单TMAC，成功转入账单存储，失败则提示失败信息后转入账单存储
	for(i=0; i<3; i++)
	{
		istate=iptTMACCalculate(iptparam, tmac_buffer, apdu_buffer, iptparam->OilBill, 95);
		if(0==istate)	break;
	}
	if(0==istate)
	{
		memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], tmac_buffer, 4);
	}
	else
	{
		memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], IPT_TMAC_DEFUALT, 4);
	}
	//计算账单校验值
	iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

	//保存账单及备份
	framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
	framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

	//记录错误信息
	memset(dsp_buffer, 0, sizeof(dsp_buffer));
	if(0x0101==istate)
	{
		strcpy(dsp_buffer, "PSAM选择应用2失败");
		sprintf(dsp_buffer + strlen(dsp_buffer), "%x%x", apdu_buffer[0], apdu_buffer[1]);
	}
	else if(0x0102==istate)
	{
		strcpy(dsp_buffer, "PSAM选择应用2失败");
	}
	else if(0x0103==istate)
	{
		strcpy(dsp_buffer, "PSAM选择应用2超时");
	}
	else if(0x0104==istate)
	{
		strcpy(dsp_buffer, "PSAM选择应用2错误");
	}
	else if(0x0201==istate)
	{
		strcpy(dsp_buffer, "PSAM计算TMAC初始化失败");
		sprintf(dsp_buffer + strlen(dsp_buffer), "%x%x", apdu_buffer[0], apdu_buffer[1]);
	}
	else if(0x0202==istate)
	{
		strcpy(dsp_buffer, "PSAM计算TMAC初始化失败");
	}
	else if(0x0203==istate)
	{
		strcpy(dsp_buffer, "PSAM计算TMAC初始化失败");
	}
	else if(0x0204==istate)
	{
		strcpy(dsp_buffer, "PSAM计算TMAC初始化失败");
	}
	else if(0x0301==istate)
	{
		strcpy(dsp_buffer, "PSAM计算TMAC第1部分失败");
		sprintf(dsp_buffer + strlen(dsp_buffer), "%x%x", apdu_buffer[0], apdu_buffer[1]);
	}
	else if(0x0302==istate)
	{
		strcpy(dsp_buffer, "PSAM计算TMAC第1部分失败");
	}
	else if(0x0303==istate)
	{
		strcpy(dsp_buffer, "PSAM计算TMAC第1部分失败");
	}
	else if(0x0304==istate)
	{
		strcpy(dsp_buffer, "PSAM计算TMAC第1部分失败");
	}
	else if(0x0401==istate)
	{
		strcpy(dsp_buffer, "PSAM计算TMAC第2部分失败");
		sprintf(dsp_buffer + strlen(dsp_buffer), "%x%x", apdu_buffer[0], apdu_buffer[1]);
	}
	else if(0x0402==istate)
	{
		strcpy(dsp_buffer, "PSAM计算TMAC第2部分失败");
	}
	else if(0x0403==istate)
	{
		strcpy(dsp_buffer, "PSAM计算TMAC第2部分失败");
	}
	else if(0x0404==istate)
	{
		strcpy(dsp_buffer, "PSAM计算TMAC第2部分失败");
	}
	else if(0x0501==istate)
	{
		strcpy(dsp_buffer, "PSAM复选应用1失败");
		sprintf(dsp_buffer + strlen(dsp_buffer), "%x%x", apdu_buffer[0], apdu_buffer[1]);
	}
	else if(0x0502==istate)
	{
		strcpy(dsp_buffer, "PSAM复选应用1失败");
	}
	else if(0x0503==istate)
	{
		strcpy(dsp_buffer, "PSAM复选应用1失败");
	}
	else if(0x0504==istate)
	{
		strcpy(dsp_buffer, "PSAM复选应用1失败");
	}
	else if(0!=istate)
	{
		strcpy(dsp_buffer, "计算账单TMAC失败");
	}
	if(strlen(dsp_buffer)>0)
	{
		jljOilErrLogWrite(iptparam->Id, dsp_buffer);
	}

#if 0
	//错误时提示错误信息
	if(0x0101==istate)
	{
		memcpy(&dsp_buffer[0], apdu_buffer, 2);
		dsp_buffer[2]=17;	memcpy(&dsp_buffer[3], "PSAM选择应用2失败", 17);
		dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
		IPT_DSP_WAIT();
	}
	else if(0x0102==istate)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM选择应用2失败", 17);
		IPT_DSP_WAIT();
	}
	else if(0x0103==istate)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM选择应用2超时", 17);
		IPT_DSP_WAIT();
	}
	else if(0x0104==istate)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM选择应用2错误", 17);
		IPT_DSP_WAIT();
	}
	else if(0x0201==istate)
	{
		memcpy(&dsp_buffer[0], apdu_buffer, 2);
		dsp_buffer[2]=22;	memcpy(&dsp_buffer[3], "PSAM计算TMAC初始化失败", 22);
		dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
		IPT_DSP_WAIT();
	}
	else if(0x0202==istate)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM计算TMAC初始化失败", 22);
		IPT_DSP_WAIT();
	}
	else if(0x0203==istate)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM计算TMAC初始化失败", 22);
		IPT_DSP_WAIT();
	}
	else if(0x0204==istate)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM计算TMAC初始化失败", 22);
		IPT_DSP_WAIT();
	}
	else if(0x0301==istate)
	{
		memcpy(&dsp_buffer[0], apdu_buffer, 2);
		dsp_buffer[2]=23;	memcpy(&dsp_buffer[3], "PSAM计算TMAC第1部分失败", 23);
		dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
		IPT_DSP_WAIT();
	}
	else if(0x0302==istate)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM计算TMAC第1部分失败", 23);
		IPT_DSP_WAIT();
	}
	else if(0x0303==istate)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM计算TMAC第1部分失败", 23);
		IPT_DSP_WAIT();
	}
	else if(0x0304==istate)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM计算TMAC第1部分失败", 23);
		IPT_DSP_WAIT();
	}
	else if(0x0401==istate)
	{
		memcpy(&dsp_buffer[0], apdu_buffer, 2);
		dsp_buffer[2]=23;	memcpy(&dsp_buffer[3], "PSAM计算TMAC第2部分失败", 23);
		dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
		IPT_DSP_WAIT();
	}
	else if(0x0402==istate)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM计算TMAC第2部分失败", 23);
		IPT_DSP_WAIT();
	}
	else if(0x0403==istate)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM计算TMAC第2部分失败", 23);
		IPT_DSP_WAIT();
	}
	else if(0x0404==istate)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM计算TMAC第2部分失败", 23);
		IPT_DSP_WAIT();
	}
	else if(0x0501==istate)
	{
		memcpy(&dsp_buffer[0], apdu_buffer, 2);
		dsp_buffer[2]=17;	memcpy(&dsp_buffer[3], "PSAM复选应用1失败", 17);
		dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
		IPT_DSP_WAIT();
	}
	else if(0x0502==istate)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM复选应用1失败", 17);
		IPT_DSP_WAIT();
	}
	else if(0x0503==istate)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM复选应用1失败", 17);
		IPT_DSP_WAIT();
	}
	else if(0x0504==istate)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM复选应用1失败", 17);
		IPT_DSP_WAIT();
	}
	else if(0!=istate)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "计算账单TMAC失败", 16);
		IPT_DSP_WAIT();
	}
#endif

	//转入账单存储过程
	iptPidSet(iptparam, IPT_PID_IC_ZD_SAVE);

	return;
}


/*******************************************************************
*Name				:iptIcZDSave
*Description		:IC卡加油账单保存
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcZDSave(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char tx_buffer[256]={0};
	int tx_len=0;
	unsigned char dsp_buffer[64]={0}, dsp_len=0;

	if(IPT_2PCD_UNUSED==iptparam->PcdTxFlag)
	{
		//保存账单
		tx_buffer[0]=++iptparam->PcdTxFrame;
		tx_buffer[1]=pcdMboardIDRead();
		tx_buffer[2]=iptparam->Id;
		tx_buffer[3]=iptparam->PhysicalNozzle;
		tx_buffer[4]=IPT_CMD_ZDSAVE;
		memcpy(&tx_buffer[5], iptparam->OilBill, IPT_BILL_SIZE);
		tx_len=133;
		//msgQSend((MSG_Q_ID)pcdMsgIdRead(), tx_buffer, tx_len, NO_WAIT, MSG_PRI_NORMAL);

		struct msg_struct msg_stIptSend;  //fj:20170918
		msg_stIptSend.msgType = 1;
		memcpy(msg_stIptSend.msgBuffer,tx_buffer,tx_len);
		msgsnd(pcdMsgIdRead(),&msg_stIptSend,tx_len,IPC_NOWAIT);

		iptparam->PcdTxFlag=IPT_2PCD_OILPROCESS;	iptparam->PcdTxTimer=0;
	}
	else if((IPT_2PCD_OILPROCESS==iptparam->PcdTxFlag)&&(msg_len>0)&&(iptparam->PhysicalNozzle==msg_buffer[3])&&(IPT_CMD_ZDSAVE==msg_buffer[4])&&(0==msg_buffer[5]))
	{
		//账单状态改为完成
		iptparam->OilBill[IPT_OFFSET_ZD_STATE]=0;

		//计算账单校验值
		iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

		//保存账单及备份
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

		//转入加油结束处理
		iptPidSet(iptparam, IPT_PID_IC_LASTSTEP);
		iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdOverTimes=0;
	}
	else if((IPT_2PCD_OILPROCESS==iptparam->PcdTxFlag)&&(iptparam->PcdTxTimer>=(2000*ONE_MILLI_SECOND)))
	{
		//通讯超时重发，3次超时失败提示信息后退卡
		iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdOverTimes++;
		if(iptparam->PcdOverTimes>=3)
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "账单保存超时", 12);
			IPT_DSP_WAIT();

			//转入加油结束处理
			iptPidSet(iptparam, IPT_PID_IC_LASTSTEP);
			iptparam->PcdTxFlag=IPT_2PCD_UNUSED;
			iptparam->PcdOverTimes=0;
		}
	}

	return;
}


/*******************************************************************
*Name				:iptIcOilEnd
*Description		:IC加油加油结束处理
*Input				:None
*Output			:None
*Return				:None
*History			:2014-10-29,modified by syj  */

static void iptIcOilEnd(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned int t_type=0, auto_print=0, money=0, volume=0, price=0, crc_return=0;
	unsigned long long money_sum=0, volume_sum=0;
	unsigned char dsp_buffer[64]={0}, dsp_len=0;
	int i=0;
	unsigned int jlmoney=0, jlvolume=0, jlprice=0, jlsto_no=0, bcd_data=0;	//用于播放语音时的数据
	int voice[32]={0}, voice_len=0, tmp_voice[16]={0}, tmp_voice_len=0;
	unsigned int balance = 0;
	unsigned char tmp_buffer[32]={0}; //szb_fj_20171120
	unsigned int data=0;

	//本次账单可通过快捷方式重打印
	iptparam->OilBillPrintRepeat = 1;

	//促销机通知平板电脑状态，仅正常或逃卡账单
	t_type = iptparam->OilBill[IPT_OFFSET_T_TYPE]&0x0f;
	if(1 == paramPromotionGet() && (IPT_BILLTYPE_NORMAL == t_type || IPT_BILLTYPE_ESCAPE == t_type))
	{
		balance=(iptparam->IcBalance[0]<<24)|(iptparam->IcBalance[1]<<16)|(iptparam->IcBalance[2]<<8)|(iptparam->IcBalance[3]<<0);
		if(balance>=iptparam->OilMoney)	balance = balance - iptparam->OilMoney;
		else														balance = 0;
	
		iptparam->TaState = IPT_STATE_CARD_OILEND;	iptparam->TaStateParamLength = 0;

		*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = (char)(iptparam->OilMoney>>24);	
		*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = (char)(iptparam->OilMoney>>16);
		*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = (char)(iptparam->OilMoney>>8);	
		*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = (char)(iptparam->OilMoney>>0);

		if(IPT_PAYUNIT_MONEY == iptparam->PayUnit)	*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = 0;
		else																			*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = 1;

		*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = (char)(iptparam->OilVolume>>24);	
		*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = (char)(iptparam->OilVolume>>16);
		*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = (char)(iptparam->OilVolume>>8);	
		*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = (char)(iptparam->OilVolume>>0);

		memcpy(iptparam->TaStateParam + iptparam->TaStateParamLength, iptparam->IcAppId, 10);
		iptparam->TaStateParamLength += 10;

		memcpy(iptparam->TaStateParam + iptparam->TaStateParamLength, iptparam->IcBalance, 4);
		iptparam->TaStateParamLength += 4;

		if(IPT_PAYUNIT_MONEY == iptparam->PayUnit)	*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = 0;
		else																			*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = 1;

		*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = (char)(iptparam->OilMoney>>24);	
		*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = (char)(iptparam->OilMoney>>16);
		*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = (char)(iptparam->OilMoney>>8);	
		*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = (char)(iptparam->OilMoney>>0);

		if(IPT_PAYUNIT_MONEY == iptparam->PayUnit)	*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = 0;
		else																			*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = 1;

		memset(iptparam->TaStateParam + iptparam->TaStateParamLength, 0, 12);
		iptparam->TaStateParamLength += 12;
		
		pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
	}

	//促销机向平板电脑发加油账单明细，仅正常或逃卡账单
	t_type = iptparam->OilBill[IPT_OFFSET_T_TYPE]&0x0f;
	if(1 == paramPromotionGet() && (IPT_BILLTYPE_NORMAL == t_type || IPT_BILLTYPE_ESCAPE == t_type))
	{
		pcBillWrite(iptparam->TabletPanel, iptparam->PhysicalNozzle, iptparam->OilBill, IPT_BILL_SIZE);
	}

	//加油状态结束
	iptparam->OilState=IPT_OIL_IDLE;

	//判断该卡类型该账单类型是否自动打印
	t_type=iptparam->OilBill[IPT_OFFSET_T_TYPE]&0x0f;
	if((1==iptparam->PrintAuto)&&(1==iptparam->IcAppId[2]))//用户卡账单
	{
		for(i=0; i<=9; i++)	if((i==t_type)&&(1==((iptparam->PrintCardUser>>i)&1)))		auto_print=1;
	}
	else
	if((1==iptparam->PrintAuto)&&(2==iptparam->IcAppId[2]))//管理卡账单
	{
		for(i=0; i<=9; i++)	if((i==t_type)&&(1==((iptparam->PrintCardManage>>i)&1)))	auto_print=1;
	}
	else
	if((1==iptparam->PrintAuto)&&(4==iptparam->IcAppId[2]))//员工卡账单
	{
		for(i=0; i<=9; i++)	if((i==t_type)&&(1==((iptparam->PrintCardStaff>>i)&1)))		auto_print=1;
	}
	else
	if((1==iptparam->PrintAuto)&&(5==iptparam->IcAppId[2]))//验泵卡账单
	{
		for(i=0; i<=9; i++)	if((i==t_type)&&(1==((iptparam->PrintCardPump>>i)&1)))	auto_print=1;
	}
	else
	if((1==iptparam->PrintAuto)&&(6==iptparam->IcAppId[2]))//维修卡账单
	{
		for(i=0; i<=9; i++)	if((i==t_type)&&(1==((iptparam->PrintCardService>>i)&1)))	auto_print=1;
	}

	if(1==auto_print && 0==iptparam->PrintUnion)			iptPrint(iptparam, 0, iptparam->OilBill, IPT_BILL_SIZE);
	else if(1==auto_print && 0!=iptparam->PrintUnion)	iptPrint(iptparam, 1, iptparam->OilBill, IPT_BILL_SIZE);

	//判断只有逃卡或正常加油，有语音播放时播放
	//语音提示"您此次的加油量是XXXX.XX升,XXXX.XX元，祝您一路平安，欢迎下次光临"
	t_type=iptparam->OilBill[IPT_OFFSET_T_TYPE]&0x0f;
	if(iptparam->VoiceVolume>0 && (IPT_BILLTYPE_NORMAL==t_type || IPT_BILLTYPE_ESCAPE==t_type))
	{
		jlvolume=iptparam->OilVolume;	jlmoney=iptparam->OilMoney;
		//您此次的加油量是
		if(IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType)	voice[voice_len++]=SPKW_THISVOLUME;	
		else																				voice[voice_len++]=SPKM_THISVOLUME;
		//XXXX.XX
		tmp_voice_len=iptHexVoiceIdGet(iptparam, jlvolume, tmp_voice);	
		for(i=0; i<tmp_voice_len; i++)	voice[voice_len++]=tmp_voice[i];
		//升
		if(IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType)	voice[voice_len++]=SPKW_SHENG;	
		else																				voice[voice_len++]=SPKM_SHENG;
		//XXXX.XX
		tmp_voice_len=iptHexVoiceIdGet(iptparam, jlmoney, tmp_voice);			
		for(i=0; i<tmp_voice_len; i++)	voice[voice_len++]=tmp_voice[i];
		//元
		if(IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType)	voice[voice_len++]=SPKW_YUAN;	
		else																				voice[voice_len++]=SPKM_YUAN;
		//祝您一路平安，欢迎下次光临
		if(IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType)	voice[voice_len++]=SPKW_SEEYOU;		
		else																				voice[voice_len++]=SPKM_SEEYOU;

		iptSpk(iptparam, voice, voice_len);
	}

	//如果有过冲则计算过冲账单并转入过冲提示过程
	if(iptparam->MoneyUnself>0)
	{
		//产生非卡加油账单
		//待填充:POS_TTC
		memcpy(&iptparam->OilBill[IPT_OFFSET_TTC], "\x00\x00\x00\x00", 4);

		//待填充:交易类型设为无卡错，后台/本地黑白名单，扣款签名无效，非卡
		iptparam->OilBill[IPT_OFFSET_T_TYPE]=(0<<7)|(0<<6)|(0<<4)|(7<<0);

		//已完成:交易日期及时间
		iptparam->OilTime[0]=iptparam->Time.century;	iptparam->OilTime[1]=iptparam->Time.year;
		iptparam->OilTime[2]=iptparam->Time.month;		iptparam->OilTime[3]=iptparam->Time.date;
		iptparam->OilTime[4]=iptparam->Time.hour;		iptparam->OilTime[5]=iptparam->Time.minute;
		iptparam->OilTime[6]=iptparam->Time.second;
		memcpy(&iptparam->OilBill[IPT_OFFSET_TIME], iptparam->OilTime, 7);

		//已完成:卡应用号
		memcpy(&iptparam->OilBill[IPT_OFFSET_ASN], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 10);

		//待填充:余额(扣前)，交易完成后填扣后余额
		memcpy(&iptparam->OilBill[IPT_OFFSET_BALANCE], "\x00\x00\x00\x00", 4);

		//待填充:数额，交易完成后填实际数额
		memcpy(&iptparam->OilBill[IPT_OFFSET_AMN], "\x00\x00\x00", 3);

		//已完成:卡交易序号
		memcpy(&iptparam->OilBill[IPT_OFFSET_CTC], "\x00\x00", 2);

		//待填充:电子签名，加油/补扣/补充时未TAC，逃卡时为GTAC
		memcpy(&iptparam->OilBill[IPT_OFFSET_TAC], "\x00\x00\x00\x00", 4);

		//待填充:解灰认证码4bytes，加油完成，PSAM计算GMAC后添加
		memcpy(&iptparam->OilBill[IPT_OFFSET_GMAC], "\x00\x00\x00\x00", 4);

		//待填充:PSAM会所签名4bytes，加油完成，PSAM计算GMAC后添加
		memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TAC], "\x00\x00\x00\x00", 4);

		//已完成:PSAM应用号10bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_ASN], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 10);

		//已完成:PSAM编号6bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_TID], "\x00\x00\x00\x00\x00\x00", 6);
			
		//已完成:PSAM终端交易序号4bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TTC], "\x00\x00\x00\x00", 4);

		//已完成:扣款来源1byte
		iptparam->OilBill[IPT_OFFSET_DS]=0;
			
		//已完成:结算单位/方式1byte
		iptparam->OilBill[IPT_OFFSET_UNIT]=0;
			
		//已完成:卡类1byte
		iptparam->OilBill[IPT_OFFSET_C_TYPE]=0;

		//已完成:卡版本1byte，b7~b4卡密钥索引号；b3~b0卡密钥版本号
		iptparam->OilBill[IPT_OFFSET_VER]=0;

		//已完成:枪号1byte
		iptparam->OilBill[IPT_OFFSET_NZN]=iptparam->LogicNozzle;
			
		//已完成:油品代码2bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_G_CODE], iptparam->OilCode, 2);

		//升数3bytes，交易完成后填实际升数
		dsp_buffer[0]=(char)(iptparam->VolumeUnself>>16);	
		dsp_buffer[1]=(char)(iptparam->VolumeUnself>>8);
		dsp_buffer[2]=(char)(iptparam->VolumeUnself>>0);
		memcpy(&iptparam->OilBill[IPT_OFFSET_VOL], dsp_buffer, 3);

		//已完成:成交价格2bytes，根据累计金额及油量计算
		money=iptparam->MoneyUnself;	volume=iptparam->VolumeUnself;	
		if((money*1000/volume%10)<IPT_ROUNDING)	price=money*100/volume;
		else																		price=money*100/volume+1;
		iptparam->OilBill[IPT_OFFSET_PRC+0]=(char)(price>>8);
		iptparam->OilBill[IPT_OFFSET_PRC+1]=(char)(price>>0);

		//已完成:员工号1byte
		iptparam->OilBill[IPT_OFFSET_EMP]=iptparam->EMP;

		//已完成:升累计4bytes,fj:
		jlSumRead(iptparam->JlNozzle, &volume_sum, &money_sum);
		iptparam->OilBill[IPT_OFFSET_V_TOT+0]=(char)(volume_sum>>24);
		iptparam->OilBill[IPT_OFFSET_V_TOT+1]=(char)(volume_sum>>16);
		iptparam->OilBill[IPT_OFFSET_V_TOT+2]=(char)(volume_sum>>8);
		iptparam->OilBill[IPT_OFFSET_V_TOT+3]=(char)(volume_sum>>0);

		//已完成:备用部分11bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_RFU], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 11);

		//待填充:T-MAC	4bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], "\x00\x00\x00\x00", 4);
					
		//已完成:物理枪号PhysicsGunId
		iptparam->OilBill[IPT_OFFSET_PHYGUN]=iptparam->PhysicalNozzle;

		//已完成:计量停机原因
		iptparam->OilBill[IPT_OFFSET_STOPNO]=0;

		//已完成:扣前余额
		memcpy(&iptparam->OilBill[IPT_OFFSET_BEFOR_BAL], iptparam->IcBalance, 4);

		//账单状态:0=正常；1=未完成
		iptparam->OilBill[IPT_OFFSET_ZD_STATE]=1;

		//计量设备ID
		iptparam->OilBill[IPT_OFFSET_JLNOZZLE]=iptparam->JlNozzle;

		//计算账单校验值
		iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

		//保存账单及备份
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

		//提请保存账单
		iptparam->OilBillSave=1;
		framWrite(FM_ADDR_IPT_SINO,iptparam->FMAddrBase+IPT_FM_BILL_FLAG,&iptparam->OilBillSave,1); //szb_fj_20171120

		//转入加油过冲提示界面
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp_buffer[0]=(char)(iptparam->MoneyUnself>>16);	dsp_buffer[1]=(char)(iptparam->MoneyUnself>>8);
		dsp_buffer[2]=(char)(iptparam->MoneyUnself>>0);	
		dsp_len=3;
		dsp(iptparam->DEVDsp, DSP_OIL_OVER_INFO, dsp_buffer, dsp_len);
		iptPidSet(iptparam, IPT_PID_IC_OIL_OVERINFO);

		//清除上一次单次过充数据，不清除累计过冲数据
		memset(tmp_buffer, 0, 32);	iptparam->MoneyUnself=0;	iptparam->VolumeUnself=0;
		tmp_buffer[0]=(char)(iptparam->MoneyUnself>>16);
		tmp_buffer[1]=(char)(iptparam->MoneyUnself>>8);	tmp_buffer[2]=(char)(iptparam->MoneyUnself>>0);
		tmp_buffer[3]=(char)(iptparam->VolumeUnself>>16);
		tmp_buffer[4]=(char)(iptparam->VolumeUnself>>8);	tmp_buffer[5]=(char)(iptparam->VolumeUnself>>0);
		tmp_buffer[6]=0;
		tmp_buffer[7]=(char)(iptparam->MoneyUnselfSum>>16);	
		tmp_buffer[8]=(char)(iptparam->MoneyUnselfSum>>8);	tmp_buffer[9]=(char)(iptparam->MoneyUnselfSum>>0);
		tmp_buffer[10]=(char)(iptparam->VolumeUnselfSum>>16);	
		tmp_buffer[11]=(char)(iptparam->VolumeUnselfSum>>8);	tmp_buffer[12]=(char)(iptparam->VolumeUnselfSum>>0);
		tmp_buffer[13]=iptparam->OilOverTimes;
		data=crc16Get(tmp_buffer, 30);
		tmp_buffer[30]=(char)(data>>8);	tmp_buffer[31]=(char)(data>>0);
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_UNSELF, tmp_buffer, 32);
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_UNSELF2, tmp_buffer, 32);

		return;
	}

	//根据账单类型判断后续步骤
	t_type=iptparam->OilBill[IPT_OFFSET_T_TYPE]&0x0f;
	if(IPT_BILLTYPE_NORMAL==t_type)
	{
		//正常加油账单，用户卡弹卡后转入等待处理界面，内部卡转入余额读取过程
		if(1==iptparam->IcAppId[2])
		{
			iptparam->NousedTimer=0;
			memcpy(&dsp_buffer[0], iptparam->IcBalance, 4);
			if(1 == iptIsLianda(iptparam->Id) && 1 == iptparam->IcDebitUnit)	dsp_buffer[4] = 2;
			else if(IPT_PAYUNIT_LOYALTY == iptparam->PayUnit)						dsp_buffer[4] = 1;
			else																										dsp_buffer[4] = 0;
			dsp(iptparam->DEVDsp, DSP_CARD_OILEND, dsp_buffer, 5);

			ICShoot(iptparam->DEVIC);
			iptPidSet(iptparam, IPT_PID_IC_ENDACK);
		}
		else
		{
			if(iptparam->JlErr_QYL>=6) //szb_fj_20171120:异常停机，缺1路脉冲
			{
				if(0x30==iptparam->IcState.DeckStateS1)	ICShoot(iptparam->DEVIC);
				iptMainInterface(iptparam);
			}
			else if(iptparam->JlErr_WMCCS>=6) //szb_fj_20171120:异常停机无脉冲超时
			{
				if(0x30==iptparam->IcState.DeckStateS1)	ICShoot(iptparam->DEVIC);
				iptMainInterface(iptparam);
			}
			else if(iptparam->JlErr_QYZ>=6) //szb_fj_20171120:异常停机缺一组脉冲
			{
				if(0x30==iptparam->IcState.DeckStateS1)	ICShoot(iptparam->DEVIC);
				iptMainInterface(iptparam);
			}
			else if(iptparam->JlErr_ZERO>=6)//szb_fj_20171120:异常停机零加油
			{
				if(0x30==iptparam->IcState.DeckStateS1)	ICShoot(iptparam->DEVIC);
				iptMainInterface(iptparam);
			}
			else
			{
			    iptPidSet(iptparam, IPT_PID_IC_BAL_READ);
			}
		}
	}
	else if(IPT_BILLTYPE_ESCAPE==t_type)
	{
		//逃卡，转入逃卡报警界面
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "逃卡，扣款失败", 14);
		iptPidSet(iptparam, IPT_PID_IC_ESCAPE_ERR);
	}
	else if(IPT_BILLTYPE_OILINFO==t_type || IPT_BILLTYPE_REFUSE==t_type)
	{
		//油价接收，卡错拒绝返回待机界面
		if(0x30==iptparam->IcState.DeckStateS1)	ICShoot(iptparam->DEVIC);
		iptMainInterface(iptparam);
	}
	else if(IPT_BILLTYPE_ERROR==t_type || IPT_BILLTYPE_WORKOFF==t_type || IPT_BILLTYPE_UNSELF==t_type)
	{
		//错卡，下班，非卡，退卡返回待机界面
		ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
	}
	else if(IPT_BILLTYPE_UNLOCK==t_type || IPT_BILLTYPE_FINISH==t_type || IPT_BILLTYPE_WORKON==t_type)
	{
		if(iptparam->EtcOilFlg==1)//szb_fj_20171120:ETC加油进行透明传输
		{
			memcpy(&dsp_buffer[0], iptparam->IcBalance, 4);
			if(1 == iptIsLianda(iptparam->Id) && 1 == iptparam->IcDebitUnit)
				dsp_buffer[4] = 2;
			else if(IPT_PAYUNIT_LOYALTY == iptparam->PayUnit)						
				dsp_buffer[4] = 1;
			else	
				dsp_buffer[4] = 0;
			dsp(iptparam->DEVDsp, DSP_CARD_OILEND, dsp_buffer, 5);

			EtcYueDisHandle(iptparam->Id);//szb_fj_20171120:通知OBU显示余额
			IPT_DSP_WAIT();
			
			iptPidSet(iptparam, IPT_PID_IC_PRETREAT);
			iptparam->Step=1;
			
			dsp(iptparam->DEVDsp, DSP_CARD_PRETREAT, "\x00", 0);//szb_fj_20171120:显示并转入卡预处理过程
			iptparam->etc_touming_flg=0;
			
			iptparam->Payment=IPT_PAYMENT_MONEY; //结算方式默认为现金
			iptparam->PayUnit=IPT_PAYUNIT_MONEY;
		}
		else  //补扣，补充，上班，转到余额读取界面
		{
		    iptPidSet(iptparam, IPT_PID_IC_BAL_READ);
		}
	}
	else
	{
		//非法的账单类型有卡退卡，返回待机界面
		if(0x30==iptparam->IcState.DeckStateS1)	ICShoot(iptparam->DEVIC);
		iptMainInterface(iptparam);
	}

	return;
}


/*******************************************************************
*Name				:iptIcOilEndWait
*Description		:IC卡加油完成显示延时界面
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcOilEndWait(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	if((iptparam->EtcOilFlg!=0) && iptparam->etc_yue_dis_flag==0)
		EtcYueDisHandle(iptparam->Id);   //通知OBU显示余额
	
	//有任意按键或5秒钟无操作返回待机界面
	if(KB_BUTTON_NO!=iptparam->Button || iptparam->NousedTimer>=5*ONE_SECOND)
	{
		iptMainInterface(iptparam);
		return;
	}

	return;
}


/*******************************************************************
*Name				:iptIcEscapeWarning
*Description		:IC卡逃卡报警界面
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcEscapeWarning(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	//按更改键停止蜂鸣器报警并返回待机界面
	if(KB_BUTTON_CHG==iptparam->Button || KB_BUTTON_BACK==iptparam->Button){
		ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		return;
	}

	//每个500豪秒发送一次报警音
	if(iptparam->WarnigBeepTimer>=500*ONE_MILLI_SECOND){

		kbBuzzerBeep(iptparam->DEVBuzzer, 0);
		iptparam->WarnigBeepTimer=0;
	}

	return;
}


/*******************************************************************
*Name				:iptIcOilOverInfo
*Description		:过冲加油信息界面
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcOilOverInfo(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char dsp_buffer[64]={0}, dsp_len=0;

	if(KB_BUTTON_BACK==iptparam->Button){

		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp_buffer[0]=(char)(iptparam->MoneyUnself>>16);	dsp_buffer[1]=(char)(iptparam->MoneyUnself>>8);
		dsp_buffer[2]=(char)(iptparam->MoneyUnself>>0);	
		dsp_buffer[3]=iptparam->SetButtonLen;	dsp_len=4;
		dsp(iptparam->DEVDsp, DSP_OIL_OVER_STAFFIN, dsp_buffer, dsp_len);
		iptPidSet(iptparam, IPT_PID_IC_OIL_OVERSTAFF);
	}

	return;
}


/*******************************************************************
*Name				:iptIcOilOverInfo
*Description		:过冲加油信息界面
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptIcOilOverStaffPassin(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char button=0, password[4]={0};
	unsigned char dsp_buffer[64]={0}, dsp_len=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0==button)	button='0';
	case KB_BUTTON_1:
		if(0==button)	button='1';
	case KB_BUTTON_2:
		if(0==button)	button='2';
	case KB_BUTTON_3:
		if(0==button)	button='3';
	case KB_BUTTON_4:
		if(0==button)	button='4';
	case KB_BUTTON_5:
		if(0==button)	button='5';
	case KB_BUTTON_6:
		if(0==button)	button='6';
	case KB_BUTTON_7:
		if(0==button)	button='7';
	case KB_BUTTON_8:
		if(0==button)	button='8';
	case KB_BUTTON_9:
		if(0==button)	button='9';
		
		if(iptparam->SetButtonLen<4){

			iptparam->SetButton[iptparam->SetButtonLen++]=button;

			dsp_buffer[0]=(char)(iptparam->MoneyUnself>>16);	dsp_buffer[1]=(char)(iptparam->MoneyUnself>>8);
			dsp_buffer[2]=(char)(iptparam->MoneyUnself>>0);	
			dsp_buffer[3]=iptparam->SetButtonLen;	dsp_len=4;
			dsp(iptparam->DEVDsp, DSP_OIL_OVER_STAFFIN, dsp_buffer, dsp_len);
		}
		break;

	case KB_BUTTON_CHG:
		//清除密码输入
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;

		dsp_buffer[0]=(char)(iptparam->MoneyUnself>>16);	dsp_buffer[1]=(char)(iptparam->MoneyUnself>>8);
		dsp_buffer[2]=(char)(iptparam->MoneyUnself>>0);
		dsp_buffer[3]=iptparam->SetButtonLen;	dsp_len=4;
		dsp(iptparam->DEVDsp, DSP_OIL_OVER_STAFFIN, dsp_buffer, dsp_len);
		break;

	case KB_BUTTON_ACK:
		password[0]=((iptparam->EMPPassword[0]>>4)&0x0f)+0x30;	password[1]=((iptparam->EMPPassword[0]>>0)&0x0f)+0x30;
		password[2]=((iptparam->EMPPassword[1]>>4)&0x0f)+0x30;	password[3]=((iptparam->EMPPassword[1]>>0)&0x0f)+0x30;

		//判断员工密码
		if(4==iptparam->SetButtonLen && 0==memcmp(password, iptparam->SetButton, 4)){

			//密码正确退卡返回待机界面
			ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
		}
		else{

			//密码错误则提示错误信息
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "员工密码错误", 12);
			IPT_DSP_WAIT();

			//清除输入并重新显示密码输入界面
			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp_buffer[0]=(char)(iptparam->MoneyUnself>>16);	dsp_buffer[1]=(char)(iptparam->MoneyUnself>>8);
			dsp_buffer[2]=(char)(iptparam->MoneyUnself>>0);
			dsp_buffer[3]=iptparam->SetButtonLen;	dsp_len=4;
			dsp(iptparam->DEVDsp, DSP_OIL_OVER_STAFFIN, dsp_buffer, dsp_len);
			break;
		}
		break;

	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptIcACTAuthen
*Description		:ACT卡认证过程
*Input				:None
*Output			:None
*Return				:None
*History			:2014-04-17,modified by syj  */

static void iptIcACTAuthen(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char buffer[128]={0}, dsp_buffer[64]={0}, dsp_len=0;
	int istate=0, apdu_len=0;

	switch(iptparam->Step)
	{
	case 0:	
		//获取安全提升功能启用状态
		istate=PsamGetAPProof(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate)
		{
			iptparam->IcOverTimes=0;	
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2) || 0==memcmp(&buffer[2+apdu_len-2], "\x9B\x02", 2))
			{
				iptparam->Step++;
			}
			else
			{
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=14;	memcpy(&dsp_buffer[3], "读安全状态失败", 14);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
				iptMainInterface(iptparam);
			}
		}
		//操作失败则提示信息后退卡
		else
		if(ICSTATE_FAILED==istate)
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "读安全状态失败", 14);
			ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
			iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else
		if(ICSTATE_OVERTIME==istate)
		{
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3)
			{
				iptparam->IcOverTimes=0;
				
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "读安全状态超时", 14);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
				iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "读安全状态错误", 14);
			ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
			iptMainInterface(iptparam);
		}
		break;
		
	case 1:
		//读26文件，获取ACT认证密钥索引号
		istate=ICFile26Read(iptparam->DEVIC, 0, buffer, 128);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate)
		{
			iptparam->IcOverTimes=0;	
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
			{
				iptparam->ACTKeyIndex=buffer[2];								//认证密钥索引号(ACT索引号)
				iptparam->ACTUnused=buffer[3];									//保留

				iptparam->Step++;
			}
			else
			{
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=14;	memcpy(&dsp_buffer[3], "读卡26文件失败", 14);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
				iptMainInterface(iptparam);
			}
		}
		//操作失败则提示信息后退卡
		else
		if(ICSTATE_FAILED==istate)
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "读卡26文件失败", 14);
			ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
			iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else
		if(ICSTATE_OVERTIME==istate)
		{
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3)
			{
				iptparam->IcOverTimes=0;

				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "读卡26文件超时", 14);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
				iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "读卡26文件错误", 14);
			ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
			iptMainInterface(iptparam);
		}
		break;

		
	case 2:	
		//申请随机数
		istate=PsamGetRandom(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate)
		{
			iptparam->IcOverTimes=0;	
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
			{
				memcpy(iptparam->ACTPSAMRandom, &buffer[2], 4);	//PSAM随机数

				iptparam->Step++;
			}
			else
			{
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=12;	memcpy(&dsp_buffer[3], "取随机数失败", 12);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
				iptMainInterface(iptparam);
			}
		}
		//操作失败则提示信息后退卡
		else
		if(ICSTATE_FAILED==istate)
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "取随机数失败", 12);
			ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
			iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else
		if(ICSTATE_OVERTIME==istate)
		{
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3)
			{
				iptparam->IcOverTimes=0;
				
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "取随机数超时", 12);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
				iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else
		{
			iptparam->IcOverTimes=0;
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "取随机数错误", 12);
			ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
			iptMainInterface(iptparam);
		}

		break;

	case 3:	
		//向ACT发送DES CRYPT命令		
		istate=ICDESCrypt(iptparam->DEVIC, 0, buffer, 128, iptparam->ACTKeyIndex, iptparam->ACTPSAMRandom);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate)
		{
			iptparam->IcOverTimes=0;	
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
			{
				memcpy(iptparam->ACTCiphertext, &buffer[2], 8);		//密文数据

				iptparam->Step++;
			}
			else
			{
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=16;	memcpy(&dsp_buffer[3], "ACT卡DES计算失败", 16);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
				iptMainInterface(iptparam);
			}
		}
		//操作失败则提示信息后退卡
		else
		if(ICSTATE_FAILED==istate)
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "ACT卡DES计算失败", 16);
			ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
			iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else
		if(ICSTATE_OVERTIME==istate)
		{
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3)
			{
				iptparam->IcOverTimes=0;

				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "ACT卡DES计算超时", 16);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
				iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "ACT卡DES计算错误", 16);
			ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
			iptMainInterface(iptparam);
		}

		break;

	case 4:	
		//向PSAM发送START BINDING SERVICE命令
		istate=PsamStartBind(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, iptparam->ACTKeyIndex, &iptparam->IcAppId[2], iptparam->ACTCiphertext);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate)
		{
			iptparam->IcOverTimes=0;
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
			{
				memcpy(iptparam->ACTAppId, iptparam->IcAppId, 10);	//保存ACT卡卡号

		//
				iptparam->BindTime[0]=iptparam->Time.century;						//绑定时间
				iptparam->BindTime[1]=iptparam->Time.year;		iptparam->BindTime[2]=iptparam->Time.month;				
				iptparam->BindTime[3]=iptparam->Time.date;		iptparam->BindTime[4]=iptparam->Time.hour;				
				iptparam->BindTime[5]=iptparam->Time.minute;	iptparam->BindTime[6]=iptparam->Time.second;				
				memcpy(iptparam->BindMboardId, MboardID, 8);						//绑定的芯片ID
				memcpy(iptparam->BindACTAppId, iptparam->IcAppId, 10);		//绑定的ACT卡号
		
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "ACT认证成功,请插入RID卡", 23);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
				iptMainInterface(iptparam);
			}
			else
			if(0x6b==buffer[2+apdu_len-2] && 0xc0==(buffer[2+apdu_len-1]&0xf0))
			{
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=24;
				memcpy(&dsp_buffer[3], "ACT认证失败,剩余", 16);
				dsp_buffer[19]=((buffer[2+apdu_len-1]&0x0f)/10)+0x30;	if('0'==dsp_buffer[19])	dsp_buffer[18]=' ';
				dsp_buffer[20]=((buffer[2+apdu_len-1]&0x0f)%10)+0x30;
				memcpy(&dsp_buffer[22], "次机会", 6);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
				iptMainInterface(iptparam);
			}
			else
			{
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=13;	memcpy(&dsp_buffer[3], "ACT卡认证失败", 13);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
				iptMainInterface(iptparam);
			}
		}
		//操作失败则提示信息后退卡
		else
		if(ICSTATE_FAILED==istate)
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "ACT卡认证失败", 13);
			ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
			iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else
		if(ICSTATE_OVERTIME==istate)
		{
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3)
			{
				iptparam->IcOverTimes=0;

				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "ACT卡认证超时", 13);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
				iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "ACT卡认证错误", 13);
			ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
			iptMainInterface(iptparam);
		}
		break;
		
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptIcRIDAuthen
*Description		:RID卡认证过程
*Input				:None
*Output			:None
*Return				:None
*History			:2014-04-17,modified by syj  */

static void iptIcRIDAuthen(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char buffer[128]={0}, dsp_buffer[64]={0}, dsp_len=0;
	int istate=0, apdu_len=0, i=0;
	
	switch(iptparam->Step)
	{
	case 0:	
		//获取安全提升功能启用状态
		istate=PsamGetAPProof(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate)
		{
			iptparam->IcOverTimes=0;	
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2) || 0==memcmp(&buffer[2+apdu_len-2], "\x9B\x02", 2))
			{
				iptparam->Step++;
			}
			else
			{
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=14;	memcpy(&dsp_buffer[3], "读安全状态失败", 14);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
				iptMainInterface(iptparam);
			}
		}
		//操作失败则提示信息后退卡
		else
		if(ICSTATE_FAILED==istate)
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "读安全状态失败", 14);
			ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
			iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else
		if(ICSTATE_OVERTIME==istate)
		{
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3)
			{
				iptparam->IcOverTimes=0;

				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "读安全状态超时", 14);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
				iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "读安全状态错误", 14);
			ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
			iptMainInterface(iptparam);
		}
		break;

	case 1:
		//读26文件，获取RID卡"认证密钥索引号"和"计算密钥版本号"
		istate=ICFile26Read(iptparam->DEVIC, 0, buffer, 128);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate)
		{
			iptparam->IcOverTimes=0;	
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
			{
				iptparam->RIDKeyIndex=buffer[2];			//认证密钥索引号(RID索引号)
				iptparam->RIDCalKeyIndex=buffer[3];		//计算密钥索引号( 日志MAC计算)

				iptparam->Step++;
			}
			else
			{
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=14;	memcpy(&dsp_buffer[3], "读卡26文件失败", 14);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
				iptMainInterface(iptparam);
			}
		}
		//操作失败则提示信息后退卡
		else
		if(ICSTATE_FAILED==istate)
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "读卡26文件失败", 14);
			ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
			iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else
		if(ICSTATE_OVERTIME==istate)
		{
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3)
			{
				iptparam->IcOverTimes=0;

				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "读卡26文件超时", 14);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
				iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "读卡26文件错误", 14);
			ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
			iptMainInterface(iptparam);
		}
		break;

	case 2:	
		//申请随机数
		istate=PsamGetRandom(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate)
		{
			iptparam->IcOverTimes=0;	
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
			{
				memcpy(iptparam->RIDPSAMRandom, &buffer[2], 4);	//PSAM随机数

				iptparam->Step++;
			}
			else
			{
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=12;	memcpy(&dsp_buffer[3], "取随机数失败", 12);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
				iptMainInterface(iptparam);
			}
		}
		//操作失败则提示信息后退卡
		else
		if(ICSTATE_FAILED==istate)
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "取随机数失败", 12);
			ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
			iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else
		if(ICSTATE_OVERTIME==istate)
		{
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3)
			{
				iptparam->IcOverTimes=0;
				
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "取随机数超时", 12);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
				iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else
		{
			iptparam->IcOverTimes=0;
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "取随机数错误", 12);
			ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
			iptMainInterface(iptparam);
		}
		break;
		
	case 3:	
		//向RID发送DES CRYPT命令		
		istate=ICDESCrypt(iptparam->DEVIC, 0, buffer, 128, iptparam->RIDKeyIndex, iptparam->RIDPSAMRandom);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate)
		{
			iptparam->IcOverTimes=0;	
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
			{
				memcpy(iptparam->RIDCiphertext, &buffer[2], 8);		//密文数据

				iptparam->Step++;
			}
			else
			{
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=16;	memcpy(&dsp_buffer[3], "RID卡DES计算失败", 16);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
				iptMainInterface(iptparam);
			}
		}
		//操作失败则提示信息后退卡
		else
		if(ICSTATE_FAILED==istate)
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "RID卡DES计算失败", 16);
			ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
			iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else
		if(ICSTATE_OVERTIME==istate)
		{
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3)
			{
				iptparam->IcOverTimes=0;

				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "RID卡DES计算超时", 16);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
				iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "RID卡DES计算错误", 16);
			ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
			iptMainInterface(iptparam);
		}
		break;

	case 4:	
		//向PSAM卡发送INIT_SAM_BINDING
		istate=PsamInitBind(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, iptparam->RIDKeyIndex, &iptparam->IcAppId[2], IPT_COMPANY_ID, iptparam->RIDCiphertext);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate)
		{
			iptparam->IcOverTimes=0;	
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "正在注册,请稍候.", 16);

				iptparam->Step++;
			}
			else
			{
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=13;	memcpy(&dsp_buffer[3], "RID卡认证失败", 13);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
				iptMainInterface(iptparam);
			}
		}
		//操作失败则提示信息后退卡
		else
		if(ICSTATE_FAILED==istate)
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "RID卡认证失败", 13);
			ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
			iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else
		if(ICSTATE_OVERTIME==istate)
		{
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3)
			{
				iptparam->IcOverTimes=0;

				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "RID卡认证超时", 13);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
				iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "RID卡认证错误", 13);
			ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
			iptMainInterface(iptparam);
		}
		break;

	case 5:	
		//向PSAM卡发送SAM_BINDING
		istate=PsamBind(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, MboardID, IPT_COMPANY_ID);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate)
		{
			iptparam->IcOverTimes=0;	
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
			{
				iptparam->Step++;
			}
			else
			{
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=12;	memcpy(&dsp_buffer[3], "芯片注册失败", 12);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
				iptMainInterface(iptparam);
			}
		}
		//操作失败则提示信息后退卡
		else
		if(ICSTATE_FAILED==istate)
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "芯片注册失败", 12);
			ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
			iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else
		if(ICSTATE_OVERTIME==istate)
		{
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3)
			{
				iptparam->IcOverTimes=0;

				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "芯片注册超时", 12);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
				iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "芯片注册错误", 12);
			ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
			iptMainInterface(iptparam);
		}
		break;

		
	case 6:	
		//向PSAM卡发送INIT_FOR_DESCRYPT	
		istate=PsamInitDESCrypt(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, iptparam->RIDCalKeyIndex);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate)
		{
			iptparam->IcOverTimes=0;	
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
			{
				iptparam->Step++;
			}
			else
			{
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=19;	memcpy(&dsp_buffer[3], "PSAM卡DES初始化失败", 19);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
				iptMainInterface(iptparam);
			}
		}
		//操作失败则提示信息后退卡
		else
		if(ICSTATE_FAILED==istate)
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM卡DES初始化失败", 19);
			ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
			iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else
		if(ICSTATE_OVERTIME==istate)
		{
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3)
			{
				iptparam->IcOverTimes=0;

				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM卡DES初始化超时", 19);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
				iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM卡DES初始化错误", 19);
			ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
			iptMainInterface(iptparam);
		}
		break;

	case 7:	
		//向PSAM发送DES CRYPT
		istate=PsamDESCrypt(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, iptparam->BindTime, iptparam->BindACTAppId, iptparam->ACTKeyIndex, iptparam->IcAppId, iptparam->RIDKeyIndex, iptparam->RIDCalKeyIndex, iptparam->PsamId, MboardID);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate)
		{
			iptparam->IcOverTimes=0;	
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
			{
				memcpy(iptparam->RIDMAC, &buffer[2], 4);	//RID绑定计算MAC

				iptparam->Step++;
			}
			else
			{
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=17;	memcpy(&dsp_buffer[3], "PSAM卡DES计算失败", 17);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
				iptMainInterface(iptparam);
			}
		}
		//操作失败则提示信息后退卡
		else
		if(ICSTATE_FAILED==istate)
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM卡DES计算失败", 17);
			ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
			iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else
		if(ICSTATE_OVERTIME==istate)
		{
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3)
			{
				iptparam->IcOverTimes=0;

				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM卡DES计算超时", 17);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
				iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM卡DES计算错误", 17);
			ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();
			iptMainInterface(iptparam);
		}
		break;

	case 8:
		//向RID发送APPEND LOG RECORD
		istate=ICAppendLog(iptparam->DEVIC, 0, buffer, 128, iptparam->BindTime, iptparam->BindACTAppId, iptparam->ACTKeyIndex, iptparam->IcAppId, iptparam->RIDKeyIndex, iptparam->RIDCalKeyIndex, iptparam->PsamId, MboardID, iptparam->RIDMAC);
		//操作成功则继续下一步
		if(ICSTATE_OK==istate)
		{	
			iptparam->BindTime[0]=iptparam->Time.century;						//绑定时间
			iptparam->BindTime[1]=iptparam->Time.year;		iptparam->BindTime[2]=iptparam->Time.month;				
			iptparam->BindTime[3]=iptparam->Time.date;		iptparam->BindTime[4]=iptparam->Time.hour;				
			iptparam->BindTime[5]=iptparam->Time.minute;	iptparam->BindTime[6]=iptparam->Time.second;				
			memcpy(iptparam->BindMboardId, MboardID, 8);						//绑定的芯片ID
			memcpy(iptparam->BindACTAppId, iptparam->ACTAppId, 10);	//绑定的ACT卡号
			memcpy(iptparam->BindRIDAppId, iptparam->IcAppId, 10);		//绑定的RID卡卡号

			//保存注册信息
			if(IPT_NOZZLE_1==iptparam->Id)
			{
				paramSetupWrite(IPT0_BIND_TIME, iptparam->BindTime, 7);
				paramSetupWrite(IPT0_BIND_MBOARD_ID, iptparam->BindMboardId, 8);
				paramSetupWrite(IPT0_BIND_ACT_APPID, iptparam->BindACTAppId, 10);
				paramSetupWrite(IPT0_BIND_RID_APPID, iptparam->BindRIDAppId, 10);
			}
			else
			{
				paramSetupWrite(IPT1_BIND_TIME, iptparam->BindTime, 7);
				paramSetupWrite(IPT1_BIND_MBOARD_ID, iptparam->BindMboardId, 8);
				paramSetupWrite(IPT1_BIND_ACT_APPID, iptparam->BindACTAppId, 10);
				paramSetupWrite(IPT1_BIND_RID_APPID, iptparam->BindRIDAppId, 10);
			}

			//组织注册信息
			memcpy(&iptparam->ErrInfo[0], "#*0011*#", 8);				//报文分类
			memcpy(&iptparam->ErrInfo[8], IPT_COMPANY_ID, 2);		//厂商编号
			memcpy(&iptparam->ErrInfo[10], PCD_VERSION_DSP, 4);	//软件版本
																											//时间
			iptparam->ErrInfo[14]=((iptparam->Time.century>>4)&0x0f)+0x30;
			iptparam->ErrInfo[15]=((iptparam->Time.century>>0)&0x0f)+0x30;
			iptparam->ErrInfo[16]=((iptparam->Time.year>>4)&0x0f)+0x30;
			iptparam->ErrInfo[17]=((iptparam->Time.year>>0)&0x0f)+0x30;
			iptparam->ErrInfo[18]=((iptparam->Time.month>>4)&0x0f)+0x30;
			iptparam->ErrInfo[19]=((iptparam->Time.month>>0)&0x0f)+0x30;
			iptparam->ErrInfo[20]=((iptparam->Time.date>>4)&0x0f)+0x30;
			iptparam->ErrInfo[21]=((iptparam->Time.date>>0)&0x0f)+0x30;
			iptparam->ErrInfo[22]=((iptparam->Time.hour>>4)&0x0f)+0x30;
			iptparam->ErrInfo[23]=((iptparam->Time.hour>>0)&0x0f)+0x30;
			iptparam->ErrInfo[24]=((iptparam->Time.minute>>4)&0x0f)+0x30;
			iptparam->ErrInfo[25]=((iptparam->Time.minute>>0)&0x0f)+0x30;
			iptparam->ErrInfo[26]=((iptparam->Time.second>>4)&0x0f)+0x30;
			iptparam->ErrInfo[27]=((iptparam->Time.second>>0)&0x0f)+0x30;
			for(i=0; i<8; i++)																	//计量芯片ID
			{																
				iptparam->ErrInfo[28+i*2+0]=((iptparam->BindMboardId[i]>>4)&0x0f)+0x30;
				iptparam->ErrInfo[28+i*2+1]=((iptparam->BindMboardId[i]>>0)&0x0f)+0x30;
			}
			memcpy(&iptparam->ErrInfo[44], "5000000000000000", 16);	//厂商自定义
			for(i=0; i<10; i++)																//PSAM卡号
			{																		
				iptparam->ErrInfo[60+i*2+0]=((iptparam->PsamId[i]>>4)&0x0f)+0x30;
				iptparam->ErrInfo[60+i*2+1]=((iptparam->PsamId[i]>>0)&0x0f)+0x30;
			}

			//提示注册成功，如果更新绑定记录失败则提示错误信息
			iptparam->IcOverTimes=0;
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
			{	
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "芯片注册成功", strlen("芯片注册成功"));			
			}
			else
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "  芯片注册成功  绑定记录更新失败", strlen("  芯片注册成功  绑定记录更新失败"));
			}
			ICShoot(iptparam->DEVIC);	
			IPT_DSP_WAIT();

			//转入错误信息计算TMAC过程
			iptPidSet(iptparam, IPT_PID_ERRINFO_TMAC);
		}
		//操作失败则提示信息后退卡
		else if(ICSTATE_FAILED==istate)
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "更新绑定记录失败", 16);
			ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();

			iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else
		if(ICSTATE_OVERTIME==istate)
		{
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3)
			{
				iptparam->IcOverTimes=0;

				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "更新绑定记录超时", 16);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();

				iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "更新绑定记录错误", 16);
			ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();

			iptMainInterface(iptparam);
		}
		#if 0

		//操作成功则继续下一步
		if(ICSTATE_OK==istate){
			
			iptparam->IcOverTimes=0;
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2)){
				
				iptparam->BindTime[0]=iptparam->Time.century;						//绑定时间
				iptparam->BindTime[1]=iptparam->Time.year;		iptparam->BindTime[2]=iptparam->Time.month;				
				iptparam->BindTime[3]=iptparam->Time.date;		iptparam->BindTime[4]=iptparam->Time.hour;				
				iptparam->BindTime[5]=iptparam->Time.minute;	iptparam->BindTime[6]=iptparam->Time.second;				
				memcpy(iptparam->BindMboardId, MboardID, 8);						//绑定的芯片ID
				memcpy(iptparam->BindACTAppId, iptparam->ACTAppId, 10);	//绑定的ACT卡号
				memcpy(iptparam->BindRIDAppId, iptparam->IcAppId, 10);		//绑定的RID卡卡号

				//保存注册信息
				if(IPT_NOZZLE_1==iptparam->Id)
				{
					paramSetupWrite(IPT0_BIND_TIME, iptparam->BindTime, 7);
					paramSetupWrite(IPT0_BIND_MBOARD_ID, iptparam->BindMboardId, 8);
					paramSetupWrite(IPT0_BIND_ACT_APPID, iptparam->BindACTAppId, 10);
					paramSetupWrite(IPT0_BIND_RID_APPID, iptparam->BindRIDAppId, 10);
				}
				else
				{
					paramSetupWrite(IPT1_BIND_TIME, iptparam->BindTime, 7);
					paramSetupWrite(IPT1_BIND_MBOARD_ID, iptparam->BindMboardId, 8);
					paramSetupWrite(IPT1_BIND_ACT_APPID, iptparam->BindACTAppId, 10);
					paramSetupWrite(IPT1_BIND_RID_APPID, iptparam->BindRIDAppId, 10);
				}
				
				//提示注册成功
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "芯片注册成功", 12);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();

				//组织注册信息
				memcpy(&iptparam->ErrInfo[0], "#*0011*#", 8);				//报文分类
				memcpy(&iptparam->ErrInfo[8], IPT_COMPANY_ID, 2);		//厂商编号
				memcpy(&iptparam->ErrInfo[10], PCD_VERSION_DSP, 4);	//软件版本
																											//时间
				iptparam->ErrInfo[14]=((iptparam->Time.century>>4)&0x0f)+0x30;
				iptparam->ErrInfo[15]=((iptparam->Time.century>>0)&0x0f)+0x30;
				iptparam->ErrInfo[16]=((iptparam->Time.year>>4)&0x0f)+0x30;
				iptparam->ErrInfo[17]=((iptparam->Time.year>>0)&0x0f)+0x30;
				iptparam->ErrInfo[18]=((iptparam->Time.month>>4)&0x0f)+0x30;
				iptparam->ErrInfo[19]=((iptparam->Time.month>>0)&0x0f)+0x30;
				iptparam->ErrInfo[20]=((iptparam->Time.date>>4)&0x0f)+0x30;
				iptparam->ErrInfo[21]=((iptparam->Time.date>>0)&0x0f)+0x30;
				iptparam->ErrInfo[22]=((iptparam->Time.hour>>4)&0x0f)+0x30;
				iptparam->ErrInfo[23]=((iptparam->Time.hour>>0)&0x0f)+0x30;
				iptparam->ErrInfo[24]=((iptparam->Time.minute>>4)&0x0f)+0x30;
				iptparam->ErrInfo[25]=((iptparam->Time.minute>>0)&0x0f)+0x30;
				iptparam->ErrInfo[26]=((iptparam->Time.second>>4)&0x0f)+0x30;
				iptparam->ErrInfo[27]=((iptparam->Time.second>>0)&0x0f)+0x30;
				for(i=0; i<8; i++){																//计量芯片ID

					iptparam->ErrInfo[28+i*2+0]=((iptparam->BindMboardId[i]>>4)&0x0f)+0x30;
					iptparam->ErrInfo[28+i*2+1]=((iptparam->BindMboardId[i]>>0)&0x0f)+0x30;
				}
				memcpy(&iptparam->ErrInfo[44], "5000000000000000", 16);	//厂商自定义
				for(i=0; i<10; i++){																		//PSAM卡号

					iptparam->ErrInfo[60+i*2+0]=((iptparam->PsamId[i]>>4)&0x0f)+0x30;
					iptparam->ErrInfo[60+i*2+1]=((iptparam->PsamId[i]>>0)&0x0f)+0x30;
				}
				//转入错误信息计算TMAC过程
				iptPidSet(iptparam, IPT_PID_ERRINFO_TMAC);
			}
			else{

				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=16;	memcpy(&dsp_buffer[3], "更新绑定记录失败", 16);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				IPT_DSP_WAIT();

				ICShoot(iptparam->DEVIC);	iptMainInterface(iptparam);
			}
		}
		//操作失败则提示信息后退卡
		else if(ICSTATE_FAILED==istate)
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "更新绑定记录失败", 16);
			ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();

			iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else
		if(ICSTATE_OVERTIME==istate)
		{
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3)
			{
				iptparam->IcOverTimes=0;

				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "更新绑定记录超时", 16);
				ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();

				iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "更新绑定记录错误", 16);
			ICShoot(iptparam->DEVIC);	IPT_DSP_WAIT();

			iptMainInterface(iptparam);
		}
	#endif
		break;
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptIcDebitStart
*Description		:非油消费加油卡支付流程
*Input				:None
*Output			:None
*Return				:None
*History			:2016-05-09,modified by syj  */

static void iptIcDebitStart(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	if(KB_BUTTON_CHG == iptparam->Button || KB_BUTTON_BACK == iptparam->Button)
	{
		iptPidSet(iptparam, IPT_PID_IC_BAL_READ);
		return;
	}

	return;
}


/*******************************************************************
*Name				:iptIcDebitStart
*Description		:非油消费加油卡支付流程
*Input				:None
*Output			:None
*Return				:None
*History			:2016-05-09,modified by syj  */

static void iptIcDebitDone(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	char tx_buffer[64] = {0};
	int tx_len = 0;

	int istate = 0;

	//放弃支付、返回支付失败
	if(KB_BUTTON_CHG == iptparam->Button || KB_BUTTON_BACK == iptparam->Button)
	{
		*(tx_buffer + 0) = 1;
		memcpy(tx_buffer + 1, "\x00\x00\x00\x00", 4);
		memcpy(tx_buffer + 5, iptparam->CardDebitData, 16);
		tx_len = 21;
		pcCardDebitResultUpload(iptparam->TabletPanel, iptparam->LogicNozzle, tx_buffer, tx_len);

		iptPidSet(iptparam, IPT_PID_IC_BAL_READ);
		return;
	}

	//确认支付，根据支付结果返回给平板
	if(KB_BUTTON_ACK == iptparam->Button)
	{
		*(tx_buffer + 0) = *(iptparam->CardDebitData + 16);
		*(tx_buffer + 1) = *(iptparam->CardDebitData + 17);
		*(tx_buffer + 2) = *(iptparam->CardDebitData + 18);
		istate = iptCardDebit(iptparam->Id, tx_buffer);
	
		if(0 == istate)	*(tx_buffer + 0) = 0;
		else					*(tx_buffer + 0) = 1;
		memcpy(tx_buffer + 1, "\x00\x00\x00\x01", 4);
		memcpy(tx_buffer + 5, iptparam->CardDebitData, 16);
		tx_len = 21;
		pcCardDebitResultUpload(iptparam->TabletPanel, iptparam->LogicNozzle, tx_buffer, tx_len);

		if(0 == istate)	dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "支付成功", strlen("支付成功"));
		else					dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "支付失败", strlen("支付失败"));
		IPT_DSP_WAIT();

		iptPidSet(iptparam, IPT_PID_IC_BAL_READ);
		return;
	}

	return;
}


/*******************************************************************
*Name				:iptUnselfPreset
*Description		:非卡机联动加油预置界面
*Input				:None
*Output			:None
*Return				:None
*History			:2014-04-17,modified by syj  */

static void iptUnselfPreset(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned int data=0;
	unsigned char dsp_buffer[64]={0}, dsp_len=0, button=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0==button)	button='0';
	case KB_BUTTON_1:
		if(0==button)	button='1';
	case KB_BUTTON_2:
		if(0==button)	button='2';
	case KB_BUTTON_3:
		if(0==button)	button='3';
	case KB_BUTTON_4:
		if(0==button)	button='4';
	case KB_BUTTON_5:
		if(0==button)	button='5';
	case KB_BUTTON_6:
		if(0==button)	button='6';
	case KB_BUTTON_7:
		if(0==button)	button='7';
	case KB_BUTTON_8:
		if(0==button)	button='8';
	case KB_BUTTON_9:
		if(0==button)	button='9';
	case KB_BUTTON_CZ:
		if(0==button)	button='.';

		//按小数点记录小数点
		if('.'==button){
			
			iptparam->Point='.';
		}
		//前一刻无小数点按键操作，记录按键值为整数
		else if(0==iptparam->Point){
			
			iptparam->IntegerBuffer[0]=iptparam->IntegerBuffer[1];	iptparam->IntegerBuffer[1]=iptparam->IntegerBuffer[2];
			iptparam->IntegerBuffer[2]=iptparam->IntegerBuffer[3];	iptparam->IntegerBuffer[3]=iptparam->IntegerBuffer[4];	
			iptparam->IntegerBuffer[4]=iptparam->IntegerBuffer[5];	iptparam->IntegerBuffer[5]=button;
		}
		//前一刻有小数点按键操作，记录按键值为小数
		else if(0!=iptparam->Point && iptparam->DecimalLen<2){
			
			iptparam->DecimalBuffer[iptparam->DecimalLen++]=button;	
		}

		//预置方式默认为金额预置
		if(IPT_PRESET_NO==iptparam->PresetMode)	iptparam->PresetMode=IPT_PRESET_MONEY;

		//计算预置值
		data=(iptparam->IntegerBuffer[0]&0x0f)*10000000+(iptparam->IntegerBuffer[1]&0x0f)*1000000+\
			(iptparam->IntegerBuffer[2]&0x0f)*100000+(iptparam->IntegerBuffer[3]&0x0f)*10000+\
			(iptparam->IntegerBuffer[4]&0x0f)*1000+(iptparam->IntegerBuffer[5]&0x0f)*100+\
			(iptparam->DecimalBuffer[0]&0x0f)*10+(iptparam->DecimalBuffer[1]&0x0f)*1;

		//显示预置界面
		dsp_buffer[0]=(char)(data>>24);	dsp_buffer[1]=(char)(data>>16);
		dsp_buffer[2]=(char)(data>>8);	dsp_buffer[3]=(char)(data>>0);
		if(IPT_PRESET_VOLUME==iptparam->PresetMode)	dsp_buffer[4]=1;
		else																			dsp_buffer[4]=0;
		dsp_len=5;
		dsp(iptparam->DEVDsp, DSP_UNSELF_PRESET, dsp_buffer, dsp_len);
		break;

	case KB_BUTTON_MON:
	case KB_BUTTON_VOL:
		//计算预置值
		data=(iptparam->IntegerBuffer[0]&0x0f)*10000000+(iptparam->IntegerBuffer[1]&0x0f)*1000000+\
			(iptparam->IntegerBuffer[2]&0x0f)*100000+(iptparam->IntegerBuffer[3]&0x0f)*10000+\
			(iptparam->IntegerBuffer[4]&0x0f)*1000+(iptparam->IntegerBuffer[5]&0x0f)*100+\
			(iptparam->DecimalBuffer[0]&0x0f)*10+(iptparam->DecimalBuffer[1]&0x0f)*1;

		//更改预置方式
		if(KB_BUTTON_MON==iptparam->Button)	iptparam->PresetMode=IPT_PRESET_MONEY;
		else																iptparam->PresetMode=IPT_PRESET_VOLUME;
		dsp_buffer[0]=(char)(data>>24);	dsp_buffer[1]=(char)(data>>16);
		dsp_buffer[2]=(char)(data>>8);	dsp_buffer[3]=(char)(data>>0);
		if(IPT_PRESET_VOLUME==iptparam->PresetMode)	dsp_buffer[4]=1;
		else																			dsp_buffer[4]=0;
		dsp_len=5;
		dsp(iptparam->DEVDsp, DSP_UNSELF_PRESET, dsp_buffer, dsp_len);
		break;

	case KB_BUTTON_CHG:
		//计算预置值
		data=(iptparam->IntegerBuffer[0]&0x0f)*10000000+(iptparam->IntegerBuffer[1]&0x0f)*1000000+\
			(iptparam->IntegerBuffer[2]&0x0f)*100000+(iptparam->IntegerBuffer[3]&0x0f)*10000+\
			(iptparam->IntegerBuffer[4]&0x0f)*1000+(iptparam->IntegerBuffer[5]&0x0f)*100+\
			(iptparam->DecimalBuffer[0]&0x0f)*10+(iptparam->DecimalBuffer[1]&0x0f)*1;

		//清空预置数据
		memset(iptparam->IntegerBuffer, 0, sizeof(iptparam->IntegerBuffer));		iptparam->IntegerLen=0;
		iptparam->Point=0;
		memset(iptparam->DecimalBuffer, 0, sizeof(iptparam->DecimalBuffer));	iptparam->DecimalLen=0;
		iptparam->PresetMode=IPT_PRESET_NO;

		//如果当前预置量为0则返回待机界面，否则清空预置量
		if(0==data)
		{
			iptMainInterface(iptparam);
		}
		else
		{
			dsp_buffer[0]=(char)(0>>24);	dsp_buffer[1]=(char)(0>>16);
			dsp_buffer[2]=(char)(0>>8);	dsp_buffer[3]=(char)(0>>0);
			if(IPT_PRESET_VOLUME==iptparam->PresetMode)	dsp_buffer[4]=1;
			else																			dsp_buffer[4]=0;
			dsp_len=5;
			dsp(iptparam->DEVDsp, DSP_UNSELF_PRESET, dsp_buffer, dsp_len);
		}
		break;

	case KB_BUTTON_BACK:
		//退卡键清空预置数据返回待机界面
		memset(iptparam->IntegerBuffer, 0, sizeof(iptparam->IntegerBuffer));		iptparam->IntegerLen=0;
		iptparam->Point=0;
		memset(iptparam->DecimalBuffer, 0, sizeof(iptparam->DecimalBuffer));	iptparam->DecimalLen=0;
		iptparam->PresetMode=IPT_PRESET_NO;

		iptMainInterface(iptparam);
		break;

	default:
		break;
	}

	//提枪，转入加油数据合法性检查过程
	if((1 == iptIsBig260(iptparam->Id) && KB_BUTTON_DOWN == iptparam->Button)||\
		(1 != iptIsBig260(iptparam->Id) && IPT_GUN_PUTUP == iptparam->GunState && 0 != iptparam->GunStateChg))
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "加油启动中...", 13);
		iptPidSet(iptparam, IPT_PID_UNSELF_CHECK);
		return;
	}

	return;
}


/*******************************************************************
*Name				:iptUnselfCheck
*Description		:非卡机联动加油启动数据合法性检查
*Input				:None
*Output			:None
*Return				:None
*History			:2014-04-17,modified by syj  */

static void iptUnselfCheck(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char dsp_buffer[64]={0}, tmp_buffer[32]={0};
	unsigned int data=0, dsp_len=0;
	unsigned long long volume_sum=0, money_sum=0;

	//printf("iptparam->FuelUnloadNumber = %d\n",iptparam->FuelUnloadNumber);
	
	//iptparam->FuelUnloadNumber = 10;  //fj:20171012

	//判断账单是否溢出
	if(iptparam->FuelUnloadNumber>=IPT_BILLUNLOAD_MAX)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "账单溢出", 8);
		IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "加油启动失败，账单溢出!");
		iptMainInterface(iptparam);
		return;
	}
	
	//判断获取单价结果,fj:
	if(0!=jlPriceRead(iptparam->JlNozzle, &iptparam->OilPrice))
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "获取单价失败", 16);
		IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "非卡加油启动失败，获取计量单价失败!");
		iptMainInterface(iptparam);
		return;
	}

	if(iptparam->JlErr_BianJia!=0)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "变价失败", 8);
		IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "加油启动失败，变价失败");
		iptMainInterface(iptparam);
		return;
	}

	//判断单价合法性
	if((iptparam->OilPrice<IPT_PRICE_MIN)||(iptparam->OilPrice>IPT_PRICE_MAX))
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "单价非法", 16);
		IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "非卡加油启动失败，单价非法!");
		iptMainInterface(iptparam);
		return;
	}

	//
	//计算预置量
	//预置量为零或非预置即默认为任意加油；
	//定升数加油，通过升数计算预置金额；
	//定金额加油，通过金额计算预置升数；
	//任意加油，以最大允许金额为预置金额，并计算预置升数；
	
	data=(iptparam->IntegerBuffer[0]&0x0f)*10000000+(iptparam->IntegerBuffer[1]&0x0f)*1000000+\
			(iptparam->IntegerBuffer[2]&0x0f)*100000+(iptparam->IntegerBuffer[3]&0x0f)*10000+\
			(iptparam->IntegerBuffer[4]&0x0f)*1000+(iptparam->IntegerBuffer[5]&0x0f)*100+\
			(iptparam->DecimalBuffer[0]&0x0f)*10+(iptparam->DecimalBuffer[1]&0x0f)*1;
	if((0==data)||((IPT_PRESET_VOLUME!=iptparam->PresetMode)&&(IPT_PRESET_MONEY!=iptparam->PresetMode)))
	{
		iptparam->PresetMoney=JL_MONEY_MAX;	iptparam->PresetMode=0;
		if((iptparam->PresetMoney*1000/iptparam->OilPrice%10)<IPT_ROUNDING)	iptparam->PresetVolume=iptparam->PresetMoney*100/iptparam->OilPrice;
		else																														iptparam->PresetVolume=iptparam->PresetMoney*100/iptparam->OilPrice+1;
	}
	else
	if(IPT_PRESET_VOLUME==iptparam->PresetMode)
	{
		iptparam->PresetVolume=data;
		if((iptparam->PresetVolume*iptparam->OilPrice/10%10)<IPT_ROUNDING)	iptparam->PresetMoney=iptparam->PresetVolume*iptparam->OilPrice/100;
		else																													iptparam->PresetMoney=iptparam->PresetVolume*iptparam->OilPrice/100+1;
	}
	else
	if(IPT_PRESET_MONEY==iptparam->PresetMode)
	{
		iptparam->PresetMoney=data;
		if((iptparam->PresetMoney*1000/iptparam->OilPrice%10)<IPT_ROUNDING)	iptparam->PresetVolume=iptparam->PresetMoney*100/iptparam->OilPrice;
		else																														iptparam->PresetVolume=iptparam->PresetMoney*100/iptparam->OilPrice+1;
	}

	//判断销售锁定
	if(IPT_SELL_UNLOCK!=iptparam->SellLock)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "加油启动锁定", 12);
		IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "非卡加油启动失败，加油启动锁定!");
		iptMainInterface(iptparam);
		return;
	}

	//判断夜间锁定
	if(IPT_NIGHT_UNLOCK!=iptparam->NightLock)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "夜间锁定", 8);
		IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "非卡加油启动失败，夜间锁定!");
		iptMainInterface(iptparam);
		return;
	}

	//判断钥匙状态
	if(KB_KEYLOCK_OIL!=iptparam->KeyLock)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "请把钥匙打到加油位置", strlen("请把钥匙打到加油位置"));
		IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "非卡加油启动失败，钥匙在设置位置!");
		iptMainInterface(iptparam);
		return;
	}

	//判断时间合法性
	tmp_buffer[0]=iptparam->Time.century;	tmp_buffer[1]=iptparam->Time.year;	tmp_buffer[2]=iptparam->Time.month;	tmp_buffer[3]=iptparam->Time.date;
	tmp_buffer[4]=iptparam->Time.hour;tmp_buffer[5]=iptparam->Time.minute;tmp_buffer[6]=iptparam->Time.second;
	if(0!=timeVerification(tmp_buffer, 7))
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "油机时间非法", 12);
		IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "非卡加油启动失败，油机时间非法!");
		iptMainInterface(iptparam);
		return;
	}

	//判断物理枪号合法性
	if((iptparam->PhysicalNozzle<1)||(iptparam->PhysicalNozzle>6))
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "物理枪号非法", 12);
		IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "非卡加油启动失败，物理枪号非法!");
		iptMainInterface(iptparam);
		return;
	}

	//判断PCD连接状态
	if(1!=iptparam->PcdState)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "与PCD连接断开", 13);
		IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "非卡加油启动失败，与PCD连接断开!");
		iptMainInterface(iptparam);
		return;
	}

	//判断PCD异常状态
	if(0!=iptparam->PcdErrNO)
	{
		memcpy(&dsp_buffer[0], "PCD状态异常", 11);
		dsp_buffer[11]=(iptparam->PcdErrNO>>4)&0x0f+0x30;
		dsp_buffer[12]=(iptparam->PcdErrNO>>0)&0x0f+0x30;
		dsp_len=13;
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);
		IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "非卡加油启动失败，PCD状态异常!");
		iptMainInterface(iptparam);
		return;
	}

	//判断预置量是否过小，不小于1升
	if((iptparam->PresetMoney<iptparam->OilPrice)||(iptparam->PresetMoney<IPT_MONEY_MIN)||(iptparam->PresetVolume<IPT_VOLUME_MIN))
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "预置量太小", 10);
		IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "非卡加油启动失败，预置量太小!");
		iptMainInterface(iptparam);
		return;
	}

	//判断预置量是否过大
	if((iptparam->PresetMoney>JL_MONEY_MAX)||(iptparam->PresetVolume>JL_VOLUME_MAX))
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "预置量太大", 10);
		IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "非卡加油启动失败，预置量太大!");
		iptMainInterface(iptparam);
		return;
	}

	//记录加油时间，初始化本次加油数据
	iptparam->OilTime[0]=iptparam->Time.century;
	iptparam->OilTime[1]=iptparam->Time.year;
	iptparam->OilTime[2]=iptparam->Time.month;	
	iptparam->OilTime[3]=iptparam->Time.date;
	iptparam->OilTime[4]=iptparam->Time.hour;	
	iptparam->OilTime[5]=iptparam->Time.minute;
	iptparam->OilTime[6]=iptparam->Time.second;
	iptparam->OilMoney=0;	
	iptparam->OilVolume=0;		
	iptparam->OilPrice=iptparam->OilPrice;
	//jlSumRead(iptparam->JlNozzle, &volume_sum, &money_sum); //fj:
	GetjlSumRead(iptparam->JlNozzle,&volume_sum,&money_sum);  //fj:20171023
	iptparam->SumMoney=money_sum;
	iptparam->SumVolume=volume_sum;
	iptparam->OilRound=0;

	//转入加油启动操作
	iptPidSet(iptparam, IPT_PID_UNSELF_START);

	return;
}


/*******************************************************************
*Name				:iptUnselfOilStart
*Description		:非卡机联动模式加油启动
*Input				:None
*Output			:None
*Return				:None
*History			:2014-04-17,modified by syj  */

static void iptUnselfOilStart(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	int istate=0, i=0, crc_return=0;
	unsigned char dsp_buffer[64]={0}, dsp_len=0;

	//for(i=0; i<2; i++)
	for(i = 0; i < 1; i++)
	{
		//向计量申请加油，预置升数以升数为预置量，否则以金额为预置量
		if(IPT_PRESET_VOLUME==iptparam->PresetMode)
		{
			printf("read preset volum add oil,volume = %d,Price = %d\n",iptparam->PresetVolume,iptparam->OilPrice);
			istate=jlOilStart(iptparam->JlNozzle, iptparam->PresetVolume, iptparam->OilPrice, iptparam->PresetMode);
		}
		else
		{
		    printf("read preset money add oil,money = %d,Price = %d\n",iptparam->PresetMoney,iptparam->OilPrice);
			istate=jlOilStart(iptparam->JlNozzle, iptparam->PresetMoney, iptparam->OilPrice, iptparam->PresetMode);
		}

		//计量启动成功不再申请
		if(0==istate)	break;

		//启动失败，下次启动之前先做延时释放
		if(0!=istate)	//usleep(1000);
		{
			usleep(10000);
		}
	}

	//计量申请失败
	if(0!=istate)
	{
		memset(dsp_buffer, 0, sizeof(dsp_buffer));
		memcpy(dsp_buffer, "计量启动失败    ", 16);
		//i=((char)(istate>>4)&0x0f)*10+((char)(istate>>0)&0x0f)*1;
		//fj:
		//memcpy(dsp_buffer+strlen(dsp_buffer), jlStartFiledReson[i], strlen(jlStartFiledReson[i]));
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, strlen(dsp_buffer));
		IPT_DSP_WAIT();

       jljOilErrLogWrite(iptparam->Id, "非卡加油启动失败，%s!", dsp_buffer);

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "加油结束中...", 13);
		iptPidSet(iptparam, IPT_PID_UNSELF_FINISH);
		return;
	}

	//参数根据状态初始化
	iptparam->OilState=IPT_OIL_FUELLING;

	//清空并保存当次加油数据
	iptparam->MoneyUnself=0;	iptparam->VolumeUnself=0;	iptparam->OilStateUnself=1;
	memset(dsp_buffer, 0, 32);
	dsp_buffer[0]=(char)(iptparam->MoneyUnself>>16);
	dsp_buffer[1]=(char)(iptparam->MoneyUnself>>8);		dsp_buffer[2]=(char)(iptparam->MoneyUnself>>0);
	dsp_buffer[3]=(char)(iptparam->VolumeUnself>>16);
	dsp_buffer[4]=(char)(iptparam->VolumeUnself>>8);		dsp_buffer[5]=(char)(iptparam->VolumeUnself>>0);
	dsp_buffer[6]=iptparam->OilStateUnself;
	dsp_buffer[7]=(char)(iptparam->MoneyUnselfSum>>16);
	dsp_buffer[8]=(char)(iptparam->MoneyUnselfSum>>8);			dsp_buffer[9]=(char)(iptparam->MoneyUnselfSum>>0);
	dsp_buffer[10]=(char)(iptparam->VolumeUnselfSum>>16);
	dsp_buffer[11]=(char)(iptparam->VolumeUnselfSum>>8);		dsp_buffer[12]=(char)(iptparam->VolumeUnselfSum>>0);
	dsp_buffer[13]=iptparam->OilOverTimes;
	crc_return=crc16Get(dsp_buffer, 30);
	dsp_buffer[30]=(char)(crc_return>>8);	dsp_buffer[31]=(char)(crc_return>>0);
	framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_UNSELF, dsp_buffer, 32);
	framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_UNSELF2, dsp_buffer, 32);

	//显示加油中界面
	dsp_buffer[0]=(char)(iptparam->MoneyUnself>>24);	dsp_buffer[1]=(char)(iptparam->MoneyUnself>>16);
	dsp_buffer[2]=(char)(iptparam->MoneyUnself>>8);	dsp_buffer[3]=(char)(iptparam->MoneyUnself>>0);
	dsp_len=4;
	dsp(iptparam->DEVDsp, DSP_UNSELF_OILLING, dsp_buffer, dsp_len);

	//转入加油中
	iptPidSet(iptparam, IPT_PID_UNSELF_OILLING);

	return;
}


/*******************************************************************
*Name				:iptUnselfOilling
*Description		:非卡机联动模式加油中
*Input				:None
*Output			:None
*Return				:None
*History			:2014-04-17,modified by syj  */

static void iptUnselfOilling(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned int money=0, volume=0, price=0, crc_return=0;
	unsigned char dsp_buffer[64]={0}, dsp_len=0, jl_stop_no=0;
	int istate=0;
	int i = 0;

	//读取实时加油量,fj:
	istate=jlOilRead(iptparam->JlNozzle, &money, &volume, &price, &jl_stop_no);
	iptparam->MoneyUnself=money;
	iptparam->VolumeUnself=volume;	
	//printf("Unself:  OilDspTimer = %d,istate=%d,volume=%d,iptparam->OilVolume=%d\n",iptparam->OilDspTimer,istate,volume,iptparam->OilVolume);
	
	//if(iptparam->OilDspTimer>=ONE_SECOND)
	if(iptparam->OilDspTimer >= 500)
	{
		//printf("istate=%d,volume=%d,iptparam->OilVolume=%d\n",istate,volume,iptparam->OilVolume);
	    //printf("Unself:  OilDspTimer = %d,istate=%d,volume=%d,iptparam->OilVolume=%d\n",iptparam->OilDspTimer,istate,volume,iptparam->OilVolume);
		//PrintTime("intev time sec=%d,  ","milsec=%d\n");
		//加油数据改变时进行存储
		if(0==istate && volume!=iptparam->OilVolume)
		{
			iptparam->VolumeUnself=volume;		iptparam->MoneyUnself=money;

			memset(dsp_buffer, 0, 32);
			dsp_buffer[0]=(char)(iptparam->MoneyUnself>>16);
			dsp_buffer[1]=(char)(iptparam->MoneyUnself>>8);		dsp_buffer[2]=(char)(iptparam->MoneyUnself>>0);
			dsp_buffer[3]=(char)(iptparam->VolumeUnself>>16);
			dsp_buffer[4]=(char)(iptparam->VolumeUnself>>8);		dsp_buffer[5]=(char)(iptparam->VolumeUnself>>0);
			dsp_buffer[6]=iptparam->OilStateUnself;
			dsp_buffer[7]=(char)(iptparam->MoneyUnselfSum>>16);
			dsp_buffer[8]=(char)(iptparam->MoneyUnselfSum>>8);			dsp_buffer[9]=(char)(iptparam->MoneyUnselfSum>>0);
			dsp_buffer[10]=(char)(iptparam->VolumeUnselfSum>>16);
			dsp_buffer[11]=(char)(iptparam->VolumeUnselfSum>>8);		dsp_buffer[12]=(char)(iptparam->VolumeUnselfSum>>0);
			dsp_buffer[13]=iptparam->OilOverTimes;
			crc_return=crc16Get(dsp_buffer, 30);
			dsp_buffer[30]=(char)(crc_return>>8);	dsp_buffer[31]=(char)(crc_return>>0);
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_UNSELF, dsp_buffer, 32);
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_UNSELF2, dsp_buffer, 32);
		}

		//送显
		dsp_buffer[0]=(char)(iptparam->MoneyUnself>>24);
		dsp_buffer[1]=(char)(iptparam->MoneyUnself>>16);
		dsp_buffer[2]=(char)(iptparam->MoneyUnself>>8);	
		dsp_buffer[3]=(char)(iptparam->MoneyUnself>>0);
		dsp_len=4;
	    //PrintTime("start---real money show: sec = %d,  ","milsec = %d\n");
		dsp(iptparam->DEVDsp, DSP_UNSELF_OILLING, dsp_buffer, dsp_len);
		//PrintTime("---real money show: sec = %d,  ","milsec = %d\n");

		iptparam->OilDspTimer=0;
	}

	//凑整，默认金额凑整
	if(KB_BUTTON_CZ == iptparam->Button)
	{
        printf("exe rounding: \n"); //fj:
		if(0==jlOilCZ(iptparam->JlNozzle, 0))
		{
			iptparam->OilRound=1;
		}
	}

	//挂枪，计量状态异常(非达到预置量)，油机掉电则结束加油状态,fj:
	if((0 == iptIsBig260(iptparam->Id) &&	IPT_GUN_PUTDOWN==iptparam->GunState)||\
		(1 == iptIsBig260(iptparam->Id) &&	KB_BUTTON_ACK==iptparam->Button)||\
		(0==istate && 0!=jl_stop_no && 2!=jl_stop_no)	||\
		POWER_STATE_OK!=powerStateRead())
	{
		if(IPT_GUN_PUTDOWN==iptparam->GunState)	
		{
			jljRunLog("[主板号=%d][面板号=%d]非卡加油结束!挂枪!\n", pcdMboardIDRead(), iptparam->Id);
		}
		if(0==istate && 0!=jl_stop_no && 2!=jl_stop_no)	
		{
			i=((char)(jl_stop_no>>4)&0x0f)*10+((char)(jl_stop_no>>0)&0x0f)*1;
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, (unsigned char *)jlStopReason[i], strlen(jlStopReason[i]));
			IPT_DSP_WAIT();
			jljOilErrLogWrite(iptparam->Id, "非卡加油结束!计量停止加油[%s]!", jlStopReason[jl_stop_no]);
		}
		if(POWER_STATE_OK!=powerStateRead())	
		{
			jljOilErrLogWrite(iptparam->Id, "非卡加油结束!油机掉电!");
		}

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "加油结束中...", 13);
		iptPidSet(iptparam, IPT_PID_UNSELF_FINISH);
		return;
	}

	return;
}


/*******************************************************************
*Name				:iptUnselfOilFinish
*Description		:非卡机联动模式加油结束中
*Input				:None
*Output			:None
*Return				:None
*History			:2014-04-17,modified by syj  */

static void iptUnselfOilFinish(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned int money=0, volume=0, price=0, crc_return=0;
	unsigned long long money_sum=0, volume_sum=0;
	unsigned char stop_no=0, dsp_buffer[64]={0};
	int istate=0;
	unsigned int self_sum_price=0;//用于计算非卡账单

	//printf("iptUnselfOilFinish,jlOilFinish\n");

    //fj:
	istate=jlOilFinish(iptparam->JlNozzle, &money_sum, &volume_sum, &money, &volume, &price, &stop_no);

	iptAbnormalStopHandle(iptparam,stop_no,money);

	if(0==istate)
	{
		//判断如果本次加油数据与累计加油数据超过账单中3字节存储空间则以先前累计数据产生一笔非卡账单
//		if(iptparam->MoneyUnselfSum+money>=0xffffffff ||iptparam->VolumeUnselfSum+volume>=0xffffff)
		if(iptparam->MoneyUnselfSum+money>=0xffffff ||iptparam->VolumeUnselfSum+volume>=0xffffff)
		{
			//产生非卡加油账单
			//待填充:POS_TTC
			memcpy(&iptparam->OilBill[IPT_OFFSET_TTC], "\x00\x00\x00\x00", 4);

			//待填充:交易类型设为无卡错，后台/本地黑白名单，扣款签名无效，逃卡
			iptparam->OilBill[IPT_OFFSET_T_TYPE]=(0<<7)|(0<<6)|(0<<4)|(7<<0);

			//已完成:交易日期及时间
			iptparam->OilTime[0]=iptparam->Time.century;	iptparam->OilTime[1]=iptparam->Time.year;
			iptparam->OilTime[2]=iptparam->Time.month;		iptparam->OilTime[3]=iptparam->Time.date;
			iptparam->OilTime[4]=iptparam->Time.hour;		iptparam->OilTime[5]=iptparam->Time.minute;
			iptparam->OilTime[6]=iptparam->Time.second;
			memcpy(&iptparam->OilBill[IPT_OFFSET_TIME], iptparam->OilTime, 7);

			//已完成:卡应用号
			memcpy(&iptparam->OilBill[IPT_OFFSET_ASN], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 10);

			//待填充:余额(扣前)，交易完成后填扣后余额
			memcpy(&iptparam->OilBill[IPT_OFFSET_BALANCE], "\x00\x00\x00\x00", 4);

			//待填充:数额，交易完成后填实际数额
			memcpy(&iptparam->OilBill[IPT_OFFSET_AMN], "\x00\x00\x00", 3);

			//已完成:卡交易序号
			memcpy(&iptparam->OilBill[IPT_OFFSET_CTC], "\x00\x00", 2);

			//待填充:电子签名，加油/补扣/补充时未TAC，逃卡时为GTAC
			memcpy(&iptparam->OilBill[IPT_OFFSET_TAC], "\x00\x00\x00\x00", 4);

			//待填充:解灰认证码4bytes，加油完成，PSAM计算GMAC后添加
			memcpy(&iptparam->OilBill[IPT_OFFSET_GMAC], "\x00\x00\x00\x00", 4);

			//待填充:PSAM会所签名4bytes，加油完成，PSAM计算GMAC后添加
			memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TAC], "\x00\x00\x00\x00", 4);

			//已完成:PSAM应用号10bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_ASN], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 10);

			//已完成:PSAM编号6bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_TID], "\x00\x00\x00\x00\x00\x00", 6);
			
			//已完成:PSAM终端交易序号4bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TTC], "\x00\x00\x00\x00", 4);

			//已完成:扣款来源1byte
			iptparam->OilBill[IPT_OFFSET_DS]=0;
			
			//已完成:结算单位/方式1byte
			iptparam->OilBill[IPT_OFFSET_UNIT]=0;
			
			//已完成:卡类1byte
			iptparam->OilBill[IPT_OFFSET_C_TYPE]=0;

			//已完成:卡版本1byte，b7~b4卡密钥索引号；b3~b0卡密钥版本号
			iptparam->OilBill[IPT_OFFSET_VER]=0;

			//已完成:枪号1byte
			iptparam->OilBill[IPT_OFFSET_NZN]=iptparam->LogicNozzle;
			
			//已完成:油品代码2bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_G_CODE], iptparam->OilCode, 2);

			//升数3bytes，交易完成后填实际升数
			dsp_buffer[0]=(char)(iptparam->VolumeUnselfSum>>16);	
			dsp_buffer[1]=(char)(iptparam->VolumeUnselfSum>>8);
			dsp_buffer[2]=(char)(iptparam->VolumeUnselfSum>>0);
			memcpy(&iptparam->OilBill[IPT_OFFSET_VOL], dsp_buffer, 3);

			//已完成:成交价格2bytes，根据累计金额及油量计算
			if((iptparam->MoneyUnselfSum*1000/iptparam->VolumeUnselfSum%10)<IPT_ROUNDING)	
				self_sum_price=iptparam->MoneyUnselfSum*100/iptparam->VolumeUnselfSum;
			else																		
				self_sum_price=iptparam->MoneyUnselfSum*100/iptparam->VolumeUnselfSum+1;
			iptparam->OilBill[IPT_OFFSET_PRC+0]=(char)(self_sum_price>>8);
			iptparam->OilBill[IPT_OFFSET_PRC+1]=(char)(self_sum_price>>0);

			//已完成:员工号1byte
			iptparam->OilBill[IPT_OFFSET_EMP]=iptparam->EMP;

			//已完成:升累计4bytes，交易完成后填实际总累(当前总累-本次加油升数)
			iptparam->OilBill[IPT_OFFSET_V_TOT+0]=(char)((volume_sum-volume)>>24);
			iptparam->OilBill[IPT_OFFSET_V_TOT+1]=(char)((volume_sum-volume)>>16);
			iptparam->OilBill[IPT_OFFSET_V_TOT+2]=(char)((volume_sum-volume)>>8);	
			iptparam->OilBill[IPT_OFFSET_V_TOT+3]=(char)((volume_sum-volume)>>0);

			//已完成:备用部分11bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_RFU], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 11);

			//待填充:T-MAC	4bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], "\x00\x00\x00\x00", 4);
					
			//已完成:物理枪号PhysicsGunId
			iptparam->OilBill[IPT_OFFSET_PHYGUN]=iptparam->PhysicalNozzle;

			//已完成:计量停机原因
			iptparam->OilBill[IPT_OFFSET_STOPNO]=0;

			//已完成:扣前余额
			memcpy(&iptparam->OilBill[IPT_OFFSET_BEFOR_BAL], "\x00\x00\x00\x00", 4);

			//账单状态:0=正常；1=未完成
			iptparam->OilBill[IPT_OFFSET_ZD_STATE]=1;

			//计量设备ID
			iptparam->OilBill[IPT_OFFSET_JLNOZZLE]=iptparam->JlNozzle;

			//计算账单校验值
			iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

			//保存账单及备份
			istate=framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
			istate=framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

			//提请保存账单
			iptparam->OilBillSave=1;
            framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_BILL_FLAG,&iptparam->OilBillSave , 1);


			//清除非卡加油累计
			iptparam->MoneyUnselfSum=0;	iptparam->VolumeUnselfSum=0;
		}

		//本次非卡加油数据
		iptparam->SumMoney=money_sum;	iptparam->SumVolume=volume_sum;
		iptparam->MoneyUnself=money;	iptparam->VolumeUnself=volume;

#if 0
		//计算非卡加油累计
		iptparam->MoneyUnselfSum+=iptparam->OilMoney;	iptparam->VolumeUnselfSum+=iptparam->OilVolume;
		memset(dsp_buffer, 0, 32);
		dsp_buffer[0]=(char)(iptparam->OilMoney>>24);	dsp_buffer[1]=(char)(iptparam->OilMoney>>16);
		dsp_buffer[2]=(char)(iptparam->OilMoney>>8);		dsp_buffer[3]=(char)(iptparam->OilMoney>>0);
		dsp_buffer[4]=(char)(iptparam->OilVolume>>24);	dsp_buffer[5]=(char)(iptparam->OilVolume>>16);
		dsp_buffer[6]=(char)(iptparam->OilVolume>>8);	dsp_buffer[7]=(char)(iptparam->OilVolume>>0);
		dsp_buffer[8]=iptparam->JlStopNO;
		dsp_buffer[9]=(char)(iptparam->MoneyUnselfSum>>16);
		dsp_buffer[10]=(char)(iptparam->MoneyUnselfSum>>8);		dsp_buffer[11]=(char)(iptparam->MoneyUnselfSum>>0);
		dsp_buffer[12]=(char)(iptparam->VolumeUnselfSum>>16);
		dsp_buffer[13]=(char)(iptparam->VolumeUnselfSum>>8);		dsp_buffer[14]=(char)(iptparam->VolumeUnselfSum>>0);
		crc_return=crc16Get(dsp_buffer, 30);
		dsp_buffer[30]=(char)(crc_return>>8);	dsp_buffer[31]=(char)(crc_return>>0);
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_UNSELF, dsp_buffer, 32);
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_UNSELF2, dsp_buffer, 32);
#endif

		//非卡加油状态设为空闲
		iptparam->OilStateUnself=0;

		//计算非卡累计数据
		iptparam->MoneyUnselfSum+=iptparam->MoneyUnself;	iptparam->VolumeUnselfSum+=iptparam->VolumeUnself;

		//保存数据
		memset(dsp_buffer, 0, 32);
		dsp_buffer[0]=(char)(iptparam->MoneyUnself>>16);
		dsp_buffer[1]=(char)(iptparam->MoneyUnself>>8);		dsp_buffer[2]=(char)(iptparam->MoneyUnself>>0);
		dsp_buffer[3]=(char)(iptparam->VolumeUnself>>16);
		dsp_buffer[4]=(char)(iptparam->VolumeUnself>>8);		dsp_buffer[5]=(char)(iptparam->VolumeUnself>>0);
		dsp_buffer[6]=iptparam->OilStateUnself;
		dsp_buffer[7]=(char)(iptparam->MoneyUnselfSum>>16);
		dsp_buffer[8]=(char)(iptparam->MoneyUnselfSum>>8);			dsp_buffer[9]=(char)(iptparam->MoneyUnselfSum>>0);
		dsp_buffer[10]=(char)(iptparam->VolumeUnselfSum>>16);
		dsp_buffer[11]=(char)(iptparam->VolumeUnselfSum>>8);		dsp_buffer[12]=(char)(iptparam->VolumeUnselfSum>>0);
		dsp_buffer[13]=iptparam->OilOverTimes;
		crc_return=crc16Get(dsp_buffer, 30);
		dsp_buffer[30]=(char)(crc_return>>8);	dsp_buffer[31]=(char)(crc_return>>0);
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_UNSELF, dsp_buffer, 32);
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_UNSELF2, dsp_buffer, 32);

		//加油状态结束
		iptparam->OilState=IPT_OIL_IDLE;
		iptparam->OilEndTimer = 0;

		iptMainInterface(iptparam);
	}


	return;
}


/*******************************************************************
*Name				:iptUnselfProcess
*Description		:非卡机联动模式处理
*Input				:None
*Output			:None
*Return				:None
*History			:2014-04-17,modified by syj  */

static void iptUnselfProcess(IptParamStructType *iptparam, unsigned char *msg_buffer,	int msg_len)
{
	switch(iptparam->ProcessId)
	{
	case IPT_PID_UNSELF_PRESET:
		//预置界面处理
		iptUnselfPreset(iptparam, msg_buffer,	msg_len);
		break;

	case IPT_PID_UNSELF_CHECK:
		//非卡机联动加油启动检查过程
		iptUnselfCheck(iptparam, msg_buffer,	msg_len);
		break;

	case IPT_PID_UNSELF_START:
		//非卡机联动加油启动过程
		iptUnselfOilStart(iptparam, msg_buffer,	msg_len);
		break;

	case IPT_PID_UNSELF_OILLING:
		//非卡机联动加油中
		//PrintTime("oilling 1:--- sec=%d,  ","milsec=%d\n");
		iptUnselfOilling(iptparam, msg_buffer,	msg_len);
		usleep(5000);
	    //PrintTime("oilling 2:--- sec=%d,  ","milsec=%d\n");
		break;

	case IPT_PID_UNSELF_FINISH:
		//非卡机联动加油结束
		iptUnselfOilFinish(iptparam, msg_buffer,	msg_len);
		break;

	default:
		break;
	}
	
	return;
}


#if 0
/*******************************************************************
*Name				:iptTMBarScan
*Description		:条码自助，扫描条码过程
*Input				:None
*Output			:None
*Return				:None
*History			:2014-04-17,modified by syj  */

static void iptTMBarScan(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char read_buffer[16]={0};
	unsigned char dsp_buffer[64]={0}, dsp_len=0;

	//读取条码
	barRead(iptparam->DEVBarcode, read_buffer, 6);

	//社会站联达加油站系统不处理内置卡，直接进行后台授权；
	//	否则，转入授权申请内置卡预处理过程；
	
	if(0 != memcmp(read_buffer, "\x00\x00\x00\x00\x00\x00", 6))
	{
		iptparam->Barcode[0]=((read_buffer[0]&0x0f)<<4)|((read_buffer[1]&0x0f)<<0);
		iptparam->Barcode[1]=((read_buffer[2]&0x0f)<<4)|((read_buffer[3]&0x0f)<<0);
		iptparam->Barcode[2]=((read_buffer[4]&0x0f)<<4)|((read_buffer[5]&0x0f)<<0);
		iptparam->Barcode[3]=0xff;	iptparam->Barcode[4]=0xff;
		memset(iptparam->BarMoney, 0, 3);memcpy(iptparam->BarOilCode, iptparam->OilCode, 2);

		barStop(iptparam->DEVBarcode, BARCODE_USER_NO);
	
		dsp(iptparam->DEVDsp, DSP_TM_AUTHORIZING, "\x00", 0);
		if(1 == iptIsLianda(iptparam->Id))	iptPidSet(iptparam, IPT_PID_TM_CODE_CHECK);
		else														iptPidSet(iptparam, IPT_PID_TM_IC_PRETREAT);
		return;
	}

	//未读取到条码时按更改键、或无操作超时30秒时，取消扫描并返回待机过程
	if(0==memcmp(read_buffer, "\x00\x00\x00\x00\x00\x00", 6) &&\
		(KB_BUTTON_CHG==iptparam->Button || iptparam->NousedTimer>=30*ONE_SECOND))
	{
		barStop(iptparam->DEVBarcode, BARCODE_USER_NO);
		iptMainInterface(iptparam);
		return;
	}

	//多枪占用同一条码扫描模块未读取到条码且被其他用户占用时，返回待机过程
	if(0==memcmp(read_buffer, "\x00\x00\x00\x00\x00\x00", 6) && iptparam->BarUserID!=barUserIDGet(iptparam->DEVBarcode))
	{
		iptMainInterface(iptparam);
		return;
	}
	
	//未读取到条码时按确认键转入手工输入条码过程
	if(0==memcmp(read_buffer, "\x00\x00\x00\x00\x00\x00", 6) && KB_BUTTON_ACK==iptparam->Button)
	{
		barStop(iptparam->DEVBarcode, BARCODE_USER_NO);

		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;

		dsp_buffer[0]=iptparam->SetButtonLen;	memcpy(&dsp_buffer[0], iptparam->SetButton, iptparam->SetButtonLen);
		dsp_len=1+iptparam->SetButtonLen;
		dsp(iptparam->DEVDsp, DSP_TM_BARCODE_INPUT, dsp_buffer, dsp_len);
		iptPidSet(iptparam, IPT_PID_TM_BAR_INPUT);
		return;
	}

	return;
}


/*******************************************************************
*Name				:iptTMScan
*Description		:条码自助，扫描条码过程
*Input				:None
*Output			:None
*Return				:None
*History			:2014-04-17,modified by syj  */

static void iptTMBarInput(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char dsp_buffer[64]={0}, dsp_len=0;
	unsigned char button=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0==button)	button='0';
	case KB_BUTTON_1:
		if(0==button)	button='1';
	case KB_BUTTON_2:
		if(0==button)	button='2';
	case KB_BUTTON_3:
		if(0==button)	button='3';
	case KB_BUTTON_4:
		if(0==button)	button='4';
	case KB_BUTTON_5:
		if(0==button)	button='5';
	case KB_BUTTON_6:
		if(0==button)	button='6';
	case KB_BUTTON_7:
		if(0==button)	button='7';
	case KB_BUTTON_8:
		if(0==button)	button='8';
	case KB_BUTTON_9:
		if(0==button)	button='9';

		if(iptparam->SetButtonLen<6)
		{
			iptparam->SetButton[iptparam->SetButtonLen++]=button;
		
			dsp_buffer[0]=iptparam->SetButtonLen;	memcpy(&dsp_buffer[1], iptparam->SetButton, iptparam->SetButtonLen);
			dsp_len=1+iptparam->SetButtonLen;
			dsp(iptparam->DEVDsp, DSP_TM_BARCODE_INPUT, dsp_buffer, dsp_len);
		}

		break;

	case KB_BUTTON_CHG:
		if(iptparam->SetButtonLen>0)
		{
			//当前有输入则清空输入并显示
			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;

			dsp_buffer[0]=iptparam->SetButtonLen;	memcpy(&dsp_buffer[0], iptparam->SetButton, iptparam->SetButtonLen);
			dsp_len=1+iptparam->SetButtonLen;
			dsp(iptparam->DEVDsp, DSP_TM_BARCODE_INPUT, dsp_buffer, dsp_len);
		}
		else
		{
			//当前无输入则开始扫描条码并转入扫描条码过程
			barScan(iptparam->DEVBarcode, iptparam->BarUserID);
			dsp(iptparam->DEVDsp, DSP_TM_SCAN, "\x00", 0);
			iptPidSet(iptparam, IPT_PID_TM_BAR_SCAN);
		}
		break;

	case KB_BUTTON_ACK:
		//判断条码输入是否正确，条码必须6位
		if(6!=iptparam->SetButtonLen)
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "条码输入错误", 12);
			IPT_DSP_WAIT();
			
			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;

			dsp_buffer[0]=iptparam->SetButtonLen;	memcpy(&dsp_buffer[0], iptparam->SetButton, iptparam->SetButtonLen);
			dsp_len=1+iptparam->SetButtonLen;
			dsp(iptparam->DEVDsp, DSP_TM_BARCODE_INPUT, dsp_buffer, dsp_len);
			break;
		}

		//保存条码
		iptparam->Barcode[0]=((iptparam->SetButton[0]&0x0f)<<4)|((iptparam->SetButton[1]&0x0f)<<0);
		iptparam->Barcode[1]=((iptparam->SetButton[2]&0x0f)<<4)|((iptparam->SetButton[3]&0x0f)<<0);
		iptparam->Barcode[2]=((iptparam->SetButton[4]&0x0f)<<4)|((iptparam->SetButton[5]&0x0f)<<0);
		iptparam->Barcode[3]=0xff;	iptparam->Barcode[4]=0xff;
		memset(iptparam->BarMoney, 0, 3);memcpy(iptparam->BarOilCode, iptparam->OilCode, 2);

		//清除输入
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;

		//社会站联达加油站系统不处理内置卡，直接进行后台授权；
		//	否则，转入授权申请内置卡预处理过程；
		
		dsp(iptparam->DEVDsp, DSP_TM_AUTHORIZING, "\x00", 0);
		if(1 == iptIsLianda(iptparam->Id))	iptPidSet(iptparam, IPT_PID_TM_CODE_CHECK);
		else														iptPidSet(iptparam, IPT_PID_TM_IC_PRETREAT);
		break;
		
	default:
		break;
	}

	return;
}
#endif


/*******************************************************************
*Name				:iptTMPretreat
*Description		:条码自助，条码自助加油预处理
*Input				:None
*Output			:None
*Return				:None
*History			:2016-06-22,modified by syj  */

static void iptTMPretreat(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	int istate = 0;
	int voice[16] = {0};
	char dsp_buffer[64] = {0};
	int dsp_len = 0;

	//社会站联达加油站不使用内置卡，否则油品选择按键选择后通过复位内置卡判断内置卡是否正常
	if(1 == iptIsLianda(iptparam->Id))	istate = 0;
	else 														istate = ICReset(iptparam->DEVIC, iptparam->DEVICInternal);

	//转入条码扫描过程语音提示"请扫描条码"，女声
	if(0==istate && iptparam->VoiceVolume>0 && IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType)
	{
		voice[0]=SPKW_CODESCAN;
		iptSpk(iptparam, voice, 1);
	}
	//转入条码扫描过程语音提示"请扫描条码"，男声
	else if(0==istate && iptparam->VoiceVolume>0 && IPT_VOICE_TYPE_MAN==iptparam->VoiceType)
	{
		voice[0]=SPKM_CODESCAN;	
		iptSpk(iptparam, voice, 1);
	}
	//内置卡异常，语音提示"出现故障，请通知工作人员"，女声
	else if(0!=istate && iptparam->VoiceVolume>0 && IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType)
	{
		voice[0]=SPKW_FAULT;
		iptSpk(iptparam, voice, 1);
	}
	//内置卡异常，语音提示"出现故障，请通知工作人员"，男声
	else if(0!=istate && iptparam->VoiceVolume>0 && IPT_VOICE_TYPE_MAN==iptparam->VoiceType)
	{
		voice[0]=SPKM_FAULT;
		iptSpk(iptparam, voice, 1);
	}

	//内置卡正常则开始扫描并转入条码扫描过程
	if(0==istate)
	{
		iptparam->NousedTimer = 0;
		barScan(iptparam->DEVBarcode, iptparam->BarUserID);

		//2016-06-22修改为直接进入即可扫描也可输入的界面
		//dsp(iptparam->DEVDsp, DSP_TM_SCAN, "\x00", 0);
		//iptPidSet(iptparam, IPT_PID_TM_BAR_SCAN); //fj:
		
		///2016-06-22修改为直接进入即可扫描也可输入的界面
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp_buffer[0]=iptparam->SetButtonLen;	memcpy(&dsp_buffer[0], iptparam->SetButton, iptparam->SetButtonLen);
		dsp_len=1+iptparam->SetButtonLen;
		dsp(iptparam->DEVDsp, DSP_TM_SCAN_AND_INPUT, dsp_buffer, dsp_len);
		iptPidSet(iptparam, IPT_PID_TM_SCAN);

		//清空外部扫描的条码数据
		memset(iptparam->TMNumber, 0, 10);	iptparam->TMExterInputDone = 0;

		//促销机通知平板油机状态
		if(1 == paramPromotionGet())
		{
			iptparam->TaState = IPT_STATE_TM_SCAN;	iptparam->TaStateParamLength = 0;
			*(iptparam->TaStateParam + 0) = 0;	iptparam->TaStateParamLength = 1;
			pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
		}
		
	}
	//内置卡异常，键盘提示故障
	else
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "出现故障，请通知工作人员", 24);
		IPT_DSP_WAIT();
		iptMainInterface(iptparam);
	}

	return;
}


/*******************************************************************
*Name				:iptTMBarcodeScan
*Description		:条码自助，条码扫描或输入界面
*Input				:None
*Output			:None
*Return				:None
*History			:2016-06-22,modified by syj  */

static void iptTMBarcodeScan(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char read_buffer[16]={0};
	unsigned char dsp_buffer[64]={0}, dsp_len=0;
	unsigned char button=0;

	//读取条码
	barRead(iptparam->DEVBarcode, read_buffer, 6);

	//读取到扫描的条码，或由外部通知油机已扫描的条码
	if(0 != memcmp(read_buffer, "\x00\x00\x00\x00\x00\x00", 6))
	{
		iptparam->Barcode[0]=((read_buffer[0]&0x0f)<<4)|((read_buffer[1]&0x0f)<<0);
		iptparam->Barcode[1]=((read_buffer[2]&0x0f)<<4)|((read_buffer[3]&0x0f)<<0);
		iptparam->Barcode[2]=((read_buffer[4]&0x0f)<<4)|((read_buffer[5]&0x0f)<<0);
		iptparam->Barcode[3]=0xff;	iptparam->Barcode[4]=0xff;
		memset(iptparam->BarMoney, 0, 3);memcpy(iptparam->BarOilCode, iptparam->OilCode, 2);

		barStop(iptparam->DEVBarcode, BARCODE_USER_NO);
	
		dsp(iptparam->DEVDsp, DSP_TM_AUTHORIZING, "\x00", 0);
		if(1 == iptIsLianda(iptparam->Id))	iptPidSet(iptparam, IPT_PID_TM_CODE_CHECK);
		else														iptPidSet(iptparam, IPT_PID_TM_IC_PRETREAT);

		//促销机通知平板油机状态
		if(1 == paramPromotionGet())
		{
			iptparam->TaState = IPT_STATE_TM_APPLY_FOR;	iptparam->TaStateParamLength = 0;
			pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
		}
		
		return;
	}

	//多枪占用同一条码扫描模块未读取到条码且被其他用户占用时，返回待机过程
	if(0==memcmp(read_buffer, "\x00\x00\x00\x00\x00\x00", 6) && iptparam->BarUserID != barUserIDGet(iptparam->DEVBarcode))
	{
		iptMainInterface(iptparam);
		return;
	}

	//促销机，有外部输入的条码，保存到输入缓存中，如果有变化时重新显示
	if(1 == paramPromotionGet() && 1 == iptparam->TMExterInputDone)
	{
		iptparam->NousedTimer = 0;
		memset(iptparam->SetButton, 0, sizeof(iptparam->SetButton));	iptparam->SetButtonLen = 0;

		//taskLock();  //fj:20170914
		if(iptparam->TMNumberLenght <= 10)	iptparam->SetButtonLen = iptparam->TMNumberLenght;
		else															iptparam->SetButtonLen = 10;
		memcpy(iptparam->SetButton, iptparam->TMNumber, iptparam->SetButtonLen);
		//taskUnlock(); //fj:20170914
		
		dsp_buffer[0]=iptparam->SetButtonLen;	memcpy(&dsp_buffer[1], iptparam->SetButton, iptparam->SetButtonLen);
		dsp_len = 1 + iptparam->SetButtonLen;
		dsp(iptparam->DEVDsp, DSP_TM_SCAN_AND_INPUT, dsp_buffer, dsp_len);

		iptparam->TMExterInputDone = 0;

		//通知平板油机状态
		iptparam->TaState = IPT_STATE_TM_SCAN;	iptparam->TaStateParamLength = 0;
		*(iptparam->TaStateParam + 0) = iptparam->SetButtonLen;	
		strncpy(iptparam->TaStateParam + 1, iptparam->SetButton, iptparam->SetButtonLen);
		iptparam->TaStateParamLength = 1 + iptparam->SetButtonLen;
		pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
	}

	//外部通知油机已扫描的条码
	if(1 == paramPromotionGet() && 2 == iptparam->TMExterInputDone)
	{
		iptparam->NousedTimer = 0;
	
		iptparam->Barcode[0]=((iptparam->SetButton[0]&0x0f)<<4)|((iptparam->SetButton[1]&0x0f)<<0);
		iptparam->Barcode[1]=((iptparam->SetButton[2]&0x0f)<<4)|((iptparam->SetButton[3]&0x0f)<<0);
		iptparam->Barcode[2]=((iptparam->SetButton[4]&0x0f)<<4)|((iptparam->SetButton[5]&0x0f)<<0);
		iptparam->Barcode[3]=0xff;	iptparam->Barcode[4]=0xff;
		memset(iptparam->BarMoney, 0, 3);memcpy(iptparam->BarOilCode, iptparam->OilCode, 2);

		barStop(iptparam->DEVBarcode, BARCODE_USER_NO);
	
		dsp(iptparam->DEVDsp, DSP_TM_AUTHORIZING, "\x00", 0);
		if(1 == iptIsLianda(iptparam->Id))	iptPidSet(iptparam, IPT_PID_TM_CODE_CHECK);
		else														iptPidSet(iptparam, IPT_PID_TM_IC_PRETREAT);

		//通知平板油机状态
		iptparam->TaState = IPT_STATE_TM_APPLY_FOR;	iptparam->TaStateParamLength = 0;
		pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);

		return;
	}

	//无操作超时1分钟时，取消扫描并返回待机过程
	if(iptparam->NousedTimer >= 60*ONE_SECOND)
	{
		barStop(iptparam->DEVBarcode, BARCODE_USER_NO);
		iptMainInterface(iptparam);
		return;
	}
	
	//输入条码
	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0==button)	button='0';
	case KB_BUTTON_1:
		if(0==button)	button='1';
	case KB_BUTTON_2:
		if(0==button)	button='2';
	case KB_BUTTON_3:
		if(0==button)	button='3';
	case KB_BUTTON_4:
		if(0==button)	button='4';
	case KB_BUTTON_5:
		if(0==button)	button='5';
	case KB_BUTTON_6:
		if(0==button)	button='6';
	case KB_BUTTON_7:
		if(0==button)	button='7';
	case KB_BUTTON_8:
		if(0==button)	button='8';
	case KB_BUTTON_9:
		if(0==button)	button='9';

		if(iptparam->SetButtonLen < 6)
		{
			iptparam->SetButton[iptparam->SetButtonLen++]=button;
		
			dsp_buffer[0]=iptparam->SetButtonLen;	memcpy(&dsp_buffer[1], iptparam->SetButton, iptparam->SetButtonLen);
			dsp_len=1+iptparam->SetButtonLen;
			dsp(iptparam->DEVDsp, DSP_TM_SCAN_AND_INPUT, dsp_buffer, dsp_len);

			//促销机通知平板油机状态
			if(1 == paramPromotionGet())
			{
				iptparam->TaState = IPT_STATE_TM_SCAN;	iptparam->TaStateParamLength = 0;
				*(iptparam->TaStateParam + 0) = iptparam->SetButtonLen;	
				strncpy(iptparam->TaStateParam + 1, iptparam->SetButton, iptparam->SetButtonLen);
				iptparam->TaStateParamLength = 1 + iptparam->SetButtonLen;
				pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
			}
		}

		break;

	case KB_BUTTON_CHG:
		//清空输入并显示
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;

		dsp_buffer[0]=iptparam->SetButtonLen;	memcpy(&dsp_buffer[0], iptparam->SetButton, iptparam->SetButtonLen);
		dsp_len=1+iptparam->SetButtonLen;
		dsp(iptparam->DEVDsp, DSP_TM_SCAN_AND_INPUT, dsp_buffer, dsp_len);

		//促销机通知平板油机状态
		if(1 == paramPromotionGet())
		{
			iptparam->TaState = IPT_STATE_TM_SCAN;	iptparam->TaStateParamLength = 0;
			*(iptparam->TaStateParam + 0) = iptparam->SetButtonLen;	
			strncpy(iptparam->TaStateParam + 1, iptparam->SetButton, iptparam->SetButtonLen);
			iptparam->TaStateParamLength = 1 + iptparam->SetButtonLen;
			pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
		}
		break;

	case KB_BUTTON_ACK:
		//判断条码输入是否正确，条码必须6位
		if(6 != iptparam->SetButtonLen)
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, " 请输入6位条码", strlen(" 请输入6位条码"));
			IPT_DSP_WAIT();
			
			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;

			dsp_buffer[0]=iptparam->SetButtonLen;	memcpy(&dsp_buffer[0], iptparam->SetButton, iptparam->SetButtonLen);
			dsp_len=1+iptparam->SetButtonLen;
			dsp(iptparam->DEVDsp, DSP_TM_SCAN_AND_INPUT, dsp_buffer, dsp_len);
			break;
		}

		//保存条码
		iptparam->Barcode[0]=((iptparam->SetButton[0]&0x0f)<<4)|((iptparam->SetButton[1]&0x0f)<<0);
		iptparam->Barcode[1]=((iptparam->SetButton[2]&0x0f)<<4)|((iptparam->SetButton[3]&0x0f)<<0);
		iptparam->Barcode[2]=((iptparam->SetButton[4]&0x0f)<<4)|((iptparam->SetButton[5]&0x0f)<<0);
		iptparam->Barcode[3]=0xff;	iptparam->Barcode[4]=0xff;
		memset(iptparam->BarMoney, 0, 3);memcpy(iptparam->BarOilCode, iptparam->OilCode, 2);

		//停止扫描
		barStop(iptparam->DEVBarcode, BARCODE_USER_NO);
		
		//清除输入
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;

		//社会站联达加油站系统不处理内置卡，直接进行后台授权；
		//	否则，转入授权申请内置卡预处理过程；
		
		dsp(iptparam->DEVDsp, DSP_TM_AUTHORIZING, "\x00", 0);
		if(1 == iptIsLianda(iptparam->Id))	iptPidSet(iptparam, IPT_PID_TM_CODE_CHECK);
		else														iptPidSet(iptparam, IPT_PID_TM_IC_PRETREAT);

		//促销机通知平板油机状态
		if(1 == paramPromotionGet())
		{
			iptparam->TaState = IPT_STATE_TM_APPLY_FOR;	iptparam->TaStateParamLength = 0;
			pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
		}
		break;

	case KB_BUTTON_BACK:
		//停止扫描返回待界面
		barStop(iptparam->DEVBarcode, BARCODE_USER_NO);
		iptMainInterface(iptparam);
		break;
		
	default:
		break;
	}


	return;
}


/*******************************************************************
*Name				:iptTMIcPretreat
*Description		:条码自助，内置卡预处理过程
*Input				:None
*Output			:None
*Return				:None
*History			:2014-10-22,modified by syj  */

static void iptTMIcPretreat(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char buffer[128]={0};
	int istate=0, apdu_len=0;
	unsigned char dsp_buffer[64]={0};

	switch(iptparam->Step)
	{
	case 0:	
		//IC卡复位
		istate=ICReset(iptparam->DEVIC, iptparam->DEVICInternal);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate){
	
			iptparam->IcOverTimes=0;	iptparam->Step++;
		}
		//操作失败则提示错误信息
		else if(ICSTATE_FAILED==istate){
			
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡复位失败", 12);
			IPT_DSP_WAIT();

			iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退出
		else if(ICSTATE_OVERTIME==istate){

			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3){
				
				iptparam->IcOverTimes=0;

				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡复位超时", 12);
				IPT_DSP_WAIT();
				
				iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else{
	
			iptparam->IcOverTimes=0;
		
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡复位错误", 12);
			IPT_DSP_WAIT();

			iptMainInterface(iptparam);
		}
		break;

	case 1:	
		//IC卡MF文件选择
		istate=ICMFSelect(iptparam->DEVIC, iptparam->DEVICInternal, buffer, 128);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate){
			iptparam->IcOverTimes=0;	
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2)){
				
				iptparam->Step++;
			}
			else{
				
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=14;	memcpy(&dsp_buffer[3], "IC卡MF选择失败", 14);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				IPT_DSP_WAIT();
				
				iptMainInterface(iptparam);
			}
		}
		//操作失败则提示信息后退卡
		else if(ICSTATE_FAILED==istate){
			
			iptparam->IcOverTimes=0;
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡MF选择失败", 14);
			IPT_DSP_WAIT();
			
			iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else if(ICSTATE_OVERTIME==istate){
			
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3){
		
				iptparam->IcOverTimes=0;
				
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡MF选择超时", 14);
				IPT_DSP_WAIT();
			
				iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else{
	
			iptparam->IcOverTimes=0;
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡MF选择错误", 14);
			IPT_DSP_WAIT();
			
			iptMainInterface(iptparam);
		}
		break;

	case 2:
		//IC卡应用选择
		if(IPT_PAYUNIT_MONEY==iptparam->PayUnit)	istate=ICAppSelect(iptparam->DEVIC, iptparam->DEVICInternal, buffer, 128, 0);
		else																		istate=ICAppSelect(iptparam->DEVIC, iptparam->DEVICInternal, buffer, 128, 1);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate){

			iptparam->IcOverTimes=0;
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2)){
				
				iptparam->Step++;
			}
			else{
				
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=16;	memcpy(&dsp_buffer[3], "IC卡应用选择失败", 16);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				IPT_DSP_WAIT();
				
				iptMainInterface(iptparam);
			}
		}
		//操作失败则提示信息后退卡
		else if(ICSTATE_FAILED==istate){
			
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡应用选择失败", 16);
			IPT_DSP_WAIT();
			
			iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else if(ICSTATE_OVERTIME==istate){
			
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3){
				
				iptparam->IcOverTimes=0;

				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡应用选择超时", 16);
				IPT_DSP_WAIT();
				
				iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else{
			
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡应用选择错误", 16);
			IPT_DSP_WAIT();
				
			iptMainInterface(iptparam);
		}
		break;

	case 3:	
		//IC卡21文件读取
		istate=ICFile21Read(iptparam->DEVIC, iptparam->DEVICInternal, buffer, 128);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate){
			
			iptparam->IcOverTimes=0;	
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2)){
				
				//保存卡信息
				memcpy(iptparam->IcIssuerMark, &buffer[2], 8);		//发卡方标识	
				iptparam->IcAppMatk=buffer[10];								//应用类型标识					
				iptparam->IcAppVersion=buffer[11];							//应用版本	
				memcpy(iptparam->IcAppId, &buffer[12], 10);			//应用序列号
				memcpy(iptparam->IcEnableTime, &buffer[22], 4);		//应用启用日期
				memcpy(iptparam->IcInvalidTime, &buffer[26], 4);		//应用有效截止日期
				iptparam->IcCodeVersion=buffer[30];							//指令集版本			
				iptparam->IcFile21Unused=0;										//21文件备用区域


				iptparam->Step++;
			}
			else{
				
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=16;	memcpy(&dsp_buffer[3], "IC卡读21文件失败", 16);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				IPT_DSP_WAIT();
				
				iptMainInterface(iptparam);
			}
		}
		//操作失败则提示信息后退卡
		else if(ICSTATE_FAILED==istate){

			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡读21文件失败", 16);
			IPT_DSP_WAIT();
				
			iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else if(ICSTATE_OVERTIME==istate){
			
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3){
				
				iptparam->IcOverTimes=0;
				
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡读21文件超时", 16);
				IPT_DSP_WAIT();
					
				iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else{
			
			iptparam->IcOverTimes=0;
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡读21文件错误", 16);
			IPT_DSP_WAIT();
				
			iptMainInterface(iptparam);
		}
		break;

	case 4:	
		//IC卡22文件读取
		istate=ICFile22Read(iptparam->DEVIC, iptparam->DEVICInternal, buffer, 128);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate){

			iptparam->IcOverTimes=0;	
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2)){
				
				//保存卡信息
				iptparam->IcTypeMark=buffer[2];								//卡类型标识
				iptparam->IcStaffMark = buffer[3];								//本系统职工标识
				memcpy(iptparam->IcUserName, &buffer[4], 20);		//持卡人姓名
				memcpy(iptparam->IcUserIdeId, &buffer[24], 18);		//持卡人证件(identity)号码(ASCII)
				iptparam->IcUserIdeType=buffer[42];							//持卡人证件类型
				
				iptparam->Step++;
			}
			else{
				
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=16;	memcpy(&dsp_buffer[3], "IC卡读22文件失败", 16);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				IPT_DSP_WAIT();
				
				iptMainInterface(iptparam);
			}
		}
		//操作失败则提示信息后退卡
		else if(ICSTATE_FAILED==istate){
			
			iptparam->IcOverTimes=0;
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡读22文件失败", 16);
			IPT_DSP_WAIT();
				
			iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else if(ICSTATE_OVERTIME==istate){
			
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3){
				
				iptparam->IcOverTimes=0;
				
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡读22文件超时", 16);
				IPT_DSP_WAIT();
					
				iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else{
			
			iptparam->IcOverTimes=0;
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡读22文件错误", 16);
			IPT_DSP_WAIT();
				
			iptMainInterface(iptparam);
		}
		break;

		
	case 5:	
		//IC卡27文件读取
		istate=ICFile27Read(iptparam->DEVIC, iptparam->DEVICInternal, buffer, 128);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate){
			
			iptparam->IcOverTimes=0;	
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2)){
				
				//保存卡信息
				iptparam->IcDefaultPassword=buffer[2];							//是否采用默认密码,00=使用默认密码，01=使用用户密码
				iptparam->IcStaffId=buffer[3];										//员工号(内部卡有效)
				memcpy(iptparam->IcStaffPassword, &buffer[4], 2);		//员工密码(内部卡有效)
				iptparam->IcDebitUnit = buffer[6];									//扣款单位(00H=元；01H=升；社会站卡结构有此字段)
				iptparam->IcDiscountFlag = buffer[7];								//是否折扣卡(00H=非折扣卡；01H=折扣卡；社会站卡结构有此字段)
		
				iptparam->Step++;
			}
			else{
				
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=16;	memcpy(&dsp_buffer[3], "IC卡读27文件失败", 16);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				IPT_DSP_WAIT();

				iptMainInterface(iptparam);
			}
		}
		//操作失败则提示信息后退卡
		else if(ICSTATE_FAILED==istate){
			
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡读27文件失败", 16);
			IPT_DSP_WAIT();
					
			iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else if(ICSTATE_OVERTIME==istate){
			
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3){

				iptparam->IcOverTimes=0;

				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡读27文件超时", 16);
				IPT_DSP_WAIT();
					
				iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else{
			
			iptparam->IcOverTimes=0;
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡读22文件错误", 16);
			IPT_DSP_WAIT();
					
			iptMainInterface(iptparam);
		}
		break;

	case 6:	
		//IC卡28文件读取
		istate=ICFile28Read(iptparam->DEVIC, iptparam->DEVICInternal, buffer, 128);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate){
			
			iptparam->IcOverTimes=0;
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2)){
				
				//保存卡信息
				memcpy(iptparam->IcOilLimit, &buffer[2], 2);					//油品限制
				iptparam->IcRegionTypeLimit=buffer[4];							//限地区,油站加油方式
				memcpy(iptparam->IcRegionLimit, &buffer[5], 40);			//限地区,油站加油
				memcpy(iptparam->IcVolumeLimit, &buffer[45], 2);		//限每次加油量
				iptparam->IcTimesLimit=buffer[47];								//限每天加油次数
				memcpy(iptparam->IcMoneyDayLimit, &buffer[48], 4);	//限每天加油金额
				memcpy(iptparam->IcCarIdLimit, &buffer[52], 16);			//车牌号限制(ASCII)

				iptPidSet(iptparam, IPT_PID_TM_PSAM_PRE);
			}
			else{
				
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=16;	memcpy(&dsp_buffer[3], "IC卡读28文件失败", 16);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				IPT_DSP_WAIT();

				iptMainInterface(iptparam);
			}
		}
		//操作失败则提示信息后退卡
		else if(ICSTATE_FAILED==istate){
			
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡读28文件失败", 16);
			IPT_DSP_WAIT();
					
			iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else if(ICSTATE_OVERTIME==istate){
			
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3){
				
				iptparam->IcOverTimes=0;

				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡读28文件超时", 16);
				IPT_DSP_WAIT();
						
				iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else{
			
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡读28文件错误", 16);
			IPT_DSP_WAIT();

			iptMainInterface(iptparam);
		}
		break;

	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptTMPsamPretreat
*Description		:条码自助，PSAM预处理过程
*Input				:None
*Output			:None
*Return				:None
*History			:2014-10-22,modified by syj  */

static void iptTMPsamPretreat(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char buffer[128]={0}, dsp_buffer[64]={0}, dsp_len=0;
	int istate=0, apdu_len=0;

	switch(iptparam->Step)
	{
	case 0:	
		//复位PSAM
		istate=PsamReset(iptparam->DEVIC, iptparam->DEVPsam);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate){
			
			iptparam->IcOverTimes=0;	iptparam->Step++;
		}
		//操作失败则提示错误信息
		else if(ICSTATE_FAILED==istate){
			
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM复位失败", 12);
			IPT_DSP_WAIT();

			iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退出
		else if(ICSTATE_OVERTIME==istate){
			
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3){
				
				iptparam->IcOverTimes=0;

				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM复位超时", 12);
				IPT_DSP_WAIT();

				iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else{
			
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM复位错误", 12);
			IPT_DSP_WAIT();

			iptMainInterface(iptparam);
		}
		break;

	case 1:	
		//选择ＭＦ文件(PSE SLECTE)	
		istate=PsamMFSelect(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate){
			
			iptparam->IcOverTimes=0;	
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2)){
				
				iptparam->Step++;
			}
			else{
				
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=14;	memcpy(&dsp_buffer[3], "PSAM选择MF失败", 14);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				IPT_DSP_WAIT();

				iptMainInterface(iptparam);
			}
		}
		//操作失败则提示信息后退卡
		else if(ICSTATE_FAILED==istate){
			
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM选择MF失败", 14);
			IPT_DSP_WAIT();

			iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else if(ICSTATE_OVERTIME==istate){
			
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3){
				
				iptparam->IcOverTimes=0;

				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM选择MF超时", 14);
				IPT_DSP_WAIT();

				iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else{
			
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM选择MF错误", 14);
			IPT_DSP_WAIT();

			iptMainInterface(iptparam);
		}
		break;
		
	case 2:	
		//读PSAM卡片公共信息21文件
		istate=PsamFile21Read(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate){
			
			iptparam->IcOverTimes=0;	
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2)){
				
				//保存PSAM信息
				memcpy(iptparam->PsamId, &buffer[2], 10);		//PSAM序列号
				iptparam->PsamVersion=buffer[12];					//PSAM版本号
				iptparam->PsamKeyType=buffer[13];					//PSAM密钥卡类型
				iptparam->PsamCodeVersion=buffer[14];			//PSAM指令集版本
				iptparam->PsamFCI=buffer[15];							//PSAM发卡方自定义FCI数据

				iptparam->Step++;
			}
			else{
				
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=16;	memcpy(&dsp_buffer[3], "PSAM读21文件失败", 16);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				IPT_DSP_WAIT();

				iptMainInterface(iptparam);
			}
		}
		//操作失败则提示信息后退卡
		else if(ICSTATE_FAILED==istate){
			
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM读21文件失败", 16);
			IPT_DSP_WAIT();

			iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else if(ICSTATE_OVERTIME==istate){
			
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3){
				
				iptparam->IcOverTimes=0;

				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM读21文件超时", 16);
				IPT_DSP_WAIT();

				iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else{
			
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM读21文件错误", 16);
			IPT_DSP_WAIT();

			iptMainInterface(iptparam);
		}
		break;

		
	case 3:	
		//读PSAM终端信息22文件
		istate=PsamFile22Read(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate){
			
			iptparam->IcOverTimes=0;	
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2)){
				
				//保存PSAM信息
				memcpy(iptparam->PsamTermId, &buffer[2], 6);	//PSAM终端机编号	
				
				iptparam->Step++;
			}
			else{
				
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=16;	memcpy(&dsp_buffer[3], "PSAM读22文件失败", 16);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				IPT_DSP_WAIT();

				iptMainInterface(iptparam);
			}
		}
		//操作失败则提示信息后退卡
		else if(ICSTATE_FAILED==istate){
			
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM读22文件失败", 16);
			IPT_DSP_WAIT();

			iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else if(ICSTATE_OVERTIME==istate){
			
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3){
				
				iptparam->IcOverTimes=0;

				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM读22文件超时", 16);
				IPT_DSP_WAIT();

				iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else{
			
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM读22文件错误", 16);
			IPT_DSP_WAIT();

			iptMainInterface(iptparam);
		}
		break;
		
	case 4:	
		//选择DF中石化应用1
		istate=PsamDFSelect(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, 1);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate){
			
			iptparam->IcOverTimes=0;	
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2)){
				
				iptparam->Step++;
			}
			else{
				
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=15;	memcpy(&dsp_buffer[3], "PSAM选择DF1失败", 15);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				IPT_DSP_WAIT();

				iptMainInterface(iptparam);
			}
		}
		//操作失败则提示信息后退卡
		else if(ICSTATE_FAILED==istate){
			
			iptparam->IcOverTimes=0;
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM选择DF1失败", 15);
			IPT_DSP_WAIT();

			iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else if(ICSTATE_OVERTIME==istate){
			
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3){
				
				iptparam->IcOverTimes=0;
			
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM选择DF1超时", 15);
				IPT_DSP_WAIT();

				iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else{
			
			iptparam->IcOverTimes=0;
						
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM选择DF1错误", 15);
			IPT_DSP_WAIT();

			iptMainInterface(iptparam);
		}
		break;

	case 5:	
		//读PSAM应用公共信息23文件
		istate=PsamFile23Read(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate){
			
			iptparam->IcOverTimes=0;	
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2)){
				
				//保存PSAM信息
				iptparam->PsamKeyIndex=buffer[2];										//PSAM消费密钥索引号
				memcpy(iptparam->PsamIssuerMark, &buffer[3], 8);				//PSAM应用发卡方标识
				memcpy(iptparam->PsamRecipientsMark, &buffer[11], 8);		//PSAM应用接收者标识
				memcpy(iptparam->PsamAppStartTime, &buffer[19], 4);			//PSAM应用启用日期
				memcpy(iptparam->PsamAppEndTime, &buffer[23], 4);			//PSAM应用有效截止日期

				//转入卡合法性检查过程
				iptPidSet(iptparam, IPT_PID_TM_CHECK);
			}
			else{
				
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=16;	memcpy(&dsp_buffer[3], "PSAM读23文件失败", 16);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				IPT_DSP_WAIT();

				iptMainInterface(iptparam);
			}
		}
		//操作失败则提示信息后退卡
		else if(ICSTATE_FAILED==istate){
			
			iptparam->IcOverTimes=0;
						
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM读23文件失败", 16);
			IPT_DSP_WAIT();

			iptMainInterface(iptparam);
		}
		//操作超时，不足三次再次操作，超过三次退卡
		else if(ICSTATE_OVERTIME==istate){
			
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3){
				
				iptparam->IcOverTimes=0;
						
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM读23文件超时", 16);
				IPT_DSP_WAIT();

				iptMainInterface(iptparam);
			}
		}
		//未定义错误
		else{
			
			iptparam->IcOverTimes=0;
						
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM读23文件错误", 16);
			IPT_DSP_WAIT();

			iptMainInterface(iptparam);
		}
		break;
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptTMIcCheck
*Description		:条码自助，内置卡及PSAM合法性检查过程
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptTMIcCheck(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	int i=0, is_oil_limit=0, is_area_limit=0;
	unsigned char oil_code[4]={0}, oil_code_limit[4]={0};
	unsigned char rtime[7]={0}, buffer[128]={0};
	unsigned char dsp_buffer[64]={0};
	unsigned int dsp_len=0;
	int voice[16]={0};

	//当前时间
	rtime[0]=iptparam->Time.century;	rtime[1]=iptparam->Time.year;	rtime[2]=iptparam->Time.month;
	rtime[3]=iptparam->Time.date;		rtime[4]=iptparam->Time.hour;	rtime[5]=iptparam->Time.minute;
	rtime[6]=iptparam->Time.second;

	//判断PSAM序列号合法性
	for(i=0; i<10; i++)
	{
		if((((iptparam->PsamId[i]>>4)&0x0f)>9)||(((iptparam->PsamId[i]>>0)&0x0f)>9)){

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM序列号非法", 14);
			IPT_DSP_WAIT();

			iptMainInterface(iptparam);
			return;
		}
	}

	//判断PSAM版本号合法性
	if(0x01!=iptparam->PsamVersion){
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM版本号非法", 14);
		IPT_DSP_WAIT();

		iptMainInterface(iptparam);
		return;
	}

	//判断PSAM密钥卡类型合法性
	if(0x01!=iptparam->PsamKeyType){

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM密钥卡类型错", 16);
		IPT_DSP_WAIT();

		iptMainInterface(iptparam);
		return;
	}

	//判断PSAM指令集版本合法性
	if(0x01!=iptparam->PsamCodeVersion){
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM指令集版本错", 16);
		IPT_DSP_WAIT();

		iptMainInterface(iptparam);
		return;
	}

	//判断PSAM发卡方FCI数据合法性
	if(0x01!=iptparam->PsamFCI){
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM卡FCI数据错", 15);
		IPT_DSP_WAIT();

		iptMainInterface(iptparam);
		return;
	}

	//判断PSAM终端机编号合法性
	for(i=0; i<6; i++)
	{
		if((((iptparam->PsamTermId[i]>>4)&0x0f)>9)||(((iptparam->PsamTermId[i]>>0)&0x0f)>9)){

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM终端编号非法", 16);
			IPT_DSP_WAIT();

			iptMainInterface(iptparam);
			return;
		}
	}

	//判断PSAM应用发行者标识合法性
	if((((iptparam->PsamIssuerMark[0]>>4)&0x0f)>9)||(((iptparam->PsamIssuerMark[0]>>0)&0x0f)>9)||(0!=memcmp(&iptparam->PsamIssuerMark[1], "\xff\xff\xff\xff\xff\xff\xff", 7))){
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM发行者标识错", 16);
		IPT_DSP_WAIT();

		iptMainInterface(iptparam);
		return;
	}

	//判断PSAM应用接收者标识合法性
	if((((iptparam->PsamRecipientsMark[0]>>4)&0x0f)>9)||(((iptparam->PsamRecipientsMark[0]>>0)&0x0f)>9)||(0!=memcmp(&iptparam->PsamRecipientsMark[1], "\xff\xff\xff\xff\xff\xff\xff", 7))){
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM接收者标识错", 16);
		IPT_DSP_WAIT();

		iptMainInterface(iptparam);
		return;
	}

	//判断PSAM启用日期合法性
	if(0!=timeVerification(iptparam->PsamAppStartTime, 4)){

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM启用日期非法", 16);
		IPT_DSP_WAIT();

		iptMainInterface(iptparam);
		return;
	}
	
	//判断PSAM截止日期合法性
	if(0!=timeVerification(iptparam->PsamAppEndTime, 4)){
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM截止日期非法", 16);
		IPT_DSP_WAIT();

		iptMainInterface(iptparam);
		return;
	}

	//判断PSAM启用日期是否达到
	if(memcmp(rtime, iptparam->PsamAppStartTime, 4)<0){
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM启用日期未到", 16);
		IPT_DSP_WAIT();

		iptMainInterface(iptparam);
		return;
	}

	//判断PSAM有效日期是否已过
	if(memcmp(rtime, iptparam->PsamAppEndTime, 4)>0){
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM失效", 8);
		IPT_DSP_WAIT();

		iptMainInterface(iptparam);
		return;
	}

	//判断IC卡应用序列号合法性
	for(i=0; i<10; i++)
	{
		if((((iptparam->IcAppId[i]>>4)&0x0f)>9)||(((iptparam->IcAppId[i]>>0)&0x0f)>9)){
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC应用序列号非法", 16);
			IPT_DSP_WAIT();

			iptMainInterface(iptparam);
			return;
		}
	}

	//判断IC卡启用日期合法性
	if(0!=timeVerification(iptparam->IcEnableTime, 4)){
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡启用日期非法", 16);
		IPT_DSP_WAIT();

		iptMainInterface(iptparam);
		return;
	}
	
	//判断IC卡截止日期合法性
	if(0!=timeVerification(iptparam->IcInvalidTime, 4)){
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡截止日期非法", 16);
		IPT_DSP_WAIT();

		iptMainInterface(iptparam);
		return;
	}

	//判断IC卡启用日期是否达到
	if(memcmp(rtime, iptparam->IcEnableTime, 4)<0){
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡启用日期未到", 16);
		IPT_DSP_WAIT();

		iptMainInterface(iptparam);
		return;
	}
	
	//判断IC卡有效日期是否已过
	if(memcmp(rtime, iptparam->IcInvalidTime, 4)>0){

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "失效卡", 6);
		IPT_DSP_WAIT();

		iptMainInterface(iptparam);
		return;
	}

	//判断下班状态退卡
	if(IPT_WORK_OFFDUTY==iptparam->WorkState){

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "加油机已下班", 12);
		IPT_DSP_WAIT();

		iptMainInterface(iptparam);
		return;
	}

	//判断内置卡非员工卡退卡
	if(ICTYPE_STAFF!=iptparam->IcAppId[2]){

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "内置卡非员工卡", 14);
		IPT_DSP_WAIT();

		iptMainInterface(iptparam);
		return;
	}
#if 0
	//判断IC卡发卡方标识合法性:第一字节为BCD，后七字节为全F
	if((((iptparam->IcIssuerMark[0]>>4)&0x0f)>9)||(((iptparam->IcIssuerMark[0]>>0)&0x0f)>9)||(0!=memcmp(&iptparam->IcIssuerMark[1], "\xff\xff\xff\xff\xff\xff\xff", 7))){

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡发卡方标识错", 16);
		IPT_DSP_WAIT();

		iptMainInterface(iptparam);
		return;
	}

	//判断IC卡应用类型标识合法性
	if(0x11!=iptparam->IcAppMatk){

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC应用类型标识错", 16);
		IPT_DSP_WAIT();

		iptMainInterface(iptparam);
		return;
	}

	//判断IC卡应用版本合法性
	if(0x01!=iptparam->IcAppVersion){

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡应用版本非法", 16);
		IPT_DSP_WAIT();

		iptMainInterface(iptparam);
		return;
	}

	//判断IC卡指令集版本合法性
	if(0x01!=iptparam->IcCodeVersion){

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡指令集版本错", 16);
		IPT_DSP_WAIT();

		iptMainInterface(iptparam);
		return;
	}

	//判断行业标识码
	if(1!=(iptparam->IcAppId[0]&0x0f)){

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "非本行业IC卡", 12);
		IPT_DSP_WAIT();

		iptMainInterface(iptparam);
		return;
	}

	//判断卡类型，只支持用户卡，管理卡，员工卡，验泵卡，维修卡
	if(	ICTYPE_USER!=iptparam->IcAppId[2] && ICTYPE_MANAGE!=iptparam->IcAppId[2] &&\
		ICTYPE_STAFF!=iptparam->IcAppId[2] && ICTYPE_PUMP!=iptparam->IcAppId[2] &&\
		ICTYPE_SERVICE!=iptparam->IcAppId[2]){

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡类型不支持", 14);
		IPT_DSP_WAIT();

		iptMainInterface(iptparam);
		return;
	}

	//判断批次号
	if(0x01!=((iptparam->IcAppId[3]>>4)&0x0f)){

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡批次号非法", 14);
		IPT_DSP_WAIT();

		iptMainInterface(iptparam);
		return;
	}
#endif

	//合法转入密码输入界面0=使用默认密码(默认密码9999)；1=使用用户密码
	if(0==iptparam->IcDefaultPassword){
		
		memcpy(iptparam->IcPassword, "\x39\x39\x39\x39", 4);	iptparam->IcPasswordLen=4;
		iptPidSet(iptparam, IPT_PID_TM_PIN_CHECK);
	}
	else{

		memcpy(iptparam->IcPassword, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 12);	iptparam->IcPasswordLen=0;
		iptPidSet(iptparam, IPT_PID_TM_PIN_INPUT);

		dsp_buffer[0]=iptparam->IcPasswordLen;	dsp_len=1;
		dsp(iptparam->DEVDsp, DSP_CARD_PASSIN, dsp_buffer, dsp_len);

		//播放语音"请输入卡密码"
		if(iptparam->VoiceVolume>0 && IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType){

			voice[0]=SPKW_PASSIN;	//女声
			iptSpk(iptparam, voice, 1);
		}
		else if(iptparam->VoiceVolume>0 && IPT_VOICE_TYPE_MAN==iptparam->VoiceType){

			voice[0]=SPKM_PASSIN;	//男声
			iptSpk(iptparam, voice, 1);
		}
	}

	return;
}


/*******************************************************************
*Name				:iptTMIcPinInput
*Description		:条码自助，内置卡密码输入过程
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptTMIcPinInput(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char dsp_buffer[64]={0}, dsp_len=0, button=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0==button)	button='0';
	case KB_BUTTON_1:
		if(0==button)	button='1';
	case KB_BUTTON_2:
		if(0==button)	button='2';
	case KB_BUTTON_3:
		if(0==button)	button='3';
	case KB_BUTTON_4:
		if(0==button)	button='4';
	case KB_BUTTON_5:
		if(0==button)	button='5';
	case KB_BUTTON_6:
		if(0==button)	button='6';
	case KB_BUTTON_7:
		if(0==button)	button='7';
	case KB_BUTTON_8:
		if(0==button)	button='8';
	case KB_BUTTON_9:
		if(0==button)	button='9';

		//记录输入的密码
		if(iptparam->IcPasswordLen<12){

			iptparam->IcPassword[iptparam->IcPasswordLen++]=button;

			dsp_buffer[0]=iptparam->IcPasswordLen;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_CARD_PASSIN, dsp_buffer, dsp_len);
		}
		break;

	case KB_BUTTON_CHG:
		//清除输入的密码，
		memcpy(iptparam->IcPassword, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 12);	iptparam->IcPasswordLen=0;

		dsp_buffer[0]=iptparam->IcPasswordLen;	dsp_len=1;
		dsp(iptparam->DEVDsp, DSP_CARD_PASSIN, dsp_buffer, dsp_len);
		break;

	case KB_BUTTON_ACK:
		//确认密码校验
		iptPidSet(iptparam, IPT_PID_TM_PIN_CHECK);
		break;

	case KB_BUTTON_BACK:
		//退卡键退卡并返回待机界面
		iptMainInterface(iptparam);
		break;

	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptTMIcPinCheck
*Description		:条码自助，内置卡密码验证过程
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptTMIcPinCheck(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char buffer[128]={0};
	int apdu_len=0, istate=0;
	unsigned char dsp_buffer[64]={0}, dsp_len=0;
	int voice[16]={0};

	//IC卡密码验证
	istate=ICPinCheck(iptparam->DEVIC, iptparam->DEVICInternal, buffer, 128, iptparam->IcPassword, iptparam->IcPasswordLen);

	//操作成功则继续下一步
	if(ICSTATE_OK==istate){
		
		iptparam->IcOverTimes=0;	
		apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
		if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2)){

			//如果该卡号已经验证为白名单卡则直接转入读取灰锁状态，否则读黑白名单
			if(0==memcmp(iptparam->CardWhite, iptparam->IcAppId, 10)){

				iptPidSet(iptparam, IPT_PID_TM_LOCK_INFO);
			}
			else{
				
				iptPidSet(iptparam, IPT_PID_TM_BL_CHECK);
			}

			if(0!=iptparam->IcDefaultPassword)	dsp(iptparam->DEVDsp, DSP_TM_AUTHORIZE, "\x00", 0);
		}
		else if((0x63==buffer[2+apdu_len-2])&&(0xc0==(buffer[2+apdu_len-1]&0xf0))){
			
			//非默认密码提示"密码错误，请重新输入"
			if(0!=iptparam->IcDefaultPassword && iptparam->VoiceVolume>0){

				if(IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType)	voice[0]=SPKW_PASERR;	//女声
				else																				voice[0]=SPKM_PASERR;	//男声
				iptSpk(iptparam, voice, 1);
			}

			//个人密码验证失败，提示错误
			memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
			dsp_buffer[2]=20;	
			memcpy(&dsp_buffer[3], "密码错误,剩余", 13);
			dsp_buffer[16]=(buffer[2+apdu_len-1]&0x0f)+0x30;
			memcpy(&dsp_buffer[17], "次机会", 6);
			dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
			IPT_DSP_WAIT();

			//0=使用默认密码(默认密码9999)，直接退卡
			if(0==iptparam->IcDefaultPassword){

				iptMainInterface(iptparam);
			}
			//1=使用用户密码，维持错误提示一段时间后转到密码输入界面
			else{

				memcpy(iptparam->IcPassword, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 12);	iptparam->IcPasswordLen=0;

				dsp_buffer[0]=iptparam->IcPasswordLen;	dsp_len=1;
				dsp(iptparam->DEVDsp, DSP_CARD_PASSIN, dsp_buffer, dsp_len);
				iptPidSet(iptparam, IPT_PID_TM_PIN_INPUT);
			}
		}
		else if(0==memcmp(&buffer[2+apdu_len-2], "\x69\x83", 2)){
			
			//密码锁定
			memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
			dsp_buffer[2]=12;	memcpy(&dsp_buffer[3], "个人密码锁定", 12);
			dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
			IPT_DSP_WAIT();
			
			iptMainInterface(iptparam);
		}
		else{
			//密码验证其它错误
			memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
			dsp_buffer[2]=12;	memcpy(&dsp_buffer[3], "个人密码错误", 12);
			dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
			IPT_DSP_WAIT();
			
			iptMainInterface(iptparam);
		}
	}
	//操作失败则提示信息后退卡
	else if(ICSTATE_FAILED==istate){

		iptparam->IcOverTimes=0;	
	
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "个人密码验证失败", 16);
		IPT_DSP_WAIT();
			
		iptMainInterface(iptparam);
	}
	//操作超时
	else if(ICSTATE_OVERTIME==istate){
		
		iptparam->IcOverTimes=0;	
	
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "个人密码验证超时", 16);
		IPT_DSP_WAIT();

		iptMainInterface(iptparam);
	}
	//未定义错误
	else{
		
		iptparam->IcOverTimes=0;	
	
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "个人密码验证错误", 16);
		IPT_DSP_WAIT();

		iptMainInterface(iptparam);
	}

	return;
}


/*******************************************************************
*Name				:iptTMBLCheck
*Description		:内置卡黑/白名单查询过程
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptTMBLCheck(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char tx_buffer[128]={0}, tx_len=0;
	unsigned char dsp_buffer[64]={0}, dsp_len=0;
	unsigned char buffer[128]={0};

	//发送PCD查询黑/白名单命令，包括最近一次加油时间
	if(IPT_2PCD_UNUSED==iptparam->PcdTxFlag)
	{
		tx_buffer[0]=++iptparam->PcdTxFrame;
		tx_buffer[1]=pcdMboardIDRead();
		tx_buffer[2]=iptparam->Id;
		tx_buffer[3]=iptparam->PhysicalNozzle;
		tx_buffer[4]=IPT_CMD_LIST;
		memcpy(&tx_buffer[5], iptparam->IcAppId, 10);
		if(iptparam->IcRecordNumber>0)	memcpy(&tx_buffer[15], iptparam->IcRecord[0].Time, 4);
		tx_len=19;
		//msgQSend((MSG_Q_ID)pcdMsgIdRead(), tx_buffer, tx_len, NO_WAIT, MSG_PRI_NORMAL);

		struct msg_struct msg_stIptSend;  //fj:20170918
		msg_stIptSend.msgType = 1;
		memcpy(msg_stIptSend.msgBuffer,tx_buffer,tx_len);
		msgsnd(pcdMsgIdRead(),&msg_stIptSend,tx_len,IPC_NOWAIT);

		iptparam->PcdTxFlag=IPT_2PCD_OILPROCESS;	iptparam->PcdTxTimer=0;
	}
	//判断为名单查询命令且查询成功则根据结果处理
	else if((IPT_2PCD_OILPROCESS==iptparam->PcdTxFlag)&&(msg_len>0)&&(IPT_CMD_LIST==msg_buffer[4])&&(0==msg_buffer[5])&&(0==memcmp(&msg_buffer[8], iptparam->IcAppId, 10)))
	{
		//查询源
		iptparam->BlistSrc=msg_buffer[6];

		//查询成功，根据查询结果处理
		if(0!=msg_buffer[7])
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "非本站员工卡", 12);
			IPT_DSP_WAIT();

			iptMainInterface(iptparam);
		}
		else if(0==msg_buffer[7])
		{
			//保存已经查过白名单的卡号
			memcpy(iptparam->CardWhite, iptparam->IcAppId, 10);

			//转入卡灰锁状态查询过程
			iptPidSet(iptparam, IPT_PID_TM_LOCK_INFO);
		}
		else
		{
			//查询失败
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "查询黑白名单失败", 16);
			IPT_DSP_WAIT();
			iptMainInterface(iptparam);
		}

		iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdOverTimes=0;
	}
	else if((IPT_2PCD_OILPROCESS==iptparam->PcdTxFlag)&&(msg_len>0)&&(IPT_CMD_LIST==msg_buffer[4])&&(0!=msg_buffer[5])&&(0==memcmp(&msg_buffer[8], iptparam->IcAppId, 10)))
	{
		if(1==iptparam->IcAppId[2])	dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "需联机查询黑名单", 16);
		else											dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "需联机查询白名单", 16);
		IPT_DSP_WAIT();

		iptMainInterface(iptparam);

		iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdOverTimes=0;
	}
	else if((IPT_2PCD_OILPROCESS==iptparam->PcdTxFlag)&&(iptparam->PcdTxTimer>=(5*ONE_SECOND)))
	{
		//通讯超时重发，3次超时失败提示信息后退卡
		iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdOverTimes++;
		if(iptparam->PcdOverTimes>=3)
		{
			iptparam->PcdOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "查询黑白名单超时", 16);
			IPT_DSP_WAIT();

			iptMainInterface(iptparam);
		}
	}

	return;
}


/*******************************************************************
*Name				:iptTMLockInfo
*Description		:内置卡灰锁信息读取过程
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptTMLockInfo(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char buffer[128]={0};
	int apdu_len=0, istate=0;
	unsigned char dsp_buffer[64]={0}, dsp_len=0;

	//IC卡灰锁信息读取
	istate=ICGreyInfoRead(iptparam->DEVIC, iptparam->DEVICInternal, buffer, 128);

	//操作成功则继续下一步
	if(ICSTATE_OK==istate){
		
		iptparam->IcOverTimes=0;
		apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
		if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2)){

			//卡插入时的状态
			iptparam->ICStateFirst=buffer[2];
			
			//保存灰锁信息
			iptparam->IcLockMark=buffer[2];								//状态字:0x00=无灰锁；0x01=已灰锁；0x10=TAC未读
			iptparam->IcLockType=buffer[3];								//上次发生解扣或灰锁交易的交易类型标识
			iptparam->IcLockET=buffer[4];									//上次发生解扣或灰锁交易为ET
			memcpy(iptparam->IcLockBalance, &buffer[5], 4);		//上次发生解扣或灰锁的有效余额
			memcpy(iptparam->IcLockCTC, &buffer[9], 2);			//上次发生解扣或灰锁的交易序号
			memcpy(iptparam->IcLockTermId, &buffer[11], 6);		//上次发生解扣或灰锁的终端编号
			memcpy(iptparam->IcLockTime, &buffer[17], 7);		//上次发生解扣或灰锁的日期时间
			memcpy(iptparam->IcLockMoney, &buffer[24], 4);		//上次发生解扣或灰锁的交易金额
			memcpy(iptparam->IcLockGTAC, &buffer[28], 4);		//上次发生解扣或灰锁的GTAC或TAC或MAC3

			if(0x00==iptparam->IcLockMark){
				
				//正常，转入余额读取过程
				iptPidSet(iptparam, IPT_PID_TM_BAL_READ);
			}
			else if(0x01==iptparam->IcLockMark){
				
				//灰卡，转入灰记录查询过程
				dsp(iptparam->DEVDsp, DSP_CARD_UNLOCK_FINISH, "\x00", 0);
				iptPidSet(iptparam, IPT_PID_TM_LOCKRECORD);
			}
			else //if(0x10==iptparam->IcLockMark)
			{
#if 0
				//IC加油数据保存补充账单
				//待填充:POS_TTC
				memcpy(&iptparam->OilBill[IPT_OFFSET_TTC], "\x00\x00\x00\x00", 4);

				//已完成:交易类型设为无卡错，后台/本地黑白名单，扣款签名无效，补充
				iptparam->OilBill[IPT_OFFSET_T_TYPE]=(0<<7)|((iptparam->BlistSrc&1)<<6)|(0<<4)|(4<<0);

				//已完成:交易日期及时间
				iptparam->OilBill[IPT_OFFSET_TIME+0]=iptparam->Time.century;	
				iptparam->OilBill[IPT_OFFSET_TIME+1]=iptparam->Time.year;
				iptparam->OilBill[IPT_OFFSET_TIME+2]=iptparam->Time.month;
				iptparam->OilBill[IPT_OFFSET_TIME+3]=iptparam->Time.date;
				iptparam->OilBill[IPT_OFFSET_TIME+4]=iptparam->Time.hour;		
				iptparam->OilBill[IPT_OFFSET_TIME+5]=iptparam->Time.minute;
				iptparam->OilBill[IPT_OFFSET_TIME+6]=iptparam->Time.second;

				//已完成:卡应用号
				memcpy(&iptparam->OilBill[IPT_OFFSET_ASN], iptparam->IcAppId, 10);
				
				//已完成:余额(扣前)，交易完成后填扣后余额
				memcpy(&iptparam->OilBill[IPT_OFFSET_BALANCE], iptparam->IcLockBalance, 4);
				
				//已完成:数额，以上次解扣的数额为当前数额
				memcpy(&iptparam->OilBill[IPT_OFFSET_AMN], &iptparam->IcLockMoney[1], 3);
				
				//已完成:卡交易序号
				memcpy(&iptparam->OilBill[IPT_OFFSET_CTC], iptparam->IcLockInitCTC, 2);
				
				//已完成:电子签名，加油/补扣/补充时为TAC，逃卡时为GTAC
				memcpy(&iptparam->OilBill[IPT_OFFSET_TAC], iptparam->IcLockGTAC, 4);

				//已完成:解灰认证码4bytes，加油完成，PSAM计算GMAC后添加
				memcpy(&iptparam->OilBill[IPT_OFFSET_GMAC], "\x00\x00\x00\x00", 4);

				//已完成:PSAM灰锁签名4bytes，加油完成，PSAM计算GMAC后添加
				memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TAC], "\x00\x00\x00\x00", 4);
				
				//已完成:PSAM应用号10bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_ASN], iptparam->PsamId, 10);
				
				//已完成:PSAM编号6bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_TID], iptparam->IcLockTermId, 6);

				//已完成:PSAM终端交易序号4bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TTC], iptparam->IcPsamTTC, 4);

				//已完成:扣款来源1byte
				iptparam->OilBill[IPT_OFFSET_DS]=iptparam->DS;
				
				//已完成:结算单位/方式1byte
				iptparam->OilBill[IPT_OFFSET_UNIT]=0;
		
				//已完成:卡类1byte
				iptparam->OilBill[IPT_OFFSET_C_TYPE]=iptparam->C_TYPE;
				
				//已完成:卡版本1byte，b7~b4卡密钥索引号；b3~b0卡密钥版本号
				iptparam->OilBill[IPT_OFFSET_VER]=((iptparam->PsamKeyIndex&0x0f)<<4)|(0<<0);

				//已完成:枪号1byte
				iptparam->OilBill[IPT_OFFSET_NZN]=0;
				
				//已完成:油品代码2bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_G_CODE], "\x00\x00", 2);

				//已完成:升数3bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_VOL], "\x00\x00\x00", 3);
				
				//已完成:成交价格2bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_PRC], "\x00\x00", 2);

				//已完成:员工号1byte
				iptparam->OilBill[IPT_OFFSET_EMP]=iptparam->EMP;

				//已完成:升累计4bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_V_TOT], "\x00\x00\x00\x00", 4);
				
				//已完成:备用部分11bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_RFU], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 11);

				//待填充:T-MAC	4bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], "\x00\x00\x00\x00", 4);
				
				//已完成:物理枪号PhysicsGunId
				iptparam->OilBill[IPT_OFFSET_PHYGUN]=iptparam->PhysicalNozzle;
				
				//已完成:计量停机原因
				iptparam->OilBill[IPT_OFFSET_STOPNO]=0;

				//已完成:扣前余额
				memcpy(&iptparam->OilBill[IPT_OFFSET_BEFOR_BAL], iptparam->IcLockBalance, 4);
				
				//账单状态:0=正常；1=未完成
				iptparam->OilBill[IPT_OFFSET_ZD_STATE]=1;

				//计量设备ID
				iptparam->OilBill[IPT_OFFSET_JLNOZZLE]=iptparam->JlNozzle;

				//计算账单校验值
				iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

				//保存账单及备份
				framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
				framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);
#endif
				//转入TAC清除过程
				dsp(iptparam->DEVDsp, DSP_CARD_TACCLR_FINISH, "\x00", 0);
				iptPidSet(iptparam, IPT_PID_TM_TAC_CLEAR);
			}
		}
		
		//新卡无灰记录
		else if(0==memcmp(&buffer[2+apdu_len-2], "\x69\x85", 2)){
	
			iptparam->IcLockMark=0;																			//状态字:0x00=无灰锁；0x01=已灰锁；0x10=TAC未读
			iptparam->IcLockType=0;																			//上次发生解扣或灰锁交易的交易类型标识
			iptparam->IcLockET=0;																				//上次发生解扣或灰锁交易为ET
			memcpy(iptparam->IcLockBalance, "\x00\x00\x00\x00", 4);						//上次发生解扣或灰锁的有效余额
			memcpy(iptparam->IcLockCTC, "\x00\x00", 2);											//上次发生解扣或灰锁的交易序号
			memcpy(iptparam->IcLockTermId, "\x00\x00\x00\x00\x00\x00", 6);		//上次发生解扣或灰锁的终端编号
			memcpy(iptparam->IcLockTime, "\x00\x00\x00\x00\x00\x00\x00", 7);	//上次发生解扣或灰锁的日期时间
			memcpy(iptparam->IcLockMoney, "\x00\x00\x00\x00", 4);						//上次发生解扣或灰锁的交易金额
			memcpy(iptparam->IcLockGTAC, "\x00\x00\x00\x00", 4);							//上次发生解扣或灰锁的GTAC或TAC或MAC3

			iptPidSet(iptparam, IPT_PID_TM_BAL_READ);
		}
		//读灰锁信息失败
		else{
			
			memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
			dsp_buffer[2]=16;	memcpy(&dsp_buffer[3], "读卡灰锁信息失败", 16);
			dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
			IPT_DSP_WAIT();

			iptMainInterface(iptparam);
		}
	}
	//操作失败则提示信息后退卡
	else if(ICSTATE_FAILED==istate){
		
		iptparam->IcOverTimes=0;

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "读卡灰锁信息失败", 16);
		IPT_DSP_WAIT();

		iptMainInterface(iptparam);
	}
	//操作超时，不足三次再次操作，超过三次退卡
	else if(ICSTATE_OVERTIME==istate){
		
		iptparam->IcOverTimes++;
		if(iptparam->IcOverTimes>=3){
			
			iptparam->IcOverTimes=0;
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "读卡灰锁信息超时", 16);
			IPT_DSP_WAIT();

			iptMainInterface(iptparam);
		}
	}
	//未定义错误
	else{
		
		iptparam->IcOverTimes=0;

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "读卡灰锁信息错误", 16);
		IPT_DSP_WAIT();

		iptMainInterface(iptparam);
	}

	return;
}


/*******************************************************************
*Name				:iptTMLockRecordGet
*Description		:查询灰锁交易记录
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptTMLockRecordGet(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char tx_buffer[64]={0}, tmp_buffer[32]={0}, buffer[128]={0};
	int tx_len=0;
	unsigned char dsp_buffer[64]={0}, dsp_len=0;

	if(IPT_2PCD_UNUSED==iptparam->PcdTxFlag){

		//发送PCD查询黑/白名单命令
		tx_buffer[0]=++iptparam->PcdTxFrame;
		tx_buffer[1]=pcdMboardIDRead();
		tx_buffer[2]=iptparam->Id;
		tx_buffer[3]=iptparam->PhysicalNozzle;
		tx_buffer[4]=IPT_CMD_GREYINFO;
		memcpy(&tx_buffer[5], iptparam->IcAppId, 10);				//卡应用号
		memcpy(&tx_buffer[15], iptparam->IcLockBalance, 4);	//余额
		memcpy(&tx_buffer[19], iptparam->IcLockCTC, 2);		//CTC
		tx_buffer[21]=iptparam->DS;											//扣款来源
		memcpy(&tx_buffer[22], iptparam->IcLockTime, 7);		//日期及时间
		tx_len=29;
		//msgQSend((MSG_Q_ID)pcdMsgIdRead(), tx_buffer, tx_len, NO_WAIT, MSG_PRI_NORMAL);	

		struct msg_struct msg_stIptSend;  //fj:20170918
		msg_stIptSend.msgType = 1;
		memcpy(msg_stIptSend.msgBuffer,tx_buffer,tx_len);
		msgsnd(pcdMsgIdRead(),&msg_stIptSend,tx_len,IPC_NOWAIT);

		iptparam->PcdTxFlag=IPT_2PCD_OILPROCESS;	iptparam->PcdTxTimer=0;
	}
	else if((IPT_2PCD_OILPROCESS==iptparam->PcdTxFlag)&&(msg_len>0)&&(IPT_CMD_GREYINFO==msg_buffer[4])&&\
		(0==msg_buffer[6])&&\
		(0==memcmp(&msg_buffer[7], iptparam->IcAppId, 10))&&(0==memcmp(&msg_buffer[17], iptparam->IcLockBalance, 4))&&\
		(0==memcmp(&msg_buffer[24], iptparam->IcLockCTC, 2))&&(msg_buffer[26]==iptparam->DS)&&(0==memcmp(&msg_buffer[27], iptparam->IcLockTime, 7)))
	{
		iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdOverTimes=0;

		//保存灰锁交易数据:金额，GMAC，PsamTermId, 
		iptparam->unlockMoney=(msg_buffer[21]<<16)|(msg_buffer[22]<<8)|(msg_buffer[23]<<0);
		memcpy(iptparam->unlockCTC, &msg_buffer[24], 2);
		memcpy(iptparam->unlockGMAC, &msg_buffer[34], 4);
		//memcpy(iptparam->unlockPsamTID,  &msg_buffer[38], 6);
		memcpy(iptparam->unlockPsamTTC, &msg_buffer[44], 4);

		//转入扣款过程
		iptPidSet(iptparam, IPT_PID_TM_UNLOCK);
	}
	else
	if((IPT_2PCD_OILPROCESS==iptparam->PcdTxFlag)&&(msg_len>0)&&(IPT_CMD_GREYINFO==msg_buffer[4])&&\
		(0!=msg_buffer[6])&&\
		(0==memcmp(&msg_buffer[7], iptparam->IcAppId, 10))&&(0==memcmp(&msg_buffer[17], iptparam->IcLockBalance, 4))&&\
		(0==memcmp(&msg_buffer[24], iptparam->IcLockCTC, 2))&&(msg_buffer[26]==iptparam->DS)&&(0==memcmp(&msg_buffer[27], iptparam->IcLockTime, 7)))
	{
		iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdOverTimes=0;
	
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "无法解灰", 8);
		IPT_DSP_WAIT();

		iptMainInterface(iptparam);
	}
	else if(IPT_2PCD_OILPROCESS==iptparam->PcdTxFlag && iptparam->PcdTxTimer>=(5*ONE_SECOND)){
		
		//通讯超时重发，3次超时失败提示信息后退卡
		iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdOverTimes++;
		
		if(iptparam->PcdOverTimes>=3){
			
			iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "查询灰记录超时", 14);
			IPT_DSP_WAIT();

			iptMainInterface(iptparam);
		}
	}

	return;
}


/*******************************************************************
*Name				:iptTMBalanceRead
*Description		:内置卡余额读取过程
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptTMBalanceRead(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	int voice[16]={0};
	unsigned char buffer[128]={0};
	int apdu_len=0, istate=0;
	unsigned char dsp_buffer[64]={0}, dsp_len=0;

	//IC卡密码验证
	istate=ICBalanceRead(iptparam->DEVIC, iptparam->DEVICInternal, buffer, 128);

	//操作成功则继续下一步
	if(ICSTATE_OK==istate){

		iptparam->IcOverTimes=0;
		apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
		if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2)){
			
			//卡已读出余额
			iptparam->IcValid=1;

			//卡余额信息
			memcpy(iptparam->IcBalance, &buffer[2], 4);

			//初始化预置数据
			memset(iptparam->IntegerBuffer, 0, 4);	iptparam->IntegerLen=0;
			iptparam->Point=0;
			memset(iptparam->DecimalBuffer, 0, 2);	iptparam->DecimalLen=0;
			iptparam->PresetMode=0;	iptparam->PresetVolume=0;	iptparam->PresetMoney=0;

			//转入向PC查询验证码过程
			iptPidSet(iptparam, IPT_PID_TM_CODE_CHECK);
		}
		//读卡余额失败
		else{
			
			memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
			dsp_buffer[2]=12;	memcpy(&dsp_buffer[3], "读卡余额失败", 12);
			dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
			IPT_DSP_WAIT();

			iptMainInterface(iptparam);
		}
	}
	//操作失败则提示信息后退卡
	else if(ICSTATE_FAILED==istate)
	{
		
		iptparam->IcOverTimes=0;

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "读卡余额失败", 12);
		IPT_DSP_WAIT();

		iptMainInterface(iptparam);
	}
	//操作超时，不足三次再次操作，超过三次退卡
	else if(ICSTATE_OVERTIME==istate){
		
		iptparam->IcOverTimes++;
		if(iptparam->IcOverTimes>=3){
			
			iptparam->IcOverTimes=0;
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "读卡余额超时", 12);
			IPT_DSP_WAIT();

			iptMainInterface(iptparam);
		}
	}
	//未定义错误
	else{
		
		iptparam->IcOverTimes=0;
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "读卡余额错误", 12);
		IPT_DSP_WAIT();

		iptMainInterface(iptparam);
	}

	return;
}


/*******************************************************************
*Name				:iptTMCodeCheck
*Description		:条码自助加油加油机向PC机查询验证码
*Input				:None
*Output			:None
*Return				:None
*History			:2014-11-15,modified by syj  */

static void iptTMCodeCheck(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	int voice[16]={0};
	unsigned char tx_buffer[128]={0};
	int tx_len=0, istate=0;
	unsigned char dsp_buffer[64]={0}, dsp_len=0;

	//printf("iptparam->CPOSFlag = %d,iptparam->CPOSTimer = %d\n",iptparam->CPOSFlag,iptparam->CPOSTimer);
	
	//CPOS端要求两帧数据间应有一定间隔
	if(IPT_2CPOS_UNUSED==iptparam->CPOSFlag && iptparam->CPOSTimer>=500*ONE_MILLI_SECOND)
	{
		if(1 == iptIsLianda(iptparam->Id))
		{
			tx_buffer[0]=++iptparam->PcdTxFrame;
			tx_buffer[1]=pcdMboardIDRead();
			tx_buffer[2]=iptparam->Id;
			tx_buffer[3]=iptparam->PhysicalNozzle;
			tx_buffer[4]=IPT_CMD_BARCODE;
			tx_buffer[5]=(char)(9>>8);
			tx_buffer[6]=(char)(9>>0);
			tx_buffer[7]=0x60;
			tx_buffer[8]=iptparam->LogicNozzle;
			memcpy(&tx_buffer[9], iptparam->OilCode, 2);
			memcpy(&tx_buffer[11], iptparam->Barcode, 5);
			tx_len=16;
			//msgQSend((MSG_Q_ID)pcdMsgIdRead(), tx_buffer, tx_len, NO_WAIT, MSG_PRI_NORMAL);

			struct msg_struct msg_stIptSend;  //fj:20170918
			msg_stIptSend.msgType = 1;
			memcpy(msg_stIptSend.msgBuffer,tx_buffer,tx_len);
			msgsnd(pcdMsgIdRead(),&msg_stIptSend,tx_len,IPC_NOWAIT);
		}
		else
		{
			tx_buffer[0]=0x60;
			tx_buffer[1]=iptparam->LogicNozzle;
			memcpy(&tx_buffer[2], iptparam->OilCode, 2);
			memcpy(&tx_buffer[4], iptparam->Barcode, 5);
			tx_len=9;
			istate=CPOSWrite(iptparam->Id, IptPcInfo.SInfo.POS_P, tx_buffer, tx_len); //fj:
		}

		iptparam->CPOSFlag=IPT_2CPOS_OILPROCESS;
		iptparam->CPOSTimer=0;
	}
	else if(IPT_2CPOS_OILPROCESS==iptparam->CPOSFlag && msg_len>0 && 0xfa==msg_buffer[0] && 0x61==msg_buffer[6] && iptparam->LogicNozzle==msg_buffer[7] && 0==memcmp(iptparam->Barcode, &msg_buffer[8], 5))
	{
		//匹配，转入加油机确认PC机的查询结果过程
		if(0==msg_buffer[13])
		{
			memcpy(iptparam->BarMoney, &msg_buffer[14], 3);
			iptparam->InvoiceMark=msg_buffer[17];
			iptPidSet(iptparam, IPT_PID_TM_CODE_ACK);
		}
		//油品不对，提示错误信息
		else if(1==msg_buffer[13])
		{
			//语音提示"油品选择错误，请选择对应的油品"
			if(iptparam->VoiceVolume>0 && IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType)
			{
				voice[0]=SPKW_SELECTERR;	iptSpk(iptparam, voice, 1);
			}
			else if(iptparam->VoiceVolume>0 && IPT_VOICE_TYPE_MAN==iptparam->VoiceType)
			{
				voice[0]=SPKM_SELECTERR;		iptSpk(iptparam, voice, 1);
			}

			//促销机通知平板油机错误信息
			if(1 == paramPromotionGet())
			{
				iptparam->TaState = IPT_STATE_ERROR_INFO;	iptparam->TaStateParamLength = 0;
				memset(iptparam->TaStateParam, 0, sizeof(iptparam->TaStateParam));
				strcpy(iptparam->TaStateParam, "油品不对");	
				iptparam->TaStateParamLength = strlen(iptparam->TaStateParam);
				pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
			}

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "    油品不对    ", 16);
			IPT_DSP_WAIT();
			
			iptMainInterface(iptparam);
		}
		//密码信息过有效期，提示错误信息
		else if(2==msg_buffer[13])
		{
			//语音提示"条码小票已过期，请到营业室处理"
			if(iptparam->VoiceVolume>0 && IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType)
			{
				voice[0]=SPKW_CODEEXPIRED;	iptSpk(iptparam, voice, 1);
			}
			else if(iptparam->VoiceVolume>0 && IPT_VOICE_TYPE_MAN==iptparam->VoiceType)
			{
				voice[0]=SPKM_CODEEXPIRED;	iptSpk(iptparam, voice, 1);
			}

			//促销机通知平板油机错误信息
			if(1 == paramPromotionGet())
			{
				iptparam->TaState = IPT_STATE_ERROR_INFO;	iptparam->TaStateParamLength = 0;
				memset(iptparam->TaStateParam, 0, sizeof(iptparam->TaStateParam));
				strcpy(iptparam->TaStateParam, "验证码过有效期");	
				iptparam->TaStateParamLength = strlen(iptparam->TaStateParam);
				pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
			}

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, " 验证码过有效期 ", 16);
			IPT_DSP_WAIT();
			
			iptMainInterface(iptparam);
		}
		//验证码不匹配，提示错误信息
		else if(3==msg_buffer[13])
		{
			//语音提示"验证码错误请重新输入"
			if(iptparam->VoiceVolume>0 && IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType)
			{
				voice[0]=SPKW_CODEINAGINE;	iptSpk(iptparam, voice, 1);
			}
			else if(iptparam->VoiceVolume>0 && IPT_VOICE_TYPE_MAN==iptparam->VoiceType)
			{
				voice[0]=SPKM_CODEINAGINE;	iptSpk(iptparam, voice, 1);
			}

			//促销机通知平板油机错误信息
			if(1 == paramPromotionGet())
			{
				iptparam->TaState = IPT_STATE_ERROR_INFO;	iptparam->TaStateParamLength = 0;
				memset(iptparam->TaStateParam, 0, sizeof(iptparam->TaStateParam));
				strcpy(iptparam->TaStateParam, "验证码不匹配");	
				iptparam->TaStateParamLength = strlen(iptparam->TaStateParam);
				pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
			}

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "  验证码不匹配  ", 16);
			IPT_DSP_WAIT();
			
			iptMainInterface(iptparam);
		}
		//未定义的错误，提示错误信息
		else
		{
			//促销机通知平板油机错误信息
			if(1 == paramPromotionGet())
			{
				iptparam->TaState = IPT_STATE_ERROR_INFO;	iptparam->TaStateParamLength = 0;
				memset(iptparam->TaStateParam, 0, sizeof(iptparam->TaStateParam));
				strcpy(iptparam->TaStateParam, "验证码查询错误");	
				iptparam->TaStateParamLength = strlen(iptparam->TaStateParam);
				pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
			}
		
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, " 验证码查询错误 ", 16);
			IPT_DSP_WAIT();
			
			iptMainInterface(iptparam);
		}

		iptparam->CPOSFlag=IPT_2CPOS_UNUSED;	iptparam->CPOSOvertimes=0;	iptparam->CPOSTimer=0;
	}
	else if(IPT_2CPOS_OILPROCESS==iptparam->CPOSFlag && iptparam->CPOSTimer>=(5*ONE_SECOND))
	{
		//通讯超时重发，3次超时失败提示信息
		iptparam->CPOSFlag=IPT_2CPOS_UNUSED;	iptparam->CPOSOvertimes++;	iptparam->CPOSTimer=0;
		if(iptparam->CPOSOvertimes>=3)
		{
			//促销机通知平板油机错误信息
			if(1 == paramPromotionGet())
			{
				iptparam->TaState = IPT_STATE_ERROR_INFO;	iptparam->TaStateParamLength = 0;
				memset(iptparam->TaStateParam, 0, sizeof(iptparam->TaStateParam));
				strcpy(iptparam->TaStateParam, "验证码查询超时");	
				iptparam->TaStateParamLength = strlen(iptparam->TaStateParam);
				pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
			}
		
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, " 验证码查询超时 ", 16);
			IPT_DSP_WAIT();
			
			iptMainInterface(iptparam);
			iptparam->CPOSFlag=IPT_2CPOS_UNUSED;	
			iptparam->CPOSOvertimes=0;
		}
	}

	return;
}


/*******************************************************************
*Name				:iptTMCodeACK
*Description		:条码自助加油加油机确认PC机的查询结果
*Input				:None
*Output			:None
*Return				:None
*History			:2014-11-15,modified by syj  */

static void iptTMCodeACK(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	int voice[SPK_MAX_NUMBER]={0}, voice_len=0, voice_data=0, voice_tmp[16]={0};
	unsigned char tx_buffer[128]={0};
	int tx_len=0, len=0, i=0, price=0;
	unsigned char dsp_buffer[64]={0}, dsp_len=0;
	unsigned long long volume_sum=0, money_sum=0;

	//CPOS端要求两帧数据间应有一定间隔
	if(IPT_2CPOS_UNUSED==iptparam->CPOSFlag && iptparam->CPOSTimer>=500*ONE_MILLI_SECOND)
	{
		if(1 == iptIsLianda(iptparam->Id))
		{
			tx_buffer[0]=++iptparam->PcdTxFrame;
			tx_buffer[1]=pcdMboardIDRead();
			tx_buffer[2]=iptparam->Id;
			tx_buffer[3]=iptparam->PhysicalNozzle;
			tx_buffer[4]=IPT_CMD_BARCODE;
			tx_buffer[5]=(char)(7>>8);
			tx_buffer[6]=(char)(7>>0);
			tx_buffer[7]=0x62;
			tx_buffer[8]=iptparam->LogicNozzle;
			memcpy(&tx_buffer[9], iptparam->Barcode, 5);
			tx_len=14;
			//msgQSend((MSG_Q_ID)pcdMsgIdRead(), tx_buffer, tx_len, NO_WAIT, MSG_PRI_NORMAL);

			struct msg_struct msg_stIptSend;  //fj:20170918
			msg_stIptSend.msgType = 1;
			memcpy(msg_stIptSend.msgBuffer,tx_buffer,tx_len);
			msgsnd(pcdMsgIdRead(),&msg_stIptSend,tx_len,IPC_NOWAIT);

		}
		else
		{
			tx_buffer[0]=0x62;
			tx_buffer[1]=iptparam->LogicNozzle;
			memcpy(&tx_buffer[2], iptparam->Barcode, 5);
			tx_len=7; //fj:
			CPOSWrite(iptparam->Id, IptPcInfo.SInfo.POS_P, tx_buffer, tx_len);
		}
		
		iptparam->CPOSFlag=IPT_2CPOS_OILPROCESS;	iptparam->CPOSTimer=0;
	}
	else	if(IPT_2CPOS_OILPROCESS==iptparam->CPOSFlag && msg_len>0 && 0xfa==msg_buffer[0] && 0x63==msg_buffer[6] && iptparam->LogicNozzle==msg_buffer[7])
	{
		//已锁定，转入油机提枪提示界面
		if(0==msg_buffer[8])
		{
			//初始化本次加油数据
			//获取单价,fj:
			jlPriceRead(iptparam->JlNozzle, &iptparam->OilPrice);
			iptparam->OilMoney=0;	iptparam->OilVolume=0;		iptparam->OilPrice=iptparam->OilPrice;
			//获取总累,fj:
			jlSumRead(iptparam->JlNozzle, &volume_sum, &money_sum);
			iptparam->SumMoney=money_sum;	iptparam->SumVolume=volume_sum;
			//记录加油时间
			iptparam->OilTime[0]=iptparam->Time.century;	iptparam->OilTime[1]=iptparam->Time.year;
			iptparam->OilTime[2]=iptparam->Time.month;		iptparam->OilTime[3]=iptparam->Time.date;
			iptparam->OilTime[4]=iptparam->Time.hour;		iptparam->OilTime[5]=iptparam->Time.minute;
			iptparam->OilTime[6]=iptparam->Time.second;
			iptparam->OilRound=0;
			//计算预置量
			iptparam->PresetMoney=(iptparam->BarMoney[0]<<16)|(iptparam->BarMoney[1]<<8)|(iptparam->BarMoney[2]<<0);
			iptparam->PresetMode=IPT_PRESET_MONEY;
			if((iptparam->PresetMoney*1000/iptparam->OilPrice%10)<IPT_ROUNDING)iptparam->PresetVolume=iptparam->PresetMoney*100/iptparam->OilPrice;
			else																													iptparam->PresetVolume=iptparam->PresetMoney*100/iptparam->OilPrice+1;


			//初始化条码自助账单数据
			//条码自助账单:1byte枪号
			iptparam->BarOilBill[IPT_BAR_OFF_NOZZLE]=iptparam->LogicNozzle;
			//条码自助账单:4bytes POS_TTC
			memcpy(&iptparam->BarOilBill[IPT_BAR_OFF_TTC], "\x00\x00\x00\x00", 4);
			//条码自助账单:7bytes日期时间
			memcpy(&iptparam->BarOilBill[IPT_BAR_OFF_TIME], iptparam->OilTime, 7);
			//条码自助账单:3bytes加油金额
			memcpy(&iptparam->BarOilBill[IPT_BAR_OFF_MONEY], "\x00\x00\x00", 3);
			//条码自助账单:3bytes加油升数
			memcpy(&iptparam->BarOilBill[IPT_BAR_OFF_VOLUME], "\x00\x00\x00", 3);
			//条码自助账单:3bytes预付金额
			memcpy(&iptparam->BarOilBill[IPT_BAR_OFF_AUTH_MONEY], iptparam->BarMoney, 3);
			//条码自助账单:5bytes授权验证码
			memcpy(&iptparam->BarOilBill[IPT_BAR_OFF_AUTH_CODE], iptparam->Barcode, 5);
			//条码自助账单:2bytes单价,fj:
			jlPriceRead(iptparam->JlNozzle, &price);
			iptparam->BarOilBill[IPT_BAR_OFF_PRICE+0]=(unsigned char)(price>>8);	
			iptparam->BarOilBill[IPT_BAR_OFF_PRICE+1]=(unsigned char)(price>>0);
			//条码自助账单:2bytes油品代码；
			memcpy(&iptparam->BarOilBill[IPT_BAR_OFF_OIL_CODE], iptparam->OilCode, 2);
			//条码自助账单:1byte账单状态0=已上传；1=未上传；
			iptparam->BarOilBill[IPT_BAR_OFF_STATE]=1;
			//条码自助账单:1byte异或校验码
			iptparam->BarOilBill[IPT_BAR_OFF_CHECK]=xorGet(iptparam->BarOilBill, IPT_BAR_BILL_SIZE-1);
			//条码自助账单:数据存储
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_TM, iptparam->BarOilBill, IPT_BAR_BILL_SIZE);
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_TM2, iptparam->BarOilBill, IPT_BAR_BILL_SIZE);


			//语音提示
			if(iptparam->VoiceVolume>0 && IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType)
			{
				//您此次的授权金额为
				voice[voice_len++]=SPKW_AUTHORIZEMONEY;		
				//XXXX.XX
				voice_data=(iptparam->BarMoney[0]<<16)|(iptparam->BarMoney[1]<<8)|(iptparam->BarMoney[2]<<0);
				len=iptHexVoiceIdGet(iptparam, voice_data, voice_tmp);	
				for(i=0; i<len; i++)	voice[voice_len++]=voice_tmp[i];
				//元
				voice[voice_len++]=SPKW_YUAN;
				iptSpk(iptparam, voice, voice_len);
			}
			else if(iptparam->VoiceVolume>0 && IPT_VOICE_TYPE_MAN==iptparam->VoiceType)
			{
				//您此次的授权金额为
				voice[voice_len++]=SPKM_AUTHORIZEMONEY;		
				//XXXX.XX
				voice_data=(iptparam->BarMoney[0]<<16)|(iptparam->BarMoney[1]<<8)|(iptparam->BarMoney[2]<<0);
				len=iptHexVoiceIdGet(iptparam, voice_data, voice_tmp);	
				for(i=0; i<len; i++)	voice[voice_len++]=voice_tmp[i];
				//元
				voice[voice_len++]=SPKM_YUAN;
				iptSpk(iptparam, voice, voice_len);
			}
			
			//转入提枪加油提示界面
			dsp_buffer[0]=iptparam->BarMoney[0];	dsp_buffer[1]=iptparam->BarMoney[1];	dsp_buffer[2]=iptparam->BarMoney[2];
			dsp_len=3;
			dsp(iptparam->DEVDsp, DSP_TM_AUTHORIZE, dsp_buffer, dsp_len);
			iptPidSet(iptparam, IPT_PID_TM_AUTHORIZED);

			//促销机通知平板油机状态
			if(1 == paramPromotionGet())
			{
				iptparam->TaState = IPT_STATE_TM_APPLY_OK;	iptparam->TaStateParamLength = 0;
				*(iptparam->TaStateParam + 0) = 0;	
				*(iptparam->TaStateParam + 1) =*(iptparam->BarMoney + 0);
				*(iptparam->TaStateParam + 2) =*(iptparam->BarMoney + 1);
				*(iptparam->TaStateParam + 3) =*(iptparam->BarMoney + 2);
				iptparam->TaStateParamLength = 4;
				pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
			}
		}
		//锁定失败，提示错误信息
		else
		{
			//促销机通知平板油机错误信息
			if(1 == paramPromotionGet())
			{
				iptparam->TaState = IPT_STATE_ERROR_INFO;	iptparam->TaStateParamLength = 0;
				memset(iptparam->TaStateParam, 0, sizeof(iptparam->TaStateParam));
				strcpy(iptparam->TaStateParam, "授权锁定失败");	
				iptparam->TaStateParamLength = strlen(iptparam->TaStateParam);
				pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
			}
		
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "  授权锁定失败  ", 16);
			IPT_DSP_WAIT();

			iptMainInterface(iptparam);
		}

		iptparam->CPOSFlag=IPT_2CPOS_UNUSED;	iptparam->CPOSOvertimes=0;	iptparam->CPOSTimer=0;
	}
	else if(IPT_2CPOS_OILPROCESS==iptparam->CPOSFlag && iptparam->CPOSTimer>=(5*ONE_SECOND))
	{
		//通讯超时重发，3次超时失败提示信息
		iptparam->CPOSFlag=IPT_2CPOS_UNUSED;	iptparam->CPOSOvertimes++;	iptparam->CPOSTimer=0;
		if(iptparam->CPOSOvertimes>=3)
		{
			//促销机通知平板油机错误信息
			if(1 == paramPromotionGet())
			{
				iptparam->TaState = IPT_STATE_ERROR_INFO;	iptparam->TaStateParamLength = 0;
				memset(iptparam->TaStateParam, 0, sizeof(iptparam->TaStateParam));
				strcpy(iptparam->TaStateParam, "授权锁定超时");	
				iptparam->TaStateParamLength = strlen(iptparam->TaStateParam);
				pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
			}
		
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "  授权锁定超时  ", 16);
			IPT_DSP_WAIT();

			iptMainInterface(iptparam);

			iptparam->CPOSFlag=IPT_2CPOS_UNUSED;	iptparam->CPOSOvertimes=0;
		}
	}

	return;
}


/*******************************************************************
*Name				:iptTMAuthorized
*Description		:条码自助加油提枪加油提示界面
*Input				:None	
*Output			:None
*Return				:None
*History			:2014-10-22,modified by syj  */

static void iptTMAuthorized(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char dsp_buffer[32]={0}, dsp_len=0;

	//提枪，转入加油数据检查过程
	if((1 == iptIsBig260(iptparam->Id) && KB_BUTTON_DOWN == iptparam->Button)||\
		(1 != iptIsBig260(iptparam->Id) && IPT_GUN_PUTUP == iptparam->GunState && 0 != iptparam->GunStateChg))
	{
		dsp(iptparam->DEVDsp, DSP_TM_OILSTART, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_TM_OILCHECK);

		//促销机通知平板油机状态
		if(1 == paramPromotionGet())
		{
			iptparam->TaState = IPT_STATE_TM_OIL_START;	iptparam->TaStateParamLength = 0;
			pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
		}
		return;
	}

	//按"取消"键，取消本次授权，产生一笔零加油交易
	if(KB_BUTTON_CLR==iptparam->Button)
	{
		dsp(iptparam->DEVDsp, DSP_TM_AUTHORIZE_CANCEL, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_TM_ZD_UPLOAD);
		return;
	}

	//按"选择"键，转入支付方式选择界面
	if(KB_BUTTON_SEL==iptparam->Button)
	{
		dsp(iptparam->DEVDsp, DSP_CARD_SETTLE_SELECT, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_TM_PAY_MODE);
		return;
	}
	
	return;
}


/*******************************************************************
*Name				:iptTMPayModeSelect
*Description		:结算方式选择
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptTMPayModeSelect(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char dsp_buffer[64]={0}, dsp_len=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_1:	//选择现金
	//case KB_BUTTON_2:	选择油票
	//case KB_BUTTON_3:	选择提油凭证
	//case KB_BUTTON_4:	选择银行卡
	case KB_BUTTON_5:	//选择其它一
	//case KB_BUTTON_6:	选择其它二
		//选择结算方式，条码自助加油暂时只支持选择"现金"或"其它一"
		if(KB_BUTTON_1==iptparam->Button)	iptparam->Payment=IPT_PAYMENT_MONEY;
		if(KB_BUTTON_2==iptparam->Button)	iptparam->Payment=IPT_PAYMENT_OILTICKET;
		if(KB_BUTTON_3==iptparam->Button)	iptparam->Payment=IPT_PAYMENT_OILCHECK;
		if(KB_BUTTON_4==iptparam->Button)	iptparam->Payment=IPT_PAYMENT_BANK;
		if(KB_BUTTON_5==iptparam->Button)	iptparam->Payment=IPT_PAYMENT_OTHER1;
		if(KB_BUTTON_6==iptparam->Button)	iptparam->Payment=IPT_PAYMENT_OTHER2;				

		//返回授权结果界面
		dsp_buffer[0]=iptparam->BarMoney[0];	dsp_buffer[1]=iptparam->BarMoney[1];	dsp_buffer[2]=iptparam->BarMoney[2];
		dsp_len=3;
		dsp(iptparam->DEVDsp, DSP_TM_AUTHORIZE, dsp_buffer, dsp_len);
		iptPidSet(iptparam, IPT_PID_TM_AUTHORIZED);
		break;

	case KB_BUTTON_CHG:
		//按"更改"键返回授权结果界面
		dsp_buffer[0]=iptparam->BarMoney[0];	dsp_buffer[1]=iptparam->BarMoney[1];	dsp_buffer[2]=iptparam->BarMoney[2];
		dsp_len=3;
		dsp(iptparam->DEVDsp, DSP_TM_AUTHORIZE, dsp_buffer, dsp_len);
		iptPidSet(iptparam, IPT_PID_TM_AUTHORIZED);
		break;
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptTMOilAck
*Description		:油品确认界面
*Input				:None
*Output			:None
*Return				:None
*History			:2016-01-29,modified by syj  */

static void iptTMOilAck(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	//按油品确认键确认油品
	if(KB_BUTTON_ACK == iptparam->Button)
	{
		return;
	}

	//挂枪放弃此次操作并返回授权结果界面
	if(IPT_GUN_PUTDOWN == iptparam->GunState)
	{
		return;
	}

	return;
}


/*******************************************************************
*Name				:iptTMOilCheck
*Description		:加油数据检查过程
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptTMOilCheck(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned int data=0, i=0;
	unsigned char tmp_buffer[64]={0}, dsp_buffer[64]={0}, dsp_len=0;
	unsigned long long money_sum=0, volume_sum=0;
	int istate = 0;

	//判断电源状态
	if(POWER_STATE_OK!=powerStateRead())
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "油机电源状态异常", 16);
		IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "条码加油启动失败，油机电源状态异常!");
		
		istate = 1;
		goto DONE;
	}

	//判断获取单价结果,fj:
	if(0!=jlPriceRead(iptparam->JlNozzle, &iptparam->OilPrice))
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "获取单价失败", 16);
		IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "条码加油启动失败，获取单价失败!");
		
		istate = 1;
		goto DONE;
	}

	if(iptparam->JlErr_BianJia!=0)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "变价失败",8);
		IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "条码加油启动失败，变价失败！");
		
		istate = 1;
		goto DONE;
	}

	//判断单价合法性
	if((iptparam->OilPrice<IPT_PRICE_MIN)||(iptparam->OilPrice>IPT_PRICE_MAX))
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "单价非法", 16);
		IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "条码加油启动失败，单价非法!");

		istate = 1;
		goto DONE;
	}

	//判断销售锁定
	if(IPT_SELL_UNLOCK!=iptparam->SellLock)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "加油启动锁定", 12);
		IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "条码加油启动失败，加油启动锁定!");

		istate = 1;
		goto DONE;
	}

	//判断夜间锁定
	if(IPT_NIGHT_UNLOCK!=iptparam->NightLock)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "夜间锁定", 8);
		IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "条码加油启动失败，夜间锁定!");

		istate = 1;
		goto DONE;
	}

	//判断钥匙状态
	if(KB_KEYLOCK_OIL!=iptparam->KeyLock)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "请把钥匙打到加油位置", strlen("请把钥匙打到加油位置"));
		IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "条码加油启动失败，钥匙在设置位置!");

		istate = 1;
		goto DONE;
	}

	//判断时间合法性
	tmp_buffer[0]=iptparam->Time.century;	tmp_buffer[1]=iptparam->Time.year;	tmp_buffer[2]=iptparam->Time.month;	tmp_buffer[3]=iptparam->Time.date;
	tmp_buffer[4]=iptparam->Time.hour;tmp_buffer[5]=iptparam->Time.minute;tmp_buffer[6]=iptparam->Time.second;
	if(0!=timeVerification(tmp_buffer, 7))
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "油机时间非法", 12);
		IPT_DSP_WAIT();

		sprintf(dsp_buffer, "%2x%2x-%2x-%2x %2x:%2x:%2x", tmp_buffer[0],\
			tmp_buffer[1],tmp_buffer[2],tmp_buffer[3],tmp_buffer[4],tmp_buffer[5],tmp_buffer[6]);
		jljOilErrLogWrite(iptparam->Id, "条码加油启动失败，油机时间非法[%s]!", dsp_buffer);

		istate = 1;
		goto DONE;
	}

	//判断物理枪号合法性
	if((iptparam->PhysicalNozzle<1)||(iptparam->PhysicalNozzle>6))
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "物理枪号非法", 12);
		IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "条码加油启动失败，物理枪号非法[物理枪号=%d]!", iptparam->PhysicalNozzle);

		istate = 1;
		goto DONE;
	}

	//判断PCD连接状态
	if(1!=iptparam->PcdState)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "与PCD连接断开", 13);
		IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "条码加油启动失败，与PCD连接断开!");

		istate = 1;
		goto DONE;
	}

	//判断PCD异常状态
	if(0!=iptparam->PcdErrNO)
	{
		memcpy(&dsp_buffer[0], "PCD状态异常", 11);
		dsp_buffer[11]=(iptparam->PcdErrNO>>4)&0x0f+0x30;
		dsp_buffer[12]=(iptparam->PcdErrNO>>0)&0x0f+0x30;
		dsp_len=13;
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);
		IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "条码加油启动失败，PCD状态异常!");

		istate = 1;
		goto DONE;
	}

	//判断通用信息版本合法性
	if(0==IptPcInfo.SInfo.Version)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "通用信息版本非法", 16);
		IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "条码加油启动失败，通用信息版本非法[版本=%d]!", IptPcInfo.SInfo.Version);

		istate = 1;
		goto DONE;
	}

	//判断油品油价版本
	if(0==IptPcInfo.OilInfo.Version)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "油品油价版本非法", 16);
		IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "条码加油启动失败，油品油价版本非法[版本=%d]!",IptPcInfo.OilInfo.Version);

		istate = 1;
		goto DONE;
	}

	//判断逻辑枪号合法性
	if(0==iptparam->LogicNozzle)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "逻辑枪号非法", 12);
		IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "条码加油启动失败，逻辑枪号非法[枪号=%d]!",iptparam->LogicNozzle);

		istate = 1;
		goto DONE;
	}

	//判断加油机是否下班
	if(IPT_WORK_ONDUTY!=iptparam->WorkState)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "加油机下班", 12);
		IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "条码加油启动失败，加油机下班!");

		istate = 1;
		goto DONE;
	}

	//判断卡余额，任意加油时若卡内余额小于最大允许量则以卡内余额做预置金额加油
	//	社会站联达加油系统无内置卡，不判断此选项
	
	data=(iptparam->IcBalance[0]<<24)|(iptparam->IcBalance[1]<<16)|(iptparam->IcBalance[2]<<8)|(iptparam->IcBalance[3]<<0);
	if(1!=iptIsLianda(iptparam->Id) && iptparam->PresetMoney>data)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "内置卡余额不足", 14);
		IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "条码加油启动失败，内置卡余额不足![预置=%d][余额=%d].", iptparam->PresetMoney, data);

		istate = 1;
		goto DONE;
	}

	//判断预置量是否过小，不小于1升
	if(iptparam->PresetMoney<iptparam->OilPrice || iptparam->PresetMoney<IPT_MONEY_MIN || iptparam->PresetVolume<IPT_VOLUME_MIN)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "预置量太小", 10);
		IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "条码加油启动失败，预置量太小![预置=%d].", data);

		istate = 1;
		goto DONE;
	}

	//判断预置量是否过大
	if(iptparam->PresetMoney>JL_MONEY_MAX || iptparam->PresetVolume>JL_VOLUME_MAX)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "预置量太大", 10);
		IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "条码加油启动失败，预置量太大![预置=%d].", data);

		istate = 1;
		goto DONE;
	}

	
DONE:
	//失败时，联达加油站系统程序直接返回待机界面
	if(0 != istate && 1 == iptIsLianda(iptparam->Id))	
	{
		iptMainInterface(iptparam);
		return;
	}		
	if(0 != istate && 1 != iptIsLianda(iptparam->Id))
	{
		dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_TM_ZD_UPLOAD);
		return;
	}

	//转入加油认证或灰锁初始化过程；
	//	社会站联达加油系统直接转入加油申请过程；
	
	if(1 == iptIsLianda(iptparam->Id))
	{
		iptPidSet(iptparam, IPT_PID_TM_OILSTART);
	}
	else
	{
		if(0==iptparam->DESAuthen)	iptPidSet(iptparam, IPT_PID_TM_OIL_AUTHEN);
		else											iptPidSet(iptparam, IPT_PID_TM_LOCK_INIT);
	}

	return;
}


/*******************************************************************
*Name				:iptTMOilAuthen
*Description		:条码自助，加油启动认证
*Input				:None
*Output			:None
*Return				:None
*History			:2014-04-17,modified by syj  */

static void iptTMOilAuthen(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char buffer[128]={0}, dsp_buffer[64]={0}, dsp_len=0;
	unsigned char irandom[8]={0};
	int istate=0, apdu_len=0;

	switch(iptparam->Step)
	{
	case 0:	
		//判断安全提升状态
		istate=PsamGetAPProof(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate){
			
			iptparam->IcOverTimes=0;
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2)){
				
				iptparam->PsamProofTimes=buffer[2];	iptparam->Step++;
			}
			else if(0==memcmp(&buffer[2+apdu_len-2], "\x6D\x00", 2) || 0==memcmp(&buffer[2+apdu_len-2], "\x9B\x01", 2) )
			{
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=12;	memcpy(&dsp_buffer[3], "请更换PSAM卡", 12);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				IPT_DSP_WAIT();

				dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
				iptPidSet(iptparam, IPT_PID_TM_ZD_UPLOAD);
			}
			else if(0==memcmp(&buffer[2+apdu_len-2], "\x9B\x02", 2)){
				
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=10;	memcpy(&dsp_buffer[3], "芯片未注册", 10);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				IPT_DSP_WAIT();

				dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
				iptPidSet(iptparam, IPT_PID_TM_ZD_UPLOAD);
			}
			else if(0==memcmp(&buffer[2+apdu_len-2], "\x9B\x03", 2)){
				
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=29;	memcpy(&dsp_buffer[3], "安全锁定,请更换PSAM或重新绑定", 29);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				IPT_DSP_WAIT();

				dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
				iptPidSet(iptparam, IPT_PID_TM_ZD_UPLOAD);
			}
			else{
				
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=20;	memcpy(&dsp_buffer[3], "获取安全提升状态失败", 20);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				IPT_DSP_WAIT();

				dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
				iptPidSet(iptparam, IPT_PID_TM_ZD_UPLOAD);
			}
		}
		//操作失败则提示错误信息
		else if(ICSTATE_FAILED==istate){
			
			iptparam->IcOverTimes=0;
		
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "获取安全提升状态失败", 20);
			IPT_DSP_WAIT();

			dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
			iptPidSet(iptparam, IPT_PID_TM_ZD_UPLOAD);
		}
		//操作超时，不足三次再次操作，超过三次退出
		else if(ICSTATE_OVERTIME==istate)
		{
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3){
				
				iptparam->IcOverTimes=0;
				
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "获取安全提升状态超时", 20);
				IPT_DSP_WAIT();

				dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
				iptPidSet(iptparam, IPT_PID_TM_ZD_UPLOAD);
			}
		}
		//未定义错误
		else{
			
			iptparam->IcOverTimes=0;
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "获取安全提升状态错误", 20);
			IPT_DSP_WAIT();

			dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
			iptPidSet(iptparam, IPT_PID_TM_ZD_UPLOAD);
		}
		break;
		
	case 1:	
		//向PSAM申请随机数
		istate=PsamGetRandom(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate){
			
			iptparam->IcOverTimes=0;
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2)){
				
				memcpy(&irandom[0], &buffer[2], 4);					//随机数
				memcpy(&irandom[4], "\x00\x00\x00\x00", 4);	//随机数后补0
				des_en3(Key, irandom, 8, iptparam->DESCiphertext);

				iptparam->Step++;
			}
			else{
				
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=22;	memcpy(&dsp_buffer[3], "安全提升申请随机数失败", 22);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				IPT_DSP_WAIT();

				dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
				iptPidSet(iptparam, IPT_PID_TM_ZD_UPLOAD);
			}
		}
		//操作失败则提示错误信息
		else if(ICSTATE_FAILED==istate){
			
			iptparam->IcOverTimes=0;
		
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "安全提升申请随机数失败", 22);
			IPT_DSP_WAIT();

			dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
			iptPidSet(iptparam, IPT_PID_TM_ZD_UPLOAD);
		}
		//操作超时，不足三次再次操作，超过三次退出
		else if(ICSTATE_OVERTIME==istate){
			
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3){
				
				iptparam->IcOverTimes=0;

				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "安全提升申请随机数超时", 22);
				IPT_DSP_WAIT();

				dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
				iptPidSet(iptparam, IPT_PID_TM_ZD_UPLOAD);
			}
		}
		//未定义错误
		else{
			
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "安全提升申请随机数错误", 22);
			IPT_DSP_WAIT();

			dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
			iptPidSet(iptparam, IPT_PID_TM_ZD_UPLOAD);
		}
		break;

	case 2:	
		//向PSAM进行安全提升认证 ANTI-PLAGIAREZE AUTHENTICATION
		istate=PsamAPAuthen(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, iptparam->DESCiphertext);

		//操作成功则继续下一步
		if(ICSTATE_OK==istate){
			
			iptparam->IcOverTimes=0;
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2)){
				
				iptPidSet(iptparam, IPT_PID_TM_LOCK_INIT);
			}
			else if(0x6B==buffer[2+apdu_len-2]){
				
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=22;
				memcpy(&dsp_buffer[3], "认证失败,剩余", 13);
				dsp_buffer[16]=(buffer[2+apdu_len-1]/100)+0x30;			if('0'==dsp_buffer[16])	dsp_buffer[16]=' ';
				dsp_buffer[17]=(buffer[2+apdu_len-1]%100/10)+0x30;	if('0'==dsp_buffer[17])	dsp_buffer[17]=' ';
				dsp_buffer[18]=(buffer[2+apdu_len-1]%10/1)+0x30;
				memcpy(&dsp_buffer[19], "次机会", 6);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				IPT_DSP_WAIT();

				dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
				iptPidSet(iptparam, IPT_PID_TM_ZD_UPLOAD);
			}
			else{
				
				memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
				dsp_buffer[2]=12;	memcpy(&dsp_buffer[3], "安全认证失败", 12);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				IPT_DSP_WAIT();

				dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
				iptPidSet(iptparam, IPT_PID_TM_ZD_UPLOAD);
			}
		}
		//操作失败则提示错误信息
		else if(ICSTATE_FAILED==istate){
			
			iptparam->IcOverTimes=0;
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "安全认证失败", 12);
			IPT_DSP_WAIT();

			dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
			iptPidSet(iptparam, IPT_PID_TM_ZD_UPLOAD);
		}
		//操作超时，不足三次再次操作，超过三次退出
		else if(ICSTATE_OVERTIME==istate){
			
			iptparam->IcOverTimes++;
			if(iptparam->IcOverTimes>=3){
				
				iptparam->IcOverTimes=0;
				
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "安全认证超时", 12);
				IPT_DSP_WAIT();

				dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
				iptPidSet(iptparam, IPT_PID_TM_ZD_UPLOAD);
			}
		}
		//未定义错误
		else{
			
			iptparam->IcOverTimes=0;
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "安全认证错误", 12);
			IPT_DSP_WAIT();

			dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
			iptPidSet(iptparam, IPT_PID_TM_ZD_UPLOAD);
		}
		break;

	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptTMIcLockInit
*Description		:条码自助，内置卡灰锁初始化过程
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptTMIcLockInit(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char buffer[128]={0}, dsp_buffer[64]={0}, dsp_len=0;
	int istate=0, apdu_len=0;

	//发送IC卡灰锁初始化命令
	istate=ICLockInit(iptparam->DEVIC, iptparam->DEVICInternal, buffer, 128, iptparam->PsamKeyIndex, iptparam->PsamTermId);

	//操作成功则继续下一步
	if(ICSTATE_OK==istate){
		
		iptparam->IcOverTimes=0;
		apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
		if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2)){
			
			memcpy(iptparam->IcLockInitBalance, &buffer[2], 4);		//灰锁初始化返回卡余额		
			memcpy(iptparam->IcLockInitCTC, &buffer[6], 2);			//灰锁初始化返回脱机交易序号
			memcpy(iptparam->IcLockInitOverdraw, &buffer[8], 3);	//灰锁初始化返回透支限额
			iptparam->IcLockInitKeysVersion=buffer[11];					//灰锁初始化返回密钥版本号		
			iptparam->IcLockInitArithmetic=buffer[12];						//灰锁初始化返回算法标识	
			memcpy(iptparam->IcLockInitRandom, &buffer[13], 4);	//灰锁初始化返回伪随机数

			iptPidSet(iptparam, IPT_PID_TM_MAC1);						//转入PSAM灰锁初始化计算MAC1过程
		}
		else{
			
			memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
			dsp_buffer[2]=14;	memcpy(&dsp_buffer[3], "灰锁初始化失败", 14);
			dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
			IPT_DSP_WAIT();

			dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
			iptPidSet(iptparam, IPT_PID_TM_ZD_UPLOAD);
		}
	}
	//操作失败则提示错误信息
	else if(ICSTATE_FAILED==istate){
		
		iptparam->IcOverTimes=0;
			
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "灰锁初始化失败", 14);
		IPT_DSP_WAIT();

		dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_TM_ZD_UPLOAD);
	}
	//操作超时，不足三次再次操作，超过三次退出
	else if(ICSTATE_OVERTIME==istate){
		
		iptparam->IcOverTimes++;
		if(iptparam->IcOverTimes>=3){
			
			iptparam->IcOverTimes=0;
					
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "灰锁初始化超时", 14);
			IPT_DSP_WAIT();

			dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
			iptPidSet(iptparam, IPT_PID_TM_ZD_UPLOAD);
		}
	}
	//未定义错误
	else{
		
		iptparam->IcOverTimes=0;
					
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "灰锁初始化错误", 14);
		IPT_DSP_WAIT();

		dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_TM_ZD_UPLOAD);
	}

	return;
}


/*******************************************************************
*Name				:iptTMIcMac1
*Description		:条码自助，PSAM灰锁初始化计算MAC1过程
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptTMMac1(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char buffer[128]={0}, dsp_buffer[64]={0}, dsp_len=0;
	int istate=0, apdu_len=0;

	//发送PSAM卡灰锁初始化命令
	istate=PsamLockInit(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, iptparam->IcLockInitRandom, iptparam->IcLockInitCTC, iptparam->IcLockInitBalance, iptparam->OilTime, iptparam->IcLockInitKeysVersion, iptparam->IcLockInitArithmetic, &iptparam->IcAppId[2],  iptparam->IcIssuerMark);

	//操作成功则继续下一步
	if(ICSTATE_OK==istate){
		
		iptparam->IcOverTimes=0;
		apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
		if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2)){
			
			memcpy(iptparam->IcPsamTTC, &buffer[2], 4);			//PSAM返回终端交易序号
			memcpy(iptparam->IcPsamRandom, &buffer[6], 4);	//PSAM返回终端随机数
			memcpy(iptparam->IcPsamMAC1, &buffer[10], 4);		//PSAM返回MAC1

			iptPidSet(iptparam, IPT_PID_TM_LOCK);					//转入IC卡灰锁过程
		}
		else{
			
			memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
			dsp_buffer[2]=12;	memcpy(&dsp_buffer[3], "计算MAC1失败", 12);
			dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
			IPT_DSP_WAIT();

			dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
			iptPidSet(iptparam, IPT_PID_TM_ZD_UPLOAD);
		}
	}
	//操作失败则提示错误信息
	else if(ICSTATE_FAILED==istate){
		
		iptparam->IcOverTimes=0;
	
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "计算MAC1失败", 12);
		IPT_DSP_WAIT();

		dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_TM_ZD_UPLOAD);
	}
	//操作超时，不足三次再次操作，超过三次退出
	else if(ICSTATE_OVERTIME==istate){
		
		iptparam->IcOverTimes++;
		if(iptparam->IcOverTimes>=3){
			
			iptparam->IcOverTimes=0;
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "计算MAC1超时", 12);
			IPT_DSP_WAIT();

			dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
			iptPidSet(iptparam, IPT_PID_TM_ZD_UPLOAD);
		}
	}
	//未定义错误
	else{

		iptparam->IcOverTimes=0;
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "计算MAC1错误", 12);
		IPT_DSP_WAIT();

		dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_TM_ZD_UPLOAD);
	}

	return;
}


/*******************************************************************
*Name				:iptTMIcLock
*Description		:条码自助，内置卡灰锁过程
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptTMIcLock(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char buffer[128]={0}, dsp_buffer[64]={0}, dsp_len=0;
	int istate=0, apdu_len=0;
	unsigned int ttc_value=0;
	unsigned long long volume_sum=0, money_sum=0;

	//发送IC卡灰锁命令
	istate=ICGreyLock(iptparam->DEVIC, iptparam->DEVICInternal, buffer, 128, iptparam->IcPsamTTC, iptparam->IcPsamRandom, iptparam->OilTime, iptparam->IcPsamMAC1);

	//操作成功则继续下一步
	if(ICSTATE_OK==istate){
		
		iptparam->IcOverTimes=0;
		apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
		if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2)){

			//保存数据
			memcpy(iptparam->IcGTAC, &buffer[2], 4);	//IC灰锁返回GTAC
			memcpy(iptparam->IcMAC2, &buffer[6], 4);	//IC灰锁返回MAC2

			//灰锁成功后脱机交易序号自加一位
			ttc_value=(iptparam->IcLockInitCTC[0]<<8)|(iptparam->IcLockInitCTC[1]<<0);
			ttc_value++;
			iptparam->IcLockInitCTC[0]=(unsigned char)(ttc_value>>8);	iptparam->IcLockInitCTC[1]=(unsigned char)(ttc_value>>0);

			//IC加油数据保存逃卡账单
			//待填充:POS_TTC
			memcpy(&iptparam->OilBill[IPT_OFFSET_TTC], "\x00\x00\x00\x00", 4);

			//待填充:交易类型设为无卡错，后台/本地黑白名单，扣款签名无效，逃卡
			iptparam->OilBill[IPT_OFFSET_T_TYPE]=(0<<7)|((iptparam->BlistSrc&1)<<6)|(0<<4)|(1<<0);

			//已完成:交易日期及时间
			memcpy(&iptparam->OilBill[IPT_OFFSET_TIME], iptparam->OilTime, 7);

			//已完成:卡应用号
			memcpy(&iptparam->OilBill[IPT_OFFSET_ASN], iptparam->IcAppId, 10);

			//待填充:余额(扣前)，交易完成后填扣后余额
			memcpy(&iptparam->OilBill[IPT_OFFSET_BALANCE], iptparam->IcBalance, 4);

			//待填充:数额，交易完成后填实际数额
			memcpy(&iptparam->OilBill[IPT_OFFSET_AMN], "\x00\x00\x00", 3);

			//已完成:卡交易序号
			memcpy(&iptparam->OilBill[IPT_OFFSET_CTC], iptparam->IcLockInitCTC, 2);

			//待填充:电子签名，加油/补扣/补充时未TAC，逃卡时为GTAC
			memcpy(&iptparam->OilBill[IPT_OFFSET_TAC], iptparam->IcGTAC, 4);

			//待填充:解灰认证码4bytes，加油完成，PSAM计算GMAC后添加
			memcpy(&iptparam->OilBill[IPT_OFFSET_GMAC], "\x00\x00\x00\x00", 4);

			//待填充:PSAM会所签名4bytes，加油完成，PSAM计算GMAC后添加
			memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TAC], "\x00\x00\x00\x00", 4);

			//已完成:PSAM应用号10bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_ASN], iptparam->PsamId, 10);

			//已完成:PSAM编号6bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_TID], iptparam->PsamTermId, 6);
			
			//已完成:PSAM终端交易序号4bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TTC], iptparam->IcPsamTTC, 4);

			//已完成:扣款来源1byte
			iptparam->OilBill[IPT_OFFSET_DS]=iptparam->DS;
			
			//已完成:结算单位/方式1byte
			iptparam->OilBill[IPT_OFFSET_UNIT]=((iptparam->Payment&0x3f)<<4)|(iptparam->PayUnit&0x03);
			
			//已完成:卡类1byte
			iptparam->OilBill[IPT_OFFSET_C_TYPE]=iptparam->C_TYPE;

			//已完成:卡版本1byte，b7~b4卡密钥索引号；b3~b0卡密钥版本号
			iptparam->OilBill[IPT_OFFSET_VER]=((iptparam->PsamKeyIndex&0x0f)<<4)|((iptparam->IcLockInitKeysVersion&0x0f)<<0);

			//已完成:枪号1byte
			iptparam->OilBill[IPT_OFFSET_NZN]=iptparam->LogicNozzle;
			
			//已完成:油品代码2bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_G_CODE], iptparam->OilCode, 2);

			//升数3bytes，交易完成后填实际升数
			memcpy(&iptparam->OilBill[IPT_OFFSET_VOL], "\x00\x00\x00", 3);
			
			//已完成:成交价格2bytes
			iptparam->OilBill[IPT_OFFSET_PRC+0]=(char)(iptparam->OilPrice>>8);	
			iptparam->OilBill[IPT_OFFSET_PRC+1]=(char)(iptparam->OilPrice>>0);

			//已完成:员工号1byte
			iptparam->OilBill[IPT_OFFSET_EMP]=iptparam->EMP;

			//已完成:升累计4bytes，交易完成后填实际总累,fj:
			jlSumRead(iptparam->Id, &volume_sum, &money_sum);
			iptparam->OilBill[IPT_OFFSET_V_TOT+0]=(char)(volume_sum>>24);
			iptparam->OilBill[IPT_OFFSET_V_TOT+1]=(char)(volume_sum>>16);
			iptparam->OilBill[IPT_OFFSET_V_TOT+2]=(char)(volume_sum>>8);	
			iptparam->OilBill[IPT_OFFSET_V_TOT+3]=(char)(volume_sum>>0);

			//已完成:备用部分11bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_RFU], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 11);

			//待填充:T-MAC	4bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], "\x00\x00\x00\x00", 4);
					
			//已完成:物理枪号PhysicsGunId
			iptparam->OilBill[IPT_OFFSET_PHYGUN]=iptparam->PhysicalNozzle;
					
			//已完成:计量停机原因
			iptparam->OilBill[IPT_OFFSET_STOPNO]=0;

			//已完成:扣前余额
			memcpy(&iptparam->OilBill[IPT_OFFSET_BEFOR_BAL], iptparam->IcBalance, 4);

			//账单状态:0=正常；1=未完成
			iptparam->OilBill[IPT_OFFSET_ZD_STATE]=1;

			//计量设备ID
			iptparam->OilBill[IPT_OFFSET_JLNOZZLE]=iptparam->JlNozzle;

			//计算账单校验值
			iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

			//保存账单及备份
			istate=framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
			istate=framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

			//转入MAC2计算过程
			iptPidSet(iptparam, IPT_PID_TM_MAC2);
		}
		else{

			memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
			dsp_buffer[2]=12;	memcpy(&dsp_buffer[3], "IC卡灰锁失败", 12);
			dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
			IPT_DSP_WAIT();

			dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
			iptPidSet(iptparam, IPT_PID_TM_ZD_UPLOAD);
		}
	}
	//操作失败则提示错误信息
	else if(ICSTATE_FAILED==istate)
	{
		iptparam->IcOverTimes=0;
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡灰锁失败", 12);
		IPT_DSP_WAIT();

		dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_TM_ZD_UPLOAD);
	}
	//操作超时，不足三次再次操作，超过三次退出
	else if(ICSTATE_OVERTIME==istate){
		
		iptparam->IcOverTimes++;
		if(iptparam->IcOverTimes>=3){
			
			iptparam->IcOverTimes=0;
		
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡灰锁超时", 12);
			IPT_DSP_WAIT();

			dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
			iptPidSet(iptparam, IPT_PID_TM_ZD_UPLOAD);
		}
	}
	//未定义错误
	else{
		
		iptparam->IcOverTimes=0;
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡灰锁错误", 12);
		IPT_DSP_WAIT();

		dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_TM_ZD_UPLOAD);
	}

	return;
}


/*******************************************************************
*Name				:iptTMMac2
*Description		:条码自助，PSAM验证MAC2
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptTMMac2(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char buffer[128]={0}, dsp_buffer[64]={0}, dsp_len=0;
	int istate=0, apdu_len=0;

	//发送PSAM卡灰锁初始化命令
	istate=PsamMAC2Check(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, iptparam->IcMAC2);

	//操作成功则继续下一步
	if(ICSTATE_OK==istate)
	{
		iptparam->IcOverTimes=0;
		apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
		if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
		{
			iptPidSet(iptparam, IPT_PID_TM_OILSTART);
		}
		else
		{
			memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
			dsp_buffer[2]=12;	memcpy(&dsp_buffer[3], "验证MAC2失败", 12);
			dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
			IPT_DSP_WAIT();

			dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
			iptPidSet(iptparam, IPT_PID_TM_PSAM_GMAC);
		}
	}
	//操作失败则提示错误信息
	else if(ICSTATE_FAILED==istate)
	{
		iptparam->IcOverTimes=0;

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "验证MAC2失败", 12);
		IPT_DSP_WAIT();

		dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_TM_PSAM_GMAC);
	}
	//操作超时，不足三次再次操作，超过三次退出
	else if(ICSTATE_OVERTIME==istate)
	{
		iptparam->IcOverTimes++;
		if(iptparam->IcOverTimes>=3)
		{
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "验证MAC2超时", 12);
			IPT_DSP_WAIT();

			dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
			iptPidSet(iptparam, IPT_PID_TM_PSAM_GMAC);
		}
	}
	//未定义错误
	else
	{
		iptparam->IcOverTimes=0;

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "验证MAC2错误", 12);
		IPT_DSP_WAIT();

		dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_TM_PSAM_GMAC);
	}
	
	return;
}


/*******************************************************************
*Name				:iptTMOilStart
*Description		:条码加油，加油开始过程
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptTMOilStart(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	int voice[16]={0};
	int i=0, istate=0;
	unsigned char dsp_buffer[64]={0}, dsp_len=0;

	unsigned long long volume_sum = 0, money_sum = 0;

	//for(i=0; i<3; i++)
	for( i = 0; i < 1; i++)
	{
		//向税控申请加油，预置升数以升数为预置量，否则以金额为预置量
		if(IPT_PRESET_VOLUME==iptparam->PresetMode)
		{
	        printf("TM oiling:read preset volum add oil,volume = %d,Price = %d\n",iptparam->PresetVolume,iptparam->OilPrice);
			istate=jlOilStart(iptparam->JlNozzle, iptparam->PresetVolume, iptparam->OilPrice, iptparam->PresetMode);
		}
		else
		{
            printf("TM oiling:read preset money add oil,money = %d,Price = %d\n",iptparam->PresetMoney,iptparam->OilPrice);
			istate=jlOilStart(iptparam->JlNozzle, iptparam->PresetMoney, iptparam->OilPrice, iptparam->PresetMode);
		}

		//计量启动成功不再申请
		if(0==istate)	break;

		//启动失败，下次启动之前先做延时释放
		if(0!=istate)	usleep(1000);
	}

	//税控申请失败
	if(0!=istate)
	{
		memset(dsp_buffer, 0, sizeof(dsp_buffer));
		memcpy(dsp_buffer, "计量启动失败    ", 16);
		i=((char)(istate>>4)&0x0f)*10+((char)(istate>>0)&0x0f)*1; //fj:
		//memcpy(dsp_buffer+strlen(dsp_buffer), jlStartFiledReson[i], strlen(jlStartFiledReson[i]));
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, strlen(dsp_buffer));
		IPT_DSP_WAIT();

		jljOilErrLogWrite(iptparam->Id, "条码加油启动失败，%s.", dsp_buffer);

		//联达加油站系统不适用内置卡，直接返回待机界面即可，否则应进行内置卡的解扣操作
		if(1 == iptIsLianda(iptparam->Id))
		{
			iptMainInterface(iptparam);
		}
		else
		{
			dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
			iptPidSet(iptparam, IPT_PID_TM_PSAM_GMAC);
		}

		return;
	}

	//语音提示"此油枪加注XX，泵码已回零，请确认"
	if(iptparam->VoiceVolume>0 && IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType)
	{
		voice[0]=SPKW_OILFILL;															//此油枪加注
																										//油品语音代码
		if(0==memcmp(iptparam->OilVoice, "\x00\x00\x00\x00", 4))
			voice[1]=iptOilVoiceIdGet(iptparam, iptparam->OilCode);
		else
			voice[1]=((iptparam->OilVoice[0]&0x0f)<<12)|((iptparam->OilVoice[1]&0x0f)<<8)|\
							((iptparam->OilVoice[2]&0x0f)<<4)|((iptparam->OilVoice[3]&0x0f)<<0);
		voice[2]=SPKW_OILACK;															//泵码已回零，请确认
		iptSpk(iptparam, voice, 3);
	}
	else if(iptparam->VoiceVolume>0 && IPT_VOICE_TYPE_MAN==iptparam->VoiceType)
	{
		voice[0]=SPKM_OILFILL;															//此油枪加注
																										//油品语音代码
		if(0==memcmp(iptparam->OilVoice, "\x00\x00\x00\x00", 4))
			voice[1]=iptOilVoiceIdGet(iptparam, iptparam->OilCode);
		else
			voice[1]=((iptparam->OilVoice[0]&0x0f)<<12)|((iptparam->OilVoice[1]&0x0f)<<8)|\
							((iptparam->OilVoice[2]&0x0f)<<4)|((iptparam->OilVoice[3]&0x0f)<<0);
		voice[2]=SPKM_OILACK;															//泵码已回零，请确认
		iptSpk(iptparam, voice, 3);
	}

	//社会站联达加油站系统需要产生非卡账单
	if(1 == iptIsLianda(iptparam->Id))
	{
		//产生非卡加油账单
		//待填充:POS_TTC
		memcpy(&iptparam->OilBill[IPT_OFFSET_TTC], "\x00\x00\x00\x00", 4);

		//待填充:交易类型设为无卡错，后台/本地黑白名单，扣款签名无效，逃卡
		iptparam->OilBill[IPT_OFFSET_T_TYPE]=(0<<7)|(0<<6)|(0<<4)|(7<<0);

		//已完成:交易日期及时间
		iptparam->OilTime[0]=iptparam->Time.century;	iptparam->OilTime[1]=iptparam->Time.year;
		iptparam->OilTime[2]=iptparam->Time.month;		iptparam->OilTime[3]=iptparam->Time.date;
		iptparam->OilTime[4]=iptparam->Time.hour;		iptparam->OilTime[5]=iptparam->Time.minute;
		iptparam->OilTime[6]=iptparam->Time.second;
		memcpy(&iptparam->OilBill[IPT_OFFSET_TIME], iptparam->OilTime, 7);

		//已完成:卡应用号，条码自助加油时以授权验证码填充
		memcpy(&iptparam->OilBill[IPT_OFFSET_ASN+0], iptparam->Barcode, 3);
		memcpy(&iptparam->OilBill[IPT_OFFSET_ASN+3], "\x00\x00\x00\x00\x00\x00\x00", 7);

		//待填充:余额(扣前)，交易完成后填扣后余额
		memcpy(&iptparam->OilBill[IPT_OFFSET_BALANCE], "\x00\x00\x00\x00", 4);

		//待填充:数额，交易完成后填实际数额
		memcpy(&iptparam->OilBill[IPT_OFFSET_AMN], "\x00\x00\x00", 3);

		//已完成:卡交易序号
		memcpy(&iptparam->OilBill[IPT_OFFSET_CTC], "\x00\x00", 2);

		//待填充:电子签名，加油/补扣/补充时未TAC，逃卡时为GTAC
		memcpy(&iptparam->OilBill[IPT_OFFSET_TAC], "\x00\x00\x00\x00", 4);

		//待填充:解灰认证码4bytes，加油完成，PSAM计算GMAC后添加
		memcpy(&iptparam->OilBill[IPT_OFFSET_GMAC], "\x00\x00\x00\x00", 4);

		//待填充:PSAM会所签名4bytes，加油完成，PSAM计算GMAC后添加
		memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TAC], "\x00\x00\x00\x00", 4);

		//已完成:PSAM应用号10bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_ASN], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 10);
		
		//已完成:PSAM编号6bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_TID], "\x00\x00\x00\x00\x00\x00", 6);
				
		//已完成:PSAM终端交易序号4bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TTC], "\x00\x00\x00\x00", 4);

		//已完成:扣款来源1byte，此处特殊设置为条码现金
		iptparam->OilBill[IPT_OFFSET_DS]=0x90;

		//已完成:结算单位/方式1byte
		iptparam->OilBill[IPT_OFFSET_UNIT]=0;
				
		//已完成:卡类1byte
		iptparam->OilBill[IPT_OFFSET_C_TYPE]=0;

		//已完成:卡版本1byte，b7~b4卡密钥索引号；b3~b0卡密钥版本号
		iptparam->OilBill[IPT_OFFSET_VER]=0;

		//已完成:枪号1byte
		iptparam->OilBill[IPT_OFFSET_NZN]=iptparam->LogicNozzle;
				
		//已完成:油品代码2bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_G_CODE], iptparam->OilCode, 2);

		//升数3bytes，交易完成后填实际升数
		memcpy(&iptparam->OilBill[IPT_OFFSET_VOL], "\x00\x00\x00", 3);

		//已完成:成交价格2bytes，根据累计金额及油量计算
		iptparam->OilBill[IPT_OFFSET_PRC+0]=(char)(iptparam->OilPrice>>8);
		iptparam->OilBill[IPT_OFFSET_PRC+1]=(char)(iptparam->OilPrice>>0);

		//已完成:员工号1byte
		iptparam->OilBill[IPT_OFFSET_EMP]=iptparam->EMP;

		//已完成:升累计4bytes,fj:
		jlSumRead(iptparam->JlNozzle, &volume_sum, &money_sum);
		iptparam->OilBill[IPT_OFFSET_V_TOT+0]=(char)(volume_sum>>24);
		iptparam->OilBill[IPT_OFFSET_V_TOT+1]=(char)(volume_sum>>16);
		iptparam->OilBill[IPT_OFFSET_V_TOT+2]=(char)(volume_sum>>8);	
		iptparam->OilBill[IPT_OFFSET_V_TOT+3]=(char)(volume_sum>>0);

		//已完成:备用部分11bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_RFU], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 11);

		//待填充:T-MAC	4bytes
		memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], "\x00\x00\x00\x00", 4);
						
		//已完成:物理枪号PhysicsGunId
		iptparam->OilBill[IPT_OFFSET_PHYGUN]=iptparam->PhysicalNozzle;

		//已完成:计量停机原因
		iptparam->OilBill[IPT_OFFSET_STOPNO]=0;

		//已完成:扣前余额
		memcpy(&iptparam->OilBill[IPT_OFFSET_BEFOR_BAL], "\x00\x00\x00\x00", 4);

		//账单状态:0=正常；1=未完成
		iptparam->OilBill[IPT_OFFSET_ZD_STATE]=1;

		//计量设备ID
		iptparam->OilBill[IPT_OFFSET_JLNOZZLE]=iptparam->JlNozzle;

		//计算账单校验值
		iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

		//保存账单及备份
		istate=framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
		istate=framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

	}

	//参数根据状态初始化
	iptparam->VoiceFlag=0;
	iptparam->OilState=IPT_OIL_FUELLING;

	//显示加油中界面
	memcpy(dsp_buffer, iptparam->BarMoney, 3);
	dsp_len=3;
	dsp(iptparam->DEVDsp, DSP_TM_OILLING, dsp_buffer, dsp_len);

	//转入加油过程
	iptPidSet(iptparam, IPT_PID_TM_OILLING);

	return;
}


/*******************************************************************
*Name				:iptTMOilling
*Description		:IC卡加油中
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptTMOilling(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	int voice[16]={0};
	unsigned int i=0, money_authorized=0, balance=0, money_sum=0, volume_sum=0, money=0, volume=0, price=0;
	long long balance_bcd=0;
	unsigned char dsp_buffer[64]={0}, dsp_len=0, tmp_buffer[16]={0}, hex_data=0, jl_stop_no=0;
	int istate=0;

	//读取实时加油量,fj:
	istate=jlOilRead(iptparam->JlNozzle, &money, &volume, &price, &jl_stop_no);
	if(iptparam->OilDspTimer >= ONE_SECOND)
	{
		//获取实时加油数据，加油数据改变时进行存储
		if(0==istate && volume!=iptparam->OilVolume)
		{
			iptparam->OilVolume=volume;	
			iptparam->OilMoney=money;		
			iptparam->OilPrice=price;

			//保存条码自助账单数据
			//条码自助账单:3bytes加油金额
			iptparam->BarOilBill[IPT_BAR_OFF_MONEY+0]=(char)(iptparam->OilMoney>>16);
			iptparam->BarOilBill[IPT_BAR_OFF_MONEY+1]=(char)(iptparam->OilMoney>>8);
			iptparam->BarOilBill[IPT_BAR_OFF_MONEY+2]=(char)(iptparam->OilMoney>>0);
			//条码自助账单:3bytes加油升数
			iptparam->BarOilBill[IPT_BAR_OFF_VOLUME+0]=(char)(iptparam->OilVolume>>16);
			iptparam->BarOilBill[IPT_BAR_OFF_VOLUME+1]=(char)(iptparam->OilVolume>>8);
			iptparam->BarOilBill[IPT_BAR_OFF_VOLUME+2]=(char)(iptparam->OilVolume>>0);
			//条码自助账单:2bytes单价
			iptparam->BarOilBill[IPT_BAR_OFF_PRICE+0]=(char)(iptparam->OilPrice>>8);	
			iptparam->BarOilBill[IPT_BAR_OFF_PRICE+1]=(char)(iptparam->OilPrice>>0);
			//条码自助账单:1byte异或校验码
			iptparam->BarOilBill[IPT_BAR_OFF_CHECK]=xorGet(iptparam->BarOilBill, IPT_BAR_BILL_SIZE-1);
			//条码自助账单:数据存储
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_TM, iptparam->BarOilBill, IPT_BAR_BILL_SIZE);
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_TM2, iptparam->BarOilBill, IPT_BAR_BILL_SIZE);
			

			//保存卡账单数据
			//油量
			iptparam->OilBill[IPT_OFFSET_VOL+0]=(char)(iptparam->OilVolume>>16);	
			iptparam->OilBill[IPT_OFFSET_VOL+1]=(char)(iptparam->OilVolume>>8);	
			iptparam->OilBill[IPT_OFFSET_VOL+2]=(char)(iptparam->OilVolume>>0);
			//金额
			iptparam->OilBill[IPT_OFFSET_AMN+0]=(char)(iptparam->OilMoney>>16);	
			iptparam->OilBill[IPT_OFFSET_AMN+1]=(char)(iptparam->OilMoney>>8);	
			iptparam->OilBill[IPT_OFFSET_AMN+2]=(char)(iptparam->OilMoney>>0);
			//单价
			iptparam->OilBill[IPT_OFFSET_PRC+0]=(char)(iptparam->OilPrice>>8);
			iptparam->OilBill[IPT_OFFSET_PRC+1]=(char)(iptparam->OilPrice>>0);
			//计算账单校验值
			iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);
			//保存账单及备份
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

			printf("iptTMOilling,save bill\n");
		}

		//送显
		money_authorized=(iptparam->BarMoney[0]<<16)|(iptparam->BarMoney[1]<<8)|(iptparam->BarMoney[2]<<0);
		balance=money_authorized-money;
		dsp_buffer[0]=(char)(balance>>16);	dsp_buffer[1]=(char)(balance>>8);	dsp_buffer[2]=(char)(balance>>0);
		dsp_len=3;
		dsp(iptparam->DEVDsp, DSP_TM_OILLING, dsp_buffer, dsp_len);

		//促销机通知平板油机状态
		if(1 == paramPromotionGet())
		{
			iptparam->TaState = IPT_STATE_TM_OILLING;	iptparam->TaStateParamLength = 0;
			*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = (char)(iptparam->OilMoney>>24);
			*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = (char)(iptparam->OilMoney>>16);
			*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = (char)(iptparam->OilMoney>>8);
			*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = (char)(iptparam->OilMoney>>0);
			*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = (char)(iptparam->OilVolume>>24);
			*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = (char)(iptparam->OilVolume>>16);
			*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = (char)(iptparam->OilVolume>>8);
			*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = (char)(iptparam->OilVolume>>0);
			*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = (char)(balance>>24);
			*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = (char)(balance>>16);
			*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = (char)(balance>>8);
			*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = (char)(balance>>0);
			pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
		}

		iptparam->OilDspTimer=0;
	}

	//凑整，默认金额凑整
	if(KB_BUTTON_CZ==iptparam->Button)
	{
	    if(0==jlOilCZ(iptparam->JlNozzle, 0))
			iptparam->OilRound=1;
	}

	//加油达到预置量未挂枪时播报语音提示
	if(0==iptparam->VoiceFlag && 2==jl_stop_no && IPT_GUN_PUTUP==iptparam->GunState && iptparam->VoiceVolume>0)
	{
		if(IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType)	voice[0]=SPKW_OILEND;
		else																				voice[0]=SPKM_OILEND;
		iptSpk(iptparam, voice, 1);

		iptparam->VoiceFlag=1;
	}

	//挂枪，计量状态异常(非达到预置量)，油机掉电，过冲则结束加油状态
	money_authorized=(iptparam->BarMoney[0]<<16)|(iptparam->BarMoney[1]<<8)|(iptparam->BarMoney[2]<<0);
	if(	(0 == iptIsBig260(iptparam->Id) && IPT_GUN_PUTDOWN == iptparam->GunState) ||\
		(1 == iptIsBig260(iptparam->Id) && KB_BUTTON_ACK == iptparam->Button) ||\
		(0==istate && 0!=jl_stop_no && 2!=jl_stop_no) ||\
		POWER_STATE_OK!=powerStateRead()	||\
		iptparam->OilMoney>money_authorized)
	{
		if(IPT_GUN_PUTDOWN==iptparam->GunState)	
			jljRunLog("[主板号=%d][面板号=%d]条码加油结束!挂枪!\n", pcdMboardIDRead(), iptparam->Id);
		if(0==istate && 0!=jl_stop_no && 2!=jl_stop_no)
		{
			i=((char)(jl_stop_no>>4)&0x0f)*10+((char)(jl_stop_no>>0)&0x0f)*1;
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, (unsigned char *)jlStopReason[i], strlen(jlStopReason[i]));
			IPT_DSP_WAIT();
			jljOilErrLogWrite(iptparam->Id, "条码加油结束!计量停止加油[%s]!", jlStopReason[jl_stop_no]);
		}
		if(POWER_STATE_OK!=powerStateRead())
			jljOilErrLogWrite(iptparam->Id, "条码加油结束!油机掉电!");
		if(iptparam->OilMoney>money_authorized)			
			jljOilErrLogWrite(iptparam->Id, "条码加油结束!过冲![金额=%d][授权额=%d]!", iptparam->OilMoney, money_authorized);
		
		dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_TM_OILFINISH);

		//促销机通知平板油机状态
		if(1 == paramPromotionGet())
		{
			iptparam->TaState = IPT_STATE_TM_FINISHING;	iptparam->TaStateParamLength = 0;
			pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
		}
		return;
	}

	return;
}


/*******************************************************************
*Name				:iptTMOilFinish
*Description		:条码自助，申请计量加油结束
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptTMOilFinish(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned int balance=0, money=0, volume=0, price=0, crc_return=0;
	unsigned int auth_money = 0, money_balance = 0;
	unsigned long long money_sum=0, volume_sum=0;
	unsigned char stop_no=0, bill_buffer[64]={0};
	int istate=0;
//fj:
	istate=jlOilFinish(iptparam->JlNozzle, &money_sum, &volume_sum, &money, &volume, &price, &stop_no);

	iptAbnormalStopHandle(iptparam,stop_no,money);

	if(0==istate)
	{
		//加油状态结束
		iptparam->OilState=IPT_OIL_IDLE;

		//保存加油数据
		iptparam->SumMoney=money_sum;	iptparam->SumVolume=volume_sum;
		iptparam->OilMoney=money;	iptparam->OilVolume=volume;	iptparam->OilPrice=price;	iptparam->JlStopNO=stop_no;

		//保存条码自助账单数据
		//条码自助账单:3bytes加油金额
		iptparam->BarOilBill[IPT_BAR_OFF_MONEY+0]=(char)(iptparam->OilMoney>>16);
		iptparam->BarOilBill[IPT_BAR_OFF_MONEY+1]=(char)(iptparam->OilMoney>>8);
		iptparam->BarOilBill[IPT_BAR_OFF_MONEY+2]=(char)(iptparam->OilMoney>>0);
		//条码自助账单:3bytes加油升数
		iptparam->BarOilBill[IPT_BAR_OFF_VOLUME+0]=(char)(iptparam->OilVolume>>16);
		iptparam->BarOilBill[IPT_BAR_OFF_VOLUME+1]=(char)(iptparam->OilVolume>>8);
		iptparam->BarOilBill[IPT_BAR_OFF_VOLUME+2]=(char)(iptparam->OilVolume>>0);
		//条码自助账单:2bytes单价
		iptparam->BarOilBill[IPT_BAR_OFF_PRICE+0]=(char)(iptparam->OilPrice>>8);	
		iptparam->BarOilBill[IPT_BAR_OFF_PRICE+1]=(char)(iptparam->OilPrice>>0);
		//条码自助账单:1byte异或校验码
		iptparam->BarOilBill[IPT_BAR_OFF_CHECK]=xorGet(iptparam->BarOilBill, IPT_BAR_BILL_SIZE-1);
		//条码自助账单:数据存储
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_TM, iptparam->BarOilBill, IPT_BAR_BILL_SIZE);
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_TM2, iptparam->BarOilBill, IPT_BAR_BILL_SIZE);
			
		//社会站联达加油站产生非卡账单
		if(1 == iptIsLianda(iptparam->Id))
		{
			//油量
			iptparam->OilBill[IPT_OFFSET_VOL+0]=(char)(iptparam->OilVolume>>16);	
			iptparam->OilBill[IPT_OFFSET_VOL+1]=(char)(iptparam->OilVolume>>8);	
			iptparam->OilBill[IPT_OFFSET_VOL+2]=(char)(iptparam->OilVolume>>0);
			//余额
			auth_money = (iptparam->BarMoney[0]<<16)|(iptparam->BarMoney[1]<<8)|(iptparam->BarMoney[2]<<0);
			if(auth_money>=iptparam->OilMoney)	money_balance = auth_money - iptparam->OilMoney;
			else															money_balance = 0;
			iptparam->OilBill[IPT_OFFSET_BALANCE+0] = (char)(money_balance>>24);
			iptparam->OilBill[IPT_OFFSET_BALANCE+1] = (char)(money_balance>>16);
			iptparam->OilBill[IPT_OFFSET_BALANCE+2] = (char)(money_balance>>8);
			iptparam->OilBill[IPT_OFFSET_BALANCE+3] = (char)(money_balance>>0);
			//金额
			iptparam->OilBill[IPT_OFFSET_AMN+0]=(char)(iptparam->OilMoney>>16);	
			iptparam->OilBill[IPT_OFFSET_AMN+1]=(char)(iptparam->OilMoney>>8);	
			iptparam->OilBill[IPT_OFFSET_AMN+2]=(char)(iptparam->OilMoney>>0);
			//单价
			iptparam->OilBill[IPT_OFFSET_PRC+0]=(char)(iptparam->OilPrice>>8);		
			iptparam->OilBill[IPT_OFFSET_PRC+1]=(char)(iptparam->OilPrice>>0);
			//总累
			iptparam->OilBill[IPT_OFFSET_V_TOT+0]=(char)(iptparam->SumVolume>>24);
			iptparam->OilBill[IPT_OFFSET_V_TOT+1]=(char)(iptparam->SumVolume>>16);
			iptparam->OilBill[IPT_OFFSET_V_TOT+2]=(char)(iptparam->SumVolume>>8);
			iptparam->OilBill[IPT_OFFSET_V_TOT+3]=(char)(iptparam->SumVolume>>0);
			//折扣后金额
			iptparam->OilBill[IPT_OFFSET_MONEY_DISCOUNT+0]=(char)(iptparam->OilMoney>>16);	
			iptparam->OilBill[IPT_OFFSET_MONEY_DISCOUNT+1]=(char)(iptparam->OilMoney>>8);	
			iptparam->OilBill[IPT_OFFSET_MONEY_DISCOUNT+2]=(char)(iptparam->OilMoney>>0);
			//计量停机代码
			iptparam->OilBill[IPT_OFFSET_STOPNO]=(char)(iptparam->JlStopNO);
			//计算账单校验值
			iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);
			//保存账单及备份
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

			//转入TTC获取过程
			iptPidSet(iptparam, IPT_PID_TM_TTC_GET);
		}
		else
		{
			//保存卡账单数据
			//油量
			iptparam->OilBill[IPT_OFFSET_VOL+0]=(char)(iptparam->OilVolume>>16);	
			iptparam->OilBill[IPT_OFFSET_VOL+1]=(char)(iptparam->OilVolume>>8);	
			iptparam->OilBill[IPT_OFFSET_VOL+2]=(char)(iptparam->OilVolume>>0);
			//金额
			iptparam->OilBill[IPT_OFFSET_AMN+0]=(char)(iptparam->OilMoney>>16);	
			iptparam->OilBill[IPT_OFFSET_AMN+1]=(char)(iptparam->OilMoney>>8);	
			iptparam->OilBill[IPT_OFFSET_AMN+2]=(char)(iptparam->OilMoney>>0);
			//单价
			iptparam->OilBill[IPT_OFFSET_PRC+0]=(char)(iptparam->OilPrice>>8);		
			iptparam->OilBill[IPT_OFFSET_PRC+1]=(char)(iptparam->OilPrice>>0);
			//总累
			iptparam->OilBill[IPT_OFFSET_V_TOT+0]=(char)(iptparam->SumVolume>>24);
			iptparam->OilBill[IPT_OFFSET_V_TOT+1]=(char)(iptparam->SumVolume>>16);
			iptparam->OilBill[IPT_OFFSET_V_TOT+2]=(char)(iptparam->SumVolume>>8);
			iptparam->OilBill[IPT_OFFSET_V_TOT+3]=(char)(iptparam->SumVolume>>0);
			//计量停机代码
			iptparam->OilBill[IPT_OFFSET_STOPNO]=(char)(iptparam->JlStopNO);
			//计算账单校验值
			iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);
			//保存账单及备份
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

			//转入GMAC计算过程
			iptPidSet(iptparam, IPT_PID_TM_PSAM_GMAC);

		}
	}

	return;
}


/*******************************************************************
*Name				:iptTMPsamGMAC
*Description		:条码自助，PSAM计算GMAC
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptTMPsamGMAC(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char buffer[128]={0}, dsp_buffer[64]={0}, dsp_len=0;
	int istate=0, apdu_len=0;
	unsigned int data=0;

	//
	//*	@1	
	//*	计算GMAC，计算成功转入解扣过程，计算失败继续执行@2；
	//*	@2
	//*	计算GMAC失败，读取GMAC查看是否实际计算成功，失败继续执行@3；
	//*	@3
	//*	验证MAC2，验证失败执行@4，验证成功执行@6；
	//*	@4
	//*	复位PSAM，成功则执行@5；
	//*	@5
	//*	选择应用1，成功则执行@6；
	//*	@6
	//*	第二次计算GMAC，操作完成后转入扣款过程；
	

	//@1	计算GMAC
	istate=PsamGMAC(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, &iptparam->IcAppId[2], iptparam->IcLockInitCTC, iptparam->OilMoney);

	if(ICSTATE_OK==istate){
		
		apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
		if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2)){

			//卡座操作返回成功
			memcpy(iptparam->IcPsamGMAC, &buffer[2], 4);	//PSAM返回GMAC
			memcpy(iptparam->IcPsamTAC, &buffer[6], 4);		//PSAM返回TAC

			//解灰认证码4bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_GMAC], iptparam->IcPsamGMAC, 4);

			//PSAM灰锁签名4bytes，加油完成，PSAM计算GMAC后添加
			memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TAC], iptparam->IcPsamTAC, 4);
				
			//计算账单校验值
			iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

			//保存账单及备份
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

			//有卡转入解扣过程，逃卡转入TTC申请过程
			iptPidSet(iptparam, IPT_PID_TM_UNLOCK);

			return;
		}
	}

	//@2	读取GMAC
	data=(iptparam->IcPsamTTC[0]<<24)|(iptparam->IcPsamTTC[1]<<16)|(iptparam->IcPsamTTC[2]<<8)|(iptparam->IcPsamTTC[3]<<0);
	data++;
	iptparam->IcPsamTTC[0]=(char)(data>>24);	iptparam->IcPsamTTC[1]=(char)(data>>16);
	iptparam->IcPsamTTC[2]=(char)(data>>8);	iptparam->IcPsamTTC[3]=(char)(data>>0);
	istate=PsamGMACRead(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, iptparam->IcPsamTTC);
	if(ICSTATE_OK==istate){

		apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
		if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2)){

			//卡座操作返回成功
			memcpy(iptparam->IcPsamGMAC, &buffer[2], 4);	//PSAM返回GMAC
			memcpy(iptparam->IcPsamTAC, &buffer[6], 4);		//PSAM返回TAC

			//解灰认证码4bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_GMAC], iptparam->IcPsamGMAC, 4);

			//PSAM灰锁签名4bytes，加油完成，PSAM计算GMAC后添加
			memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TAC], iptparam->IcPsamTAC, 4);
				
			//计算账单校验值
			iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

			//保存账单及备份
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

			//有卡转入解扣过程，逃卡转入TTC申请过程
		    if(0x30==iptparam->IcState.DeckStateS1 || iptparam->EtcOilFlg == 1)	
				iptPidSet(iptparam, IPT_PID_TM_UNLOCK);
			else
				iptPidSet(iptparam, IPT_PID_TM_TTC_GET);

			return;
		}
	}

	//@3	验证MAC2
	istate=PsamMAC2Check(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, iptparam->IcMAC2);

	//@4	复位PSAM
	istate=PsamReset(iptparam->DEVIC, iptparam->DEVPsam);

	//@5	选择应用1
	istate=PsamDFSelect(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, 1);

	//@6	计算GMAC
PSAM_GMAC_AGAIN:
	istate=PsamGMAC(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, &iptparam->IcAppId[2], iptparam->IcLockInitCTC, iptparam->OilMoney);

	if(ICSTATE_OK==istate){

		iptparam->IcOverTimes=0;
		apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
		if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2)){

			//卡座操作返回成功
			memcpy(iptparam->IcPsamGMAC, &buffer[2], 4);	//PSAM返回GMAC
			memcpy(iptparam->IcPsamTAC, &buffer[6], 4);		//PSAM返回TAC

			//解灰认证码4bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_GMAC], iptparam->IcPsamGMAC, 4);

			//PSAM灰锁签名4bytes，加油完成，PSAM计算GMAC后添加
			memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TAC], iptparam->IcPsamTAC, 4);
			
			//计算账单校验值
			iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

			//保存账单及备份
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

			//有卡转入解扣过程，逃卡转入TTC申请过程
			if(0x30==iptparam->IcState.DeckStateS1 || iptparam->EtcOilFlg == 1)	
				iptPidSet(iptparam, IPT_PID_TM_UNLOCK);
			else
				iptPidSet(iptparam, IPT_PID_TM_TTC_GET);
		}
		else{

			memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
			dsp_buffer[2]=16;	memcpy(&dsp_buffer[3], "PSAM计算GMAC失败", 16);
			dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
			IPT_DSP_WAIT();

			dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
			iptPidSet(iptparam, IPT_PID_TM_TTC_GET);
		}
	}
	else if(ICSTATE_FAILED==istate){
		
		iptparam->IcOverTimes=0;

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM计算GMAC失败", 16);
		IPT_DSP_WAIT();

		dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_TM_TTC_GET);
	}
	else if(ICSTATE_OVERTIME==istate){
		
		iptparam->IcOverTimes=0;
	
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM计算GMAC超时", 16);
		IPT_DSP_WAIT();

		dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_TM_TTC_GET);
	}
	else{
		
		iptparam->IcOverTimes=0;

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM计算GMAC错误", 16);
		IPT_DSP_WAIT();

		dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_TM_TTC_GET);
	}

	return;
}


/*******************************************************************
*Name				:iptTMIcUnlock
*Description		:条码自助，IC卡解扣
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptTMIcUnlock(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char buffer[128]={0}, dsp_buffer[64]={0}, dsp_len=0, t_type=0;
	int istate=0, apdu_len=0;
	unsigned int balance=0, bill_type=0;

	//补扣及其它账单处理有异，需判断账单类型
	bill_type=iptparam->OilBill[IPT_OFFSET_T_TYPE]&0x0f;

	//发送IC卡解扣命令，补扣操作以灰锁信息进行扣款
	//if(IPT_BILLTYPE_UNLOCK==bill_type)	
	if(0x01 == iptparam->ICStateFirst)  //szb_fj_20171120:修改
		istate=ICGreyUnlock(iptparam->DEVIC, iptparam->DEVICInternal, buffer, 128, iptparam->unlockMoney, iptparam->IcLockCTC, iptparam->IcLockTermId, iptparam->unlockPsamTTC, iptparam->IcLockTime, iptparam->unlockGMAC);
	else								
		istate=ICGreyUnlock(iptparam->DEVIC, iptparam->DEVICInternal, buffer, 128, iptparam->OilMoney, iptparam->IcLockInitCTC, iptparam->PsamTermId, iptparam->IcPsamTTC, iptparam->OilTime, iptparam->IcPsamGMAC);

	printf("iptTMIcUnlock istate = %d\n",istate);

	//操作成功则继续下一步
	if(ICSTATE_OK==istate)
	{
		iptparam->IcOverTimes=0;
		apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
		if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2))
		{
			//卡座操作成功返回，转入下一步
			memcpy(iptparam->IcTac, &buffer[2], 4);		//IC解扣返回:TAC

			//卡插入时初始状态为灰锁则本处为补扣成功，产生补扣交易
			if(0x01==iptparam->ICStateFirst)
			{
				//初始状态转为正常
				iptparam->ICStateFirst=0;

				//IC加油数据保存补扣账单
				//待填充:POS_TTC
				memcpy(&iptparam->OilBill[IPT_OFFSET_TTC], "\x00\x00\x00\x00", 4);
				//已完成:交易类型设为无卡错，后台/本地黑白名单，扣款签名无效，补扣
				iptparam->OilBill[IPT_OFFSET_T_TYPE]=(0<<7)|((iptparam->BlistSrc&1)<<6)|(0<<4)|(IPT_BILLTYPE_UNLOCK<<0);
				//已完成:交易日期及时间，补扣时以逃卡时间为账单时间
				memcpy(&iptparam->OilBill[IPT_OFFSET_TIME], iptparam->IcLockTime, 7);
				//已完成:卡应用号
				memcpy(&iptparam->OilBill[IPT_OFFSET_ASN], iptparam->IcAppId, 10);					
				//已完成:余额(扣前)，交易完成后填扣后余额
				memcpy(&iptparam->OilBill[IPT_OFFSET_BALANCE], iptparam->IcLockBalance, 4);
				//已完成:数额，以上次加油的数额为当前数额
				iptparam->OilBill[IPT_OFFSET_AMN+0]=(char)(iptparam->unlockMoney>>16);
				iptparam->OilBill[IPT_OFFSET_AMN+1]=(char)(iptparam->unlockMoney>>8);
				iptparam->OilBill[IPT_OFFSET_AMN+2]=(char)(iptparam->unlockMoney>>0);					
				//已完成:卡交易序号
				memcpy(&iptparam->OilBill[IPT_OFFSET_CTC], iptparam->IcLockCTC, 2);					
				//已完成:电子签名，加油/补扣/补充时为TAC，逃卡时为GTAC
				memcpy(&iptparam->OilBill[IPT_OFFSET_TAC], iptparam->IcLockGTAC, 4);
				//已完成:解灰认证码4bytes，加油完成，PSAM计算GMAC后添加
				memcpy(&iptparam->OilBill[IPT_OFFSET_GMAC], "\x00\x00\x00\x00", 4);
				//已完成:PSAM灰锁签名4bytes，加油完成，PSAM计算GMAC后添加
				memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TAC], "\x00\x00\x00\x00", 4);						
				//已完成:PSAM应用号10bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_ASN], iptparam->PsamId, 10);				
				//已完成:PSAM编号6bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_TID], iptparam->IcLockTermId, 6);
				//已完成:PSAM终端交易序号4bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TTC], iptparam->unlockPsamTTC, 4);
				//已完成:扣款来源1byte
				iptparam->OilBill[IPT_OFFSET_DS]=iptparam->DS;				
				//已完成:结算单位/方式1byte
				iptparam->OilBill[IPT_OFFSET_UNIT]=0;			
				//已完成:卡类1byte
				iptparam->OilBill[IPT_OFFSET_C_TYPE]=iptparam->C_TYPE;					
				//已完成:卡版本1byte，b7~b4卡密钥索引号；b3~b0卡密钥版本号
				iptparam->OilBill[IPT_OFFSET_VER]=((iptparam->PsamKeyIndex&0x0f)<<4)|(0<<0);
				//已完成:枪号1byte
				iptparam->OilBill[IPT_OFFSET_NZN]=0;						
				//已完成:油品代码2bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_G_CODE], "\x00\x00", 2);
				//已完成:升数3bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_VOL], "\x00\x00\x00", 3);						
				//已完成:成交价格2bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_PRC], "\x00\x00", 2);
				//已完成:员工号1byte
				iptparam->OilBill[IPT_OFFSET_EMP]=iptparam->EMP;
				//已完成:升累计4bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_V_TOT], "\x00\x00\x00\x00", 4);			
				//已完成:备用部分11bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_RFU], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 11);
				//待填充:T-MAC	4bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], "\x00\x00\x00\x00", 4);					
				//已完成:物理枪号PhysicsGunId
				iptparam->OilBill[IPT_OFFSET_PHYGUN]=iptparam->PhysicalNozzle;						
				//已完成:计量停机原因
				iptparam->OilBill[IPT_OFFSET_STOPNO]=0;
				//已完成:扣前余额
				memcpy(&iptparam->OilBill[IPT_OFFSET_BEFOR_BAL], iptparam->IcLockBalance, 4);			
				//账单状态:0=正常；1=未完成
				iptparam->OilBill[IPT_OFFSET_ZD_STATE]=1;
				//计量设备ID
				iptparam->OilBill[IPT_OFFSET_JLNOZZLE]=iptparam->JlNozzle;
				//计算账单校验值
				iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);


				//计算扣后余额
				balance=(iptparam->IcLockBalance[0]<<24)|(iptparam->IcLockBalance[1]<<16)|(iptparam->IcLockBalance[2]<<8)|(iptparam->IcLockBalance[3]<<0);
				balance=balance-iptparam->unlockMoney;
				iptparam->IcBalance[0]=(char)(balance>>24);	iptparam->IcBalance[1]=(char)(balance>>16);
				iptparam->IcBalance[2]=(char)(balance>>8);		iptparam->IcBalance[3]=(char)(balance>>0);
			}
			else
			{
				//账单类型更改为正常
				iptparam->OilBill[IPT_OFFSET_T_TYPE]=(0<<7)|((iptparam->BlistSrc&1)<<6)|(1<<4)|(0<<0);

				//计算扣后余额
				balance=(iptparam->IcBalance[0]<<24)|(iptparam->IcBalance[1]<<16)|(iptparam->IcBalance[2]<<8)|(iptparam->IcBalance[3]<<0);
				balance=balance-iptparam->OilMoney;
				iptparam->IcBalance[0]=(char)(balance>>24);	
				iptparam->IcBalance[1]=(char)(balance>>16);
				iptparam->IcBalance[2]=(char)(balance>>8);	
				iptparam->IcBalance[3]=(char)(balance>>0);
			}


			//卡余额(扣后)
			memcpy(&iptparam->OilBill[IPT_OFFSET_BALANCE], iptparam->IcBalance, 4);

			//电子签名，加油/补扣/补充时为TAC，逃卡时为GTAC
			memcpy(&iptparam->OilBill[IPT_OFFSET_TAC], iptparam->IcTac, 4);
	
			//解灰认证码4bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_GMAC], "\x00\x00\x00\x00", 4);

			//PSAM灰锁签名4bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TAC], "\x00\x00\x00\x00", 4);

			//计算账单校验值
			iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

			//保存账单及备份
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

			//转入TAC清除过程
			iptPidSet(iptparam, IPT_PID_TM_TAC_CLEAR);
		}
		else
		{
 	        printf("iptTMIcUnlock code = %02x%02x\n",buffer[2+apdu_len-2],buffer[2+apdu_len-1]);

			memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
			dsp_buffer[2]=12;	memcpy(&dsp_buffer[3], "IC卡解扣失败", 12);
			dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
			IPT_DSP_WAIT();

			//该卡执行补扣操作失败直接退出，其它则继续保存账单
			if(0x01==iptparam->ICStateFirst)	
				iptMainInterface(iptparam);
			else								
				iptPidSet(iptparam, IPT_PID_TM_TTC_GET);//szb_fj_20171120:修改
		}
	}	
	else if(ICSTATE_FAILED==istate)//操作失败则提示错误信息
	{
        printf("iptTMIcUnlock cccccc\n");

		iptparam->IcOverTimes=0;
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡解扣失败", 12);
		IPT_DSP_WAIT();
			
		//该卡执行补扣操作失败直接退出，其它则继续保存账单
		if(0x01==iptparam->ICStateFirst)	
			iptMainInterface(iptparam);
		else	
			iptPidSet(iptparam, IPT_PID_TM_TTC_GET); //szb_fj_20171120:
	}
	else if(ICSTATE_OVERTIME==istate)	//操作超时，不足2次再次操作，超过2次退出
	{
		iptparam->IcOverTimes++;
		if(iptparam->IcOverTimes>=2)
		{	
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡解扣超时", 12);
			IPT_DSP_WAIT();
				
			//该卡执行补扣操作失败直接退出，其它则继续保存账单
			if(0x01==iptparam->ICStateFirst)
				iptMainInterface(iptparam);
			else
				iptPidSet(iptparam, IPT_PID_TM_TTC_GET);//szb_fj_20171120:
		}
	}	
	else//未定义错误
	{	
		iptparam->IcOverTimes=0;

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡解扣错误", 12);
		IPT_DSP_WAIT();
				
		//该卡执行补扣操作失败直接退出，其它则继续保存账单
		if(0x01==iptparam->ICStateFirst)
			iptMainInterface(iptparam);
		else
			iptPidSet(iptparam, IPT_PID_TM_TTC_GET);  //szb_fj_20171120:
	}

	return;
}


/*******************************************************************
*Name				:iptTMIcTACClear
*Description		:条码自助，内置卡TAC清除
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptTMIcTACClear(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char buffer[128]={0}, dsp_buffer[64]={0}, dsp_len=0, t_type=0;
	int istate=0, apdu_len=0;

	//发送IC卡TAC清除命令
	istate=ICTacClr(iptparam->DEVIC, iptparam->DEVICInternal, buffer, 128);

	//操作成功则继续下一步
	if(ICSTATE_OK==istate)
	{

		iptparam->IcOverTimes=0;
		apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
		if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2)){

			if(0x10==iptparam->ICStateFirst){
	
				iptparam->ICStateFirst=0;

				//IC加油数据保存补充账单
				//待填充:POS_TTC
				memcpy(&iptparam->OilBill[IPT_OFFSET_TTC], "\x00\x00\x00\x00", 4);

				//已完成:交易类型设为无卡错，后台/本地黑白名单，扣款签名无效，补充
				iptparam->OilBill[IPT_OFFSET_T_TYPE]=(0<<7)|((iptparam->BlistSrc&1)<<6)|(0<<4)|(IPT_BILLTYPE_FINISH<<0);

				//已完成:交易日期及时间
				iptparam->OilBill[IPT_OFFSET_TIME+0]=iptparam->Time.century;	
				iptparam->OilBill[IPT_OFFSET_TIME+1]=iptparam->Time.year;
				iptparam->OilBill[IPT_OFFSET_TIME+2]=iptparam->Time.month;
				iptparam->OilBill[IPT_OFFSET_TIME+3]=iptparam->Time.date;
				iptparam->OilBill[IPT_OFFSET_TIME+4]=iptparam->Time.hour;
				iptparam->OilBill[IPT_OFFSET_TIME+5]=iptparam->Time.minute;
				iptparam->OilBill[IPT_OFFSET_TIME+6]=iptparam->Time.second;

				//已完成:卡应用号
				memcpy(&iptparam->OilBill[IPT_OFFSET_ASN], iptparam->IcAppId, 10);
				
				//已完成:余额(扣前)，交易完成后填扣后余额
				memcpy(&iptparam->OilBill[IPT_OFFSET_BALANCE], iptparam->IcLockBalance, 4);
				
				//已完成:数额，以上次解扣的数额为当前数额
				memcpy(&iptparam->OilBill[IPT_OFFSET_AMN], &iptparam->IcLockMoney[1], 3);
				
				//已完成:卡交易序号
				memcpy(&iptparam->OilBill[IPT_OFFSET_CTC], iptparam->IcLockCTC, 2);
				
				//已完成:电子签名，加油/补扣/补充时为TAC，逃卡时为GTAC
				memcpy(&iptparam->OilBill[IPT_OFFSET_TAC], iptparam->IcLockGTAC, 4);

				//已完成:解灰认证码4bytes，加油完成，PSAM计算GMAC后添加
				memcpy(&iptparam->OilBill[IPT_OFFSET_GMAC], "\x00\x00\x00\x00", 4);

				//已完成:PSAM灰锁签名4bytes，加油完成，PSAM计算GMAC后添加
				memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TAC], "\x00\x00\x00\x00", 4);
				
				//已完成:PSAM应用号10bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_ASN], iptparam->PsamId, 10);
				
				//已完成:PSAM编号6bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_TID], iptparam->IcLockTermId, 6);

				//已完成:PSAM终端交易序号4bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TTC], "\x00\x00\x00\x00", 4);

				//已完成:扣款来源1byte
				iptparam->OilBill[IPT_OFFSET_DS]=iptparam->DS;
				
				//已完成:结算单位/方式1byte
				iptparam->OilBill[IPT_OFFSET_UNIT]=0;
		
				//已完成:卡类1byte
				iptparam->OilBill[IPT_OFFSET_C_TYPE]=iptparam->C_TYPE;
				
				//已完成:卡版本1byte，b7~b4卡密钥索引号；b3~b0卡密钥版本号
				iptparam->OilBill[IPT_OFFSET_VER]=((iptparam->PsamKeyIndex&0x0f)<<4)|(0<<0);

				//已完成:枪号1byte
				iptparam->OilBill[IPT_OFFSET_NZN]=0;
				
				//已完成:油品代码2bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_G_CODE], "\x00\x00", 2);

				//已完成:升数3bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_VOL], "\x00\x00\x00", 3);
				
				//已完成:成交价格2bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_PRC], "\x00\x00", 2);

				//已完成:员工号1byte
				iptparam->OilBill[IPT_OFFSET_EMP]=iptparam->EMP;

				//已完成:升累计4bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_V_TOT], "\x00\x00\x00\x00", 4);
				
				//已完成:备用部分11bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_RFU], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 11);

				//待填充:T-MAC	4bytes
				memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], "\x00\x00\x00\x00", 4);
				
				//已完成:物理枪号PhysicsGunId
				iptparam->OilBill[IPT_OFFSET_PHYGUN]=iptparam->PhysicalNozzle;
				
				//已完成:计量停机原因
				iptparam->OilBill[IPT_OFFSET_STOPNO]=0;

				//已完成:扣前余额
				memcpy(&iptparam->OilBill[IPT_OFFSET_BEFOR_BAL], iptparam->IcLockBalance, 4);
				
				//账单状态:0=正常；1=未完成
				iptparam->OilBill[IPT_OFFSET_ZD_STATE]=1;

				//计量设备ID
				iptparam->OilBill[IPT_OFFSET_JLNOZZLE]=iptparam->JlNozzle;

				//计算账单校验值
				iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

				//保存账单及备份
				framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
				framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);
			}

			iptPidSet(iptparam, IPT_PID_TM_TTC_GET);
		}
		else
		{

			memcpy(&dsp_buffer[0], &buffer[2+apdu_len-2], 2);
			dsp_buffer[2]=15;	memcpy(&dsp_buffer[3], "IC卡TAC清除失败", 15);
			dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
			IPT_DSP_WAIT();

			//该卡执行补充操作失败直接退出，其它则继续保存账单
			if(0x10==iptparam->ICStateFirst)
				iptMainInterface(iptparam);
			else	
				iptPidSet(iptparam, IPT_PID_TM_TTC_GET);
		}
	}
	//操作失败则提示错误信息
	else if(ICSTATE_FAILED==istate)
	{

		iptparam->IcOverTimes=0;
	
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡TAC清除失败", 15);
		IPT_DSP_WAIT();
			
		//该卡执行补充操作失败直接退出，其它则继续保存账单
		if(0x10==iptparam->ICStateFirst)	
			iptMainInterface(iptparam);
		else
			iptPidSet(iptparam, IPT_PID_TM_TTC_GET);
	}
	//操作超时，不足2次再次操作，超过2次退出
	else if(ICSTATE_OVERTIME==istate)
	{
		
		iptparam->IcOverTimes++;
		if(iptparam->IcOverTimes>=3)
		{
		
			iptparam->IcOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡TAC清除超时", 15);
			IPT_DSP_WAIT();
			
			//该卡执行补充操作失败直接退出，其它则继续保存账单
			if(0x10==iptparam->ICStateFirst)	
				iptMainInterface(iptparam);
			else	
				iptPidSet(iptparam, IPT_PID_TM_TTC_GET);
		}
	}
	//未定义错误
	else
	{

		iptparam->IcOverTimes=0;

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡TAC清除错误", 15);
		IPT_DSP_WAIT();

		//该卡执行补充操作失败直接退出，其它则继续保存账单
		if(0x10==iptparam->ICStateFirst)	
			iptMainInterface(iptparam);
		else		
			iptPidSet(iptparam, IPT_PID_TM_TTC_GET);
	}

	return;
}


/*******************************************************************
*Name				:iptTMTTCGet
*Description		:条码自助，加油完成向PCD申请POS_TTC
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptTMTTCGet(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char tx_buffer[256]={0}, tx_len=0;
	unsigned char dsp_buffer[64]={0}, dsp_len=0;

	if(IPT_2PCD_UNUSED==iptparam->PcdTxFlag)
	{
		//发送PCD获取TTC命令
		tx_buffer[0]=++iptparam->PcdTxFrame;
		tx_buffer[1]=pcdMboardIDRead();
		tx_buffer[2]=iptparam->Id;
		tx_buffer[3]=iptparam->PhysicalNozzle;
		tx_buffer[4]=IPT_CMD_FORTTC;
		memcpy(&tx_buffer[5], iptparam->OilBill, IPT_BILL_SIZE);
		tx_len=133;
		//msgQSend((MSG_Q_ID)pcdMsgIdRead(), tx_buffer, tx_len, NO_WAIT, MSG_PRI_NORMAL);	

		struct msg_struct msg_stIptSend;  //fj:20170918
		msg_stIptSend.msgType = 1;
		memcpy(msg_stIptSend.msgBuffer,tx_buffer,tx_len);
		msgsnd(pcdMsgIdRead(),&msg_stIptSend,tx_len,IPC_NOWAIT);

		iptparam->PcdTxFlag=IPT_2PCD_OILPROCESS;	iptparam->PcdTxTimer=0;
	}
	else
	if(IPT_2PCD_OILPROCESS==iptparam->PcdTxFlag && msg_len>0 && iptparam->PhysicalNozzle==msg_buffer[3] && IPT_CMD_FORTTC==msg_buffer[4] && 0==msg_buffer[5]){
		
		iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdOverTimes=0;

		//保存条码账单数据
		memcpy(&iptparam->BarOilBill[IPT_BAR_OFF_TTC], &msg_buffer[6], 4);
		//条码自助账单:1byte异或校验码
		iptparam->BarOilBill[IPT_BAR_OFF_CHECK]=xorGet(iptparam->BarOilBill, IPT_BAR_BILL_SIZE-1);
		//条码自助账单:数据存储
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_TM, iptparam->BarOilBill, IPT_BAR_BILL_SIZE);
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_TM2, iptparam->BarOilBill, IPT_BAR_BILL_SIZE);
		

		//保存卡账单数据
		//申请TTC成功
		memcpy(&iptparam->OilBill[IPT_OFFSET_TTC], &msg_buffer[6], 4);
		//计算账单校验值
		iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);
		//保存账单及备份
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);


		//转入T_MAC计算过程
		iptPidSet(iptparam, IPT_PID_TM_TMAC);
	}
	else
	if((IPT_2PCD_OILPROCESS==iptparam->PcdTxFlag)&&(iptparam->PcdTxTimer>=(2000*ONE_MILLI_SECOND))){

		//通讯超时重发，3次超时失败提示信息后转入选择ADF2过程
		iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdOverTimes++;
		if(iptparam->PcdOverTimes>=3){

			iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdOverTimes=0;

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "申请TTC超时", 11);
			IPT_DSP_WAIT();

			iptPidSet(iptparam, IPT_PID_TM_OIL_END);
		}
	}

	return;
}


/*******************************************************************
*Name				:iptTMIcTMAC
*Description		:条码自助，计算账单TMAC
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptTMIcTMAC(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	int istate=0, i = 0;
	unsigned char tmac_buffer[4]={0}, apdu_buffer[2]={0}, dsp_buffer[64]={0}, dsp_len=0;

	
	//计算账单TMAC，成功转入账单存储，失败则提示失败信息后转入账单存储
	for(i=0; i<3; i++)
	{
		istate=iptTMACCalculate(iptparam, tmac_buffer, apdu_buffer, iptparam->OilBill, 95);
		if(0==istate)	break;
	}
	if(0==istate)
	{
		memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], tmac_buffer, 4);
	}
	else
	{
		memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], IPT_TMAC_DEFUALT, 4);
	}

	//计算账单校验值
	iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

	//保存账单及备份
	framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
	framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

	//记录错误信息
	memset(dsp_buffer, 0, sizeof(dsp_buffer));
	if(0x0101==istate)
	{
		strcpy(dsp_buffer, "PSAM选择应用2失败");
		sprintf(dsp_buffer + strlen(dsp_buffer), "%x%x", apdu_buffer[0], apdu_buffer[1]);
	}
	else if(0x0102==istate)
	{
		strcpy(dsp_buffer, "PSAM选择应用2失败");
	}
	else if(0x0103==istate)
	{
		strcpy(dsp_buffer, "PSAM选择应用2超时");
	}
	else if(0x0104==istate)
	{
		strcpy(dsp_buffer, "PSAM选择应用2错误");
	}
	else if(0x0201==istate)
	{
		strcpy(dsp_buffer, "PSAM计算TMAC初始化失败");
		sprintf(dsp_buffer + strlen(dsp_buffer), "%x%x", apdu_buffer[0], apdu_buffer[1]);
	}
	else if(0x0202==istate)
	{
		strcpy(dsp_buffer, "PSAM计算TMAC初始化失败");
	}
	else if(0x0203==istate)
	{
		strcpy(dsp_buffer, "PSAM计算TMAC初始化失败");
	}
	else if(0x0204==istate)
	{
		strcpy(dsp_buffer, "PSAM计算TMAC初始化失败");
	}
	else if(0x0301==istate)
	{
		strcpy(dsp_buffer, "PSAM计算TMAC第1部分失败");
		sprintf(dsp_buffer + strlen(dsp_buffer), "%x%x", apdu_buffer[0], apdu_buffer[1]);
	}
	else if(0x0302==istate)
	{
		strcpy(dsp_buffer, "PSAM计算TMAC第1部分失败");
	}
	else if(0x0303==istate)
	{
		strcpy(dsp_buffer, "PSAM计算TMAC第1部分失败");
	}
	else if(0x0304==istate)
	{
		strcpy(dsp_buffer, "PSAM计算TMAC第1部分失败");
	}
	else if(0x0401==istate)
	{
		strcpy(dsp_buffer, "PSAM计算TMAC第2部分失败");
		sprintf(dsp_buffer + strlen(dsp_buffer), "%x%x", apdu_buffer[0], apdu_buffer[1]);
	}
	else if(0x0402==istate)
	{
		strcpy(dsp_buffer, "PSAM计算TMAC第2部分失败");
	}
	else if(0x0403==istate)
	{
		strcpy(dsp_buffer, "PSAM计算TMAC第2部分失败");
	}
	else if(0x0404==istate)
	{
		strcpy(dsp_buffer, "PSAM计算TMAC第2部分失败");
	}
	else if(0x0501==istate)
	{
		strcpy(dsp_buffer, "PSAM复选应用1失败");
		sprintf(dsp_buffer + strlen(dsp_buffer), "%x%x", apdu_buffer[0], apdu_buffer[1]);
	}
	else if(0x0502==istate)
	{
		strcpy(dsp_buffer, "PSAM复选应用1失败");
	}
	else if(0x0503==istate)
	{
		strcpy(dsp_buffer, "PSAM复选应用1失败");
	}
	else if(0x0504==istate)
	{
		strcpy(dsp_buffer, "PSAM复选应用1失败");
	}
	else if(0!=istate)
	{
		strcpy(dsp_buffer, "计算账单TMAC失败");
	}
	if(strlen(dsp_buffer)>0)
	{
		jljOilErrLogWrite(iptparam->Id, dsp_buffer);
	}

	//转入账单存储过程
	iptPidSet(iptparam, IPT_PID_TM_ZD_SAVE);


#if 0
	//根据错误代码提示
	if(0x0101==istate){
		
		memcpy(&dsp_buffer[0], apdu_buffer, 2);
		dsp_buffer[2]=17;	memcpy(&dsp_buffer[3], "PSAM选择应用2失败", 17);
		dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
		IPT_DSP_WAIT();
	}
	else if(0x0102==istate){

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM选择应用2失败", 17);
		IPT_DSP_WAIT();
	}
	else if(0x0103==istate){
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM选择应用2超时", 17);
		IPT_DSP_WAIT();
	}
	else if(0x0104==istate){
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM选择应用2错误", 17);
		IPT_DSP_WAIT();
	}
	else if(0x0201==istate){
		
		memcpy(&dsp_buffer[0], apdu_buffer, 2);
		dsp_buffer[2]=22;	memcpy(&dsp_buffer[3], "PSAM计算TMAC初始化失败", 22);
		dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
		IPT_DSP_WAIT();
	}
	else if(0x0202==istate){
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM计算TMAC初始化失败", 22);
		IPT_DSP_WAIT();
	}
	else if(0x0203==istate){
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM计算TMAC初始化失败", 22);
		IPT_DSP_WAIT();
	}
	else if(0x0204==istate){
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM计算TMAC初始化失败", 22);
		IPT_DSP_WAIT();
	}
	else if(0x0301==istate){
		
		memcpy(&dsp_buffer[0], apdu_buffer, 2);
		dsp_buffer[2]=23;	memcpy(&dsp_buffer[3], "PSAM计算TMAC第1部分失败", 23);
		dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
		IPT_DSP_WAIT();
	}
	else if(0x0302==istate){
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM计算TMAC第1部分失败", 23);
		IPT_DSP_WAIT();
	}
	else if(0x0303==istate){
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM计算TMAC第1部分失败", 23);
		IPT_DSP_WAIT();
	}
	else if(0x0304==istate){
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM计算TMAC第1部分失败", 23);
		IPT_DSP_WAIT();
	}
	else if(0x0401==istate){
		
		memcpy(&dsp_buffer[0], apdu_buffer, 2);
		dsp_buffer[2]=23;	memcpy(&dsp_buffer[3], "PSAM计算TMAC第2部分失败", 23);
		dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
		IPT_DSP_WAIT();
	}
	else if(0x0402==istate){
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM计算TMAC第2部分失败", 23);
		IPT_DSP_WAIT();
	}
	else if(0x0403==istate){
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM计算TMAC第2部分失败", 23);
		IPT_DSP_WAIT();
	}
	else if(0x0404==istate){
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM计算TMAC第2部分失败", 23);
		IPT_DSP_WAIT();
	}
	else if(0x0501==istate){
		
		memcpy(&dsp_buffer[0], apdu_buffer, 2);
		dsp_buffer[2]=17;	memcpy(&dsp_buffer[3], "PSAM复选应用1失败", 17);
		dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
		IPT_DSP_WAIT();
	}
	else if(0x0502==istate){
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM复选应用1失败", 17);
		IPT_DSP_WAIT();
	}
	else if(0x0503==istate){
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM复选应用1失败", 17);
		IPT_DSP_WAIT();
	}
	else if(0x0504==istate){
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "PSAM复选应用1失败", 17);
		IPT_DSP_WAIT();
	}
	else{

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "计算账单TMAC失败", 16);
		IPT_DSP_WAIT();
	}


	//转入账单存储过程
	if(0!=istate)	dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
	iptPidSet(iptparam, IPT_PID_TM_ZD_SAVE);
#endif
	return;
}


/*******************************************************************
*Name				:iptTMIcZDSave
*Description		:条码自助，内置卡加油账单保存
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptTMIcZDSave(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char tx_buffer[256]={0};
	int tx_len=0, t_type=0;
	unsigned char dsp_buffer[64]={0}, dsp_len=0;

	if(IPT_2PCD_UNUSED==iptparam->PcdTxFlag)
	{
		//保存账单
		tx_buffer[0]=++iptparam->PcdTxFrame;
		tx_buffer[1]=pcdMboardIDRead();
		tx_buffer[2]=iptparam->Id;
		tx_buffer[3]=iptparam->PhysicalNozzle;
		tx_buffer[4]=IPT_CMD_ZDSAVE;
		memcpy(&tx_buffer[5], iptparam->OilBill, IPT_BILL_SIZE);
		tx_len=133;
		//msgQSend((MSG_Q_ID)pcdMsgIdRead(), tx_buffer, tx_len, NO_WAIT, MSG_PRI_NORMAL);

		struct msg_struct msg_stIptSend;  //fj:20170918
		msg_stIptSend.msgType = 1;
		memcpy(msg_stIptSend.msgBuffer,tx_buffer,tx_len);
		msgsnd(pcdMsgIdRead(),&msg_stIptSend,tx_len,IPC_NOWAIT);

		iptparam->PcdTxFlag=IPT_2PCD_OILPROCESS;	iptparam->PcdTxTimer=0;
	}
	else
	if((IPT_2PCD_OILPROCESS==iptparam->PcdTxFlag)&&(msg_len>0)&&(iptparam->PhysicalNozzle==msg_buffer[3])&&(IPT_CMD_ZDSAVE==msg_buffer[4])&&(0==msg_buffer[5])){
		
		//账单状态改为完成
		iptparam->OilBill[IPT_OFFSET_ZD_STATE]=0;

		//计算账单校验值
		iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

		//保存账单及备份
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

		//如果是补扣或补充账单则不再上送条码账单并转入结果界面
		t_type=iptparam->OilBill[IPT_OFFSET_T_TYPE]&0x0f;
		if(1 == iptIsLianda(iptparam->Id))
		{
			iptPidSet(iptparam, IPT_PID_TM_OIL_END);
		}
		else if(IPT_BILLTYPE_UNLOCK==t_type || IPT_BILLTYPE_FINISH==t_type)
		{
			iptPidSet(iptparam, IPT_PID_TM_OIL_END);
		}
		else
		{
			iptPidSet(iptparam, IPT_PID_TM_ZD_UPLOAD);
		}

		iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdOverTimes=0;
	}
	else
	if((IPT_2PCD_OILPROCESS==iptparam->PcdTxFlag)&&(iptparam->PcdTxTimer>=(2000*ONE_MILLI_SECOND))){

		//通讯超时重发，3次超时失败提示信息后退卡
		iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdOverTimes++;
		if(iptparam->PcdOverTimes>=3){

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "账单保存超时", 12);
			IPT_DSP_WAIT();

			//如果是补扣或补充账单则不再上送条码账单并转入结果界面
			dsp(iptparam->DEVDsp, DSP_TM_OILFINISH, "\x00", 0);
			t_type=iptparam->OilBill[IPT_OFFSET_T_TYPE]&0x0f;
			if(IPT_BILLTYPE_UNLOCK==t_type || IPT_BILLTYPE_FINISH==t_type){

				iptPidSet(iptparam, IPT_PID_TM_OIL_END);
			}
			else{

				iptPidSet(iptparam, IPT_PID_TM_ZD_UPLOAD);
			}
			
			iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdOverTimes=0;
		}
	}

	return;
}


/*******************************************************************
*Name				:iptTMZDUpload
*Description		:条码自助加油加油机向PC机上传账单
*Input				:None
*Output			:None
*Return				:None
*History			:2014-11-15,modified by syj  */

static void iptTMZDUpload(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char tx_buffer[128]={0};
	int tx_len=0, istate=0;
	unsigned char dsp_buffer[64]={0}, dsp_len=0;
	
	if(IPT_2CPOS_UNUSED==iptparam->CPOSFlag && iptparam->CPOSTimer>=500*ONE_MILLI_SECOND){

		tx_buffer[0]=0x64;
		tx_buffer[1]=iptparam->LogicNozzle;
		framRead(FM_ADDR_IPT_SINO, IPT_FM_DATALEN*iptparam->Id+IPT_FM_ZD_TM, &tx_buffer[1], 28);
		tx_len=29;
		istate=CPOSWrite(iptparam->Id, IptPcInfo.SInfo.POS_P, tx_buffer, tx_len);

		iptparam->CPOSFlag=IPT_2CPOS_OILPROCESS;	iptparam->CPOSTimer=0;
	}
	else	if(IPT_2CPOS_OILPROCESS==iptparam->CPOSFlag && msg_len>0 && 0xfa==msg_buffer[0] && 0x65==msg_buffer[6] && iptparam->LogicNozzle==msg_buffer[7]){

		//1byte账单状态0=已上传；1=未上传；
		iptparam->BarOilBill[IPT_BAR_OFF_STATE]=0;
		//1byte异或校验码
		iptparam->BarOilBill[IPT_BAR_OFF_CHECK]=xorGet(iptparam->BarOilBill, IPT_BAR_BILL_SIZE-1);
		//存储账单数据
		framWrite(FM_ADDR_IPT_SINO, IPT_FM_DATALEN*iptparam->Id+IPT_FM_ZD_TM, iptparam->BarOilBill, IPT_BAR_BILL_SIZE);
		framWrite(FM_ADDR_IPT_SINO, IPT_FM_DATALEN*iptparam->Id+IPT_FM_ZD_TM2, iptparam->BarOilBill, IPT_BAR_BILL_SIZE);

		//转入条码加油结束处理过程
		iptPidSet(iptparam, IPT_PID_TM_OIL_END);

		iptparam->CPOSFlag=IPT_2CPOS_UNUSED;	iptparam->CPOSTimer=0;	iptparam->CPOSOvertimes=0;
	}
	else if(IPT_2CPOS_OILPROCESS==iptparam->CPOSFlag && iptparam->CPOSTimer>=(5*ONE_SECOND)){
		
		//通讯超时重发，3次超时失败提示信息
		iptparam->CPOSFlag=IPT_2CPOS_UNUSED;	iptparam->CPOSTimer=0;	iptparam->CPOSOvertimes++;

		if(iptparam->CPOSOvertimes>=3){

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "授权账单上送超时", 16);
			IPT_DSP_WAIT();

			//置位条码账单上传标识，使条码账单能够主动上传
			iptparam->BarBillUpload=1;

			//转入条码加油结束处理过程
			iptPidSet(iptparam, IPT_PID_TM_OIL_END);

			iptparam->CPOSOvertimes=0;
		}
	}

	return;
}


/*******************************************************************
*Name				:iptTMZDOilEnd
*Description		:条码自助加油结束处理
*Input				:None
*Output			:None
*Return				:None
*History			:2014-11-15,modified by syj  */

static void iptTMZDOilEnd(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char dsp_buffer[64]={0}, dsp_len=0, t_type=0, auto_print=0;
	unsigned int shouquan_money=0, money_balance=0;
	int voice[SPK_MAX_NUMBER]={0}, voice_len=0, tmp_voice[16]={0}, tmp_voice_len=0, i=0;

	//本次账单可通过快捷方式重打印
	iptparam->BarBillPrintRepeat = 1;

	//如果是补扣或补充账单则继续读取卡余额
	t_type=iptparam->OilBill[IPT_OFFSET_T_TYPE]&0x0f;
	if(IPT_BILLTYPE_UNLOCK==t_type || IPT_BILLTYPE_FINISH==t_type)
	{
		dsp(iptparam->DEVDsp, DSP_TM_AUTHORIZING, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_TM_BAL_READ);
		return;
	}

	//计算授权余额
	shouquan_money=(iptparam->BarMoney[0]<<16)|(iptparam->BarMoney[1]<<8)|(iptparam->BarMoney[2]<<0);
	money_balance=shouquan_money-iptparam->OilMoney;

	//语音提示"您此次的加油量是XXXX.XX升,XXXX.XX元，祝您一路平安，欢迎下次光临"
	if(iptparam->VoiceVolume>0 && (IPT_BILLTYPE_NORMAL==t_type || IPT_BILLTYPE_ESCAPE==t_type))
	{
		//您此次的加油量是
		if(IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType)	voice[voice_len++]=SPKW_THISVOLUME;	
		else																				voice[voice_len++]=SPKM_THISVOLUME;
		//XXXX.XX
		tmp_voice_len=iptHexVoiceIdGet(iptparam, iptparam->OilVolume, tmp_voice);
		for(i=0; i<tmp_voice_len; i++)	voice[voice_len++]=tmp_voice[i];
		//升
		if(IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType)	voice[voice_len++]=SPKW_SHENG;	
		else																				voice[voice_len++]=SPKM_SHENG;
		//XXXX.XX
		tmp_voice_len=iptHexVoiceIdGet(iptparam, iptparam->OilMoney, tmp_voice);			
		for(i=0; i<tmp_voice_len; i++)	voice[voice_len++]=tmp_voice[i];
		//元
		if(IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType)	voice[voice_len++]=SPKW_YUAN;	
		else																				voice[voice_len++]=SPKM_YUAN;
		//
		//*	有余额提示"本次加油尚有余额，请凭打印票据到营业室退款"；
		//*	无余额提示"祝您一路平安，欢迎下次光临"；
		
		if(money_balance>0)
		{
			if(IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType)	voice[voice_len++]=SPKW_OILBALANCE;		
			else																				voice[voice_len++]=SPKM_OILBALANCE;
		}
		else
		{
			if(IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType)	voice[voice_len++]=SPKW_SEEYOU;		
			else																				voice[voice_len++]=SPKM_SEEYOU;
		}

		iptSpk(iptparam, voice, voice_len);
	}

	//自动打印条码小票
	if(money_balance>0 || 1 == iptparam->PrintAuto)
	{
		iptparam->BarBillPrintRepeat = 0;
		iptPrint(iptparam, 3, iptparam->BarOilBill, IPT_BAR_BILL_SIZE);
	}

	//显示条码加油结束界面
	dsp_buffer[0]=(char)(money_balance>>16);	dsp_buffer[1]=(char)(money_balance>>8);	dsp_buffer[2]=(char)(money_balance>>0);
	dsp_len=3;
	dsp(iptparam->DEVDsp, DSP_TM_OIL_FINAL, dsp_buffer, dsp_len);

	//促销机通知平板油机状态
	if(1 == paramPromotionGet())
	{
		iptparam->TaState = IPT_STATE_TM_OIL_END;	iptparam->TaStateParamLength = 0;
		*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = (char)(iptparam->OilMoney>>24);
		*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = (char)(iptparam->OilMoney>>16);
		*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = (char)(iptparam->OilMoney>>8);
		*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = (char)(iptparam->OilMoney>>0);
		*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = (char)(iptparam->OilVolume>>24);
		*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = (char)(iptparam->OilVolume>>16);
		*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = (char)(iptparam->OilVolume>>8);
		*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = (char)(iptparam->OilVolume>>0);
		*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = (char)(money_balance>>24);
		*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = (char)(money_balance>>16);
		*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = (char)(money_balance>>8);
		*(iptparam->TaStateParam + iptparam->TaStateParamLength++) = (char)(money_balance>>0);
		pcStateUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TaState, iptparam->TaStateParam, iptparam->TaStateParamLength);
	}

	//转入等待结束处理
	iptparam->NousedTimer=0;
	iptPidSet(iptparam, IPT_PID_TM_OIL_ENDWAIT);
	
	return;
}


/*******************************************************************
*Name				:iptTMZDOilEndWait
*Description		:条码自助加油结束等待处理
*Input				:None
*Output			:None
*Return				:None
*History			:2014-11-15,modified by syj  */

static void iptTMZDOilEndWait(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	//超时5秒无操作或有按键操作时返回待机过程
	if(iptparam->NousedTimer>=(5*ONE_SECOND) || KB_BUTTON_NO!=iptparam->Button)
	{
		iptMainInterface(iptparam);
	}

	return;
}


/*******************************************************************
*Name				:iptTMProcess
*Description		:条码加油处理
*Input				:None
*Output			:None
*Return				:None
*History			:2014-04-17,modified by syj  */

static void iptTMProcess(IptParamStructType *iptparam, unsigned char *msg_buffer,	int msg_len)
{
	switch(iptparam->ProcessId)
	{
//	case IPT_PID_TM_BAR_SCAN:			//条码自助:等待界面扫描条码
//		iptTMBarScan(iptparam, msg_buffer,	msg_len);
//		break;

//	case IPT_PID_TM_BAR_INPUT:			//条码自助:条码输入界面
//		iptTMBarInput(iptparam, msg_buffer,	msg_len);
//		break;

	case IPT_PID_TM_PRETREAT:			//条码自助:条码扫描前的预处理工作
		iptTMPretreat(iptparam, msg_buffer, msg_len);
		break;

	case IPT_PID_TM_SCAN:
		iptTMBarcodeScan(iptparam, msg_buffer, msg_len);
		break;
		
	case IPT_PID_TM_IC_PRETREAT:		//条码自助:IC卡预处理
		iptTMIcPretreat(iptparam, msg_buffer,	msg_len);
		break;
		
	case IPT_PID_TM_PSAM_PRE:			//条码自助:PSAM预处理
		iptTMPsamPretreat(iptparam, msg_buffer,	msg_len);
		break;
		
	case IPT_PID_TM_CHECK:				//条码自助:PSAM卡及IC卡合法性检查
		iptTMIcCheck(iptparam, msg_buffer,	msg_len);
		break;
		
	case IPT_PID_TM_PIN_INPUT:			//条码自助:IC卡密码输入
		iptTMIcPinInput(iptparam, msg_buffer,	msg_len);
		break;
		
	case IPT_PID_TM_PIN_CHECK:			//条码自助:IC卡密码验证
		iptTMIcPinCheck(iptparam, msg_buffer,	msg_len);
		break;
		
	case IPT_PID_TM_BL_CHECK:			//条码自助:IC卡黑/白名单检查
		iptTMBLCheck(iptparam, msg_buffer,	msg_len);
		break;
		
	case IPT_PID_TM_LOCK_INFO:			//条码自助:IC卡灰锁交易记录查询
		iptTMLockInfo(iptparam, msg_buffer,	msg_len);
		break;
		
	case IPT_PID_TM_LOCKRECORD:		//条码自助:查询灰卡交易记录
		iptTMLockRecordGet(iptparam, msg_buffer, msg_len);
		break;

	case IPT_PID_TM_BAL_READ:			//条码自助:IC卡余额读取
		iptTMBalanceRead(iptparam, msg_buffer,	msg_len);
		break;
		
	case IPT_PID_TM_CODE_CHECK:		//条码自助:加油机向PC机查询验证码
		iptTMCodeCheck(iptparam, msg_buffer,	msg_len);
		break;
		
	case IPT_PID_TM_CODE_ACK:			//条码自助:加油机确认PC机的查询结果
		iptTMCodeACK(iptparam, msg_buffer,	msg_len);
		break;
		
	case IPT_PID_TM_AUTHORIZED:		//条码自助:授权成功界面
		iptTMAuthorized(iptparam, msg_buffer,	msg_len);
		break;

	case IPT_PID_TM_PAY_MODE:			//结算方式选择
		iptTMPayModeSelect(iptparam, msg_buffer, msg_len);
		break;

	case IPT_PID_TM_OIL_ACK:				//条码自助:油品确认界面
		iptTMOilAck(iptparam, msg_buffer, msg_len);
		break;
		
	case IPT_PID_TM_OILCHECK	:			//条码自助:加油启动数据合法性检测
		iptTMOilCheck(iptparam, msg_buffer,	msg_len);
		break;
		
	case IPT_PID_TM_OIL_AUTHEN	:		//条码自助:IC卡加油启动认证
		iptTMOilAuthen(iptparam, msg_buffer,	msg_len);
		break;

	case IPT_PID_TM_LOCK_INIT:			//条码自助:灰锁初始化
		iptTMIcLockInit(iptparam, msg_buffer,	msg_len);
		break;
		
	case IPT_PID_TM_MAC1:					//条码自助:PSAM计算MAC1
		iptTMMac1(iptparam, msg_buffer,	msg_len);
		break;
		
	case IPT_PID_TM_LOCK:					//条码自助:IC卡灰锁
		iptTMIcLock(iptparam, msg_buffer,	msg_len);
		break;
		
	case IPT_PID_TM_MAC2:					//条码自助:PSAM验证MAC2
		iptTMMac2(iptparam, msg_buffer,	msg_len);
		break;
		
	case IPT_PID_TM_OILSTART:			//条码自助:IC卡开始加油
		iptTMOilStart(iptparam, msg_buffer,	msg_len);
		break;
		
	case IPT_PID_TM_OILLING:				//条码自助:IC卡加油中
		iptTMOilling(iptparam, msg_buffer,	msg_len);
		break;
		
	case IPT_PID_TM_OILFINISH	:			//条码自助:IC卡结束加油
		iptTMOilFinish(iptparam, msg_buffer,	msg_len);
		break;
		
	case IPT_PID_TM_PSAM_GMAC:		//条码自助:PSAM产生GMAC
		iptTMPsamGMAC(iptparam, msg_buffer,	msg_len);
		break;
		
	case IPT_PID_TM_UNLOCK:				//条码自助:IC卡解扣
		iptTMIcUnlock(iptparam, msg_buffer,	msg_len);
		break;
		
	case IPT_PID_TM_TAC_CLEAR:			//条码自助:IC卡TAC清除
		iptTMIcTACClear(iptparam, msg_buffer,	msg_len);
		break;
		
	case IPT_PID_TM_TTC_GET:				//条码自助:获取PCD分配的TTC
		iptTMTTCGet(iptparam, msg_buffer,	msg_len);
		break;
		
	case IPT_PID_TM_TMAC:					//条码自助:计算账单TMAC
		iptTMIcTMAC(iptparam, msg_buffer,	msg_len);
		break;

	case IPT_PID_TM_ZD_SAVE:				//条码自助:加油数据保存
		iptTMIcZDSave(iptparam, msg_buffer,	msg_len);
		break;
		
	case IPT_PID_TM_ZD_UPLOAD:		//条码自助:加油机主动上传授权加油结果信息
		iptTMZDUpload(iptparam, msg_buffer,	msg_len);
		break;

	case IPT_PID_TM_OIL_END:				//条码自助:加油结束等待处理
		iptTMZDOilEnd(iptparam, msg_buffer,	msg_len);
		break;

	case IPT_PID_TM_OIL_ENDWAIT:		//条码自助:加油结束等待处理
		iptTMZDOilEndWait(iptparam, msg_buffer,	msg_len);
		break;

	default:
		iptMainInterface(iptparam);
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptErrOilOver
*Description		:加油机加油过冲
*Input				:None
*Output			:None
*Return				:None
*History			:2014-04-17,modified by syj  */

static void iptErrOilOver(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char bill_buffer[64]={0};
	int crc_return=0;

	//有卡插入时退卡
	if(0x30==iptparam->IcState.DeckStateS1)
	{
		ICShoot(iptparam->DEVIC);
	}

	//钥匙打到设置位置，按"设置+1"解除过冲锁机
	if(KB_KEYLOCK_SET==iptparam->KeyLock && KB_BUTTON_SET1==iptparam->Button)
	{
		memset(bill_buffer, 0, 32);	iptparam->MoneyUnself=0;	iptparam->VolumeUnself=0;
		iptparam->MoneyUnselfSum=0;	iptparam->VolumeUnselfSum=0;	iptparam->OilOverTimes=0;
		bill_buffer[0]=(char)(iptparam->MoneyUnself>>16);
		bill_buffer[1]=(char)(iptparam->MoneyUnself>>8);		bill_buffer[2]=(char)(iptparam->MoneyUnself>>0);
		bill_buffer[3]=(char)(iptparam->VolumeUnself>>16);
		bill_buffer[4]=(char)(iptparam->VolumeUnself>>8);	bill_buffer[5]=(char)(iptparam->VolumeUnself>>0);
		bill_buffer[6]=0;
		bill_buffer[7]=(char)(iptparam->MoneyUnselfSum>>16);	
		bill_buffer[8]=(char)(iptparam->MoneyUnselfSum>>8);		bill_buffer[9]=(char)(iptparam->MoneyUnselfSum>>0);
		bill_buffer[10]=(char)(iptparam->VolumeUnselfSum>>16);	
		bill_buffer[11]=(char)(iptparam->VolumeUnselfSum>>8);	bill_buffer[12]=(char)(iptparam->VolumeUnselfSum>>0);
		bill_buffer[13]=iptparam->OilOverTimes;
		crc_return=crc16Get(bill_buffer, 30);
		bill_buffer[30]=(char)(crc_return>>8);	bill_buffer[31]=(char)(crc_return>>0);
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_UNSELF, bill_buffer, 32);
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_UNSELF2, bill_buffer, 32);

		//返回待机界面
		iptMainInterface(iptparam);
	}

	return;
}


/*******************************************************************
*Name				:iptErrInfoTMAC
*Description		:内部出错信息计算TMAC过程
*Input				:None
*Output			:None
*Return				:None
*History			:2015-05-27,modified by syj  */

static void iptErrInfoTMAC(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char buffer[128]={0}, tmac_buffer[128]={0};
	int istate=0, apdu_len=0, i=0, crc_data=0;

	//组织TMAC计算的数据
	memset(&tmac_buffer[0], 0, 8);		//初始值
	for(i=0; i<36; i++){

		if(iptparam->ErrInfo[8+i*2+0]>='0' && iptparam->ErrInfo[8+i*2+0]<='9')			tmac_buffer[8+i]|=((iptparam->ErrInfo[8+i*2+0]-'0'+0x00)<<4);
		else if(iptparam->ErrInfo[8+i*2+0]>='a' && iptparam->ErrInfo[8+i*2+0]<='z')	tmac_buffer[8+i]|=((iptparam->ErrInfo[8+i*2+0]-'a'+0x0a)<<4);
		else if(iptparam->ErrInfo[8+i*2+0]>='A' && iptparam->ErrInfo[8+i*2+0]<='Z')	tmac_buffer[8+i]|=((iptparam->ErrInfo[8+i*2+0]-'A'+0x0a)<<4);
		else																															tmac_buffer[8+i]|=((iptparam->ErrInfo[8+i*2+0]&0x0f)<<4);

		if(iptparam->ErrInfo[8+i*2+1]>='0' && iptparam->ErrInfo[8+i*2+1]<='9')			tmac_buffer[8+i]|=((iptparam->ErrInfo[8+i*2+1]-'0'+0x00)<<0);
		else if(iptparam->ErrInfo[8+i*2+1]>='a' && iptparam->ErrInfo[8+i*2+1]<='z')	tmac_buffer[8+i]|=((iptparam->ErrInfo[8+i*2+1]-'a'+0x0a)<<0);
		else if(iptparam->ErrInfo[8+i*2+1]>='A' && iptparam->ErrInfo[8+i*2+1]<='Z')	tmac_buffer[8+i]|=((iptparam->ErrInfo[8+i*2+1]-'A'+0x0a)<<0);
		else																															tmac_buffer[8+i]|=((iptparam->ErrInfo[8+i*2+1]&0x0f)<<0);
	}
	memcpy(&tmac_buffer[44], "\x80\x00\x00\x00", 4);	//补齐长度为8的倍数

	//计算TMAC
	for(i=0; i<3; i++){

		//复位PSAM
		istate=PsamReset(iptparam->DEVIC, iptparam->DEVPsam);
		if(ICSTATE_OK!=istate){

			continue;
		}

		//选择ＭＦ文件(PSE SLECTE)	
		memset(buffer, 0, 128);
		istate=PsamMFSelect(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128);
		if(ICSTATE_OK==istate){

			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2)){}
			else{
				
				continue;
			}
		}
		else{

			continue;
		}

		//PSAM选择应用2
		memset(buffer, 0, 128);
		istate=PsamDFSelect(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, 2);
		if(ICSTATE_OK==istate){
		
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2)){}
			else{

				continue;
			}
		}
		else{

			continue;
		}

		//PSAM计算T_MAC初始化
		memset(buffer, 0, 128);
		istate=PsamTMACInit(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128);
		if(ICSTATE_OK==istate){
		
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2)){}
			else{

				continue;
			}
		}
		else{

			continue;
		}

		//计算错误信息TMAC?/
		memset(buffer, 0, 128);
		istate=PsamTMACOperat(iptparam->DEVIC, iptparam->DEVPsam, buffer, 128, tmac_buffer, 48, 0, 1);
		if(ICSTATE_OK==istate){
		
			apdu_len=(buffer[0]<<8)|(buffer[1]<<0);
			if(0==memcmp(&buffer[2+apdu_len-2], "\x90\x00", 2)){

				hex2Ascii(&buffer[2], 4, &iptparam->ErrInfo[80], 8);	//以字符形式保存TMAC计算结果
				break;
			}
			else{

				continue;
			}
		}
		else{

			continue;
		}
	}

	//计算并保存错误信息CRC，自厂商编号~验算MAC共80字节
	memset(buffer, 0, 128);
	for(i=0; i<40; i++){

		if(iptparam->ErrInfo[8+i*2+0]>='0' && iptparam->ErrInfo[8+i*2+0]<='9')			buffer[i]|=((iptparam->ErrInfo[8+i*2+0]-'0'+0x00)<<4);
		else if(iptparam->ErrInfo[8+i*2+0]>='a' && iptparam->ErrInfo[8+i*2+0]<='z')	buffer[i]|=((iptparam->ErrInfo[8+i*2+0]-'a'+0x0a)<<4);
		else if(iptparam->ErrInfo[8+i*2+0]>='A' && iptparam->ErrInfo[8+i*2+0]<='Z')	buffer[i]|=((iptparam->ErrInfo[8+i*2+0]-'A'+0x0a)<<4);
		else																															buffer[i]|=((iptparam->ErrInfo[8+i*2+0]&0x0f)<<4);

		if(iptparam->ErrInfo[8+i*2+1]>='0' && iptparam->ErrInfo[8+i*2+1]<='9')			buffer[i]|=((iptparam->ErrInfo[8+i*2+1]-'0'+0x00)<<0);
		else if(iptparam->ErrInfo[8+i*2+1]>='a' && iptparam->ErrInfo[8+i*2+1]<='z')	buffer[i]|=((iptparam->ErrInfo[8+i*2+1]-'a'+0x0a)<<0);
		else if(iptparam->ErrInfo[8+i*2+1]>='A' && iptparam->ErrInfo[8+i*2+1]<='Z')	buffer[i]|=((iptparam->ErrInfo[8+i*2+1]-'A'+0x0a)<<0);
		else																															buffer[i]|=((iptparam->ErrInfo[8+i*2+1]&0x0f)<<0);
	}
	crc_data=crc16Get(buffer, 40);
	buffer[0]=(char)(crc_data>>8);	buffer[1]=(char)(crc_data>>0);
	hex2Ascii(buffer, 2, &iptparam->ErrInfo[88], 4);

	//错误数据长度
	iptparam->ErrInfoBytes=92;

	//转入错误信息上传过程
	iptPidSet(iptparam, IPT_PID_ERRINFO_UPLOAD);

	return;
}


/*******************************************************************
*Name				:iptErrInfoUpload
*Description		:内部出错信息上传过程
*Input				:None
*Output			:None
*Return				:None
*History			:2015-05-27,modified by syj  */

static void iptErrInfoUpload(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	char tx_buffer[128]={0};
	int tx_len=0, i=0;

	if(IPT_2PCD_UNUSED==iptparam->PcdTxFlag){

		tx_buffer[0]=++iptparam->PcdTxFrame;
		tx_buffer[1]=pcdMboardIDRead();
		tx_buffer[2]=iptparam->Id;
		tx_buffer[3]=iptparam->PhysicalNozzle;
		tx_buffer[4]=IPT_CMD_ERRINFO_UPLOAD;
		tx_buffer[5]=(char)(iptparam->ErrInfoBytes>>8);	tx_buffer[6]=(char)(iptparam->ErrInfoBytes>>0);
		memcpy(&tx_buffer[7], iptparam->ErrInfo, iptparam->ErrInfoBytes);

		tx_len=iptparam->ErrInfoBytes+7;
		//msgQSend((MSG_Q_ID)pcdMsgIdRead(), tx_buffer, tx_len, NO_WAIT, MSG_PRI_NORMAL);

		struct msg_struct msg_stIptSend;  //fj:20170918
		msg_stIptSend.msgType = 1;
		memcpy(msg_stIptSend.msgBuffer,tx_buffer,tx_len);
		msgsnd(pcdMsgIdRead(),&msg_stIptSend,tx_len,IPC_NOWAIT);

		iptparam->PcdTxFlag=IPT_2PCD_OILPROCESS;	iptparam->PcdTxTimer=0;
	}
	else if(IPT_2PCD_OILPROCESS==iptparam->PcdTxFlag && msg_len>0 && IPT_CMD_ERRINFO_UPLOAD==msg_buffer[4]){

		iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdOverTimes=0;
		iptMainInterface(iptparam);
	}
	else if(IPT_2PCD_OILPROCESS==iptparam->PcdTxFlag && iptparam->PcdTxTimer>=(2*ONE_SECOND)){

		//通讯超时重发，3次超时失败提示信息后退卡
		iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdOverTimes++;
		if(iptparam->PcdOverTimes>=3){

			iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdOverTimes=0;
			iptMainInterface(iptparam);
		}
	}

	return;
}

//szb_fj_20171120:add
static void iptErrInfoPulseOrZero(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char state=0;

	//有卡插入时退卡
	if(0x30==iptparam->IcState.DeckStateS1)
	{
		ICShoot(iptparam->DEVIC);
	}
	
	//拧一下钥匙解除锁定
	if((iptparam->JlErr_Freebuff[0]!=0x55)&&(iptparam->JlErr_Freebuff[0]!=0x66) )
	{
		if(iptparam->KeyLock==0)
			iptparam->JlErr_Freebuff[0]=0x55;
		else
			iptparam->JlErr_Freebuff[0]=0x66;
	}
	else if((iptparam->JlErr_Freebuff[1]!=0x55)&&(iptparam->JlErr_Freebuff[1]!=0x66) )
	{
		if(iptparam->KeyLock==0)
			state=0x55;
		else
			state=0x66;
		if(state!=iptparam->JlErr_Freebuff[0])
			iptparam->JlErr_Freebuff[1]=state;
	}
	else if((iptparam->JlErr_Freebuff[2]!=0x55)&&(iptparam->JlErr_Freebuff[2]!=0x66) )
	{
		if(iptparam->KeyLock==0)
			state=0x55;
		else
			state=0x66;
		if(state!=iptparam->JlErr_Freebuff[1])
			iptparam->JlErr_Freebuff[2]=state;
	}

	//加油-设置-加油或者设置-加油-设置锁定解除
	if((memcmp(iptparam->JlErr_Freebuff,"\x55\x66\x55",3)==0) || \
		(memcmp(iptparam->JlErr_Freebuff,"\x66\x55\x66",3)==0))
	{
		//异常停机缺一路脉冲
		if(iptparam->JlErr_QYL>=6)
		{
			iptparam->JlErr_QYL=0;
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+FM_ERR_QUEYILU_PULSE,&iptparam->JlErr_QYL, 1);
		}
		//异常停机无脉冲超时
		else if(iptparam->JlErr_WMCCS>=6)
		{
			iptparam->JlErr_WMCCS=0;
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+FM_ERR_WU_PULSE,&iptparam->JlErr_WMCCS, 1);
		}
		//异常停机缺一组脉冲
		else if(iptparam->JlErr_QYZ>=6)
		{
			iptparam->JlErr_QYZ=0;
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+FM_ERR_QUEYIZU_PULSE,&iptparam->JlErr_QYZ, 1);
		}
		//异常停机零加油
		else if(iptparam->JlErr_ZERO>=6)
		{
			iptparam->JlErr_ZERO=0;
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+FM_ERR_LING_JIAYOU,&iptparam->JlErr_ZERO, 1);
		}
		memset(iptparam->JlErr_Freebuff,0,sizeof(iptparam->JlErr_Freebuff));
		
		iptMainInterface(iptparam);
	}
}


#if _IPT_DEBUG_
/*******************************************************************
*Name				:iptDebugCardTest
*Description		:加油机手工检测卡座
*Input				:None
*Output			:None
*Return				:None
*History			:2014-04-17,modified by syj  */

static void iptDebugCardTest(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	int istate=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_1:
		//电特性单次测试
		istate=IcReaderTestElectrical(iptparam->DEVIC, 0x30);
		break;
	case KB_BUTTON_2:
		//电特性连续测试 
		istate=IcReaderTestElectrical(iptparam->DEVIC, 0x31);
		break;
	case KB_BUTTON_3:
		//协议单次测试
		istate=IcReaderTestProtocol(iptparam->DEVIC, 0x34);
		break;
	case KB_BUTTON_4:
		//协议连续测试
		istate=IcReaderTestProtocol(iptparam->DEVIC, 0x35);
		break;
	case KB_BUTTON_5:
		//进入设置连续协议测试轮训时间
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_CARD_PROTOCOL_TIME, "\x00", 1);

		iptPidSet(iptparam, IPT_PID_DEBUG_TIME);
		break;
	case KB_BUTTON_6:
		//退出测试模式
		istate=IcReaderTestExit(iptparam->DEVIC);
		break;
	case KB_BUTTON_BACK:
		//退卡
		istate=ICShoot(iptparam->DEVIC);
		break;
	case KB_BUTTON_CHG:
		//退出操作
		*	退出测试模式；
		*	重新开始轮询；
		*	弹卡；
		*	返回待机界面；
		
		istate=IcReaderTestExit(iptparam->DEVIC);
		istate=ICShoot(iptparam->DEVIC);
		istate=IcPollStart(iptparam->DEVIC);
		iptMainInterface(iptparam);
		break;
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptDbgProTimeSet
*Description		:设置卡座连续协议测试轮训时间
*Input				:None
*Output			:None
*Return				:None
*History			:2014-04-17,modified by syj  */

static void iptDbgProTimeSet(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char dsp_buffer[16]={0}, button=0;
	unsigned int time_data=0;
	int istate=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0==button)	button='0';
	case KB_BUTTON_1:
		if(0==button)	button='1';
	case KB_BUTTON_2:
		if(0==button)	button='2';
	case KB_BUTTON_3:
		if(0==button)	button='3';
	case KB_BUTTON_4:
		if(0==button)	button='4';
	case KB_BUTTON_5:
		if(0==button)	button='5';
	case KB_BUTTON_6:
		if(0==button)	button='6';
	case KB_BUTTON_7:
		if(0==button)	button='7';
	case KB_BUTTON_8:
		if(0==button)	button='8';
	case KB_BUTTON_9:
		if(0==button)	button='9';

		//输入设置的时间，最大允许为两位数
		if(iptparam->SetButtonLen<2){

			iptparam->SetButton[0]=iptparam->SetButton[1];	iptparam->SetButton[1]=button;

			time_data=(iptparam->SetButton[0]&0x0f)*10+(iptparam->SetButton[1]&0x0f)*1;
			dsp_buffer[0]=(char)time_data;
			dsp(iptparam->DEVDsp, DSP_CARD_PROTOCOL_TIME, dsp_buffer, 1);
		}

		break;

	case KB_BUTTON_CHG:

		//有输入则清除输入，无输入返回卡座测试过程
		if(0==iptparam->SetButtonLen){

			dsp(iptparam->DEVDsp, DSP_CARD_TEST, "\x00", 0);	iptPidSet(iptparam, IPT_PID_DEBUG_CARD_TEST);
		}
		else{

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_CARD_PROTOCOL_TIME, "\x00", 1);
		}
		break;

	case KB_BUTTON_ACK:
		//输入值大于0时设置
		time_data=(iptparam->SetButton[0]&0x0f)*10+(iptparam->SetButton[1]&0x0f)*1;
		if(time_data>0){

			istate=IcReaderTestProtocolTime(iptparam->DEVIC, time_data*10);
		}

		dsp(iptparam->DEVDsp, DSP_CARD_TEST, "\x00", 0);	iptPidSet(iptparam, IPT_PID_DEBUG_CARD_TEST);
		break;

	default:
		break;
	}

	return;
}

#endif


/*******************************************************************
*Name				:iptErrProcess
*Description		:加油机内部出错处理
*Input				:None
*Output			:None
*Return				:None
*History			:2014-04-17,modified by syj  */

static void iptErrProcess(IptParamStructType *iptparam, unsigned char *msg_buffer,	int msg_len)
{
	switch(iptparam->ProcessId)
	{
	case IPT_PID_ERR_OILOVER:
		//过冲锁机的处理
		iptErrOilOver(iptparam, msg_buffer, msg_len);
		break;

	case IPT_PID_ERRINFO_TMAC:
		//内部出错信息计算TMAC过程
		iptErrInfoTMAC(iptparam, msg_buffer, msg_len);
		break;

	case IPT_PID_ERRINFO_UPLOAD:
		//内部出错信息上传过程
		iptErrInfoUpload(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_ERR_QUEYILU:    //缺一路脉冲停机
	case IPT_PID_ERR_LINGJIAYOU: //零加油停机
	case IPT_PID_ERR_WUPULSE:    //无脉冲超时停机
	case IPT_PID_ERR_QUEYIZU:    //缺一组脉冲停机
		iptErrInfoPulseOrZero(iptparam, msg_buffer, msg_len);
		break;	
#if _IPT_DEBUG_
	case IPT_PID_DEBUG_CARD_TEST:
		//送检时测试卡座
		iptDebugCardTest(iptparam, msg_buffer, msg_len);
		break;

	case IPT_PID_DEBUG_TIME:
		//检测卡座协议连续测试轮询时间设置过程
		iptDbgProTimeSet(iptparam, msg_buffer, msg_len);
		break;
#endif

	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptOperatPassIn
*Description		:油机操作准入密码验证界面
*Input				:None
*Output			:None
*Return				:None
*History			:2014-02-18,modified by syj  */

static void iptOperatPassIn(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char dsp_buffer[64]={0}, dsp_len=0, read_buffer[4]={0}, tmp_buffer[4]={0}, read_len=0, button=0;

	//油机进行查询/设置操作之前进行密码验证，
	//固定四位油站操作密码，输入密码时以"*"表示密码输入位数
	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0==button)	button='0';
	case KB_BUTTON_1:
		if(0==button)	button='1';
	case KB_BUTTON_2:
		if(0==button)	button='2';
	case KB_BUTTON_3:
		if(0==button)	button='3';
	case KB_BUTTON_4:
		if(0==button)	button='4';
	case KB_BUTTON_5:
		if(0==button)	button='5';
	case KB_BUTTON_6:
		if(0==button)	button='6';
	case KB_BUTTON_7:
		if(0==button)	button='7';
	case KB_BUTTON_8:
		if(0==button)	button='8';
	case KB_BUTTON_9:
		if(0==button)	button='9';

		//按数字键保存密码ASCII值
		if(iptparam->SetButtonLen<4)
		{
			iptparam->SetButton[iptparam->SetButtonLen++]=button;

			dsp_buffer[0]=iptparam->SetButtonLen;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_PASSWORD_INPUT, dsp_buffer, dsp_len);
		}
		break;

	case KB_BUTTON_CHG:
		//按"清除/退出"键，有密码时清除密码，无密码时返回服务选择界面
		if(0==iptparam->SetButtonLen)
		{
			iptMainInterface(iptparam);
		}
		else
		{
			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;

			dsp_buffer[0]=iptparam->SetButtonLen;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_PASSWORD_INPUT, dsp_buffer, dsp_len);
		}
		break;

	case KB_BUTTON_BACK:
		//按"退卡"键退出，返回待机界面
		iptMainInterface(iptparam);
		break;
		
	case KB_BUTTON_ACK:
		//选择"确认"，验证操作密码	
		tmp_buffer[0]=((iptparam->Password[0]>>4)&0x0f)+0x30;	tmp_buffer[1]=((iptparam->Password[0]>>0)&0x0f)+0x30;
		tmp_buffer[2]=((iptparam->Password[1]>>4)&0x0f)+0x30;	tmp_buffer[3]=((iptparam->Password[1]>>0)&0x0f)+0x30;
		if((4==iptparam->SetButtonLen)&&(0==memcmp(tmp_buffer, iptparam->SetButton, 4)))
		{
			dsp(iptparam->DEVDsp, DSP_OPERATE_SELECT, "\x00", 0);
		
			iptparam->SetPage=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_OPERATE_SELECT);
		}
		else
		{
			memcpy(&dsp_buffer[0], "密码错误，      ", 16);
			memcpy(&dsp_buffer[16], "      请重新输入", 16);	
			dsp_len=32;
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);
			IPT_DSP_WAIT();

			iptparam->SetPage=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp_buffer[0]=iptparam->SetButtonLen;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_PASSWORD_INPUT, dsp_buffer, dsp_len);
		}
		break;
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptOperatSelect
*Description		:操作选项选择处理
*Input				:None
*Output			:None
*Return				:None
*History			:2014-02-18,modified by syj  */

static void iptOperatSelect(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	switch(iptparam->Button)
	{
	case KB_BUTTON_1:
		//转入查询项选择界面，显示第一页
		dsp(iptparam->DEVDsp, DSP_INQ_SELECT, "\x00", 1);
		
		iptparam->SetPage=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_INQUIRY);
		break;
		
	case KB_BUTTON_2:
		//钥匙在加油位置，提示异常后恢复显示
		if(KB_KEYLOCK_OIL==iptparam->KeyLock)
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "请把钥匙打到设置位置", strlen("请把钥匙打到设置位置"));
			IPT_DSP_WAIT();

			dsp(iptparam->DEVDsp, DSP_OPERATE_SELECT, "\x00", 0);
			break;
		}

		//转入设置项选择界面，显示第一页
		dsp(iptparam->DEVDsp, DSP_SET_SELECT, "\x00", 1);

		iptparam->SetPage=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_SET);
		break;

	case KB_BUTTON_CHG:
	case KB_BUTTON_BACK:
		//返回主界面
		iptMainInterface(iptparam);
		break;
	default:
		break;
	}
	
	return;
}


/*******************************************************************
*Name				:iptInqInterface
*Description		:查询选项选择处理
*Input				:None
*Output			:None
*Return				:None
*History			:2014-11-27,modified by syj  */

static void iptInqInterface(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char dsp_buffer[128+1]={0}, dsp_len=0, tx_buffer[32]={0}, tx_len=0, button=0, tmpdata=0;

	unsigned int i=0, data_hex=0;
	unsigned long long data=0, sum_money=0, sum_volume=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0==button)	button='0';
	case KB_BUTTON_1:
		if(0==button)	button='1';
	case KB_BUTTON_2:
		if(0==button)	button='2';
	case KB_BUTTON_3:
		if(0==button)	button='3';
	case KB_BUTTON_4:
		if(0==button)	button='4';
	case KB_BUTTON_5:
		if(0==button)	button='5';
	case KB_BUTTON_6:
		if(0==button)	button='6';
	case KB_BUTTON_7:
		if(0==button)	button='7';
	case KB_BUTTON_8:
		if(0==button)	button='8';
	case KB_BUTTON_9:
		if(0==button)	button='9';
		//保存按键
		iptparam->SetButton[0]=iptparam->SetButton[1];	iptparam->SetButton[1]=button;

		if(0==iptparam->SetPage && '1'==iptparam->SetButton[1])
		{
			//1.总累,fj:
			jlSumRead(iptparam->JlNozzle, &sum_volume, &sum_money);

			dsp_buffer[0]=(char)(sum_money>>56);	dsp_buffer[1]=(char)(sum_money>>48);
			dsp_buffer[2]=(char)(sum_money>>40);	dsp_buffer[3]=(char)(sum_money>>32);
			dsp_buffer[4]=(char)(sum_money>>24);	dsp_buffer[5]=(char)(sum_money>>16);
			dsp_buffer[6]=(char)(sum_money>>8);	dsp_buffer[7]=(char)(sum_money>>0);
			dsp_buffer[8]=(char)(sum_volume>>56);	dsp_buffer[9]=(char)(sum_volume>>48);
			dsp_buffer[10]=(char)(sum_volume>>40);	dsp_buffer[11]=(char)(sum_volume>>32);
			dsp_buffer[12]=(char)(sum_volume>>24);	dsp_buffer[13]=(char)(sum_volume>>16);
			dsp_buffer[14]=(char)(sum_volume>>8);	dsp_buffer[15]=(char)(sum_volume>>0);
			dsp_len=16;
			dsp(iptparam->DEVDsp, DSP_INQ_JLSUM, dsp_buffer, dsp_len);

			//转入查询结果等待处理过程
			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_INQUIRY_WAIT);
		}
		else if(0==iptparam->SetPage && '2'==iptparam->SetButton[1])
		{
			//2.加油明细
			dsp(iptparam->DEVDsp, DSP_INQ_BILL_SELECT, "\x00", 0);

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptparam->InqBillNozzle=0;	iptparam->InqBillTTC=0;	iptparam->InqBillNext=0;
			iptPidSet(iptparam, IPT_PID_INQ_ZD_SEL);
		}
		else if(0==iptparam->SetPage && '3'==iptparam->SetButton[1])
		{
			//3.重打印
			iptPrint(iptparam, iptparam->PrintUnion, iptparam->OilBill, IPT_BILL_SIZE);

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "请取走小票", 10);
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_INQ_SELECT, &iptparam->SetPage, 1);
		}
		else if(0==iptparam->SetPage && '4'==iptparam->SetButton[1])
		{
			//4.油枪信息
			iptparam->SetPage2=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			
			dsp_buffer[0]=iptparam->SetPage2;
			dsp_buffer[1]=iptparam->LogicNozzle;	dsp_buffer[2]=iptparam->PhysicalNozzle;
			dsp_buffer[3]=iptparam->Id;	memcpy(&dsp_buffer[4], iptparam->OilCode, 2);
			dsp_buffer[6]=(char)(iptparam->FuelBillTTC>>24);	dsp_buffer[7]=(char)(iptparam->FuelBillTTC>>16);
			dsp_buffer[8]=(char)(iptparam->FuelBillTTC>>8);	dsp_buffer[9]=(char)(iptparam->FuelBillTTC>>0);
			dsp_buffer[10]=(char)(iptparam->FuelUnloadNumber>>24);	dsp_buffer[11]=(char)(iptparam->FuelUnloadNumber>>16);
			dsp_buffer[12]=(char)(iptparam->FuelUnloadNumber>>8);		dsp_buffer[13]=(char)(iptparam->FuelUnloadNumber>>0);
			dsp_len=14;
			dsp(iptparam->DEVDsp, DSP_INQ_NOZZLE_INFO, dsp_buffer, dsp_len);

			//转入查询结果等待处理过程
			iptPidSet(iptparam, IPT_PID_INQ_GUNINFO);
		}
		else if(1==iptparam->SetPage && '5'==iptparam->SetButton[1])
		{
			//5.主板信息
			dsp_buffer[0]=pcdMboardIDRead();
			dsp_buffer[1]=(char)(iptparam->BillTTC>>24);	dsp_buffer[2]=(char)(iptparam->BillTTC>>16);
			dsp_buffer[3]=(char)(iptparam->BillTTC>>8);		dsp_buffer[4]=(char)(iptparam->BillTTC>>0);
			dsp_buffer[5]=(char)(iptparam->UnloadNumber>>24);	dsp_buffer[6]=(char)(iptparam->UnloadNumber>>16);
			dsp_buffer[7]=(char)(iptparam->UnloadNumber>>8);	dsp_buffer[8]=(char)(iptparam->UnloadNumber>>0);
			dsp_len=9;
			dsp(iptparam->DEVDsp, DSP_INQ_BOARD_INFO, dsp_buffer, dsp_len);

			//转入主板信息查询操作界面
			iptparam->SetPage2=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_INQ_BOARDINFO);
		}
		else if(1==iptparam->SetPage && '6'==iptparam->SetButton[1])
		{
			//6.时间
			dsp_buffer[0]=iptparam->Time.century;	dsp_buffer[1]=iptparam->Time.year;	dsp_buffer[2]=iptparam->Time.month;
			dsp_buffer[3]=iptparam->Time.date;	dsp_buffer[4]=iptparam->Time.hour;dsp_buffer[5]=iptparam->Time.minute;
			dsp_buffer[6]=iptparam->Time.second;	dsp_len=7;
			dsp(iptparam->DEVDsp, DSP_INQ_TIME, dsp_buffer, dsp_len);

			//转入查询结果等待处理过程
			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_INQUIRY_WAIT);
		}
		else if(1==iptparam->SetPage && '7'==iptparam->SetButton[1])
		{
			//7.语音信息
			//转入查询结果等待处理过程
			dsp_buffer[0]=iptparam->Speaker;		dsp_buffer[1]=iptparam->VoiceType;	dsp_buffer[2]=iptparam->VoiceVolume;
			dsp_len=3;
			dsp(iptparam->DEVDsp, DSP_INQ_VOICE, dsp_buffer, dsp_len);

			//转入查询结果等待处理过程
			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_INQUIRY_WAIT);
		}
		else if(1==iptparam->SetPage && '8'==iptparam->SetButton[1])
		{
			//8.打印信息
			//转入查询结果等待处理过程
			dsp_buffer[0]=iptparam->Printer;		dsp_buffer[1]=iptparam->PrintAuto;	dsp_buffer[2]=iptparam->PrintUnion;
			dsp_len=3;
			dsp(iptparam->DEVDsp, DSP_INQ_PRINT, dsp_buffer, dsp_len);

			iptparam->SetPage2=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_INQ_PRN);
		}
		else if(2==iptparam->SetPage && '9'==iptparam->SetButton[1])
		{
			//9.税务累计,fj:
			jlTaxSumDsp(iptparam->JlNozzle, 0);

			//转入税控查询结果等待处理过程
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "请看大屏显示", 12);
			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_INQ_TAXWAIT);
		}
		else if(2==iptparam->SetPage && '1'==iptparam->SetButton[0] && '0'==iptparam->SetButton[1])
		{
			//10.出厂累计,fj:
			jlTaxSumDsp(iptparam->JlNozzle, 1);
			
			//转入税控查询结果等待处理过程
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "请看大屏显示", 12);
			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_INQ_TAXWAIT);
		}
		else if(2==iptparam->SetPage && '1'==iptparam->SetButton[0] && '1'==iptparam->SetButton[1])
		{
			//11.首检累计,fj:
			jlTaxSumDsp(iptparam->JlNozzle, 2);
			
			//转入税控查询结果等待处理过程
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "请看大屏显示", 12);
			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_INQ_TAXWAIT);
		}
		else if(2==iptparam->SetPage && '1'==iptparam->SetButton[0] && '2'==iptparam->SetButton[1])
		{
			//12.税务当次数据,fj:
			jlTaxNoteDsp(iptparam->JlNozzle);
			
			//转入税控查询结果等待处理过程
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "请看大屏显示", 12);
			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_INQ_TAXWAIT);
		}
		else if(3==iptparam->SetPage && '1'==iptparam->SetButton[0] && '3'==iptparam->SetButton[1])
		{
			//13.税务时间,fj:
			jlTaxTimeDsp();
			
			//转入税控查询结果等待处理过程
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "请看大屏显示", 12);
			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_INQ_TAXWAIT);
		}
		else if(3==iptparam->SetPage && '1'==iptparam->SetButton[0] && '4'==iptparam->SetButton[1])
		{
			//14.税务月累
			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp_buffer[0]=((iptparam->SetButton[0]&0x0f)<<4)|((iptparam->SetButton[1]&0x0f)<<0);
			dsp_buffer[1]=((iptparam->SetButton[2]&0x0f)<<4)|((iptparam->SetButton[3]&0x0f)<<0);
			dsp_buffer[2]=((iptparam->SetButton[4]&0x0f)<<4)|((iptparam->SetButton[5]&0x0f)<<0);
			dsp_len=3;
			dsp(iptparam->DEVDsp, DSP_MONTH_INPUT, dsp_buffer, dsp_len);

			iptPidSet(iptparam, IPT_PID_INQ_TAXMSUM);
		}
		else if(3==iptparam->SetPage && '1'==iptparam->SetButton[0] && '5'==iptparam->SetButton[1])
		{
			//15.税务日累
			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp_buffer[0]=((iptparam->SetButton[0]&0x0f)<<4)|((iptparam->SetButton[1]&0x0f)<<0);
			dsp_buffer[1]=((iptparam->SetButton[2]&0x0f)<<4)|((iptparam->SetButton[3]&0x0f)<<0);
			dsp_buffer[2]=((iptparam->SetButton[4]&0x0f)<<4)|((iptparam->SetButton[5]&0x0f)<<0);
			dsp_buffer[3]=((iptparam->SetButton[6]&0x0f)<<4)|((iptparam->SetButton[7]&0x0f)<<0);
			dsp_len=4;
			dsp(iptparam->DEVDsp, DSP_DATE_INPUT, dsp_buffer, dsp_len);

			iptPidSet(iptparam, IPT_PID_INQ_TAXDSUM);
		}
		else if(3==iptparam->SetPage && '1'==iptparam->SetButton[0] && '6'==iptparam->SetButton[1])
		{
			//16.加油限制
			dsp_buffer[0]=iptparam->CardStaffLimit;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_INQ_LIMIT_INFO, dsp_buffer, dsp_len);

			//转入查询结果等待处理过程
			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_INQUIRY_WAIT);
		}
		else if(4==iptparam->SetPage && '1'==iptparam->SetButton[0] && '7'==iptparam->SetButton[1])
		{
			//17.提前量,fj:
			printf("jlAdvanceRead:\n");
			jlAdvanceRead(iptparam->JlNozzle, &data_hex);
			dsp_buffer[0]=(char)(data_hex>>8);	dsp_buffer[1]=(char)(data_hex>>0);	dsp_len=2;
			dsp(iptparam->DEVDsp, DSP_INQ_ADVANCE_INFO, dsp_buffer, dsp_len);
			
			//转入查询结果等待处理过程
			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_INQUIRY_WAIT);
		}
		else if(4==iptparam->SetPage && '1'==iptparam->SetButton[0] && '8'==iptparam->SetButton[1])
		{
			//18.超时停机时间,fj:
			printf("jlUnPulseTimeRead:\n");
			jlUnPulseTimeRead(iptparam->JlNozzle, &data_hex);
			dsp_buffer[0]=data_hex;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_INQ_UNPULSE_TIME, dsp_buffer, dsp_len);
			
			//转入查询结果等待处理过程
			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_INQUIRY_WAIT);
		}
		else if(4==iptparam->SetPage && '1'==iptparam->SetButton[0] && '9'==iptparam->SetButton[1])
		{
			//19.绑定信息
			//	第一行时间；第二行主板ID；第三行ACT卡号后16位；第四行RID卡号后16位；
			
			memcpy(&dsp_buffer[0], iptparam->BindTime, 7);	memcpy(&dsp_buffer[7], iptparam->BindMboardId, 8);	
			memcpy(&dsp_buffer[15], &iptparam->BindACTAppId[2], 8);	memcpy(&dsp_buffer[23], &iptparam->BindRIDAppId[2], 8);	
			dsp_len=31;
			dsp(iptparam->DEVDsp, DSP_INQ_BIND_INFO, dsp_buffer, dsp_len);
			
			//转入查询结果等待处理过程
			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_INQUIRY_WAIT);
		}
		else if(4==iptparam->SetPage && '2'==iptparam->SetButton[0] && '0'==iptparam->SetButton[1])
		{
			//20.机型信息
			strcpy(dsp_buffer + strlen(dsp_buffer), "版本:");
			strcpy(dsp_buffer + strlen(dsp_buffer), _SOFTWARE_VERSION_);	
			if(strlen(dsp_buffer) < 16)	memset(dsp_buffer + strlen(dsp_buffer), ' ', 16-strlen(dsp_buffer));
			if(0 == paramPanelNozzleGet())	strcpy(dsp_buffer + strlen(dsp_buffer), "油机枪数:双枪机 ");
			if(1 == paramPanelNozzleGet())	strcpy(dsp_buffer + strlen(dsp_buffer), "油机枪数:四枪机 ");
			strcpy(dsp_buffer + strlen(dsp_buffer), ModelParam[paramModelGet()]);
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, strlen(dsp_buffer));

			//转入查询结果等待处理过程
			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_INQ_VERSION); //szb_fj_20171120,update
			//iptPidSet(iptparam, IPT_PID_INQUIRY_WAIT);
		}
		else if(5==iptparam->SetPage && '2'==iptparam->SetButton[0] && '1'==iptparam->SetButton[1])
		{
			//21.重打印自助小票
			iptPrint(iptparam, 4, iptparam->BarOilBill, IPT_BAR_BILL_SIZE);

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "请取走小票", 10);
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_INQ_SELECT, &iptparam->SetPage, 1);
		}
		else if(5==iptparam->SetPage && '2'==iptparam->SetButton[0] && '2'==iptparam->SetButton[1])
		{
			//22.显示油品语音
			if(0==spkFileNameGet(iptparam->OilVoice, dsp_buffer+1, 60))
			{
				dsp_buffer[0]=strlen(dsp_buffer+1);	dsp_len=1+strlen(dsp_buffer+1);
			}
			else
			{
				dsp_buffer[0]=strlen("无");	strcpy(dsp_buffer+1, "无");
				dsp_len=1+strlen(dsp_buffer+1);
			}
			dsp(iptparam->DEVDsp, DSP_INQ_OILVOICE, dsp_buffer, dsp_len);

			//转入查询结果等待处理过程
			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_INQUIRY_WAIT);
		}
		else if(5==iptparam->SetPage && '2'==iptparam->SetButton[0] && '3'==iptparam->SetButton[1])
		{
			//23.显示并转入加油错误日志界面
			if(0==jljOilErrLogRead(iptparam->Id, 0, dsp_buffer, 64))
			{
				memcpy(iptparam->TempBuffer, dsp_buffer, 64);
				dsp(iptparam->DEVDsp, DSP_INQ_OILERRLOG, dsp_buffer, 64);
				iptPidSet(iptparam, IPT_PID_INQ_OILERRLOG);
			}
			else
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "读取记录失败", 12);
				IPT_DSP_WAIT();
				memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
				dsp(iptparam->DEVDsp, DSP_INQ_SELECT, &iptparam->SetPage, 1);
			}
		}
		else if(5==iptparam->SetPage && '2'==iptparam->SetButton[0] && '4'==iptparam->SetButton[1])
		{
			//24.显示对比度查询界面
			*(dsp_buffer + 0) = iptparam->Contrast;	dsp_len = 1;
			dsp(iptparam->DEVDsp, DSP_CONTRAST, dsp_buffer, dsp_len);

			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_INQUIRY_WAIT);
		}
		else if(6==iptparam->SetPage && '2'==iptparam->SetButton[0] && '5'==iptparam->SetButton[1])
		{
			//25.显示条码品牌界面
			barBrandRead(iptparam->DEVBarcode, &tmpdata);
			dsp_buffer[0]=tmpdata;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_INQ_BARBRAND, dsp_buffer, dsp_len);

			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_INQUIRY_WAIT);
		}
		else if(6==iptparam->SetPage && '2'==iptparam->SetButton[0] && '6'==iptparam->SetButton[1])
		{
			//26.本地网络信息查询项选择界面
			dsp(iptparam->DEVDsp, DSP_LOCAL_NETINFO, "\x00", 0);

			iptPidSet(iptparam, IPT_PID_INQ_LOCAL_NET);
		}
		else if(6==iptparam->SetPage && '2'==iptparam->SetButton[0] && '7'==iptparam->SetButton[1])
		{
			//27.油机后台信息查询项选择界面
			dsp(iptparam->DEVDsp, DSP_BACKSTAGE_INFO, "\x00", 0);

			iptPidSet(iptparam, IPT_PID_INQ_BACKSTAGE);
		}
		else if(6==iptparam->SetPage && '2'==iptparam->SetButton[0] && '8'==iptparam->SetButton[1])
		{
			//28.平板电脑信息查询项选择界面
			iptparam->SetPage2 = 0;
			*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
			dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);

			iptPidSet(iptparam, IPT_PID_INQ_TABLETPC);
		}
		
		break;

	case KB_BUTTON_UP:
		//上翻一页
		if(iptparam->SetPage==0)	iptparam->SetPage=6;
		else										iptparam->SetPage--;
		dsp(iptparam->DEVDsp, DSP_INQ_SELECT, &iptparam->SetPage, 1);
		break;

	case KB_BUTTON_DOWN: 
		//下翻一页
		if(iptparam->SetPage>=6)	iptparam->SetPage=0;
		else										iptparam->SetPage++;
		dsp(iptparam->DEVDsp, DSP_INQ_SELECT, &iptparam->SetPage, 1);
		break;

	case KB_BUTTON_CHG:
	case KB_BUTTON_BACK:
		//返回查询/设置选择界面
		dsp(iptparam->DEVDsp, DSP_OPERATE_SELECT, "\x00", 0);

		iptPidSet(iptparam, IPT_PID_OPERATE_SELECT);
		break;
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptInqBillSelect
*Description		:查询账单对象选择界面
*Input				:None
*Output			:None
*Return				:None
*History			:2014-11-27,modified by syj  */

static void iptInqBillSelect(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char dsp_buffer[64]={0}, dsp_len=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_1:
	case KB_BUTTON_2:
		//选择查询本油枪(根据物理枪号1~6)或整机的账单明细
		if(KB_BUTTON_1==iptparam->Button)	iptparam->InqBillNozzle=0;
		else															iptparam->InqBillNozzle=iptparam->PhysicalNozzle;

		//初始化输入和TTC参数
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptparam->InqBillTTC=0;	iptparam->InqBillNext=0;
		iptPidSet(iptparam, IPT_PID_INQ_ZD_TTCIN);

		//显示输入TTC的界面
		dsp_buffer[0]=0;	dsp_len=1;
		dsp(iptparam->DEVDsp, DSP_INQ_BILL_TTCINPUT, dsp_buffer, dsp_len);
		break;
		
	case KB_BUTTON_CHG:
	case KB_BUTTON_BACK:
		//按"更改"或"退卡"键返回账单明细界面
		dsp(iptparam->DEVDsp, DSP_INQ_SELECT, &iptparam->SetPage, 1);

		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_INQUIRY);
		break;

	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptInqBillTTCInput
*Description		:查询账单TTC输入界面
*Input				:None
*Output			:None
*Return				:None
*History			:2014-11-27,modified by syj  */

static void iptInqBillTTCInput(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char dsp_buffer[64]={0}, dsp_len=0, button=0;
	int i=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0==button)	button='0';
	case KB_BUTTON_1:
		if(0==button)	button='1';
	case KB_BUTTON_2:
		if(0==button)	button='2';
	case KB_BUTTON_3:
		if(0==button)	button='3';
	case KB_BUTTON_4:
		if(0==button)	button='4';
	case KB_BUTTON_5:
		if(0==button)	button='5';
	case KB_BUTTON_6:
		if(0==button)	button='6';
	case KB_BUTTON_7:
		if(0==button)	button='7';
	case KB_BUTTON_8:
		if(0==button)	button='8';
	case KB_BUTTON_9:
		if(0==button)	button='9';

		if(iptparam->SetButtonLen<10){

			iptparam->SetButton[iptparam->SetButtonLen++]=button;

			dsp_buffer[0]=iptparam->SetButtonLen;	memcpy(&dsp_buffer[1], iptparam->SetButton, iptparam->SetButtonLen);
			dsp_len=1+iptparam->SetButtonLen;
			dsp(iptparam->DEVDsp, DSP_INQ_BILL_TTCINPUT, dsp_buffer, dsp_len);
		}
		break;

	case KB_BUTTON_CHG:
		//按"更改"键，有输入时清空输入，否则返回查询对象选择界面
		if(0==iptparam->SetButtonLen){

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;

			dsp(iptparam->DEVDsp, DSP_INQ_BILL_SELECT, "\x00", 0);
			iptPidSet(iptparam, IPT_PID_INQ_ZD_SEL);
		}
		else{

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;

			dsp_buffer[0]=0;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_INQ_BILL_TTCINPUT, dsp_buffer, dsp_len);
		}
		break;
		
	case KB_BUTTON_BACK:
		//按"退卡"键退出本界面返回查询对象选择界面
		dsp(iptparam->DEVDsp, DSP_INQ_BILL_SELECT, "\x00", 0);
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_INQ_ZD_SEL);
		break;

	case KB_BUTTON_ACK:
		//按"确认"键转入向PCD查询账单界面
		//判断是否超限
		if(iptparam->SetButtonLen>=10 && memcmp(iptparam->SetButton, "4294967295", 10)>0){

			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "查询范围超限", 12);
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_INQ_BILL_TTCINPUT, iptparam->SetButton, iptparam->SetButtonLen);
			break;
		}

		//计算要查询的账单TTC
		iptparam->InqBillTTC=atoi(iptparam->SetButton);

		//清空输入
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;

		//转入账单查询过程
		iptparam->InqBillNext=0;
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "明细查询中...", 13);
		iptPidSet(iptparam, IPT_PID_INQ_ZD_CHECK);
		break;

	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptInqBillFromPcd
*Description		:查询账单从PCD获取账单数据
*Input				:None
*Output			:None
*Return				:None
*History			:2014-11-27,modified by syj  */

static void iptInqBillFromPcd(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char tx_buffer[128]={0}, tx_len=0;
	unsigned char dsp_buffer[64]={0}, dsp_len=0;

	//发送PCD查询黑/白名单命令，包括最近一次加油时间
	if(IPT_2PCD_UNUSED==iptparam->PcdTxFlag){

		tx_buffer[0]=++iptparam->PcdTxFrame;
		tx_buffer[1]=pcdMboardIDRead();
		tx_buffer[2]=iptparam->Id;
		tx_buffer[3]=iptparam->PhysicalNozzle;
		tx_buffer[4]=IPT_CMD_ZD_CHECK;
		tx_buffer[5]=iptparam->InqBillNozzle;						//查寻枪号
		tx_buffer[6]=(char)(iptparam->InqBillTTC>>24);		//查询的账单TTC
		tx_buffer[7]=(char)(iptparam->InqBillTTC>>16);	
		tx_buffer[8]=(char)(iptparam->InqBillTTC>>8);
		tx_buffer[9]=(char)(iptparam->InqBillTTC>>0);
		tx_buffer[10]=iptparam->InqBillNext;						//查询的账单
		tx_len=11;
		//msgQSend((MSG_Q_ID)pcdMsgIdRead(), tx_buffer, tx_len, NO_WAIT, MSG_PRI_NORMAL);

		struct msg_struct msg_stIptSend;  //fj:20170918
		msg_stIptSend.msgType = 1;
		memcpy(msg_stIptSend.msgBuffer,tx_buffer,tx_len);
		msgsnd(pcdMsgIdRead(),&msg_stIptSend,tx_len,IPC_NOWAIT);

		iptparam->PcdTxFlag=IPT_2PCD_INQ;	iptparam->PcdTxTimer=0;
	}
	//查询成功，显示账单索引界面
	else if(IPT_2PCD_INQ==iptparam->PcdTxFlag && msg_len>0 && IPT_CMD_ZD_CHECK==msg_buffer[4] && 0==msg_buffer[5])
	{
		memcpy(iptparam->InqBill, &msg_buffer[6], IPT_BILL_SIZE);					//保存账单及查询到的TTC
		iptparam->InqBillTTC=(iptparam->InqBill[IPT_OFFSET_TTC+0]<<24)|\
												(iptparam->InqBill[IPT_OFFSET_TTC+1]<<16)|\
												(iptparam->InqBill[IPT_OFFSET_TTC+2]<<8)|\
												(iptparam->InqBill[IPT_OFFSET_TTC+3]<<0);

		printf("InqBillTTC = %d\n",iptparam->InqBillTTC);
		printf("InqBill = %d,%d,%d\n",dsp_buffer[19],dsp_buffer[20],dsp_buffer[21]);

		memcpy(&dsp_buffer[0], &iptparam->InqBill[IPT_OFFSET_TTC], 4);			//TTC
		memcpy(&dsp_buffer[4], &iptparam->InqBill[IPT_OFFSET_TIME], 7);			//时间
		memcpy(&dsp_buffer[11], &iptparam->InqBill[IPT_OFFSET_ASN+2], 8);		//卡号后16位
		memcpy(&dsp_buffer[19], &iptparam->InqBill[IPT_OFFSET_AMN], 3);			//数额
		memcpy(&dsp_buffer[22], &iptparam->InqBill[IPT_OFFSET_PHYGUN], 1);	//物理枪号
		dsp_len=23;
		dsp(iptparam->DEVDsp, DSP_INQ_BILL_INDEX, dsp_buffer, dsp_len);

		iptPidSet(iptparam, IPT_PID_INQ_ZD_INDEX);
		iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	
		iptparam->PcdOverTimes=0;
	}
	//查询失败，提示错误并返回TTC输入界面
	else if(IPT_2PCD_INQ==iptparam->PcdTxFlag && msg_len>0 && IPT_CMD_ZD_CHECK==msg_buffer[4] && 0!=msg_buffer[5]){

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "无此账单", 8);
		IPT_DSP_WAIT();

		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_INQ_BILL_TTCINPUT, iptparam->SetButton, iptparam->SetButtonLen);
		iptPidSet(iptparam, IPT_PID_INQ_ZD_TTCIN);

		iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdOverTimes=0;
	}
	//查询超时，提示错误并返回TTC输入界面
	else if(IPT_2PCD_INQ==iptparam->PcdTxFlag && iptparam->PcdTxTimer>=(5*ONE_SECOND)){
		
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "查询明细超时", 12);
		IPT_DSP_WAIT();

		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_INQ_BILL_TTCINPUT, iptparam->SetButton, iptparam->SetButtonLen);
		iptPidSet(iptparam, IPT_PID_INQ_ZD_TTCIN);

		iptparam->PcdTxFlag=IPT_2PCD_UNUSED;	iptparam->PcdOverTimes=0;
	}

	return;
}


/*******************************************************************
*Name				:iptInqBillIndex
*Description		:查询账单明细索引界面
*Input				:None
*Output			:None
*Return				:None
*History			:2014-11-27,modified by syj  */

static void iptInqBillIndex(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char dsp_buffer[255]={0}, dsp_len=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_UP:				//查询上一笔

		iptparam->InqBillNext=1;
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "明细查询中...", 13);
		iptPidSet(iptparam, IPT_PID_INQ_ZD_CHECK);
		break;
		
	case KB_BUTTON_DOWN:		//查询下一笔

		iptparam->InqBillNext=2;
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "明细查询中...", 13);
		iptPidSet(iptparam, IPT_PID_INQ_ZD_CHECK);
		break;

	case KB_BUTTON_CZ:
		//按"凑整"键打印本账单
		printf("KB_BUTTON_CZ,iptPrint\n");
		iptPrint(iptparam, 1, iptparam->InqBill, IPT_BILL_SIZE);
		break;
		
	case KB_BUTTON_CHG:
		//返回TTC输入界面
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;

		dsp_len=0;
		dsp(iptparam->DEVDsp, DSP_INQ_BILL_TTCINPUT, dsp_buffer, dsp_len);
		iptPidSet(iptparam, IPT_PID_INQ_ZD_TTCIN);
		break;

	case KB_BUTTON_ACK:
		//转入明细显示界面
		iptparam->InqBillPage=0;
		dsp_buffer[0]=iptparam->InqBillPage;	memcpy(&dsp_buffer[1], iptparam->InqBill, IPT_BILL_SIZE);
		dsp_len=1+IPT_BILL_SIZE;
		dsp(iptparam->DEVDsp, DSP_INQ_BILL_DATA, dsp_buffer, dsp_len);

		iptPidSet(iptparam, IPT_PID_INQ_ZD_DETAIL);
		break;

	default:
		break;
	}
	return;
}


/*******************************************************************
*Name				:iptInqBillOriginalData
*Description		:查询账单明细原始数据显示界面
*Input				:None
*Output			:None
*Return				:None
*History			:2014-11-27,modified by syj  */

static void iptInqBillOriginalData(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char dsp_buffer[255]={0}, dsp_len=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_UP:
		//向上翻页
		if(iptparam->InqBillPage<=0)	break;
		else											iptparam->InqBillPage--;

		dsp_buffer[0]=iptparam->InqBillPage;	memcpy(&dsp_buffer[1], iptparam->InqBill, IPT_BILL_SIZE);
		dsp_len=1+IPT_BILL_SIZE;
		dsp(iptparam->DEVDsp, DSP_INQ_BILL_DATA, dsp_buffer, dsp_len);
		break;
	case KB_BUTTON_DOWN:
		//向下翻页
		if(iptparam->InqBillPage>=4)	break;
		else											iptparam->InqBillPage++;
			
		dsp_buffer[0]=iptparam->InqBillPage;	memcpy(&dsp_buffer[1], iptparam->InqBill, IPT_BILL_SIZE);
		dsp_len=1+IPT_BILL_SIZE;
		dsp(iptparam->DEVDsp, DSP_INQ_BILL_DATA, dsp_buffer, dsp_len);
		break;

	case KB_BUTTON_CHG:
		//返回账单索引界面
		memcpy(&dsp_buffer[0], &iptparam->InqBill[IPT_OFFSET_TTC], 4);			//TTC
		memcpy(&dsp_buffer[4], &iptparam->InqBill[IPT_OFFSET_TIME], 7);			//时间
		memcpy(&dsp_buffer[11], &iptparam->InqBill[IPT_OFFSET_ASN+2], 8);		//卡号后16位
		memcpy(&dsp_buffer[19], &iptparam->InqBill[IPT_OFFSET_AMN], 3);			//数额
		memcpy(&dsp_buffer[22], &iptparam->InqBill[IPT_OFFSET_PHYGUN], 1);	//物理枪号
		dsp_len=23;
		dsp(iptparam->DEVDsp, DSP_INQ_BILL_INDEX, dsp_buffer, dsp_len);

		iptPidSet(iptparam, IPT_PID_INQ_ZD_INDEX);
		break;

	default:
		break;
	}
	return;
}


/*******************************************************************
*Name				:iptInqNozzleInfo
*Description		:查询油枪信息界面
*Input				:None
*Output			:None
*Return				:None
*History			:2014-11-27,modified by syj  */

static void iptInqNozzleInfo(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char dsp_buffer[64]={0}, dsp_len=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_UP:			//向上翻页
	case KB_BUTTON_DOWN:	//向下翻页
		//第一页向上翻或最后一页向下翻都不允许
		if((KB_BUTTON_UP==iptparam->Button && iptparam->SetPage2<=0)||\
			(KB_BUTTON_DOWN==iptparam->Button && iptparam->SetPage2>=1)){

			break;
		}

		if(KB_BUTTON_UP==iptparam->Button)	iptparam->SetPage2--;
		else															iptparam->SetPage2++;

		dsp_buffer[0]=iptparam->SetPage2;
		dsp_buffer[1]=iptparam->LogicNozzle;	dsp_buffer[2]=iptparam->PhysicalNozzle;
		dsp_buffer[3]=iptparam->Id;	memcpy(&dsp_buffer[4], iptparam->OilCode, 2);
		dsp_buffer[6]=(char)(iptparam->FuelBillTTC>>24);	dsp_buffer[7]=(char)(iptparam->FuelBillTTC>>16);
		dsp_buffer[8]=(char)(iptparam->FuelBillTTC>>8);	dsp_buffer[9]=(char)(iptparam->FuelBillTTC>>0);
		dsp_buffer[10]=(char)(iptparam->FuelUnloadNumber>>24);	dsp_buffer[11]=(char)(iptparam->FuelUnloadNumber>>16);
		dsp_buffer[12]=(char)(iptparam->FuelUnloadNumber>>8);		dsp_buffer[13]=(char)(iptparam->FuelUnloadNumber>>0);
		dsp_len=14;
		dsp(iptparam->DEVDsp, DSP_INQ_NOZZLE_INFO, dsp_buffer, dsp_len);
		break;

	case KB_BUTTON_CHG:
		//返回查询选项选择处理
		dsp(iptparam->DEVDsp, DSP_INQ_SELECT, &iptparam->SetPage, 1);
	
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_INQUIRY);
		break;
		
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptInqMboardInfo
*Description		:查询主板信息界面
*Input				:None
*Output			:None
*Return				:None
*History			:2014-11-27,modified by syj  */

static void iptInqMboardInfo(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char dsp_buffer[64]={0}, dsp_len=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_CHG:
		//返回查询选项选择处理
		dsp(iptparam->DEVDsp, DSP_INQ_SELECT, &iptparam->SetPage, 1);
	
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_INQUIRY);
		break;

	case KB_BUTTON_UP:
	case KB_BUTTON_DOWN:
		//按上下键切换显示查询界面
		//包括主板信息，通用信息1，通用信息2，油品油价信息，
		//基础黑名单，新增黑名单，新删黑名单，白名单；共7页信息
		if(KB_BUTTON_UP==iptparam->Button && 0==iptparam->SetPage2)			iptparam->SetPage2=7;
		else if(KB_BUTTON_UP==iptparam->Button && 0!=iptparam->SetPage2)	iptparam->SetPage2--;
		else if(KB_BUTTON_UP!=iptparam->Button && 7==iptparam->SetPage2)	iptparam->SetPage2=0;
		else																													iptparam->SetPage2++;

		//主板信息界面
		if(0==iptparam->SetPage2)
		{
			dsp_buffer[0]=pcdMboardIDRead();
			dsp_buffer[1]=(char)(iptparam->BillTTC>>24);	dsp_buffer[2]=(char)(iptparam->BillTTC>>16);
			dsp_buffer[3]=(char)(iptparam->BillTTC>>8);		dsp_buffer[4]=(char)(iptparam->BillTTC>>0);
			dsp_buffer[5]=(char)(iptparam->UnloadNumber>>24);	dsp_buffer[6]=(char)(iptparam->UnloadNumber>>16);
			dsp_buffer[7]=(char)(iptparam->UnloadNumber>>8);	dsp_buffer[8]=(char)(iptparam->UnloadNumber>>0);
			dsp_len=9;
			dsp(iptparam->DEVDsp, DSP_INQ_BOARD_INFO, dsp_buffer, dsp_len);
		}
		//通用信息界面1
		else if(1==iptparam->SetPage2)
		{
			dsp_buffer[0]=IptPcInfo.SInfo.Version;	dsp_buffer[1]=IptPcInfo.SInfo.Province;	dsp_buffer[2]=IptPcInfo.SInfo.City;
			dsp_len=3;
			dsp(iptparam->DEVDsp, DSP_INQ_STATION_INFO1, dsp_buffer, dsp_len);
		}
		//通用信息界面2
		else if(2==iptparam->SetPage2)
		{
			memcpy(&dsp_buffer[0], IptPcInfo.SInfo.Superior, 4);	memcpy(&dsp_buffer[4], IptPcInfo.SInfo.S_ID, 4);
			dsp_len=8;
			dsp(iptparam->DEVDsp, DSP_INQ_STATION_INFO2, dsp_buffer, dsp_len);
		}
		//油品油价信息界面
		else if(3==iptparam->SetPage2)
		{
			dsp_buffer[0]=IptPcInfo.OilInfo.Version;	dsp_buffer[1]=IptPcInfo.OilInfo.FieldNumber;
			memcpy(&dsp_buffer[2], IptPcInfo.OilInfo.ValidTime, 6);
			dsp_len=8;
			dsp(iptparam->DEVDsp, DSP_INQ_OILINFO, dsp_buffer, dsp_len);
		}
		//基础黑名单信息界面
		else if(4==iptparam->SetPage2)
		{
			dsp_buffer[0]=IptPcInfo.BList.Version[0];	dsp_buffer[1]=IptPcInfo.BList.Version[1];
			dsp_buffer[2]=IptPcInfo.BList.Number[2];	dsp_buffer[3]=IptPcInfo.BList.Number[3];
			memcpy(&dsp_buffer[4], IptPcInfo.BList.TimeStart, 4);
			memcpy(&dsp_buffer[8], IptPcInfo.BList.TimeFinish, 4);
			dsp_len=12;
			dsp(iptparam->DEVDsp, DSP_INQ_BASELIST, dsp_buffer, dsp_len);
		}
		//新增黑名单信息界面
		else if(5==iptparam->SetPage2)
		{
			dsp_buffer[0]=IptPcInfo.ABList.Version[1];
			dsp_buffer[1]=IptPcInfo.ABList.Number[2];	dsp_buffer[2]=IptPcInfo.ABList.Number[3];
			memcpy(&dsp_buffer[3], IptPcInfo.ABList.TimeStart, 4);
			memcpy(&dsp_buffer[7], IptPcInfo.ABList.TimeFinish, 4);
			dsp_len=11;
			dsp(iptparam->DEVDsp, DSP_INQ_ADDLIST, dsp_buffer, dsp_len);
		}
		//新删黑名单信息界面
		else if(6==iptparam->SetPage2)
		{
			dsp_buffer[0]=IptPcInfo.DBList.Version[1];
			dsp_buffer[1]=IptPcInfo.DBList.Number[2];	dsp_buffer[2]=IptPcInfo.DBList.Number[3];
			memcpy(&dsp_buffer[3], IptPcInfo.DBList.TimeStart, 4);
			memcpy(&dsp_buffer[7], IptPcInfo.DBList.TimeFinish, 4);
			dsp_len=11;
			dsp(iptparam->DEVDsp, DSP_INQ_DELLIST, dsp_buffer, dsp_len);
		}
		//白名单信息界面
		else if(7==iptparam->SetPage2)
		{
			dsp_buffer[0]=IptPcInfo.WList.Version[1];
			dsp_buffer[1]=IptPcInfo.WList.Number[2];	dsp_buffer[2]=IptPcInfo.WList.Number[3];
			memcpy(&dsp_buffer[3], IptPcInfo.WList.TimeStart, 4);
			memcpy(&dsp_buffer[7], IptPcInfo.WList.TimeFinish, 4);
			dsp_len=11;
			dsp(iptparam->DEVDsp, DSP_INQ_WHITELIST, dsp_buffer, dsp_len);
		}
		break;
	default:
		break;
	}

	return;
}



/*******************************************************************
*Name				:iptInqPrint
*Description		:打印信息查询界面
*Input				:None
*Output			:None
*Return				:None
*History			:2014-02-18,modified by syj  */

static void iptInqPrint(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char dsp_buffer[64]={0}, dsp_len=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_CHG:
	case KB_BUTTON_BACK:
		//返回查询选项选择处理
		dsp(iptparam->DEVDsp, DSP_INQ_SELECT, &iptparam->SetPage, 1);
	
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_INQUIRY);
		break;

	case KB_BUTTON_ACK:
		//转入打印卡类型信息查询界面
		dsp(iptparam->DEVDsp, DSP_INQ_PRINT_CARD, "\x00", 0);

		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_INQ_PRNCARD);
		break;
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptInqPrintCardSelect
*Description		:打印卡类型信息查询操作
*Input				:None
*Output			:None
*Return				:None
*History			:2014-02-18,modified by syj  */

static void iptInqPrintCardSelect(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char dsp_buffer[64]={0}, dsp_len=0, button=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_1:
		if(0==button)	{iptparam->PrintCard=&iptparam->PrintCardUser;		button='1';}	//用户卡
	case KB_BUTTON_2:
		if(0==button)	{iptparam->PrintCard=&iptparam->PrintCardManage;	button='2';}	//管理卡
	case KB_BUTTON_3:
		if(0==button)	{iptparam->PrintCard=&iptparam->PrintCardStaff;		button='3';}	//员工卡
	case KB_BUTTON_4:
		if(0==button)	{iptparam->PrintCard=&iptparam->PrintCardPump;		button='4';}	//验泵卡
	case KB_BUTTON_5:
		if(0==button)	{iptparam->PrintCard=&iptparam->PrintCardService;	button='5';}	//维修卡

		//转入自动打印账单类型
		iptparam->SetPage2=0;
		dsp_buffer[0]=iptparam->SetPage2;	
		dsp_buffer[1]=(char)(*iptparam->PrintCard>>8);	dsp_buffer[2]=(char)(*iptparam->PrintCard>>0);
		dsp_len=3;
		dsp(iptparam->DEVDsp, DSP_INQ_PRINT_BILLTYPE, dsp_buffer, dsp_len);

		iptPidSet(iptparam, IPT_PID_INQ_PRNTYPE);
		break;

	case KB_BUTTON_CHG:
	case KB_BUTTON_BACK:
		//返回打印信息查询操作
		dsp_buffer[0]=iptparam->Printer;		dsp_buffer[1]=iptparam->PrintAuto;	dsp_buffer[2]=iptparam->PrintUnion;
		dsp_len=3;
		dsp(iptparam->DEVDsp, DSP_INQ_PRINT, dsp_buffer, dsp_len);

		iptPidSet(iptparam, IPT_PID_INQ_PRN);
		break;
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptInqPrnType
*Description		:自动打印账单类型
*Input				:None
*Output			:None
*Return				:None
*History			:2014-02-18,modified by syj  */

static void iptInqPrnType(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char dsp_buffer[64]={0}, dsp_len=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_UP:
	case KB_BUTTON_DOWN:
		//当前为第一页按向上键或当前为第二页按向下键均不操作
		if((KB_BUTTON_UP==iptparam->Button && iptparam->SetPage2<=0)||(KB_BUTTON_DOWN==iptparam->Button && iptparam->SetPage2>=1))
			break;

		//切换页面显示
		if(0==iptparam->SetPage2)	iptparam->SetPage2=1;
		else											iptparam->SetPage2=0;
		dsp_buffer[0]=iptparam->SetPage2;
		dsp_buffer[1]=(char)(*iptparam->PrintCard>>8);	dsp_buffer[2]=(char)(*iptparam->PrintCard>>0);
		dsp_len=3;
		dsp(iptparam->DEVDsp, DSP_INQ_PRINT_BILLTYPE, dsp_buffer, dsp_len);
		break;
		
	case KB_BUTTON_CHG:
	case KB_BUTTON_BACK:
		//返回打印卡类型信息查询界面
		dsp(iptparam->DEVDsp, DSP_INQ_PRINT_CARD, "\x00", 0);

		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_INQ_PRNCARD);
		break;

	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptInqTaxMonth
*Description		:税控月累查询月份输入
*Input				:None
*Output			:None
*Return				:None
*History			:2014-02-18,modified by syj  */

static void iptInqTaxMonth(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char dsp_buffer[64]={0}, dsp_len=0, button=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0==button)	button='0';
	case KB_BUTTON_1:
		if(0==button)	button='1';
	case KB_BUTTON_2:
		if(0==button)	button='2';
	case KB_BUTTON_3:
		if(0==button)	button='3';
	case KB_BUTTON_4:
		if(0==button)	button='4';
	case KB_BUTTON_5:
		if(0==button)	button='5';
	case KB_BUTTON_6:
		if(0==button)	button='6';
	case KB_BUTTON_7:
		if(0==button)	button='7';
	case KB_BUTTON_8:
		if(0==button)	button='8';
	case KB_BUTTON_9:
		if(0==button)	button='9';
		//输入月份
		if(iptparam->SetButtonLen<6)
		{
			iptparam->SetButton[iptparam->SetButtonLen++]=button;

			dsp_buffer[0]=((iptparam->SetButton[0]&0x0f)<<4)|((iptparam->SetButton[1]&0x0f)<<0);
			dsp_buffer[1]=((iptparam->SetButton[2]&0x0f)<<4)|((iptparam->SetButton[3]&0x0f)<<0);
			dsp_buffer[2]=((iptparam->SetButton[4]&0x0f)<<4)|((iptparam->SetButton[5]&0x0f)<<0);
			dsp_len=3;
			dsp(iptparam->DEVDsp, DSP_MONTH_INPUT, dsp_buffer, dsp_len);
		}
		break;

	case KB_BUTTON_CHG:
		//清空输入的月份
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;

		dsp_buffer[0]=((iptparam->SetButton[0]&0x0f)<<4)|((iptparam->SetButton[1]&0x0f)<<0);
		dsp_buffer[1]=((iptparam->SetButton[2]&0x0f)<<4)|((iptparam->SetButton[3]&0x0f)<<0);
		dsp_buffer[2]=((iptparam->SetButton[4]&0x0f)<<4)|((iptparam->SetButton[5]&0x0f)<<0);
		dsp_len=3;
		dsp(iptparam->DEVDsp, DSP_MONTH_INPUT, dsp_buffer, dsp_len);
		break;

	case KB_BUTTON_BACK:
		//返回查询项选择界面
		dsp(iptparam->DEVDsp, DSP_INQ_SELECT, &iptparam->SetPage, 1);
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_INQUIRY);
		break;

	case KB_BUTTON_ACK:
		//确认显示月累
		//校验月份合法性
		dsp_buffer[0]=((iptparam->SetButton[0]&0x0f)<<4)|((iptparam->SetButton[1]&0x0f)<<0);
		dsp_buffer[1]=((iptparam->SetButton[2]&0x0f)<<4)|((iptparam->SetButton[3]&0x0f)<<0);
		dsp_buffer[2]=((iptparam->SetButton[4]&0x0f)<<4)|((iptparam->SetButton[5]&0x0f)<<0);
		if(0!=timeVerification(dsp_buffer, 3))
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "月份非法", 8);
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp_buffer[0]=((iptparam->SetButton[0]&0x0f)<<4)|((iptparam->SetButton[1]&0x0f)<<0);
			dsp_buffer[1]=((iptparam->SetButton[2]&0x0f)<<4)|((iptparam->SetButton[3]&0x0f)<<0);
			dsp_buffer[2]=((iptparam->SetButton[4]&0x0f)<<4)|((iptparam->SetButton[5]&0x0f)<<0);
			dsp_len=3;
			dsp(iptparam->DEVDsp, DSP_MONTH_INPUT, dsp_buffer, dsp_len);
			break;
		}

		//查询税控月累
		dsp_buffer[0]=((iptparam->SetButton[0]&0x0f)<<4)|((iptparam->SetButton[1]&0x0f)<<0);
		dsp_buffer[1]=((iptparam->SetButton[2]&0x0f)<<4)|((iptparam->SetButton[3]&0x0f)<<0);
		dsp_buffer[2]=((iptparam->SetButton[4]&0x0f)<<4)|((iptparam->SetButton[5]&0x0f)<<0);
		jlTaxMonthVolDsp(iptparam->JlNozzle, dsp_buffer, 3); //fj:

		//转入税控查询结果等待处理过程
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "请看大屏显示", 12);
		iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_INQ_TAXWAIT);
		break;

	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptInqTaxDate
*Description		:税控日累查询日期输入
*Input				:None
*Output			:None
*Return				:None
*History			:2014-02-18,modified by syj  */

static void iptInqTaxDate(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char dsp_buffer[16]={0}, dsp_len=0, button=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0==button)	button='0';
	case KB_BUTTON_1:
		if(0==button)	button='1';
	case KB_BUTTON_2:
		if(0==button)	button='2';
	case KB_BUTTON_3:
		if(0==button)	button='3';
	case KB_BUTTON_4:
		if(0==button)	button='4';
	case KB_BUTTON_5:
		if(0==button)	button='5';
	case KB_BUTTON_6:
		if(0==button)	button='6';
	case KB_BUTTON_7:
		if(0==button)	button='7';
	case KB_BUTTON_8:
		if(0==button)	button='8';
	case KB_BUTTON_9:
		if(0==button)	button='9';

		//输入日期
		if(iptparam->SetButtonLen<8)
		{
			iptparam->SetButton[iptparam->SetButtonLen++]=button;

			dsp_buffer[0]=((iptparam->SetButton[0]&0x0f)<<4)|((iptparam->SetButton[1]&0x0f)<<0);
			dsp_buffer[1]=((iptparam->SetButton[2]&0x0f)<<4)|((iptparam->SetButton[3]&0x0f)<<0);
			dsp_buffer[2]=((iptparam->SetButton[4]&0x0f)<<4)|((iptparam->SetButton[5]&0x0f)<<0);
			dsp_buffer[3]=((iptparam->SetButton[6]&0x0f)<<4)|((iptparam->SetButton[7]&0x0f)<<0);
			dsp_len=4;
			dsp(iptparam->DEVDsp, DSP_DATE_INPUT, dsp_buffer, dsp_len);
		}
		break;
	case KB_BUTTON_CHG:
		//清空输入的日期
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;

		dsp_buffer[0]=((iptparam->SetButton[0]&0x0f)<<4)|((iptparam->SetButton[1]&0x0f)<<0);
		dsp_buffer[1]=((iptparam->SetButton[2]&0x0f)<<4)|((iptparam->SetButton[3]&0x0f)<<0);
		dsp_buffer[2]=((iptparam->SetButton[4]&0x0f)<<4)|((iptparam->SetButton[5]&0x0f)<<0);
		dsp_buffer[3]=((iptparam->SetButton[6]&0x0f)<<4)|((iptparam->SetButton[7]&0x0f)<<0);
		dsp_len=4;
		dsp(iptparam->DEVDsp, DSP_DATE_INPUT, dsp_buffer, dsp_len);
		break;

	case KB_BUTTON_BACK:
		//返回查询项选择界面
		dsp(iptparam->DEVDsp, DSP_INQ_SELECT, &iptparam->SetPage, 1);
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_INQUIRY);
		break;

	case KB_BUTTON_ACK:
		//确认显示月累
		//校验月份合法性
		dsp_buffer[0]=((iptparam->SetButton[0]&0x0f)<<4)|((iptparam->SetButton[1]&0x0f)<<0);
		dsp_buffer[1]=((iptparam->SetButton[2]&0x0f)<<4)|((iptparam->SetButton[3]&0x0f)<<0);
		dsp_buffer[2]=((iptparam->SetButton[4]&0x0f)<<4)|((iptparam->SetButton[5]&0x0f)<<0);
		dsp_buffer[3]=((iptparam->SetButton[6]&0x0f)<<4)|((iptparam->SetButton[7]&0x0f)<<0);
		if(0!=timeVerification(dsp_buffer, 4))
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "日期非法", 8);
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp_buffer[0]=((iptparam->SetButton[0]&0x0f)<<4)|((iptparam->SetButton[1]&0x0f)<<0);
			dsp_buffer[1]=((iptparam->SetButton[2]&0x0f)<<4)|((iptparam->SetButton[3]&0x0f)<<0);
			dsp_buffer[2]=((iptparam->SetButton[4]&0x0f)<<4)|((iptparam->SetButton[5]&0x0f)<<0);
			dsp_buffer[3]=((iptparam->SetButton[6]&0x0f)<<4)|((iptparam->SetButton[7]&0x0f)<<0);
			dsp_len=4;
			dsp(iptparam->DEVDsp, DSP_DATE_INPUT, dsp_buffer, dsp_len);
			break;
		}

		//查询税控日累
		dsp_buffer[0]=((iptparam->SetButton[0]&0x0f)<<4)|((iptparam->SetButton[1]&0x0f)<<0);
		dsp_buffer[1]=((iptparam->SetButton[2]&0x0f)<<4)|((iptparam->SetButton[3]&0x0f)<<0);
		dsp_buffer[2]=((iptparam->SetButton[4]&0x0f)<<4)|((iptparam->SetButton[5]&0x0f)<<0);
		dsp_buffer[3]=((iptparam->SetButton[6]&0x0f)<<4)|((iptparam->SetButton[7]&0x0f)<<0);
		jlTaxDayVolDsp(iptparam->JlNozzle, dsp_buffer, 4); //fj:

		//转入税控查询结果等待处理过程
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "请看大屏显示", 12);
		iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_INQ_TAXWAIT);
		break;
	default:
		break;
	}

	return;
}



/*******************************************************************
*Name				:iptInquiryWait
*Description		:IPT查询结果等待处理界面
*Input				:nozzle	面板号
*Output			:None
*Return				:None
*History			:2014-04-10,modified by syj  */

static void iptInquiryWait(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	if(KB_BUTTON_NO!=iptparam->Button || iptparam->NousedTimer>=30*ONE_SECOND){

		//显示并返回查询项选择界面
		dsp(iptparam->DEVDsp, DSP_INQ_SELECT, &iptparam->SetPage, 1);
	
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_INQUIRY);
	}

	return;
}


/*******************************************************************
*Name				:iptInquiryTaxWait
*Description		:税控查询结果等待处理
*Input				:None
*Output			:None
*Return				:None
*History			:2014-02-18,modified by syj  */

static void iptInquiryTaxWait(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	if(KB_BUTTON_NO!=iptparam->Button || iptparam->NousedTimer>=30*ONE_SECOND){

		//大屏显示当次明细
		jlNoteDsp(iptparam->JlNozzle); //fj:

		//显示并返回查询项选择界面
		dsp(iptparam->DEVDsp, DSP_INQ_SELECT, &iptparam->SetPage, 1);
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_INQUIRY);
	}

	return;
}


/*******************************************************************
*Name				:iptInquiryOilErrLog
*Description		:显示加油异常日志
*Input				:None
*Output			:None
*Return				:None
*History			:2014-02-18,modified by syj  */

static void iptInquiryOilErrLog(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char dsp_buffer[64+1]={0};
	int dsp_len=0, istate=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_UP:
	case KB_BUTTON_DOWN:
		if(KB_BUTTON_UP==iptparam->Button)	
			istate=jljOilErrLogRead(iptparam->Id, 1, dsp_buffer, 64);
		else	
			istate=jljOilErrLogRead(iptparam->Id, 2, dsp_buffer, 64);

		if(0==istate)
		{
			memcpy(iptparam->TempBuffer, dsp_buffer, 64);
			dsp(iptparam->DEVDsp, DSP_INQ_OILERRLOG, dsp_buffer, 64);
		}
		else
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "没有更多记录", 12);
			IPT_DSP_WAIT();
			dsp(iptparam->DEVDsp, DSP_INQ_OILERRLOG, iptparam->TempBuffer, 64);
		}
		break;
		
	case KB_BUTTON_BACK:
	case KB_BUTTON_CHG:
		//显示并返回查询项选择界面
		dsp(iptparam->DEVDsp, DSP_INQ_SELECT, &iptparam->SetPage, 1);
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_INQUIRY);
		break;
		
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptInquiryLocalNetInfo
*Description		:本地网络信息查询项选择界面
*Input				:None
*Output			:None
*Return				:None
*History			:2014-02-18,modified by syj  */

static void iptInquiryLocalNetInfo(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	char dsp_buffer[128] = {0};
	unsigned int iMask = 0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_1:	//IP地址
		usrNetIpGet("eth0", dsp_buffer); //fj:
		dsp(iptparam->DEVDsp, DSP_LOCAL_IP, dsp_buffer, strlen(dsp_buffer));

		iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_INQ_LOCAL_WAIT);
		break;
	case KB_BUTTON_2:	//子网掩码
		usrNetMaskGet("eth0", &iMask); //fj:
		//sprintf(dsp_buffer + strlen(dsp_buffer), "%d.", (iMask>>24)&0xff);
		//sprintf(dsp_buffer + strlen(dsp_buffer), "%d.", (iMask>>16)&0xff);
		//sprintf(dsp_buffer + strlen(dsp_buffer), "%d.", (iMask>>8)&0xff);
		//sprintf(dsp_buffer + strlen(dsp_buffer), "%d", (iMask>>0)&0xff);
		sprintf(dsp_buffer + strlen(dsp_buffer), "%d.", (iMask>>0)&0xff);
		sprintf(dsp_buffer + strlen(dsp_buffer), "%d.", (iMask>>8)&0xff);
		sprintf(dsp_buffer + strlen(dsp_buffer), "%d.", (iMask>>16)&0xff);
		sprintf(dsp_buffer + strlen(dsp_buffer), "%d", (iMask>>24)&0xff);
		dsp(iptparam->DEVDsp, DSP_LOCAL_MASK, dsp_buffer, strlen(dsp_buffer));

		iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_INQ_LOCAL_WAIT);
		break;
	case KB_BUTTON_3:	//默认网关
		usrNetHostGatewayGet("eth0", dsp_buffer); //fj:
		dsp(iptparam->DEVDsp, DSP_LOCAL_GATEWAY, dsp_buffer, strlen(dsp_buffer));

		iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_INQ_LOCAL_WAIT);
		break;
	case KB_BUTTON_CHG:
	case KB_BUTTON_BACK:
		//显示并返回查询项选择界面
		dsp(iptparam->DEVDsp, DSP_INQ_SELECT, &iptparam->SetPage, 1);
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_INQUIRY);
		break;
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptInquiryLocalNetInfoWait
*Description		:设置选项选择界面
*Input				:None
*Output			:None
*Return				:None
*History			:2014-02-18,modified by syj  */

static void iptInquiryLocalNetInfoWait(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	//有按键或超时30秒无操作，显示并返回本地网络信息查询项选择界面
	if(KB_BUTTON_NO!=iptparam->Button || iptparam->NousedTimer>=30*ONE_SECOND){

		dsp(iptparam->DEVDsp, DSP_LOCAL_NETINFO, "\x00", 0);
	
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_INQ_LOCAL_NET);
	}

	return;
}


/*******************************************************************
*Name				:iptInquiryBackstageInfo
*Description		:石化后台配置信息项选择界面
*Input				:None
*Output			:None
*Return				:None
*History			:2014-02-18,modified by syj  */

static void iptInquiryBackstageInfo(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	char dsp_buffer[128] = {0};
	int dsp_len = 0;
	char iip[32] = {0}, imask[32] = {0};
	unsigned int iMask = 0, itype = 0;
	int port = 0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_1:
		itype = kjldChannelGet();
		if(KJLD_CHANNEL_COM == itype)	dsp_buffer[0] = '0';
		if(KJLD_CHANNEL_NET == itype)	dsp_buffer[0] = '1';
		dsp_len = 1;
		dsp(iptparam->DEVDsp, DSP_CONNECT_TYPE_DSP, dsp_buffer, dsp_len);

		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;	iptparam->NousedTimer = 0;
		iptPidSet(iptparam, IPT_PID_INQ_BACKS_WAIT);
		break;
		
	case KB_BUTTON_2:	
		//后台IP地址
		kjldServerNetGet(iip, imask);
		dsp(iptparam->DEVDsp, DSP_BACKSTAGE_IP, iip, strlen(iip));

		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;	iptparam->NousedTimer = 0;
		iptPidSet(iptparam, IPT_PID_INQ_BACKS_WAIT);
		break;
		
	case KB_BUTTON_3:	
		//后台端口号
		kjldServerNetGet(iip, imask);
		dsp(iptparam->DEVDsp, DSP_BACKSTAGE_PORT, imask, strlen(imask));

		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;	iptparam->NousedTimer = 0;
		iptPidSet(iptparam, IPT_PID_INQ_BACKS_WAIT);
		break;

	case KB_BUTTON_4:	
		//本地端口号
		port = kjldLocalPortGet();
		sprintf(dsp_buffer, "%d", port);
		dsp(iptparam->DEVDsp, DSP_BACKSTAGE_LOCAL_PORT, dsp_buffer, strlen(dsp_buffer));

		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;	iptparam->NousedTimer = 0;
		iptPidSet(iptparam, IPT_PID_INQ_BACKS_WAIT);
		break;
		
	case KB_BUTTON_CHG:
	case KB_BUTTON_BACK:
		//返回查询项选择界面
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_INQ_SELECT, &iptparam->SetPage, 1);
		iptPidSet(iptparam, IPT_PID_INQUIRY);
		break;
		
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptInquiryBackstageInfoWait
*Description		:石化后台配置信息查询结果显示等待
*Input				:None
*Output			:None
*Return				:None
*History			:2014-02-18,modified by syj  */

static void iptInquiryBackstageInfoWait(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	//有按键或超时30秒无操作，显示并返回本地网络信息查询项选择界面
	if(KB_BUTTON_NO!=iptparam->Button || iptparam->NousedTimer>=30*ONE_SECOND){
	
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_BACKSTAGE_INFO, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_INQ_BACKSTAGE);
	}

	return;
}


/*******************************************************************
*Name				:iptInquiryTabletInfo
*Description		:平板电脑配置信息项选择界面
*Input				:None
*Output			:None
*Return				:None
*History			:2014-02-18,modified by syj  */

static void iptInquiryTabletInfo(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	char dsp_buffer[128] = {0};
	int dsp_len = 0;
	char serverip[32]= {0}, telephoneip[32] = {0};
	unsigned char volume = 0;
	unsigned int button = 0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0 == button)	button = '0';
	case KB_BUTTON_1:
		if(0 == button)	button = '1';
	case KB_BUTTON_2:
		if(0 == button)	button = '2';
	case KB_BUTTON_3:
		if(0 == button)	button = '3';
	case KB_BUTTON_4:
		if(0 == button)	button = '4';
	case KB_BUTTON_5:
		if(0 == button)	button = '5';
	case KB_BUTTON_6:
		if(0 == button)	button = '6';
	case KB_BUTTON_7:
		if(0 == button)	button = '7';
	case KB_BUTTON_8:
		if(0 == button)	button = '8';
	case KB_BUTTON_9:
		if(0 == button)	button = '9';
		
		iptparam->SetButton[0]=iptparam->SetButton[1];	iptparam->SetButton[1]=button;

		//平板电脑IP地址
		if(0==iptparam->SetPage2 && '1'==iptparam->SetButton[1])
		{
			if(0 != pcNetInfoGet(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TabletIP, iptparam->TabletMask, iptparam->TabletGateway))
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "查询失败", 8);
				IPT_DSP_WAIT();
		
				memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
				dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, &iptparam->SetPage2, 1);
				break;
			}

			dsp(iptparam->DEVDsp, DSP_TABLETPC_IP, iptparam->TabletIP, strlen(iptparam->TabletIP));

			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_INQ_TABLET_WAIT);
		}
		//平板子网掩码
		else if(0==iptparam->SetPage2 && '2'==iptparam->SetButton[1])
		{
			if(0 != pcNetInfoGet(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TabletIP, iptparam->TabletMask, iptparam->TabletGateway))
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "查询失败", 8);
				IPT_DSP_WAIT();
		
				memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
				dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, &iptparam->SetPage2, 1);
				break;
			}

			dsp(iptparam->DEVDsp, DSP_TABLETPC_MASK, iptparam->TabletMask, strlen(iptparam->TabletMask));

			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_INQ_TABLET_WAIT);
		}
		//平板默认网关
		else if(0==iptparam->SetPage2 && '3'==iptparam->SetButton[1])
		{
			if(0 != pcNetInfoGet(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TabletIP, iptparam->TabletMask, iptparam->TabletGateway))
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "查询失败", 8);
				IPT_DSP_WAIT();
		
				memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
				dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, &iptparam->SetPage2, 1);
				break;
			}

			dsp(iptparam->DEVDsp, DSP_TABLETPC_GATEWAY, iptparam->TabletGateway, strlen(iptparam->TabletGateway));

			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_INQ_TABLET_WAIT);
		}
		//平板电脑首选DNS
		else if(1==iptparam->SetPage2 && '4'==iptparam->SetButton[1])
		{	
			if(0 != pcDNSInfoGet(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TabletFirstDNS, iptparam->TabletSecondDNS))
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "查询失败", 8);
				IPT_DSP_WAIT();
		
				memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
				dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, &iptparam->SetPage2, 1);
				break;
			}

			dsp(iptparam->DEVDsp, DSP_TABLETPC_FIRSTDNS, iptparam->TabletFirstDNS, strlen(iptparam->TabletFirstDNS));

			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_INQ_TABLET_WAIT);
		}
		//平板电脑备用DNS
		else if(1==iptparam->SetPage2 && '5'==iptparam->SetButton[1])
		{
			if(0 != pcDNSInfoGet(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TabletFirstDNS, iptparam->TabletSecondDNS))
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "查询失败", 8);
				IPT_DSP_WAIT();
		
				memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
				dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, &iptparam->SetPage2, 1);
				break;
			}

			dsp(iptparam->DEVDsp, DSP_TABLETPC_SECONDDNS, iptparam->TabletSecondDNS, strlen(iptparam->TabletSecondDNS));

			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_INQ_TABLET_WAIT);
		}
		//平板电脑FTP服务器地址
		else if(1==iptparam->SetPage2 && '6'==iptparam->SetButton[1])
		{
			if(0 != pcFtpServerInfoGet(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TabletFtpIP, iptparam->TabletFtpPort))
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "查询失败", 8);
				IPT_DSP_WAIT();
		
				memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
				dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, &iptparam->SetPage2, 1);
				break;
			}

			dsp(iptparam->DEVDsp, DSP_TABLETPC_FTP_IP, iptparam->TabletFtpIP, strlen(iptparam->TabletFtpIP));

			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_INQ_TABLET_WAIT);
		}
		//平板电脑FTP服务器端口号
		else if(2==iptparam->SetPage2 && '7'==iptparam->SetButton[1])
		{
			if(0 != pcFtpServerInfoGet(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TabletFtpIP, iptparam->TabletFtpPort))
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "查询失败", 8);
				IPT_DSP_WAIT();
		
				memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
				dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, &iptparam->SetPage2, 1);
				break;
			}

			dsp(iptparam->DEVDsp, DSP_TABLETPC_FTP_PORT, iptparam->TabletFtpPort, strlen(iptparam->TabletFtpPort));

			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_INQ_TABLET_WAIT);
		}
		//平板电脑后台服务器地址
		else if(2==iptparam->SetPage2 && '8'==iptparam->SetButton[1])
		{
			if(0 != pcServerInfoGet(iptparam->TabletPanel, iptparam->LogicNozzle, serverip))
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "查询失败", 8);
				IPT_DSP_WAIT();
		
				memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
				dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, &iptparam->SetPage2, 1);
				break;
			}

			dsp(iptparam->DEVDsp, DSP_TABLETPC_SERVERIP, serverip, strlen(serverip));

			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_INQ_TABLET_WAIT);
		}
		//平板电脑音量
		else if(2==iptparam->SetPage2 && '9'==iptparam->SetButton[1])
		{
			if(0 != pcVolumeGet(iptparam->TabletPanel, iptparam->LogicNozzle, &volume))
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "查询失败", 8);
				IPT_DSP_WAIT();
		
				memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
				dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, &iptparam->SetPage2, 1);
				break;
			}

			dsp(iptparam->DEVDsp, DSP_TABLETPC_VOLUME, &volume, 1);

			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_INQ_TABLET_WAIT);
		}
		//平板电脑语音对讲后台IP地址
		else if(3==iptparam->SetPage2 && '1'==iptparam->SetButton[0] && '0'==iptparam->SetButton[1])
		{
			if(0 != pcTelephoneIPGet(iptparam->TabletPanel, iptparam->LogicNozzle, telephoneip))
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "查询失败", 8);
				IPT_DSP_WAIT();
		
				memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
				dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, &iptparam->SetPage2, 1);
				break;
			}

			dsp(iptparam->DEVDsp, DSP_TABLETPC_TELE_IP, telephoneip, strlen(telephoneip));

			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_INQ_TABLET_WAIT);
		}
		//是否启用促销功能
		else if(3==iptparam->SetPage2 && '1'==iptparam->SetButton[0] && '1'==iptparam->SetButton[1])
		{
			 *(dsp_buffer + 0) = paramPromotionGet();
			 *(dsp_buffer + 1) = 0;
			dsp_len = 2;
			dsp(iptparam->DEVDsp, DSP_PROMOTION, dsp_buffer, dsp_len);

			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_INQ_TABLET_WAIT);
		}
		//是否启用油品确认功能
		else if(3==iptparam->SetPage2 && '1'==iptparam->SetButton[0] && '2'==iptparam->SetButton[1])
		{
			 *(dsp_buffer + 0) = iptparam->TabletGradeTag;
			 *(dsp_buffer + 1) = 0;
			dsp_len = 2;
			dsp(iptparam->DEVDsp, DSP_YuLe_Grade_Fun, dsp_buffer, dsp_len);

			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_INQ_TABLET_WAIT);
		}
		break;

	case KB_BUTTON_UP:
	case KB_BUTTON_DOWN:
		if(KB_BUTTON_UP==iptparam->Button  && 0==iptparam->SetPage2)
		{
			iptparam->SetPage2 = 3;
		}
		else if(KB_BUTTON_UP==iptparam->Button  && 0!=iptparam->SetPage2)
		{
			iptparam->SetPage2--;
		}
		else if(KB_BUTTON_DOWN==iptparam->Button  && iptparam->SetPage2<3)
		{
			iptparam->SetPage2++;
		}
		else if(KB_BUTTON_DOWN==iptparam->Button  && iptparam->SetPage2>=3)
		{
			iptparam->SetPage2 = 0;
		}

		*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);
		break;
	case KB_BUTTON_CHG:
	case KB_BUTTON_BACK:
		//显示并返回查询项选择界面
		dsp(iptparam->DEVDsp, DSP_INQ_SELECT, &iptparam->SetPage, 1);
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_INQUIRY);
		break;
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptInquiryTabletInfoWait
*Description		:平板电脑配置信息查询结果显示等待
*Input				:None
*Output			:None
*Return				:None
*History			:2014-02-18,modified by syj  */

static void iptInquiryTabletInfoWait(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	//有按键或超时30秒无操作，显示并返回本地网络信息查询项选择界面
	if(KB_BUTTON_NO!=iptparam->Button || iptparam->NousedTimer>=30*ONE_SECOND){

		dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, &iptparam->SetPage2, 1);
	
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_INQ_TABLETPC);
	}

	return;
}

//查询版本信息
static void iptInquiryVersionInf(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char dsp_buffer[128+1]={0};
	
	if(iptparam->Button==KB_BUTTON_UP)
	{
		//20，机型信息
		memset(dsp_buffer,0,sizeof(dsp_buffer));
		strcpy(dsp_buffer + strlen(dsp_buffer), "版本");
		strcpy(dsp_buffer + strlen(dsp_buffer), _SOFTWARE_VERSION_);	
		if(strlen(dsp_buffer) < 16)	memset(dsp_buffer + strlen(dsp_buffer), ' ', 16-strlen(dsp_buffer));
		if(0 == paramPanelNozzleGet())	strcpy(dsp_buffer + strlen(dsp_buffer), "油机枪数：双枪机 ");
		if(1 == paramPanelNozzleGet())	strcpy(dsp_buffer + strlen(dsp_buffer), "油机枪数：四枪机 ");
		strcpy(dsp_buffer + strlen(dsp_buffer), ModelParam[paramModelGet()]);
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, strlen(dsp_buffer));
	}
	else if(iptparam->Button==KB_BUTTON_DOWN)
	{
		memset(dsp_buffer,0,sizeof(dsp_buffer));
		sprintf(dsp_buffer,"205IAP:%02x.%02x    ",Ipt205IAP_Ver[0],Ipt205IAP_Ver[1]);
		sprintf(dsp_buffer+strlen(dsp_buffer),"205APP:%02x.%02x    ",Ipt205APP_Ver[0],Ipt205APP_Ver[1]);
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, strlen(dsp_buffer));
	}
	else if(iptparam->Button==KB_BUTTON_CHG || iptparam->Button==KB_BUTTON_BACK)
	{
		//显示并返回查询项选择界面
		dsp(iptparam->DEVDsp, DSP_INQ_SELECT, &iptparam->SetPage, 1);
	
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_INQUIRY);
	}
}
/*******************************************************************
*Name				:iptSetInterface
*Description		:设置选项选择界面
*Input				:None
*Output			:None
*Return				:None
*History			:2014-02-18,modified by syj  */

static void iptSetInterface(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char button=0, dsp_buffer[64]={0}, dsp_len=0, rdbuffer[32]={0};
	unsigned int i=0, value=0;
	unsigned int data_hex=0;
	int istate=0;
	long long data=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0==button)	button='0';
	case KB_BUTTON_1:
		if(0==button)	button='1';
	case KB_BUTTON_2:
		if(0==button)	button='2';
	case KB_BUTTON_3:
		if(0==button)	button='3';
	case KB_BUTTON_4:
		if(0==button)	button='4';
	case KB_BUTTON_5:
		if(0==button)	button='5';
	case KB_BUTTON_6:
		if(0==button)	button='6';
	case KB_BUTTON_7:
		if(0==button)	button='7';
	case KB_BUTTON_8:
		if(0==button)	button='8';
	case KB_BUTTON_9:
		if(0==button)	button='9';
		//保存按键
		iptparam->SetButton[0]=iptparam->SetButton[1];	iptparam->SetButton[1]=button;

		if(0==iptparam->SetPage && '1'==iptparam->SetButton[1])
		{
			//1.单价设置
			//清除输入
			memset(iptparam->IntegerBuffer, 0, 4);	iptparam->IntegerLen=0;
			iptparam->Point=0;
			memset(iptparam->DecimalBuffer, 0, 2);	iptparam->DecimalLen=0;
			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;	iptparam->SetButtonFlag=0;

			//联网状态不允许手工修改单价
			if(1==iptparam->PcOnline){

				memcpy(&dsp_buffer[0], "联网状态，      ", 16);
				memcpy(&dsp_buffer[16], "禁止手工修改单价", 16);
				dsp_len=32;
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);
				IPT_DSP_WAIT();

				dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
				memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
				iptPidSet(iptparam, IPT_PID_SET);
				break;
			}

			//获取当前单价,fj:
			jlPriceRead(iptparam->JlNozzle, &data_hex);

			//显示当前单价并转入单价修改界面
			dsp_buffer[0]=(char)(data_hex>>8);	dsp_buffer[1]=(char)(data_hex>>0);	dsp_len=2;
			dsp(iptparam->DEVDsp, DSP_SET_PRICE, dsp_buffer, dsp_len);
			iptPidSet(iptparam, IPT_PID_SET_PRICE);
		}
		else if(0==iptparam->SetPage && '2'==iptparam->SetButton[1])
		{
			//2.时间设置
			dsp_buffer[0]=iptparam->Time.century;	dsp_buffer[1]=iptparam->Time.year;
			dsp_buffer[2]=iptparam->Time.month;	dsp_buffer[3]=iptparam->Time.date;
			dsp_buffer[4]=iptparam->Time.hour;		dsp_buffer[5]=iptparam->Time.minute;
			dsp_buffer[6]=iptparam->Time.second;	dsp_len=7;
			dsp(iptparam->DEVDsp, DSP_SET_TIME, dsp_buffer, dsp_len);

			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;	iptparam->SetButtonFlag=0;
			iptPidSet(iptparam, IPT_PID_SET_TIME);
		}
		else if(0==iptparam->SetPage && '3'==iptparam->SetButton[1])
		{
			//3.首次检定
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "首次检定?", 9);
			
			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;	iptparam->SetButtonFlag=0;
			iptPidSet(iptparam, IPT_PID_SET_SCJD);
		}
		else if(0==iptparam->SetPage && '4'==iptparam->SetButton[1])
		{
			//4.出厂检定
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "出厂检定?", 9);

			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;	iptparam->SetButtonFlag=0;
			iptPidSet(iptparam, IPT_PID_SET_CCJD);
		}
		else if(1==iptparam->SetPage && '5'==iptparam->SetButton[1])
		{
			//5.背光设置
			iptparam->SetParam=IptBacklit;
			dsp_buffer[0]=iptparam->SetParam;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_SET_BACKLIT, dsp_buffer, dsp_len);
			
			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;	iptparam->SetButtonFlag=0;
			iptPidSet(iptparam, IPT_PID_SET_BACKLIT);
		}
		else if(1==iptparam->SetPage && '6'==iptparam->SetButton[1])
		{
			//6.夜间锁定
			iptparam->SetParam=iptparam->NightLock;
			dsp_buffer[0]=iptparam->SetParam;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_SET_NIGHTLOCK, dsp_buffer, dsp_len);
			
			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;	iptparam->SetButtonFlag=0;
			iptPidSet(iptparam, IPT_PID_SET_NIGHTLOCK);
		}
		else if(1==iptparam->SetPage && '7'==iptparam->SetButton[1])
		{
			//7.操作密码设置
			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;	iptparam->SetButtonFlag=0;
			memset(iptparam->SetPassNew, 0, 4);	memset(iptparam->SetPassNew2, 0, 4);

			dsp_buffer[0]=iptparam->SetButtonLen;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_SET_PASSWORD_OLD, dsp_buffer, dsp_len);
			iptPidSet(iptparam, IPT_PID_SET_PASS_OLD);
		}
		else if(1==iptparam->SetPage && '8'==iptparam->SetButton[1])
		{
			//8.物理枪号设置
			iptparam->SetParam=iptparam->PhysicalNozzle;
			dsp_buffer[0]=iptparam->SetParam;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_SET_PHYSICAL_NOZZLE, dsp_buffer, dsp_len);
			
			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;	iptparam->SetButtonFlag=0;
			iptPidSet(iptparam, IPT_PID_SET_PHYNOZZLE);
		}
		else if(2==iptparam->SetPage && '9'==iptparam->SetButton[1])
		{
			//9.税务时间
			memset(dsp_buffer, 0, 6);	dsp_len=6;
			dsp(iptparam->DEVDsp, DSP_SET_TAX_TIME, dsp_buffer, dsp_len);

			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;	iptparam->SetButtonFlag=0;
			iptPidSet(iptparam, IPT_PID_SET_TAXTIME);
		}
		else if(2==iptparam->SetPage && '1'==iptparam->SetButton[0] && '0'==iptparam->SetButton[1])
		{
			//10.扬声器选择
			iptparam->SetParam=iptparam->Speaker;
			dsp_buffer[0]=iptparam->SetParam;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_SET_SPEAKER, dsp_buffer, dsp_len);

			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;	iptparam->SetButtonFlag=0;
			iptPidSet(iptparam, IPT_PID_SET_SPEAKER);
		}
		else if(2==iptparam->SetPage && '1'==iptparam->SetButton[0] && '1'==iptparam->SetButton[1])
		{
			//11.语音音量
			dsp_buffer[0]=iptparam->VoiceVolume;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_SET_VOICE_VOLUME, dsp_buffer, dsp_len);

			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;	iptparam->SetButtonFlag=0;
			iptPidSet(iptparam, IPT_PID_SET_SPKVOLUME);
		}
		else if(2==iptparam->SetPage && '1'==iptparam->SetButton[0] && '2'==iptparam->SetButton[1])
		{
			//12.语音类型
			iptparam->SetParam=iptparam->VoiceType;
			dsp_buffer[0]=iptparam->SetParam;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_SET_VOICE_TYPE, dsp_buffer, dsp_len);

			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;	iptparam->SetButtonFlag=0;
			iptPidSet(iptparam, IPT_PID_SET_SPKTYPE);
		}
		else if(3==iptparam->SetPage && '1'==iptparam->SetButton[0] && '3'==iptparam->SetButton[1])
		{
			//13.打印机选择
			iptparam->SetParam=iptparam->Printer;
			dsp_buffer[0]=iptparam->SetParam;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_SET_PRINTER, dsp_buffer, dsp_len);

			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;	iptparam->SetButtonFlag=0;
			iptPidSet(iptparam, IPT_PID_SET_PRINTER);
		}
		else if(3==iptparam->SetPage && '1'==iptparam->SetButton[0] && '4'==iptparam->SetButton[1])
		{
			//14.自动打印设置
			iptparam->SetParam=iptparam->PrintAuto;
			dsp_buffer[0]=iptparam->SetParam;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_SET_PRINT_AUTO, dsp_buffer, dsp_len);

			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;	iptparam->SetButtonFlag=0;
			iptPidSet(iptparam, IPT_PID_SET_PRNAUTO);
		}
		else if(3==iptparam->SetPage && '1'==iptparam->SetButton[0] && '5'==iptparam->SetButton[1])
		{
			//15.打印联设置
			iptparam->SetParam=iptparam->PrintUnion;
			dsp_buffer[0]=iptparam->SetParam;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_SET_PRINT_UNION, dsp_buffer, dsp_len);

			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;	iptparam->SetButtonFlag=0;
			iptPidSet(iptparam, IPT_PID_SET_PRNUNION);
		}
		else if(3==iptparam->SetPage && '1'==iptparam->SetButton[0] && '6'==iptparam->SetButton[1])
		{
			//16.自动打印类型
			dsp(iptparam->DEVDsp, DSP_SET_PRINT_CARD, "\x00", 0);

			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;	iptparam->SetButtonFlag=0;
			iptPidSet(iptparam, IPT_PID_SET_PRNAUTO_IC);
		}
		else if(4==iptparam->SetPage && '1'==iptparam->SetButton[0] && '7'==iptparam->SetButton[1])
		{
			//17.提前量设置.fj:	
			jlAdvanceRead(iptparam->JlNozzle, &data_hex);
			dsp_buffer[0]=(char)(data_hex>>8);	dsp_buffer[1]=(char)(data_hex>>0);	dsp_len=2;
			dsp(iptparam->DEVDsp, DSP_SET_ADVANCE, dsp_buffer, dsp_len);

			memset(iptparam->IntegerBuffer, 0, 4);	iptparam->IntegerLen=0;
			iptparam->Point=0;
			memset(iptparam->DecimalBuffer, 0, 2);	iptparam->DecimalLen=0;
			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;	iptparam->SetButtonFlag=0;
			iptPidSet(iptparam, IPT_PID_SET_ADVANCE);
		}
		else if(4==iptparam->SetPage && '1'==iptparam->SetButton[0] && '8'==iptparam->SetButton[1])
		{
			//18.超时停机时间,fj:
			jlUnPulseTimeRead(iptparam->JlNozzle, &data_hex);
			dsp_buffer[0]=(char)(data_hex>>8);	dsp_buffer[1]=(char)(data_hex>>0);	dsp_len=2;
			dsp(iptparam->DEVDsp, DSP_SET_UNPULSE_TIME, dsp_buffer, dsp_len);

			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;	iptparam->SetButtonFlag=0;
			iptPidSet(iptparam, IPT_PID_SET_UNPULSE_TIME);
		}
		else if(4==iptparam->SetPage && '1'==iptparam->SetButton[0] && '9'==iptparam->SetButton[1])
		{
			//19.员工卡加油限制
			iptparam->SetParam=iptparam->CardStaffLimit;
			dsp_buffer[0]=iptparam->SetParam;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_SET_STAFF_LIMIT, dsp_buffer, dsp_len);

			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;	iptparam->SetButtonFlag=0;
			iptPidSet(iptparam, IPT_PID_SET_STAFF_LIMIT);
		}
		else if(4==iptparam->SetPage && '2'==iptparam->SetButton[0] && '0'==iptparam->SetButton[1])
		{
			//20.模式设置
			iptparam->SetParam=iptparam->Mode;
			dsp_buffer[0]=iptparam->SetParam;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_SET_MODE, dsp_buffer, dsp_len);

			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;	iptparam->SetButtonFlag=0;
			iptPidSet(iptparam, IPT_PID_SET_MODE);
		}
		else if(5==iptparam->SetPage && '2'==iptparam->SetButton[0] && '1'==iptparam->SetButton[1])
		{
			//21.油品语音大项选择
			dsp(iptparam->DEVDsp, DSP_SET_OILVOICE_SELECT, "\x00", 0);

			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;	iptparam->SetButtonFlag=0;
			iptPidSet(iptparam, IPT_PID_SET_OILVOICE_SEL);
		}
		else if(5==iptparam->SetPage && '2'==iptparam->SetButton[0] && '2'==iptparam->SetButton[1])
		{
			//22.面板单面枪数设置
			iptparam->SetParam=paramPanelNozzleGet();
			dsp_buffer[0]=iptparam->SetParam;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_SET_NOZZLE_NUMBER, dsp_buffer, dsp_len);

			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;	iptparam->SetButtonFlag=0;
			iptPidSet(iptparam, IPT_PID_SET_NOZZLE_NUM);
		}
		else if(5==iptparam->SetPage && '2'==iptparam->SetButton[0] && '3'==iptparam->SetButton[1])
		{
			//23.条码模块品牌设置
			barBrandRead(iptparam->DEVBarcode, dsp_buffer);	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_SET_BARBRAND, dsp_buffer, dsp_len);

			iptparam->SetParam=*dsp_buffer;
			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;	iptparam->SetButtonFlag=0;
			iptPidSet(iptparam, IPT_PID_SET_BARBRAND);
		}
		else if(5==iptparam->SetPage && '2'==iptparam->SetButton[0] && '4'==iptparam->SetButton[1])
		{
			//24.后台联网方式显示界面
			i = kjldChannelGet();
			if(KJLD_CHANNEL_COM == i)	dsp_buffer[0] = '0';
			if(KJLD_CHANNEL_NET == i)		dsp_buffer[0] = '1';
			dsp_len = 1;
			dsp(iptparam->DEVDsp, DSP_CONNECT_TYPE_SET, dsp_buffer, dsp_len);

			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_SET_CONNECT_TYPE);
		}
		else if(6==iptparam->SetPage && '2'==iptparam->SetButton[0] && '5'==iptparam->SetButton[1])
		{
			//25.本地网络信息设置界面
			dsp(iptparam->DEVDsp, DSP_LOCAL_NETINFO, "\x00", 0);

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_SET_LOCAL_NET);
		}
		else if(6==iptparam->SetPage && '2'==iptparam->SetButton[0] && '6'==iptparam->SetButton[1])
		{
			//26.石化后台网络信息设置界面
			dsp(iptparam->DEVDsp, DSP_BACKSTAGE_INFO, "\x00", 0);

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_SET_BACKSTAGE);
		}
		else if(6==iptparam->SetPage && '2'==iptparam->SetButton[0] && '7'==iptparam->SetButton[1])
		{
			//27.平板电脑信息设置界面
			iptparam->SetPage2 = 0;
			*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
			dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_SET_PC_INFO);
		}
		else if(6==iptparam->SetPage && '2'==iptparam->SetButton[0] && '8'==iptparam->SetButton[1])
		{
			//28.键盘显示对比度设置界面
			*(dsp_buffer + 0) = iptparam->Contrast;	dsp_len = 1;
			dsp(iptparam->DEVDsp, DSP_CONTRAST, dsp_buffer, dsp_len);

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_SET_CONTRAST);
		}
		else if(7==iptparam->SetPage && '2'==iptparam->SetButton[0] && '9'==iptparam->SetButton[1])
		{
			//szb_fj_20171120:ETC功能设置
			*(dsp_buffer + 0) = iptparam->etc_set_flg;	dsp_len = 1;
			dsp(iptparam->DEVDsp, DSP_ETC_FUN_COUR, dsp_buffer, dsp_len);

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_SET_ETC_FUN);
		}
		break;

	case KB_BUTTON_UP:
		//上翻一页
		if(iptparam->SetPage==0)
			iptparam->SetPage=7; //szb_fj_20171120:update
		else
			iptparam->SetPage--;
		dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
		break;

	case KB_BUTTON_DOWN: 
		//下翻一页
		if(iptparam->SetPage>=7) //szb_fj_20171120:update
			iptparam->SetPage=0;
		else
			iptparam->SetPage++;
		dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
		break;

	case KB_BUTTON_CHG:
	case KB_BUTTON_BACK:
		//返回查询/设置选择界面
		dsp(iptparam->DEVDsp, DSP_OPERATE_SELECT, "\x00", 0);

		iptPidSet(iptparam, IPT_PID_OPERATE_SELECT);
		break;

	default:
		break;
	} 

	return;
}


/*******************************************************************
*Name				:iptSetPrice
*Description		:单价设置
*Input				:None
*Output			:None
*Return				:None
*History			:2014-03-11,modified by syj  */

static void iptSetPrice(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char button=0, dsp_buffer[64]={0}, dsp_len=0;
	unsigned int price=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0==button)	button='0';
	case KB_BUTTON_1:
		if(0==button)	button='1';
	case KB_BUTTON_2:
		if(0==button)	button='2';
	case KB_BUTTON_3:
		if(0==button)	button='3';
	case KB_BUTTON_4:
		if(0==button)	button='4';
	case KB_BUTTON_5:
		if(0==button)	button='5';
	case KB_BUTTON_6:
		if(0==button)	button='6';
	case KB_BUTTON_7:
		if(0==button)	button='7';
	case KB_BUTTON_8:
		if(0==button)	button='8';
	case KB_BUTTON_9:
		if(0==button)	button='9';
	case KB_BUTTON_CZ:
		if(0==button)	button='.';

		//记录按键动作
		iptparam->SetButtonFlag=1;

		//按小数点记录小数点
		if('.'==button)
		{
			iptparam->Point='.';
		}
		//前一刻无小数点按键操作，记录按键值为整数
		else if(0==iptparam->Point)
		{
			iptparam->IntegerBuffer[2]=iptparam->IntegerBuffer[3];	iptparam->IntegerBuffer[3]=button;
		}
		//前一刻有小数点按键操作，记录按键值为小数
		else if((0!=iptparam->Point)&&(iptparam->DecimalLen<2))
		{
			iptparam->DecimalBuffer[iptparam->DecimalLen++]=button;
		}

		//计算单价
		price=(iptparam->IntegerBuffer[0]&0x0f)*100000+(iptparam->IntegerBuffer[1]&0x0f)*10000+\
			(iptparam->IntegerBuffer[2]&0x0f)*1000+(iptparam->IntegerBuffer[3]&0x0f)*100+\
			(iptparam->DecimalBuffer[0]&0x0f)*10+(iptparam->DecimalBuffer[1]&0x0f)*1;

		//显示单价输入
		dsp_buffer[0]=(char)(price>>8);	dsp_buffer[1]=(char)(price>>0);	dsp_len=2;
		dsp(iptparam->DEVDsp, DSP_SET_PRICE, dsp_buffer, dsp_len);
		break;

	case KB_BUTTON_CHG:
		//记录按键动作
		iptparam->SetButtonFlag=1;

		//计算单价
		price=(iptparam->IntegerBuffer[0]&0x0f)*100000+(iptparam->IntegerBuffer[1]&0x0f)*10000+\
			(iptparam->IntegerBuffer[2]&0x0f)*1000+(iptparam->IntegerBuffer[3]&0x0f)*100+\
			(iptparam->DecimalBuffer[0]&0x0f)*10+(iptparam->DecimalBuffer[1]&0x0f)*1;
		
		//计算设置值并根据设置值判断操作，
		//	设置值为0时返回设置选项选择界面,设置值非0时清空设置值
		
		if(0==price)
		{
			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
		}
		else
		{
			dsp_buffer[0]=(char)(0>>8);	dsp_buffer[1]=(char)(0>>0);	dsp_len=2;
			dsp(iptparam->DEVDsp, DSP_SET_PRICE, dsp_buffer, dsp_len);
		}

		//清除输入
		memset(iptparam->IntegerBuffer, 0, 4);	iptparam->IntegerLen=0;
		iptparam->Point=0;
		memset(iptparam->DecimalBuffer, 0, 2);	iptparam->DecimalLen=0;
		break;

	case KB_BUTTON_ACK:
		//按确认键的操作
		//在设置界面无操作则直接退出
		if(0==iptparam->SetButtonFlag)
		{
			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
			break;
		}
		
		//计算单价
		price=(iptparam->IntegerBuffer[0]&0x0f)*100000+(iptparam->IntegerBuffer[1]&0x0f)*10000+\
			(iptparam->IntegerBuffer[2]&0x0f)*1000+(iptparam->IntegerBuffer[3]&0x0f)*100+\
			(iptparam->DecimalBuffer[0]&0x0f)*10+(iptparam->DecimalBuffer[1]&0x0f)*1;

		//清除输入
		memset(iptparam->IntegerBuffer, 0, 4);	iptparam->IntegerLen=0;
		iptparam->Point=0;
		memset(iptparam->DecimalBuffer, 0, 2);	iptparam->DecimalLen=0;

		printf("ipt ---ready set price,price = %d\n",price);

		//设置单价并根据结果提示信息,fj:
		if(0==jlPriceWrite(iptparam->JlNozzle, price))
		{
			//szb_fj_20171120:add
         	iptparam->JlErr_BianJia=0;
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+FM_ERR_BIAN_PRICE,&iptparam->JlErr_BianJia,1);

			memcpy(&dsp_buffer[0], "操作成功", 8);	dsp_len=8;
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);
			IPT_DSP_WAIT();

			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
		}
		else
		{
			//szb_fj_20171120:add
         	iptparam->JlErr_BianJia=1;
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+FM_ERR_BIAN_PRICE,&iptparam->JlErr_BianJia,1);
	
			memcpy(&dsp_buffer[0], "操作失败", 8);	dsp_len=8;
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);
			IPT_DSP_WAIT();

			dsp_buffer[0]=(char)(0>>8);	dsp_buffer[1]=(char)(0>>0);	dsp_len=2;
			dsp(iptparam->DEVDsp, DSP_SET_PRICE, dsp_buffer, dsp_len);
		}
		break;

	case KB_BUTTON_BACK:
		//按退卡键退出本界面返回设置项选择界面
		memset(iptparam->IntegerBuffer, 0, 4);	iptparam->IntegerLen=0;
		iptparam->Point=0;
		memset(iptparam->DecimalBuffer, 0, 2);	iptparam->DecimalLen=0;

		dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
		iptPidSet(iptparam, IPT_PID_SET);
		break;
		
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptSetTime
*Description		:时间设置
*Input				:None
*Output			:None
*Return				:None
*History			:2014-03-11,modified by syj  */

static void iptSetTime(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char button=0, dsp_buffer[64]={0}, dsp_len=0;
	RTCTime time;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0==button)	button='0';
	case KB_BUTTON_1:
		if(0==button)	button='1';
	case KB_BUTTON_2:
		if(0==button)	button='2';
	case KB_BUTTON_3:
		if(0==button)	button='3';
	case KB_BUTTON_4:
		if(0==button)	button='4';
	case KB_BUTTON_5:
		if(0==button)	button='5';
	case KB_BUTTON_6:
		if(0==button)	button='6';
	case KB_BUTTON_7:
		if(0==button)	button='7';
	case KB_BUTTON_8:
		if(0==button)	button='8';
	case KB_BUTTON_9:
		if(0==button)	button='9';

		//记录按键动作
		iptparam->SetButtonFlag=1;

		//记录输入的时间
		if(iptparam->SetButtonLen<14)
		{
			iptparam->SetButton[iptparam->SetButtonLen++]=button;

			dsp_buffer[0]=((iptparam->SetButton[0]&0x0f)<<4)|((iptparam->SetButton[1]&0x0f)<<0);
			dsp_buffer[1]=((iptparam->SetButton[2]&0x0f)<<4)|((iptparam->SetButton[3]&0x0f)<<0);
			dsp_buffer[2]=((iptparam->SetButton[4]&0x0f)<<4)|((iptparam->SetButton[5]&0x0f)<<0);
			dsp_buffer[3]=((iptparam->SetButton[6]&0x0f)<<4)|((iptparam->SetButton[7]&0x0f)<<0);
			dsp_buffer[4]=((iptparam->SetButton[8]&0x0f)<<4)|((iptparam->SetButton[9]&0x0f)<<0);
			dsp_buffer[5]=((iptparam->SetButton[10]&0x0f)<<4)|((iptparam->SetButton[11]&0x0f)<<0);
			dsp_buffer[6]=((iptparam->SetButton[12]&0x0f)<<4)|((iptparam->SetButton[13]&0x0f)<<0);
			dsp_len=7;
			dsp(iptparam->DEVDsp, DSP_SET_TIME, dsp_buffer, dsp_len);
		}
		break;
 
	case KB_BUTTON_CHG:
		//记录按键动作
		iptparam->SetButtonFlag=1;

		//有输入时清空输入，无输入时返回设置项选择界面
		if(0==iptparam->SetButtonLen)
		{
			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
		}
		else
		{
			memset(dsp_buffer, 0, 7);	dsp_len=7;
			dsp(iptparam->DEVDsp, DSP_SET_TIME, dsp_buffer, dsp_len);
		}

		//清空输入
		memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;
		break;

	case KB_BUTTON_ACK:
		//转入此界面后无有效按键则直接退出
		if(0==iptparam->SetButtonFlag)
		{
			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
			break;
		}

		//判断时间合法性
		dsp_buffer[0]=((iptparam->SetButton[0]&0x0f)<<4)|((iptparam->SetButton[1]&0x0f)<<0);
		dsp_buffer[1]=((iptparam->SetButton[2]&0x0f)<<4)|((iptparam->SetButton[3]&0x0f)<<0);
		dsp_buffer[2]=((iptparam->SetButton[4]&0x0f)<<4)|((iptparam->SetButton[5]&0x0f)<<0);
		dsp_buffer[3]=((iptparam->SetButton[6]&0x0f)<<4)|((iptparam->SetButton[7]&0x0f)<<0);
		dsp_buffer[4]=((iptparam->SetButton[8]&0x0f)<<4)|((iptparam->SetButton[9]&0x0f)<<0);
		dsp_buffer[5]=((iptparam->SetButton[10]&0x0f)<<4)|((iptparam->SetButton[11]&0x0f)<<0);
		dsp_buffer[6]=((iptparam->SetButton[12]&0x0f)<<4)|((iptparam->SetButton[13]&0x0f)<<0);
		dsp_len=7;
		if(0!=timeVerification(dsp_buffer, 7))
		{
			memcpy(dsp_buffer, "时间非法", 8);	
			dsp_len=8;
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;
			memset(dsp_buffer, 0, 7);	dsp_len=7;
			dsp(iptparam->DEVDsp, DSP_SET_TIME, dsp_buffer, dsp_len);
			break;
		}
		
		//设置并判断设置结果
		timeRead(&time);
		time.century=((iptparam->SetButton[0]&0x0f)<<4)|((iptparam->SetButton[1]&0x0f)<<0);
		time.year=((iptparam->SetButton[2]&0x0f)<<4)|((iptparam->SetButton[3]&0x0f)<<0);
		time.month=((iptparam->SetButton[4]&0x0f)<<4)|((iptparam->SetButton[5]&0x0f)<<0);
		time.date=((iptparam->SetButton[6]&0x0f)<<4)|((iptparam->SetButton[7]&0x0f)<<0);
		time.hour=((iptparam->SetButton[8]&0x0f)<<4)|((iptparam->SetButton[9]&0x0f)<<0);
		time.minute=((iptparam->SetButton[10]&0x0f)<<4)|((iptparam->SetButton[11]&0x0f)<<0);
		time.second=((iptparam->SetButton[12]&0x0f)<<4)|((iptparam->SetButton[13]&0x0f)<<0);
		if(0==timeWrite(time))
		{
			memcpy(&dsp_buffer[0], "操作成功", 8);	dsp_len=8;
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);
			IPT_DSP_WAIT();

			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
		}
		else
		{
			memcpy(&dsp_buffer[0], "操作失败", 8);	dsp_len=8;
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);
			IPT_DSP_WAIT();

			memset(dsp_buffer, 0, 7);	dsp_len=7;
			dsp(iptparam->DEVDsp, DSP_SET_TIME, dsp_buffer, dsp_len);
		}

		//清空输入
		memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;
		break;

	case KB_BUTTON_BACK:
		//退出本界面
		memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
		iptPidSet(iptparam, IPT_PID_SET);
		break;
	
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptSetSCJD
*Description		:首次检定设置
*Input				:None
*Output			:None
*Return				:None
*History			:2014-03-11,modified by syj  */

static void iptSetSCJD(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	int istate=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_CHG:
	case KB_BUTTON_BACK:
		//退出本界面，返回设置项选择界面
		dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
		iptPidSet(iptparam, IPT_PID_SET);
		break;
		
	case KB_BUTTON_ACK:
		//进行首次检定,fj:
		istate=jlTaxVerifyWrite(1);
		
		//提示操作结果
		if(0==istate)	dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", 8);
		else				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", 8);

		iptparam->NousedTimer=0;	iptPidSet(iptparam, IPT_PID_SET_TAX_WAIT);
		break;
	default:
		break;
	}
	
	return;
}


/*******************************************************************
*Name				:iptSetCCJD
*Description		:出厂检定设置
*Input				:None
*Output			:None
*Return				:None
*History			:2014-03-11,modified by syj  */

static void iptSetCCJD(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	int istate=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_CHG:
	case KB_BUTTON_BACK:
		//退出本界面，返回设置项选择界面
		dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
		iptPidSet(iptparam, IPT_PID_SET);
		break;

	case KB_BUTTON_ACK:
		//进行出厂检定,fj:
		istate=jlTaxVerifyWrite(0);

		//提示操作结果
		if(0==istate)	dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", 8);
		else				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", 8);

		iptparam->NousedTimer=0;	iptPidSet(iptparam, IPT_PID_SET_TAX_WAIT);
		break;
	default:
		break;
	}
	
	return;
}


/*******************************************************************
*Name				:iptSetBacklit
*Description		:背光设置
*Input				:None
*Output			:None
*Return				:None
*History			:2014-03-11,modified by syj  */

static void iptSetBacklit(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char dsp_buffer[64]={0}, dsp_len=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_UP:
	case KB_BUTTON_DOWN:
		//记录按键动作
		iptparam->SetButtonFlag=1;

		//更改设置
		if(KB_BUTTON_UP==iptparam->Button)
		{
			if(0==iptparam->SetParam)			iptparam->SetParam=2;
			else if(1==iptparam->SetParam)	iptparam->SetParam=0;
			else													iptparam->SetParam=1;
		}
		else
		{
			if(0==iptparam->SetParam)			iptparam->SetParam=1;
			else	if(1==iptparam->SetParam)	iptparam->SetParam=2;
			else													iptparam->SetParam=0;
		}

		//显示设置
		dsp_buffer[0]=iptparam->SetParam;	dsp_len=1;
		dsp(iptparam->DEVDsp, DSP_SET_BACKLIT, dsp_buffer, dsp_len);
		break;
		
	case KB_BUTTON_CHG:
	case KB_BUTTON_BACK:
		//记录按键动作
		iptparam->SetButtonFlag=1;

		//退出本界面，返回设置项选择界面
		dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
		iptPidSet(iptparam, IPT_PID_SET);
		break;

	case KB_BUTTON_ACK:
		//转入此界面后无有效按键则直接退出
		if(0==iptparam->SetButtonFlag)
		{
			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
			break;
		}

		dsp_buffer[0]=(char)iptparam->SetParam;
		if(0==paramSetupWrite(PRM_BACKLIT, dsp_buffer, 1))
		{
			IptBacklit=iptparam->SetParam;
			//fj:
			//if(1==IptBacklit)	pioBacklitCtr(0);
			//else						pioBacklitCtr(1);
			
			if(1==IptBacklit)
			{
				SET_GPIO_HIGH(0x0b);
			}
			else
			{
				SET_GPIO_LOW(0x0b);
			}
		
			memcpy(&dsp_buffer[0], "操作成功", 8);	dsp_len=8;
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);
			IPT_DSP_WAIT();

			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
		}
		else
		{
			memcpy(&dsp_buffer[0], "操作失败", 8);	dsp_len=8;
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);
			IPT_DSP_WAIT();

			dsp_buffer[0]=iptparam->SetParam;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_SET_BACKLIT, dsp_buffer, dsp_len);
		}
		break;
	default:
		break;
	}
	
	return;
}


/*******************************************************************
*Name				:iptSetNightLock
*Description		:夜间锁定设置
*Input				:None
*Output			:None
*Return				:None
*History			:2014-03-11,modified by syj  */

static void iptSetNightLock(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	off_t offset=0;
	unsigned char dsp_buffer[64]={0}, dsp_len=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_UP:
	case KB_BUTTON_DOWN:
		//记录按键动作
		iptparam->SetButtonFlag=1;

		//更改设置
		if(0==iptparam->SetParam)	iptparam->SetParam=1;
		else											iptparam->SetParam=0;

		//显示设置
		dsp_buffer[0]=iptparam->SetParam;	dsp_len=1;
		dsp(iptparam->DEVDsp, DSP_SET_NIGHTLOCK, dsp_buffer, dsp_len);
		break;

	case KB_BUTTON_CHG:
	case KB_BUTTON_BACK:
		//记录按键动作
		iptparam->SetButtonFlag=1;

		//退出本界面，返回设置项选择界面
		dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
		iptPidSet(iptparam, IPT_PID_SET);
		break;

	case KB_BUTTON_ACK:
		//转入此界面后无有效按键则直接退出
		if(0==iptparam->SetButtonFlag)
		{
			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
			break;
		}

		dsp_buffer[0]=(char)iptparam->SetParam;
		if(0==iptparam->Id)	offset=IPT0_NIGHT_LOCK;
		else								offset=IPT1_NIGHT_LOCK;
		if(0==paramSetupWrite(PRM_BACKLIT, dsp_buffer, 1))
		{
			iptparam->NightLock=iptparam->SetParam;

			memcpy(&dsp_buffer[0], "操作成功", 8);	dsp_len=8;
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);
			IPT_DSP_WAIT();

			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
		}
		else
		{
			memcpy(&dsp_buffer[0], "操作失败", 8);	dsp_len=8;
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);
			IPT_DSP_WAIT();

			dsp_buffer[0]=iptparam->SetParam;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_SET_NIGHTLOCK, dsp_buffer, dsp_len);
		}
		break;
	default:
		break;
	}
	
	return;
}


/*******************************************************************
*Name				:iptSetPasswordOld
*Description		:操作密码旧密码输入
*Input				:None
*Output			:None
*Return				:None
*History			:2014-03-11,modified by syj  */

static void iptSetPasswordOld(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char password[4]={0}, dsp_buffer[64]={0}, dsp_len=0, button=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0==button)	button='0';
	case KB_BUTTON_1:
		if(0==button)	button='1';
	case KB_BUTTON_2:
		if(0==button)	button='2';
	case KB_BUTTON_3:
		if(0==button)	button='3';
	case KB_BUTTON_4:
		if(0==button)	button='4';
	case KB_BUTTON_5:
		if(0==button)	button='5';
	case KB_BUTTON_6:
		if(0==button)	button='6';
	case KB_BUTTON_7:
		if(0==button)	button='7';
	case KB_BUTTON_8:
		if(0==button)	button='8';
	case KB_BUTTON_9:
		if(0==button)	button='9';

		//记录按键动作
		iptparam->SetButtonFlag=1;
		
		//记录输入密码
		if(iptparam->SetButtonLen<4)
		{
			iptparam->SetButton[iptparam->SetButtonLen++]=button;

			dsp_buffer[0]=iptparam->SetButtonLen;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_SET_PASSWORD_OLD, dsp_buffer, dsp_len);
		}
		break;

	case KB_BUTTON_CHG:
		//记录按键动作
		iptparam->SetButtonFlag=1;

		//清除密码输入
		memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;

		dsp_buffer[0]=iptparam->SetButtonLen;	dsp_len=1;
		dsp(iptparam->DEVDsp, DSP_SET_PASSWORD_OLD, dsp_buffer, dsp_len);
		break;

	case KB_BUTTON_BACK:
		//返回设置项选择界面
		memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
		iptPidSet(iptparam, IPT_PID_SET);
		break;
		
	case KB_BUTTON_ACK:
		//转入此界面后无有效按键则直接退出
		if(0==iptparam->SetButtonFlag)
		{
			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
			break;
		}
		
		//判断旧密码是否正确
		password[0]=((iptparam->Password[0]>>4)&0x0f)+0x30;	password[1]=((iptparam->Password[0]>>0)&0x0f)+0x30;
		password[2]=((iptparam->Password[1]>>4)&0x0f)+0x30;	password[3]=((iptparam->Password[1]>>0)&0x0f)+0x30;
		if(4!=iptparam->SetButtonLen||0!=memcmp(password, iptparam->SetButton, 4))
		{
			memcpy(&dsp_buffer[0], "密码错误", 8);	dsp_len=8;
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;
			
			dsp_buffer[0]=iptparam->SetButtonLen;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_SET_PASSWORD_OLD, dsp_buffer, dsp_len);
			break;
		}

		//清除输入
		memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;
		memset(iptparam->SetPassNew, 0, 4);

		//转入新密码输入界面
		dsp_buffer[0]=iptparam->SetButtonLen;	dsp_len=1;
		dsp(iptparam->DEVDsp, DSP_SET_PASSWORD_NEW, dsp_buffer, dsp_len);

		iptPidSet(iptparam, IPT_PID_SET_PASS_NEW);
		break;
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptSetPasswordNew
*Description		:操作密码旧密码输入
*Input				:None
*Output			:None
*Return				:None
*History			:2014-03-11,modified by syj  */

static void iptSetPasswordNew(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char password[4]={0}, dsp_buffer[64]={0}, dsp_len=0, button=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0==button)	button='0';
	case KB_BUTTON_1:
		if(0==button)	button='1';
	case KB_BUTTON_2:
		if(0==button)	button='2';
	case KB_BUTTON_3:
		if(0==button)	button='3';
	case KB_BUTTON_4:
		if(0==button)	button='4';
	case KB_BUTTON_5:
		if(0==button)	button='5';
	case KB_BUTTON_6:
		if(0==button)	button='6';
	case KB_BUTTON_7:
		if(0==button)	button='7';
	case KB_BUTTON_8:
		if(0==button)	button='8';
	case KB_BUTTON_9:
		if(0==button)	button='9';

		//记录按键动作
		iptparam->SetButtonFlag=1;
		
		//记录输入密码
		if(iptparam->SetButtonLen<4)
		{
			iptparam->SetButton[iptparam->SetButtonLen++]=button;

			dsp_buffer[0]=iptparam->SetButtonLen;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_SET_PASSWORD_NEW, dsp_buffer, dsp_len);
		}
		break;

	case KB_BUTTON_CHG:
		//记录按键动作
		iptparam->SetButtonFlag=1;

		//清除密码输入
		memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;

		dsp_buffer[0]=iptparam->SetButtonLen;	dsp_len=1;
		dsp(iptparam->DEVDsp, DSP_SET_PASSWORD_NEW, dsp_buffer, dsp_len);
		break;

	case KB_BUTTON_BACK:
		//返回设置项选择界面
		memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
		iptPidSet(iptparam, IPT_PID_SET);
		break;
		
	case KB_BUTTON_ACK:
		//转入此界面后无有效按键则直接退出
		if(0==iptparam->SetButtonFlag)
		{
			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
			break;
		}

		//保存输入的密码
		memcpy(iptparam->SetPassNew, iptparam->SetButton, iptparam->SetButtonLen);

		//清除输入
		memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;
		memset(iptparam->SetPassNew2, 0, 4);

		//转入新密码输入界面
		dsp_buffer[0]=iptparam->SetButtonLen;	dsp_len=1;
		dsp(iptparam->DEVDsp, DSP_SET_PASSWORD_ACK, dsp_buffer, dsp_len);
		
		iptPidSet(iptparam, IPT_PID_SET_PASS_ACK);
		break;
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptSetPasswordAck
*Description		:操作密码旧密码输入
*Input				:None
*Output			:None
*Return				:None
*History			:2014-03-11,modified by syj  */

static void iptSetPasswordAck(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char password[4]={0}, dsp_buffer[64]={0}, dsp_len=0, button=0;
	off_t offset=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0==button)	button='0';
	case KB_BUTTON_1:
		if(0==button)	button='1';
	case KB_BUTTON_2:
		if(0==button)	button='2';
	case KB_BUTTON_3:
		if(0==button)	button='3';
	case KB_BUTTON_4:
		if(0==button)	button='4';
	case KB_BUTTON_5:
		if(0==button)	button='5';
	case KB_BUTTON_6:
		if(0==button)	button='6';
	case KB_BUTTON_7:
		if(0==button)	button='7';
	case KB_BUTTON_8:
		if(0==button)	button='8';
	case KB_BUTTON_9:
		if(0==button)	button='9';

		//记录按键动作
		iptparam->SetButtonFlag=1;
		
		//记录输入密码
		if(iptparam->SetButtonLen<4)
		{
			iptparam->SetButton[iptparam->SetButtonLen++]=button;

			dsp_buffer[0]=iptparam->SetButtonLen;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_SET_PASSWORD_ACK, dsp_buffer, dsp_len);
		}
		break;

	case KB_BUTTON_CHG:
		//记录按键动作
		iptparam->SetButtonFlag=1;

		//清除密码输入
		memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;

		dsp_buffer[0]=iptparam->SetButtonLen;	dsp_len=1;
		dsp(iptparam->DEVDsp, DSP_SET_PASSWORD_ACK, dsp_buffer, dsp_len);
		break;

	case KB_BUTTON_BACK:
		//返回设置项选择界面
		memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;

		dsp_buffer[0]=iptparam->SetButtonLen;	dsp_len=1;
		dsp(iptparam->DEVDsp, DSP_SET_PASSWORD_NEW, dsp_buffer, dsp_len);
		iptPidSet(iptparam, IPT_PID_SET_PASS_NEW);
		break;
		
	case KB_BUTTON_ACK:
		//转入此界面后无有效按键则直接退出
		if(0==iptparam->SetButtonFlag)
		{
			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
			break;
		}

		//保存输入的密码
		memcpy(iptparam->SetPassNew2, iptparam->SetButton, iptparam->SetButtonLen);

		//清除输入
		memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;

		//判断两次密码是否一致
		if(0!=memcmp(iptparam->SetPassNew, iptparam->SetPassNew2, 4))
		{
			memcpy(&dsp_buffer[0], "密码不一致", 10);	dsp_len=10;
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);
			IPT_DSP_WAIT();

			dsp_buffer[0]=iptparam->SetButtonLen;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_SET_PASSWORD_ACK, dsp_buffer, dsp_len);
			break;
		}

		//判断保存是否成功
		if(0==iptparam->Id)	offset=IPT0_PASSWORD;
		else								offset=IPT1_PASSWORD;
		password[0]=((iptparam->SetPassNew[0]&0x0f)<<4)|((iptparam->SetPassNew[1]&0x0f)<<0);
		password[1]=((iptparam->SetPassNew[2]&0x0f)<<4)|((iptparam->SetPassNew[3]&0x0f)<<0);
		if(0==paramSetupWrite(offset, password, 2))
		{
			//更新操作密码
			memcpy(iptparam->Password, password, 2);
		
			memcpy(&dsp_buffer[0], "操作成功", 8);	dsp_len=8;
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);
			IPT_DSP_WAIT();

			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
		}
		else
		{
			memcpy(&dsp_buffer[0], "操作失败", 8);	dsp_len=8;
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);
			IPT_DSP_WAIT();

			dsp_buffer[0]=iptparam->SetButtonLen;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_SET_PASSWORD_NEW, dsp_buffer, dsp_len);
			iptPidSet(iptparam, IPT_PID_SET_PASS_NEW);
		}
		break;
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptSetPhysicalNozzle
*Description		:物理枪号设置
*Input				:None
*Output			:None
*Return				:None
*History			:2014-03-11,modified by syj  */

static void iptSetPhysicalNozzle(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char wrbuffer[4]={0}, dsp_buffer[16]={0}, dsp_len=0, button=0;
	off_t offset=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0==button)	button='0';
	case KB_BUTTON_1:
		if(0==button)	button='1';
	case KB_BUTTON_2:
		if(0==button)	button='2';
	case KB_BUTTON_3:
		if(0==button)	button='3';
	case KB_BUTTON_4:
		if(0==button)	button='4';
	case KB_BUTTON_5:
		if(0==button)	button='5';
	case KB_BUTTON_6:
		if(0==button)	button='6';
	case KB_BUTTON_7:
		if(0==button)	button='7';
	case KB_BUTTON_8:
		if(0==button)	button='8';
	case KB_BUTTON_9:
		if(0==button)	button='9';

		//记录有效按键动作
		iptparam->SetButtonFlag=1;		

		iptparam->SetParam=button&0x0f;
		dsp_buffer[0]=iptparam->SetParam;	dsp_len=1;
		dsp(iptparam->DEVDsp, DSP_SET_PHYSICAL_NOZZLE, dsp_buffer, dsp_len);
		break;
		
	case KB_BUTTON_CHG:
		//清除输入
		iptparam->SetButtonFlag=1;		

		iptparam->SetParam=0;
		dsp_buffer[0]=iptparam->SetParam;	dsp_len=1;
		dsp(iptparam->DEVDsp, DSP_SET_PHYSICAL_NOZZLE, dsp_buffer, dsp_len);
		break;

	case KB_BUTTON_BACK:
		//返回设置项选择界面
		dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
		iptPidSet(iptparam, IPT_PID_SET);
		break;
		
	case KB_BUTTON_ACK:
		//无按键操作直接返回上级界面
		if(0==iptparam->SetButtonFlag)
		{
			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
			break;
		}
		
		//判断是否在有效范围内
		if(iptparam->SetParam<IPT_PHY_NOZZLE_MIN || iptparam->SetParam>IPT_PHY_NOZZLE_MAX)
		{
			memcpy(&dsp_buffer[0], "有效范围:", 9);	
			dsp_buffer[9]=(char)(IPT_PHY_NOZZLE_MIN&0x0f)+0x30;		dsp_buffer[10]='~';
			dsp_buffer[11]=(char)(IPT_PHY_NOZZLE_MAX&0x0f)+0x30;		
			dsp_len=12;
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);
			IPT_DSP_WAIT();

			dsp_buffer[0]=iptparam->SetParam;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_SET_PHYSICAL_NOZZLE, dsp_buffer, dsp_len);
			break;
		}
		
		//保存设置值
		if(0==iptparam->Id)	offset=IPT0_PHYSICAL_NOZZLE;
		else								offset=IPT1_PHYSICAL_NOZZLE;
		wrbuffer[0]=(char)iptparam->SetParam;
		if(0==paramSetupWrite(offset, wrbuffer, 1))
		{
			//更新物理枪号
			iptparam->PhysicalNozzle=(char)iptparam->SetParam;
	
			memcpy(&dsp_buffer[0], "操作成功", 8);	dsp_len=8;
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);
			IPT_DSP_WAIT();

			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
		}
		else
		{
			memcpy(&dsp_buffer[0], "操作失败", 8);	dsp_len=8;
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);
			IPT_DSP_WAIT();

			dsp_buffer[0]=iptparam->SetParam;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_SET_PHYSICAL_NOZZLE, dsp_buffer, dsp_len);
		}
		break;
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptSetTaxTime
*Description		:税务时间设置
*Input				:None
*Output			:None
*Return				:None
*History			:2014-03-11,modified by syj  */

static void iptSetTaxTime(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char button=0, dsp_buffer[64]={0}, dsp_len=0;
	int istate=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0==button)	button='0';
	case KB_BUTTON_1:
		if(0==button)	button='1';
	case KB_BUTTON_2:
		if(0==button)	button='2';
	case KB_BUTTON_3:
		if(0==button)	button='3';
	case KB_BUTTON_4:
		if(0==button)	button='4';
	case KB_BUTTON_5:
		if(0==button)	button='5';
	case KB_BUTTON_6:
		if(0==button)	button='6';
	case KB_BUTTON_7:
		if(0==button)	button='7';
	case KB_BUTTON_8:
		if(0==button)	button='8';
	case KB_BUTTON_9:
		if(0==button)	button='9';

		//记录按键动作
		iptparam->SetButtonFlag=1;

		//记录输入的时间
		if(iptparam->SetButtonLen<12)
		{
			iptparam->SetButton[iptparam->SetButtonLen++]=button;

			dsp_buffer[0]=((iptparam->SetButton[0]&0x0f)<<4)|((iptparam->SetButton[1]&0x0f)<<0);
			dsp_buffer[1]=((iptparam->SetButton[2]&0x0f)<<4)|((iptparam->SetButton[3]&0x0f)<<0);
			dsp_buffer[2]=((iptparam->SetButton[4]&0x0f)<<4)|((iptparam->SetButton[5]&0x0f)<<0);
			dsp_buffer[3]=((iptparam->SetButton[6]&0x0f)<<4)|((iptparam->SetButton[7]&0x0f)<<0);
			dsp_buffer[4]=((iptparam->SetButton[8]&0x0f)<<4)|((iptparam->SetButton[9]&0x0f)<<0);
			dsp_buffer[5]=((iptparam->SetButton[10]&0x0f)<<4)|((iptparam->SetButton[11]&0x0f)<<0);
			dsp_len=6;
			dsp(iptparam->DEVDsp, DSP_SET_TAX_TIME, dsp_buffer, dsp_len);
		}
		break;
 
	case KB_BUTTON_CHG:
		//记录按键动作
		iptparam->SetButtonFlag=1;

		//有输入时清空输入，无输入时返回设置项选择界面
		if(0==iptparam->SetButtonLen)
		{
			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
		}
		else
		{
			memset(dsp_buffer, 0, 6);	dsp_len=6;
			dsp(iptparam->DEVDsp, DSP_SET_TAX_TIME, dsp_buffer, dsp_len);
		}

		//清空输入
		memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;
		break;

	case KB_BUTTON_BACK:
		//退出本界面
		memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
		iptPidSet(iptparam, IPT_PID_SET);
		break;

	case KB_BUTTON_ACK:
		//转入此界面后无有效按键则直接退出
		if(0==iptparam->SetButtonFlag)
		{
			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
			break;
		}

		//判断时间合法性
		dsp_buffer[0]=((iptparam->SetButton[0]&0x0f)<<4)|((iptparam->SetButton[1]&0x0f)<<0);
		dsp_buffer[1]=((iptparam->SetButton[2]&0x0f)<<4)|((iptparam->SetButton[3]&0x0f)<<0);
		dsp_buffer[2]=((iptparam->SetButton[4]&0x0f)<<4)|((iptparam->SetButton[5]&0x0f)<<0);
		dsp_buffer[3]=((iptparam->SetButton[6]&0x0f)<<4)|((iptparam->SetButton[7]&0x0f)<<0);
		dsp_buffer[4]=((iptparam->SetButton[8]&0x0f)<<4)|((iptparam->SetButton[9]&0x0f)<<0);
		dsp_buffer[5]=((iptparam->SetButton[10]&0x0f)<<4)|((iptparam->SetButton[11]&0x0f)<<0);
		dsp_len=6;
		if(0!=timeVerification(dsp_buffer, 7))
		{
			memcpy(dsp_buffer, "时间非法", 8);	
			dsp_len=8;
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;
			memset(dsp_buffer, 0, 6);	dsp_len=6;
			dsp(iptparam->DEVDsp, DSP_SET_TAX_TIME, dsp_buffer, dsp_len);
			break;
		}
		
		//设置并判断设置结果
		istate=jlTaxTimeWrite(dsp_buffer, 6); //fj:

		//提示操作结果
		if(0==istate)	dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", 8);
		else				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", 8);
		IPT_DSP_WAIT();

		IPT_DSP_WAIT();
		jlNoteDsp(iptparam->JlNozzle); //大屏显示当次明细

		//返回设置项选择界面
		dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
		iptPidSet(iptparam, IPT_PID_SET);
		break;

	default:
		break;
	}
}


/*******************************************************************
*Name				:iptSetSpeaker
*Description		:扬声器设置
*Input				:None
*Output			:None
*Return				:None
*History			:2014-03-11,modified by syj  */

static void iptSetSpeaker(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char wrbuffer[4]={0}, dsp_buffer[64]={0}, dsp_len=0;
	int voice[16]={0};
	off_t offset=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_UP:
		//记录有效按键动作
		iptparam->SetButtonFlag=1;

		//选择扬声器
		if(0x10==iptparam->SetParam)			iptparam->SetParam=0x31;
		else if(0x11==iptparam->SetParam)	iptparam->SetParam=0x10;
		else if(0x20==iptparam->SetParam)	iptparam->SetParam=0x11;
		else if(0x21==iptparam->SetParam)	iptparam->SetParam=0x20;
		else if(0x30==iptparam->SetParam)	iptparam->SetParam=0x21;
		else if(0x31==iptparam->SetParam)	iptparam->SetParam=0x30;
		else														iptparam->SetParam=0x31;

		//显示选择的扬声器
		dsp_buffer[0]=iptparam->SetParam;	dsp_len=0;
		dsp(iptparam->DEVDsp, DSP_SET_SPEAKER, dsp_buffer, dsp_len);
		break;
		
	case KB_BUTTON_DOWN:
		//记录有效按键动作
		iptparam->SetButtonFlag=1;

		//选择扬声器
		if(0x10==iptparam->SetParam)			iptparam->SetParam=0x11;
		else if(0x11==iptparam->SetParam)	iptparam->SetParam=0x20;
		else if(0x20==iptparam->SetParam)	iptparam->SetParam=0x21;
		else if(0x21==iptparam->SetParam)	iptparam->SetParam=0x30;
		else if(0x30==iptparam->SetParam)	iptparam->SetParam=0x31;
		else if(0x31==iptparam->SetParam)	iptparam->SetParam=0x10;
		else														iptparam->SetParam=0x10;

		//显示选择的扬声器
		dsp_buffer[0]=iptparam->SetParam;	dsp_len=0;
		dsp(iptparam->DEVDsp, DSP_SET_SPEAKER, dsp_buffer, dsp_len);
		break;
		
	case KB_BUTTON_CHG:
	case KB_BUTTON_BACK:
		//退出，返回设置项选择界面
		dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
		iptPidSet(iptparam, IPT_PID_SET);
		break;
	
	case KB_BUTTON_ACK:
		//转入此界面后无有效按键则直接退出
		if(0==iptparam->SetButtonFlag)
		{
			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
			break;
		}

		//设置并判断设置结果，失败则提示结果并重新设置
		if(0==iptparam->Id)	offset=IPT0_VOICE_SPEAKER;
		else								offset=IPT1_VOICE_SPEAKER;
		wrbuffer[0]=(unsigned char)iptparam->SetParam;
		if(0==paramSetupWrite(offset, wrbuffer, 1)){
			
			//更新扬声器设置
			iptparam->Speaker=(char)iptparam->SetParam;

			//语音提示
			if(IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType && iptparam->VoiceVolume>0){

				voice[0]=SPKW_1;	voice[1]=SPKW_2;	voice[2]=SPKW_3;	voice[3]=SPKW_4;	voice[4]=SPKW_5;
				iptSpk(iptparam, voice, 5);
			}
			else if(iptparam->VoiceVolume>0){

				voice[0]=SPKM_1;	voice[1]=SPKM_2;	voice[2]=SPKM_3;	voice[3]=SPKM_4;	voice[4]=SPKM_5;
				iptSpk(iptparam, voice, 5);
			}
			
			//提示成功
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", 8);
			IPT_DSP_WAIT();

			//返回设置项选择界面
			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
		}
		else{
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", 8);
			IPT_DSP_WAIT();

			dsp_buffer[0]=iptparam->SetParam;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_SET_SPEAKER, dsp_buffer, dsp_len);
		}
		break;
		
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptSetVoiceVolume
*Description		:语音音量设置
*Input				:None
*Output			:None
*Return				:None
*History			:2014-03-11,modified by syj  */

static void iptSetVoiceVolume(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char wrbuffer[4]={0}, dsp_buffer[64]={0}, dsp_len=0, button=0;
	int voice[16]={0};
	off_t offset=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0==button)	button='0';
	case KB_BUTTON_1:
		if(0==button)	button='1';
	case KB_BUTTON_2:
		if(0==button)	button='2';
	case KB_BUTTON_3:
		if(0==button)	button='3';
	case KB_BUTTON_4:
		if(0==button)	button='4';
	case KB_BUTTON_5:
		if(0==button)	button='5';
	case KB_BUTTON_6:
		if(0==button)	button='6';
	case KB_BUTTON_7:
		if(0==button)	button='7';
	case KB_BUTTON_8:
		if(0==button)	button='8';
	case KB_BUTTON_9:
		if(0==button)	button='9';

		//记录按键动作
		iptparam->SetButtonFlag=1;

		//记录输入的音量按键并作显示
		iptparam->SetButton[0]=iptparam->SetButton[1];	iptparam->SetButton[1]=button;
		dsp_buffer[0]=(iptparam->SetButton[0]&0x0f)*10+(iptparam->SetButton[1]&0x0f)*1;
		dsp_len=1;
		dsp(iptparam->DEVDsp, DSP_SET_VOICE_VOLUME, dsp_buffer, dsp_len);
		break;
		
	case KB_BUTTON_CHG:
		//记录按键动作
		iptparam->SetButtonFlag=1;

		//清空设置值
		memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;	
		dsp_buffer[0]=(iptparam->SetButton[0]&0x0f)*10+(iptparam->SetButton[1]&0x0f)*1;
		dsp_len=1;
		dsp(iptparam->DEVDsp, DSP_SET_VOICE_VOLUME, dsp_buffer, dsp_len);
		break;

	case KB_BUTTON_BACK:
		//退出，返回设置项选择界面
		dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
		iptPidSet(iptparam, IPT_PID_SET);
		break;
		
	case KB_BUTTON_ACK:
		//转入此界面后无有效按键则直接退出
		if(0==iptparam->SetButtonFlag){
			
			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
			break;
		}

		//计算输入的音量
		wrbuffer[0]=(iptparam->SetButton[0]&0x0f)*10+(iptparam->SetButton[1]&0x0f)*1;

		//清除输入
		memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;

		//设置并判断设置结果，失败则提示后重新输入，成功则提示后返回上级界面
		if(0==iptparam->Id)	offset=IPT0_VOICE_VOLUME;
		else								offset=IPT1_VOICE_VOLUME;
		if(0==paramSetupWrite(offset, wrbuffer, 1)){
			
			//更新扬声器设置
			iptparam->VoiceVolume=wrbuffer[0];

			//语音提示
			if(IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType && iptparam->VoiceVolume>0){

				voice[0]=SPKW_1;	voice[1]=SPKW_2;	voice[2]=SPKW_3;	voice[3]=SPKW_4;	voice[4]=SPKW_5;
				iptSpk(iptparam, voice, 5);
			}
			else if(iptparam->VoiceVolume>0){

				voice[0]=SPKM_1;	voice[1]=SPKM_2;	voice[2]=SPKM_3;	voice[3]=SPKM_4;	voice[4]=SPKM_5;
				iptSpk(iptparam, voice, 5);
			}

			//提示成功
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", 8);
			IPT_DSP_WAIT();

			//返回设置项选择界面
			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
		}
		else{
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", 8);
			IPT_DSP_WAIT();

			dsp_buffer[0]=0;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_SET_VOICE_VOLUME, dsp_buffer, dsp_len);
		}
		break;
		
	default:
		break;
	}
	
	return;
}


/*******************************************************************
*Name				:iptSetVoiceType
*Description		:语音类型设置
*Input				:None
*Output			:None
*Return				:None
*History			:2014-03-11,modified by syj  */

static void iptSetVoiceType(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char wrbuffer[4]={0}, dsp_buffer[64]={0}, dsp_len=0, button=0;
	int voice[16]={0};
	off_t offset=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_UP:
	case KB_BUTTON_DOWN:
		//记录按键动作
		iptparam->SetButtonFlag=1;

		//切换语音类型设置
		if(0==iptparam->SetParam)	iptparam->SetParam=1;
		else											iptparam->SetParam=0;

		//显示设置的语音类型
		dsp_buffer[0]=iptparam->SetParam;	dsp_len=1;
		dsp(iptparam->DEVDsp, DSP_SET_VOICE_TYPE, dsp_buffer, dsp_len);
		break;
		
	case KB_BUTTON_CHG:
	case KB_BUTTON_BACK:
		//退出，返回设置项选择界面
		dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
		iptPidSet(iptparam, IPT_PID_SET);
		break;
		
	case KB_BUTTON_ACK:
		//转入此界面后无有效按键则直接退出
		if(0==iptparam->SetButtonFlag)
		{
			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
			break;
		}

		//保存设置，成功则提示成功后返回上级界面，失败则提示失败后重新设置
		if(0==iptparam->Id)	offset=IPT0_VOICE_TYPE;
		else								offset=IPT1_VOICE_TYPE;
		wrbuffer[0]=(unsigned char)iptparam->SetParam;
		if(0==paramSetupWrite(offset, wrbuffer, 1)){
			
			//更新扬声器设置
			iptparam->VoiceType=wrbuffer[0];

			//语音提示
			if(IPT_VOICE_TYPE_WOMAN==iptparam->VoiceType && iptparam->VoiceVolume>0){

				voice[0]=SPKW_1;	voice[1]=SPKW_2;	voice[2]=SPKW_3;	voice[3]=SPKW_4;	voice[4]=SPKW_5;
				iptSpk(iptparam, voice, 5);
			}
			else if(iptparam->VoiceVolume>0){

				voice[0]=SPKM_1;	voice[1]=SPKM_2;	voice[2]=SPKM_3;	voice[3]=SPKM_4;	voice[4]=SPKM_5;
				iptSpk(iptparam, voice, 5);
			}

			//提示成功
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", 8);
			IPT_DSP_WAIT();

			//返回设置项选择界面
			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
		}
		else{
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", 8);
			IPT_DSP_WAIT();

			dsp_buffer[0]=iptparam->SetParam;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_SET_VOICE_TYPE, dsp_buffer, dsp_len);
		}
		break;

	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptSetPrinter
*Description		:打印机设置
*Input				:None
*Output			:None
*Return				:None
*History			:2014-03-11,modified by syj  */

static void iptSetPrinter(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char wrbuffer[4]={0}, dsp_buffer[64]={0}, dsp_len=0;
	off_t offset=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_UP:
		//记录有效按键动作
		iptparam->SetButtonFlag=1;

		//选择打印机
		if(0x10==iptparam->SetParam)			iptparam->SetParam=0x31;
		else if(0x11==iptparam->SetParam)	iptparam->SetParam=0x10;
		else if(0x20==iptparam->SetParam)	iptparam->SetParam=0x11;
		else if(0x21==iptparam->SetParam)	iptparam->SetParam=0x20;
		else if(0x30==iptparam->SetParam)	iptparam->SetParam=0x21;
		else if(0x31==iptparam->SetParam)	iptparam->SetParam=0x30;
		else														iptparam->SetParam=0x31;

		//显示选择的打印机
		dsp_buffer[0]=iptparam->SetParam;	dsp_len=0;
		dsp(iptparam->DEVDsp, DSP_SET_PRINTER, dsp_buffer, dsp_len);
		break;
		
	case KB_BUTTON_DOWN:
		//记录有效按键动作
		iptparam->SetButtonFlag=1;

		//选择打印机
		if(0x10==iptparam->SetParam)			iptparam->SetParam=0x11;
		else if(0x11==iptparam->SetParam)	iptparam->SetParam=0x20;
		else if(0x20==iptparam->SetParam)	iptparam->SetParam=0x21;
		else if(0x21==iptparam->SetParam)	iptparam->SetParam=0x30;
		else if(0x30==iptparam->SetParam)	iptparam->SetParam=0x31;
		else if(0x31==iptparam->SetParam)	iptparam->SetParam=0x10;
		else														iptparam->SetParam=0x10;

		//显示选择的打印机
		dsp_buffer[0]=iptparam->SetParam;	dsp_len=0;
		dsp(iptparam->DEVDsp, DSP_SET_PRINTER, dsp_buffer, dsp_len);
		break;
		
	case KB_BUTTON_CHG:
	case KB_BUTTON_BACK:
		//退出，返回设置项选择界面
		dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
		iptPidSet(iptparam, IPT_PID_SET);
		break;
	
	case KB_BUTTON_ACK:
		//转入此界面后无有效按键则直接退出
		if(0==iptparam->SetButtonFlag)
		{
			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
			break;
		}

		//设置并判断设置结果，失败则提示结果并重新设置
		if(0==iptparam->Id)	offset=IPT0_PRINTER;
		else								offset=IPT1_PRINTER;
		wrbuffer[0]=(unsigned char)iptparam->SetParam;
		if(0==paramSetupWrite(offset, wrbuffer, 1))
		{
			//更新打印机设置
			iptparam->Printer=(char)iptparam->SetParam;

			//提示成功
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", 8);
			IPT_DSP_WAIT();

			//返回设置项选择界面
			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
		}
		else
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", 8);
			IPT_DSP_WAIT();

			dsp_buffer[0]=iptparam->SetParam;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_SET_PRINTER, dsp_buffer, dsp_len);
		}
		break;
		
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptSetPrintAuto
*Description		:是否自动打印设置
*Input				:None
*Output			:None
*Return				:None
*History			:2014-03-11,modified by syj  */

static void iptSetPrintAuto(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char wrbuffer[4]={0}, dsp_buffer[64]={0}, dsp_len=0;
	off_t offset=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_UP:
	case KB_BUTTON_DOWN:
		//记录有效按键动作
		iptparam->SetButtonFlag=1;

		//选择自动打印
		if(0==iptparam->SetParam)	iptparam->SetParam=1;
		else											iptparam->SetParam=0;

		//显示是否自动打印
		dsp_buffer[0]=iptparam->SetParam;	dsp_len=0;
		dsp(iptparam->DEVDsp, DSP_SET_PRINT_AUTO, dsp_buffer, dsp_len);
		break;
		
	case KB_BUTTON_CHG:
	case KB_BUTTON_BACK:
		//退出，返回设置项选择界面
		dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
		iptPidSet(iptparam, IPT_PID_SET);
		break;
	
	case KB_BUTTON_ACK:
		//转入此界面后无有效按键则直接退出
		if(0==iptparam->SetButtonFlag)
		{
			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
			break;
		}

		//设置并判断设置结果，失败则提示结果并重新设置
		if(0==iptparam->Id)	offset=IPT0_PRINT_AUTO;
		else								offset=IPT1_PRINT_AUTO;
		wrbuffer[0]=(unsigned char)iptparam->SetParam;
		if(0==paramSetupWrite(offset, wrbuffer, 1))
		{
			//更新自动打印设置
			iptparam->PrintAuto=(char)iptparam->SetParam;

			//提示成功
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", 8);
			IPT_DSP_WAIT();

			//返回设置项选择界面
			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
		}
		else
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", 8);
			IPT_DSP_WAIT();

			dsp_buffer[0]=iptparam->SetParam;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_SET_PRINT_AUTO, dsp_buffer, dsp_len);
		}
		break;
		
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptSetPrintUnion
*Description		:打印联数设置
*Input				:None
*Output			:None
*Return				:None
*History			:2014-03-11,modified by syj  */

static void iptSetPrintUnion(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char wrbuffer[4]={0}, dsp_buffer[64]={0}, dsp_len=0;
	off_t offset=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_UP:
	case KB_BUTTON_DOWN:
		//记录有效按键动作
		iptparam->SetButtonFlag=1;

		//选择打印联数
		if(0==iptparam->SetParam)	iptparam->SetParam=1;
		else											iptparam->SetParam=0;

		//显示是否自动打印
		dsp_buffer[0]=iptparam->SetParam;	dsp_len=0;
		dsp(iptparam->DEVDsp, DSP_SET_PRINT_UNION, dsp_buffer, dsp_len);
		break;
		
	case KB_BUTTON_CHG:
	case KB_BUTTON_BACK:
		//退出，返回设置项选择界面
		dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
		iptPidSet(iptparam, IPT_PID_SET);
		break;
	
	case KB_BUTTON_ACK:
		//转入此界面后无有效按键则直接退出
		if(0==iptparam->SetButtonFlag)
		{
			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
			break;
		}

		//设置并判断设置结果，失败则提示结果并重新设置
		if(0==iptparam->Id)	offset=IPT0_PRINT_UNION;
		else								offset=IPT1_PRINT_UNION;
		wrbuffer[0]=(unsigned char)iptparam->SetParam;
		if(0==paramSetupWrite(offset, wrbuffer, 1))
		{
			//更新自动打印设置
			iptparam->PrintUnion=(char)iptparam->SetParam;

			//提示成功
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", 8);
			IPT_DSP_WAIT();

			//返回设置项选择界面
			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
		}
		else
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", 8);
			IPT_DSP_WAIT();

			dsp_buffer[0]=iptparam->SetParam;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_SET_PRINT_UNION, dsp_buffer, dsp_len);
		}
		break;
		
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptSetPrintCardSelect
*Description		:打印卡类型信息设置
*Input				:None
*Output			:None
*Return				:None
*History			:2014-02-18,modified by syj  */

static void iptSetPrintCardSelect(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char dsp_buffer[64]={0}, dsp_len=0, button=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_1:
		if(0==button)	{iptparam->PrintCard=&(iptparam->PrintCardUser);		button='1';}	//用户卡
	case KB_BUTTON_2:
		if(0==button)	{iptparam->PrintCard=&(iptparam->PrintCardManage);	button='2';}	//管理卡
	case KB_BUTTON_3:
		if(0==button)	{iptparam->PrintCard=&(iptparam->PrintCardStaff);		button='3';}	//员工卡
	case KB_BUTTON_4:
		if(0==button)	{iptparam->PrintCard=&(iptparam->PrintCardPump);		button='4';}	//验泵卡
	case KB_BUTTON_5:
		if(0==button)	{iptparam->PrintCard=&(iptparam->PrintCardService);	button='5';}	//维修卡

		//转入自动打印账单类型
		iptparam->SetPage2=0;	iptparam->SetParam=*(iptparam->PrintCard);	iptparam->SetButtonFlag=0;
		dsp_buffer[0]=iptparam->SetPage2;
		dsp_buffer[1]=(char)(iptparam->SetParam>>8);	dsp_buffer[2]=(char)(iptparam->SetParam>>0);
		dsp_len=3;
		dsp(iptparam->DEVDsp, DSP_SET_PRINT_BILLTYPE, dsp_buffer, dsp_len);

		iptparam->SetButtonFlag=0;
		iptPidSet(iptparam, IPT_PID_SET_PRNAUTO_ZD);
		break;

	case KB_BUTTON_CHG:
	case KB_BUTTON_BACK:
		//返回设置项选择界面
		dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
		iptPidSet(iptparam, IPT_PID_SET);
		break;
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptSetPrintBillType
*Description		:自动打印账单类型设置
*Input				:None
*Output			:None
*Return				:None
*History			:2014-02-18,modified by syj  */

static void iptSetPrintBillType(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char wrbuffer[4]={0}, dsp_buffer[64]={0}, dsp_len=0;
	off_t offset=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_UP:
		//记录操作
		iptparam->SetButtonFlag=1;
		
		//上移一行选择操作的账单类型
		if(0==iptparam->SetPage2)	;
		else											iptparam->SetPage2--;

		dsp_buffer[0]=iptparam->SetPage2;
		dsp_buffer[1]=(char)(iptparam->SetParam>>8);	dsp_buffer[2]=(char)(iptparam->SetParam>>0);
		dsp_len=3;
		dsp(iptparam->DEVDsp, DSP_SET_PRINT_BILLTYPE, dsp_buffer, dsp_len);
		break;

	case KB_BUTTON_DOWN:
		//记录操作
		iptparam->SetButtonFlag=1;
		
		//下移一行选择操作的账单类型
		if(iptparam->SetPage2>=9)	;
		else											iptparam->SetPage2++;

		dsp_buffer[0]=iptparam->SetPage2;
		dsp_buffer[1]=(char)(iptparam->SetParam>>8);	dsp_buffer[2]=(char)(iptparam->SetParam>>0);
		dsp_len=3;
		dsp(iptparam->DEVDsp, DSP_SET_PRINT_BILLTYPE, dsp_buffer, dsp_len);
		break;

	case KB_BUTTON_CHG:
		//记录操作
		iptparam->SetButtonFlag=1;
		
		//取消已选定账单类型自动打印设置
		iptparam->SetParam&=(~(1<<iptparam->SetPage2));

		dsp_buffer[0]=iptparam->SetPage2;
		dsp_buffer[1]=(char)(iptparam->SetParam>>8);	dsp_buffer[2]=(char)(iptparam->SetParam>>0);
		dsp_len=3;
		dsp(iptparam->DEVDsp, DSP_SET_PRINT_BILLTYPE, dsp_buffer, dsp_len);
		break;

	case KB_BUTTON_SEL:
		//记录操作
		iptparam->SetButtonFlag=1;

		//已选定账单类型设置自动打印
		iptparam->SetParam|=(1<<iptparam->SetPage2);

		dsp_buffer[0]=iptparam->SetPage2;
		dsp_buffer[1]=(char)(iptparam->SetParam>>8);	dsp_buffer[2]=(char)(iptparam->SetParam>>0);
		dsp_len=3;
		dsp(iptparam->DEVDsp, DSP_SET_PRINT_BILLTYPE, dsp_buffer, dsp_len);
		break;

	case KB_BUTTON_BACK:
		//记录操作
		iptparam->SetButtonFlag=1;

		//返回设置自动打印卡类型选择界面
		dsp(iptparam->DEVDsp, DSP_SET_PRINT_CARD, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_SET_PRNAUTO_IC);
		break;

	case KB_BUTTON_ACK:
		//转入此界面后无有效按键则直接退出
		if(0==iptparam->SetButtonFlag){

			dsp(iptparam->DEVDsp, DSP_SET_PRINT_CARD, "\x00", 0);
			iptPidSet(iptparam, IPT_PID_SET_PRNAUTO_IC);
			break;
		}
		
		//已选定账单类型设置自动打印
		if(0==iptparam->Id && iptparam->PrintCard==&iptparam->PrintCardUser)				offset=IPT0_PRN_CARD_USER;
		else if(0==iptparam->Id && iptparam->PrintCard==&iptparam->PrintCardManage)	offset=IPT0_PRN_CARD_MANAGE;
		else if(0==iptparam->Id && iptparam->PrintCard==&iptparam->PrintCardStaff)		offset=IPT0_PRN_CARD_STAFF;
		else if(0==iptparam->Id && iptparam->PrintCard==&iptparam->PrintCardPump)	offset=IPT0_PRN_CARD_PUMP;
		else	if(0==iptparam->Id) 																							offset=IPT0_PRN_CARD_SERVICE;
		else if(0!=iptparam->Id && iptparam->PrintCard==&iptparam->PrintCardUser)		offset=IPT1_PRN_CARD_USER;
		else if(0!=iptparam->Id && iptparam->PrintCard==&iptparam->PrintCardManage)	offset=IPT1_PRN_CARD_MANAGE;
		else if(0!=iptparam->Id && iptparam->PrintCard==&iptparam->PrintCardStaff)		offset=IPT1_PRN_CARD_STAFF;
		else if(0!=iptparam->Id && iptparam->PrintCard==&iptparam->PrintCardPump)	offset=IPT1_PRN_CARD_PUMP;
		else	if(0!=iptparam->Id) 																							offset=IPT1_PRN_CARD_SERVICE;

		wrbuffer[0]=(char)(iptparam->SetParam>>8);	wrbuffer[1]=(char)(iptparam->SetParam>>0);
		if(0==paramSetupWrite(offset, wrbuffer, 2)){

			//更新自动打印设置
			*(iptparam->PrintCard)=iptparam->SetParam;

			//提示成功
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", 8);
			IPT_DSP_WAIT();

			//返回设置项选择界面
			dsp(iptparam->DEVDsp, DSP_SET_PRINT_CARD, "\x00", 0);
			iptPidSet(iptparam, IPT_PID_SET_PRNAUTO_IC);
		}
		else{
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", 8);
			IPT_DSP_WAIT();

			dsp_buffer[0]=iptparam->SetPage2;
			dsp_buffer[1]=(char)(iptparam->SetParam>>8);	dsp_buffer[2]=(char)(iptparam->SetParam>>0);
			dsp_len=3;
			dsp(iptparam->DEVDsp, DSP_SET_PRINT_BILLTYPE, dsp_buffer, dsp_len);
		}
		break;

	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptSetAdvance
*Description		:提前量设置
*Input				:None
*Output			:None
*Return				:None
*History			:2014-03-11,modified by syj  */

static void iptSetAdvance(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char button=0, dsp_buffer[64]={0}, dsp_len=0;
	unsigned int advance=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0==button)	button='0';
	case KB_BUTTON_1:
		if(0==button)	button='1';
	case KB_BUTTON_2:
		if(0==button)	button='2';
	case KB_BUTTON_3:
		if(0==button)	button='3';
	case KB_BUTTON_4:
		if(0==button)	button='4';
	case KB_BUTTON_5:
		if(0==button)	button='5';
	case KB_BUTTON_6:
		if(0==button)	button='6';
	case KB_BUTTON_7:
		if(0==button)	button='7';
	case KB_BUTTON_8:
		if(0==button)	button='8';
	case KB_BUTTON_9:
		if(0==button)	button='9';
	case KB_BUTTON_CZ:
		if(0==button)	button='.';

		//记录按键动作
		iptparam->SetButtonFlag=1;

		//按小数点记录小数点
		if('.'==button)
		{
			iptparam->Point='.';
		}
		//前一刻无小数点按键操作，记录按键值为整数
		else if(0==iptparam->Point)
		{
			iptparam->IntegerBuffer[3]=button;
		}
		//前一刻有小数点按键操作，记录按键值为小数
		else if((0!=iptparam->Point)&&(iptparam->DecimalLen<2))
		{
			iptparam->DecimalBuffer[iptparam->DecimalLen++]=button;
		}

		//计算提前量
		advance=(iptparam->IntegerBuffer[0]&0x0f)*100000+(iptparam->IntegerBuffer[1]&0x0f)*10000+\
			(iptparam->IntegerBuffer[2]&0x0f)*1000+(iptparam->IntegerBuffer[3]&0x0f)*100+\
			(iptparam->DecimalBuffer[0]&0x0f)*10+(iptparam->DecimalBuffer[1]&0x0f)*1;

		//显示提前量输入
		dsp_buffer[0]=(char)(advance>>8);	dsp_buffer[1]=(char)(advance>>0);	dsp_len=2;
		dsp(iptparam->DEVDsp, DSP_SET_ADVANCE, dsp_buffer, dsp_len);
		break;

	case KB_BUTTON_CHG:
		//记录按键动作
		iptparam->SetButtonFlag=1;

		//计算输入的提前量
		advance=(iptparam->IntegerBuffer[0]&0x0f)*100000+(iptparam->IntegerBuffer[1]&0x0f)*10000+\
			(iptparam->IntegerBuffer[2]&0x0f)*1000+(iptparam->IntegerBuffer[3]&0x0f)*100+\
			(iptparam->DecimalBuffer[0]&0x0f)*10+(iptparam->DecimalBuffer[1]&0x0f)*1;
		
		//计算设置值并根据设置值判断操作，
		//	设置值为0时返回设置选项选择界面,设置值非0时清空设置值
		
		if(0==advance)
		{
			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
		}
		else
		{
			dsp_buffer[0]=(char)(0>>8);	dsp_buffer[1]=(char)(0>>0);	dsp_len=2;
			dsp(iptparam->DEVDsp, DSP_SET_ADVANCE, dsp_buffer, dsp_len);
		}

		//清除输入
		memset(iptparam->IntegerBuffer, 0, 4);	iptparam->IntegerLen=0;
		iptparam->Point=0;
		memset(iptparam->DecimalBuffer, 0, 2);	iptparam->DecimalLen=0;
		break;

	case KB_BUTTON_BACK:
		//按退卡键退出本界面返回设置项选择界面
		memset(iptparam->IntegerBuffer, 0, 4);	iptparam->IntegerLen=0;
		iptparam->Point=0;
		memset(iptparam->DecimalBuffer, 0, 2);	iptparam->DecimalLen=0;

		dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
		iptPidSet(iptparam, IPT_PID_SET);
		break;

	case KB_BUTTON_ACK:
		//按确认键的操作
		//在设置界面无操作则直接退出
		if(0==iptparam->SetButtonFlag)
		{
			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, DSP_SET_SELECT);
			break;
		}
		
		//计算提前量
		advance=(iptparam->IntegerBuffer[0]&0x0f)*100000+(iptparam->IntegerBuffer[1]&0x0f)*10000+\
			(iptparam->IntegerBuffer[2]&0x0f)*1000+(iptparam->IntegerBuffer[3]&0x0f)*100+\
			(iptparam->DecimalBuffer[0]&0x0f)*10+(iptparam->DecimalBuffer[1]&0x0f)*1;

		//判断提前量范围
		if(advance<JL_ADVANCE_MIN || advance>JL_ADVANCE_MAX)
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置超出有效范围", 16);
			IPT_DSP_WAIT();

			dsp_buffer[0]=(char)(advance>>8);	dsp_buffer[1]=(char)(advance>>0);	dsp_len=2;
			dsp(iptparam->DEVDsp, DSP_SET_ADVANCE, dsp_buffer, dsp_len);
			break;
		}

		//设置提前量并根据结果提示信息
		if(0==jlAdvanceWrite(iptparam->JlNozzle, advance)) //fj:
		{
			memcpy(&dsp_buffer[0], "操作成功", 8);	dsp_len=8;
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);
			IPT_DSP_WAIT();

			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
		}
		else
		{
			memcpy(&dsp_buffer[0], "操作失败", 8);	dsp_len=8;
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);
			IPT_DSP_WAIT();

			dsp_buffer[0]=(char)(advance>>8);	dsp_buffer[1]=(char)(advance>>0);	dsp_len=2;
			dsp(iptparam->DEVDsp, DSP_SET_ADVANCE, dsp_buffer, dsp_len);
		}
		break;

	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptSetUnpulseTime
*Description		:无脉冲超时停机时间设置
*Input				:None
*Output			:None
*Return				:None
*History			:2014-03-11,modified by syj  */

static void iptSetUnpulseTime(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char dsp_buffer[16]={0}, dsp_len=0, button=0;
	unsigned int unpulse_time=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0==button)	button='0';
	case KB_BUTTON_1:
		if(0==button)	button='1';
	case KB_BUTTON_2:
		if(0==button)	button='2';
	case KB_BUTTON_3:
		if(0==button)	button='3';
	case KB_BUTTON_4:
		if(0==button)	button='4';
	case KB_BUTTON_5:
		if(0==button)	button='5';
	case KB_BUTTON_6:
		if(0==button)	button='6';
	case KB_BUTTON_7:
		if(0==button)	button='7';
	case KB_BUTTON_8:
		if(0==button)	button='8';
	case KB_BUTTON_9:
		if(0==button)	button='9';

		//记录有效按键动作
		iptparam->SetButtonFlag=1;		

		iptparam->SetButton[0]=iptparam->SetButton[1];	
		iptparam->SetButton[1]=iptparam->SetButton[2];
		iptparam->SetButton[2]=button;

		//计算无脉冲超时时间
		unpulse_time=(iptparam->SetButton[0]&0x0f)*100+(iptparam->SetButton[1]&0x0f)*10+(iptparam->SetButton[2]&0x0f)*1;

		dsp_buffer[0]=(char)(unpulse_time>>8);	dsp_buffer[1]=(char)(unpulse_time>>0);	dsp_len=2;
		dsp(iptparam->DEVDsp, DSP_SET_UNPULSE_TIME, dsp_buffer, dsp_len);
		break;

	case KB_BUTTON_CHG:
		//清除输入
		iptparam->SetButtonFlag=1;

		//计算无脉冲超时时间
		unpulse_time=(iptparam->SetButton[0]&0x0f)*100+(iptparam->SetButton[1]&0x0f)*10+(iptparam->SetButton[2]&0x0f)*1;

		//清除输入
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;

		//输入为0，退出本界面，否则清空输入
		if(0==unpulse_time)
		{
			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
		}
		else
		{
			dsp_buffer[0]=(char)(0>>8);	dsp_buffer[1]=(char)(0>>0);	dsp_len=2;
			dsp(iptparam->DEVDsp, DSP_SET_UNPULSE_TIME, dsp_buffer, dsp_len);
		}
		break;

	case KB_BUTTON_BACK:
		//返回设置项选择界面
		dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
		iptPidSet(iptparam, IPT_PID_SET);
		break;
		
	case KB_BUTTON_ACK:
		//无按键操作直接返回上级界面
		if(0==iptparam->SetButtonFlag)
		{
			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
			break;
		}

		//计算无脉冲超时时间
		unpulse_time=(iptparam->SetButton[0]&0x0f)*100+(iptparam->SetButton[1]&0x0f)*10+(iptparam->SetButton[2]&0x0f)*1;

		//判断是否超出允许范围
		if(unpulse_time<JL_UNPULSE_TIME_MIN|| unpulse_time>JL_UNPULSE_TIME_MAX)
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "有效范围30~180秒", 16);
			IPT_DSP_WAIT();

			dsp_buffer[0]=(char)(unpulse_time>>8);	dsp_buffer[1]=(char)(unpulse_time>>0);	dsp_len=2;
			dsp(iptparam->DEVDsp, DSP_SET_UNPULSE_TIME, dsp_buffer, dsp_len);
			break;
		}

		//设置提前量并根据结果提示信息,fj:
		if(0==jlUnPulseTimeWrite(iptparam->JlNozzle, unpulse_time))
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", 8);
			IPT_DSP_WAIT();

			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
		}
		else
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", 8);
			IPT_DSP_WAIT();

			dsp_buffer[0]=(char)(unpulse_time>>8);	dsp_buffer[1]=(char)(unpulse_time>>0);	dsp_len=2;
			dsp(iptparam->DEVDsp, DSP_SET_UNPULSE_TIME, dsp_buffer, dsp_len);
		}
		break;
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptSetStaffLimit
*Description		:员工卡加油限制设置
*Input				:None
*Output			:None
*Return				:None
*History			:2014-03-11,modified by syj  */

static void iptSetStaffLimit(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char wrbuffer[4]={0}, dsp_buffer[16]={0}, dsp_len=0;
	off_t offset=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_UP:
	case KB_BUTTON_DOWN:
		//记录按键动作
		iptparam->SetButtonFlag=1;
		
		//切换员工卡加油限制设置
		if(0==iptparam->SetParam)	iptparam->SetParam=1;
		else											iptparam->SetParam=0;

		dsp_buffer[0]=iptparam->SetParam;	dsp_len=1;
		dsp(iptparam->DEVDsp, DSP_SET_STAFF_LIMIT, dsp_buffer, dsp_len);
		break;

	case KB_BUTTON_CHG:
	case KB_BUTTON_BACK:
		//退出，返回设置项选择界面
		dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
		iptPidSet(iptparam, IPT_PID_SET);
		break;

	case KB_BUTTON_ACK:
		//转入此界面后无有效按键则直接退出
		if(0==iptparam->SetButtonFlag)
		{
			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
			break;
		}

		//设置并判断设置结果，失败则提示结果并重新设置
		if(0==iptparam->Id)	offset=IPT0_STAFF_LIMIT;
		else								offset=IPT1_STAFF_LIMIT;
		wrbuffer[0]=(unsigned char)iptparam->SetParam;
		if(0==paramSetupWrite(offset, wrbuffer, 1))
		{
			//更新员工卡加油限制设置
			iptparam->CardStaffLimit=(char)iptparam->SetParam;

			//提示成功
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", 8);
			IPT_DSP_WAIT();

			//返回设置项选择界面
			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
		}
		else
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", 8);
			IPT_DSP_WAIT();

			dsp_buffer[0]=iptparam->SetParam;	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_SET_STAFF_LIMIT, dsp_buffer, dsp_len);
		}
		break;

	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptSetMode
*Description		:加油模式设置
*Input				:None
*Output			:None
*Return				:None
*History			:2014-03-11,modified by syj  */

static void iptSetMode(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char wrbuffer[4]={0}, dsp_buffer[64]={0}, dsp_len=0;
	off_t offset=0;
	unsigned int money=0, volume=0, price=0, pos_ttc=0;
	unsigned long long volume_sum=0, money_sum=0;
	int istate=0, crc_return=0;
	unsigned char tmac_buffer[16]={0}, apdu_buffer[16]={0};

	switch(iptparam->Button)
	{
	case KB_BUTTON_UP:
	case KB_BUTTON_DOWN:
		//记录按键动作
		iptparam->SetButtonFlag=1;
		
		//切换员工卡加油限制设置
		if(KB_BUTTON_UP==iptparam->Button)
		{
			if(IPT_MODE_UNSELF==iptparam->SetParam)			iptparam->SetParam=IPT_MODE_IC;
			else if(IPT_MODE_BARCODE==iptparam->SetParam)	iptparam->SetParam=IPT_MODE_UNSELF;
			else																				iptparam->SetParam=IPT_MODE_BARCODE;
		}
		else
		{
			if(IPT_MODE_IC==iptparam->SetParam)					iptparam->SetParam=IPT_MODE_UNSELF;
			else if(IPT_MODE_UNSELF==iptparam->SetParam)	iptparam->SetParam=IPT_MODE_BARCODE;
			else																				iptparam->SetParam=IPT_MODE_IC;
		}
		dsp_buffer[0]=iptparam->SetParam;	dsp_len=1;
		dsp(iptparam->DEVDsp, DSP_SET_MODE, dsp_buffer, dsp_len);
		break;

	case KB_BUTTON_CHG:
	case KB_BUTTON_BACK:
		//退出，返回设置项选择界面
		dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
		iptPidSet(iptparam, IPT_PID_SET);
		break;
	
	case KB_BUTTON_ACK:
		//转入此界面后无有效按键则直接退出
		if(0==iptparam->SetButtonFlag)
		{
			memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
			break;
		}

		
		//如果是从"非卡机联动模式"设置为"卡机联动模式"或"卡机及条码模式"
		//	需要将非卡机联动累计的加油量存为账单；
		
		if(IPT_MODE_UNSELF==iptparam->Mode && IPT_MODE_UNSELF!=iptparam->SetParam){

			//检查PSAM卡是否存在
			if(IPT_MODE_UNSELF==iptparam->Mode && IPT_MODE_UNSELF!=iptparam->SetParam){

				//通过复位PSAM卡检查PSAM卡是否存在
				istate=PsamReset(iptparam->DEVIC, iptparam->DEVPsam);
				if(0!=istate){

					memcpy(&dsp_buffer[0], "    操作失败    ", 16);
					memcpy(&dsp_buffer[0], "请检查PSAM卡", 12);
					dsp_len=28;
					dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);
					IPT_DSP_WAIT();

					dsp_buffer[0]=iptparam->SetParam;	dsp_len=1;
					dsp(iptparam->DEVDsp, DSP_SET_MODE, dsp_buffer, dsp_len);
					break;
				}
			}

			//设置并判断设置结果，失败则提示结果并重新设置
			if(0==iptparam->Id)	offset=IPT0_WORKMODE;
			else								offset=IPT1_WORKMODE;
			wrbuffer[0]=(unsigned char)iptparam->SetParam;
			if(0==paramSetupWrite(offset, wrbuffer, 1)){
				
				//更新加油模式设置
				iptparam->Mode=(char)iptparam->SetParam;

				//提示成功
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", 8);
				IPT_DSP_WAIT();

				printf("ppppppppppppppppppppppppppp\n");

				//返回设置项选择界面
				dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
				iptPidSet(iptparam, IPT_PID_SET);
			}
			else{

				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", 8);
				IPT_DSP_WAIT();

				dsp_buffer[0]=iptparam->SetParam;	dsp_len=1;
				dsp(iptparam->DEVDsp, DSP_SET_MODE, dsp_buffer, dsp_len);
				break;
			}

			//产生非卡加油账单
			//待填充:POS_TTC
			memcpy(&iptparam->OilBill[IPT_OFFSET_TTC], "\x00\x00\x00\x00", 4);

			//待填充:交易类型设为无卡错，后台/本地黑白名单，扣款签名无效，逃卡
			iptparam->OilBill[IPT_OFFSET_T_TYPE]=(0<<7)|(0<<6)|(0<<4)|(7<<0);

			//已完成:交易日期及时间
			iptparam->OilTime[0]=iptparam->Time.century;	iptparam->OilTime[1]=iptparam->Time.year;
			iptparam->OilTime[2]=iptparam->Time.month;		iptparam->OilTime[3]=iptparam->Time.date;
			iptparam->OilTime[4]=iptparam->Time.hour;		iptparam->OilTime[5]=iptparam->Time.minute;
			iptparam->OilTime[6]=iptparam->Time.second;
			memcpy(&iptparam->OilBill[IPT_OFFSET_TIME], iptparam->OilTime, 7);

			//已完成:卡应用号
			memcpy(&iptparam->OilBill[IPT_OFFSET_ASN], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 10);

			//待填充:余额(扣前)，交易完成后填扣后余额
			memcpy(&iptparam->OilBill[IPT_OFFSET_BALANCE], "\x00\x00\x00\x00", 4);

			//待填充:数额，交易完成后填实际数额
			memcpy(&iptparam->OilBill[IPT_OFFSET_AMN], "\x00\x00\x00", 3);

			//已完成:卡交易序号
			memcpy(&iptparam->OilBill[IPT_OFFSET_CTC], "\x00\x00", 2);

			//待填充:电子签名，加油/补扣/补充时未TAC，逃卡时为GTAC
			memcpy(&iptparam->OilBill[IPT_OFFSET_TAC], "\x00\x00\x00\x00", 4);

			//待填充:解灰认证码4bytes，加油完成，PSAM计算GMAC后添加
			memcpy(&iptparam->OilBill[IPT_OFFSET_GMAC], "\x00\x00\x00\x00", 4);

			//待填充:PSAM会所签名4bytes，加油完成，PSAM计算GMAC后添加
			memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TAC], "\x00\x00\x00\x00", 4);

			//已完成:PSAM应用号10bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_ASN], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 10);

			//已完成:PSAM编号6bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_TID], "\x00\x00\x00\x00\x00\x00", 6);
			
			//已完成:PSAM终端交易序号4bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_PSAM_TTC], "\x00\x00\x00\x00", 4);

			//已完成:扣款来源1byte
			iptparam->OilBill[IPT_OFFSET_DS]=0;
			
			//已完成:结算单位/方式1byte
			iptparam->OilBill[IPT_OFFSET_UNIT]=0;
			
			//已完成:卡类1byte
			iptparam->OilBill[IPT_OFFSET_C_TYPE]=0;

			//已完成:卡版本1byte，b7~b4卡密钥索引号；b3~b0卡密钥版本号
			iptparam->OilBill[IPT_OFFSET_VER]=0;

			//已完成:枪号1byte
			iptparam->OilBill[IPT_OFFSET_NZN]=iptparam->LogicNozzle;
			
			//已完成:油品代码2bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_G_CODE], iptparam->OilCode, 2);

			//升数3bytes，交易完成后填实际升数
			dsp_buffer[0]=(char)(iptparam->VolumeUnselfSum>>16);	
			dsp_buffer[1]=(char)(iptparam->VolumeUnselfSum>>8);
			dsp_buffer[2]=(char)(iptparam->VolumeUnselfSum>>0);
			memcpy(&iptparam->OilBill[IPT_OFFSET_VOL], dsp_buffer, 3);

			//已完成:成交价格2bytes，根据累计金额及油量计算
			money=iptparam->MoneyUnselfSum;	volume=iptparam->VolumeUnselfSum;
			if(volume == 0) //fj:0929,发现过除0非法的情况
			{
				volume = 1;
			}

		
			if((money*1000/volume%10)<IPT_ROUNDING)	price=money*100/volume;
			else																		price=money*100/volume+1;
			iptparam->OilBill[IPT_OFFSET_PRC+0]=(char)(price>>8);
			iptparam->OilBill[IPT_OFFSET_PRC+1]=(char)(price>>0);

			//已完成:员工号1byte
			iptparam->OilBill[IPT_OFFSET_EMP]=iptparam->EMP;

			//已完成:升累计4bytes，交易完成后填实际总累
			printf("jlSumRead:\n");
			jlSumRead(iptparam->Id, &volume_sum, &money_sum);//fj:
			
			iptparam->OilBill[IPT_OFFSET_V_TOT+0]=(char)(volume_sum>>24);
			iptparam->OilBill[IPT_OFFSET_V_TOT+1]=(char)(volume_sum>>16);
			iptparam->OilBill[IPT_OFFSET_V_TOT+2]=(char)(volume_sum>>8);	
			iptparam->OilBill[IPT_OFFSET_V_TOT+3]=(char)(volume_sum>>0);

        	printf("money = %d,volume_sum = %d\n");

			//已完成:备用部分11bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_RFU], "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 11);

			//待填充:T-MAC	4bytes
			memcpy(&iptparam->OilBill[IPT_OFFSET_T_MAC], "\x00\x00\x00\x00", 4);
					
			//已完成:物理枪号PhysicsGunId
			iptparam->OilBill[IPT_OFFSET_PHYGUN]=iptparam->PhysicalNozzle;

			//已完成:计量停机原因
			iptparam->OilBill[IPT_OFFSET_STOPNO]=0;

			//已完成:扣前余额
			memcpy(&iptparam->OilBill[IPT_OFFSET_BEFOR_BAL], iptparam->IcBalance, 4);

			//账单状态:0=正常；1=未完成
			iptparam->OilBill[IPT_OFFSET_ZD_STATE]=1;

			//计量设备ID
			iptparam->OilBill[IPT_OFFSET_JLNOZZLE]=iptparam->JlNozzle;

			//计算账单校验值
			iptparam->OilBill[IPT_OFFSET_ZDXOR]=xorGet(iptparam->OilBill, IPT_BILL_SIZE-1);

			//保存账单及备份
			istate=framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD, iptparam->OilBill, IPT_BILL_SIZE);
			istate=framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZDBACKUP, iptparam->OilBill, IPT_BILL_SIZE);

			//提请保存账单
			iptparam->OilBillSave=1;
			//szb_fj_20171120:add
        	framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_BILL_FLAG,&iptparam->OilBillSave , 1);

			//清除非卡加油累计
			iptparam->MoneyUnself=0;	iptparam->VolumeUnself=0;	iptparam->OilStateUnself=0;
			iptparam->MoneyUnselfSum=0;	iptparam->VolumeUnselfSum=0;	iptparam->OilOverTimes=0;
			memset(dsp_buffer, 0, 32);
			crc_return=crc16Get(dsp_buffer, 30);
			dsp_buffer[30]=(char)(crc_return>>8);	dsp_buffer[31]=(char)(crc_return>>0);
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_UNSELF, dsp_buffer, 32);
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+IPT_FM_ZD_UNSELF2, dsp_buffer, 32);
		}
		else{

			//设置并判断设置结果，失败则提示结果并重新设置
			if(0==iptparam->Id)	offset=IPT0_WORKMODE;
			else								offset=IPT1_WORKMODE;
			wrbuffer[0]=(unsigned char)iptparam->SetParam;
			if(0==paramSetupWrite(offset, wrbuffer, 1)){
				
				//更新加油模式设置
				iptparam->Mode=(char)iptparam->SetParam;

				//提示成功
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", 8);
				IPT_DSP_WAIT();

	printf("kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk\n");

				//返回设置项选择界面
				dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
				iptPidSet(iptparam, IPT_PID_SET);
			}
			else{

				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", 8);
				IPT_DSP_WAIT();

				dsp_buffer[0]=iptparam->SetParam;	dsp_len=1;
				dsp(iptparam->DEVDsp, DSP_SET_MODE, dsp_buffer, dsp_len);
				break;
			}
		}

		break;

	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptSetOilVoiceSelect
*Description		:油品语音设置大项选择界面
*Input				:None
*Output			:None
*Return				:None
*History			:2015-10-20,modified by syj  */

static void iptSetOilVoiceSelect(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char searchbuffer[4+1]={0};
	unsigned char dsp_buffer[64]={0};
	int dsp_len=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_1:
	case KB_BUTTON_2:
		//1、汽油大类
		//2、柴油大类
		if(KB_BUTTON_1==iptparam->Button)	{iptparam->SetButton[0]=KB_BUTTON_1;	memcpy(searchbuffer, "汽油", 4);}
		else															{iptparam->SetButton[0]=KB_BUTTON_2;	memcpy(searchbuffer, "柴油", 4);}
		
		memset(iptparam->TempBuffer, 0, sizeof(iptparam->TempBuffer));
		
		if(0==spkFileNameGet(iptparam->OilVoice, dsp_buffer+1, 60))
		{
			dsp_buffer[0]=strlen(dsp_buffer+1);	dsp_len=1+strlen(dsp_buffer+1);
		}
		else
		{
			dsp_buffer[0]=strlen("无");	strcpy(dsp_buffer+1, "无");
			dsp_len=1+strlen(dsp_buffer+1);
		}
		dsp(iptparam->DEVDsp, DSP_SET_OILVOICE, dsp_buffer, dsp_len);
		iptPidSet(iptparam, IPT_PID_SET_OILVOICE);
		break;

	case KB_BUTTON_CHG:
	case KB_BUTTON_BACK:
		//返回设置项选择界面
		dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
		iptPidSet(iptparam, IPT_PID_SET);
		break;

	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptSetOilVoice
*Description		:油品语音设置选择界面
*Input				:None
*Output			:None
*Return				:None
*History			:2015-10-20,modified by syj  */

static void iptSetOilVoice(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char searchbuffer[4+1]={0};
	unsigned char dsp_buffer[64]={0};
	int dsp_len=0, flag=0, voicebuffer[2]={0};
	int istate = 0;
	unsigned int offset=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_UP:
	case KB_BUTTON_DOWN:
		//按上下键查询上一个或下一个语音
		//	根据临时存储的数据判断是查询汽油大类还是柴油大类；
		//	根据操作判断是查询前一个还是后一个语音文件名；
		//	查找对应的语音文件名；
		//	将本次查找到的语音文件名存储为下次查询时的基础语音文件名；
		
		if(KB_BUTTON_1==iptparam->SetButton[0])	
			memcpy(searchbuffer, "汽油", 4);
		else
			memcpy(searchbuffer, "柴油", 4);

		if(KB_BUTTON_UP==iptparam->Button)	
			flag=0;
		else
			flag=1;

		if(0==spkNextFileNameGet(searchbuffer, dsp_buffer+1, 60, iptparam->TempBuffer, flag, iptparam->VoiceType))
		{
			dsp_buffer[0]=strlen(dsp_buffer+1);	dsp_len=strlen(dsp_buffer+1)+1;
			dsp(iptparam->DEVDsp, DSP_SET_OILVOICE, dsp_buffer, dsp_len);

			memset(iptparam->TempBuffer, 0, sizeof(iptparam->TempBuffer));
			memcpy(iptparam->TempBuffer, dsp_buffer+1, strlen(dsp_buffer+1));
		}
		else
		{
			printf("spkNextFileNameGet failure\n");  //fj:
		}
		break;
	case KB_BUTTON_ACK:
		//保存配置
		if(IPT_NOZZLE_1==iptparam->Id)	offset=IPT0_OIL_VOICE;
		else													offset=IPT1_OIL_VOICE;
		if(0==paramSetupWrite(offset, iptparam->TempBuffer, 4))
		{
			voicebuffer[0]=((iptparam->TempBuffer[0]&0x0f)<<12)|((iptparam->TempBuffer[1]&0x0f)<<8)|\
				((iptparam->TempBuffer[2]&0x0f)<<4)|((iptparam->TempBuffer[3]&0x0f)<<0);
			
			//if(EOS!=*iptparam->TempBuffer)	//fj:
			//	iptSpk(iptparam, voicebuffer, 1);
			if('\0'!=*iptparam->TempBuffer)
			{
				iptSpk(iptparam,voicebuffer,1);
			}

			memcpy(iptparam->OilVoice, iptparam->TempBuffer, 4);
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", 8);
			IPT_DSP_WAIT();
		}
		else
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", 8);
			IPT_DSP_WAIT();
		}

		//返回油品语音大类选择界面
		dsp(iptparam->DEVDsp, DSP_SET_OILVOICE_SELECT, "\x00", 0);
		memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;	iptparam->SetButtonFlag=0;
		iptPidSet(iptparam, IPT_PID_SET_OILVOICE_SEL);
		break;
	case KB_BUTTON_CHG:
		//清空设置
		memset(iptparam->TempBuffer, 0, sizeof(iptparam->TempBuffer));
		dsp_buffer[0]=strlen("无");	strcpy(dsp_buffer + 1, "无");
		dsp_len=1+strlen(dsp_buffer+1);
		dsp(iptparam->DEVDsp, DSP_SET_OILVOICE, dsp_buffer, dsp_len);
		break;
	case KB_BUTTON_BACK:
		//返回油品语音大类选择界面
		dsp(iptparam->DEVDsp, DSP_SET_OILVOICE_SELECT, "\x00", 0);
		memset(iptparam->SetButton, 0, 16);		iptparam->SetButtonLen=0;	iptparam->SetButtonFlag=0;
		iptPidSet(iptparam, IPT_PID_SET_OILVOICE_SEL);
		break;
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptSetNozzleNumber
*Description		:设置单面枪数
*Input				:None
*Output			:None
*Return				:None
*History			:2015-11-03,modified by syj  */

static void iptSetNozzleNumber(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char dsp_buffer[64]={0};
	int dsp_len=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_UP:
	case KB_BUTTON_DOWN:
		//根据上下键切换选择双枪机或四枪机
		if(0==iptparam->SetParam)	iptparam->SetParam=1;
		else											iptparam->SetParam=0;

		dsp_buffer[0]=iptparam->SetParam;	dsp_len=1;
		dsp(iptparam->DEVDsp, DSP_SET_NOZZLE_NUMBER, dsp_buffer, dsp_len);
		break;

	case KB_BUTTON_ACK:
		//保存设置
		if(0!=paramPanelNozzleSet(iptparam->SetParam))
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", 8);
			IPT_DSP_WAIT();

			dsp_buffer[0]=paramPanelNozzleGet();	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_SET_NOZZLE_NUMBER, dsp_buffer, dsp_len);
			break;
		}

		//此配置需使两条枪同时生效，B枪在多枪模式下操作应操作的条码设备为1号条码模块
		paramPanelNozzleSet(iptparam->SetParam);
		if(0 == iptparam->SetParam)	IptParamB.DEVBarcode=BARCODE_NOZZLE_2;
		else											IptParamB.DEVBarcode=BARCODE_NOZZLE_1;
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", 8);
		IPT_DSP_WAIT();

		dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
		iptPidSet(iptparam, IPT_PID_SET);
		break;

	case KB_BUTTON_CHG:
	case KB_BUTTON_BACK:
		//放弃设置，返回设置项选择界面
		dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
		iptPidSet(iptparam, IPT_PID_SET);
		break;

	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptSetBarcodeBrand
*Description		:设置条码扫描模块品牌
*Input				:None
*Output			:None
*Return				:None
*History			:2015-11-03,modified by syj  */

static void iptSetBarcodeBrand(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char dsp_buffer[64]={0};
	int dsp_len=0, i_offset=0, istate = 0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_UP:
		//根据上下键切换选择条码扫描模块品牌
		if(YUANJD_BRAND==iptparam->SetParam)					iptparam->SetParam=0;
		else if(YUANJD_LV1000==iptparam->SetParam)		iptparam->SetParam=YUANJD_BRAND;
		else if(HONEYWELL_BRAND==iptparam->SetParam)	iptparam->SetParam=YUANJD_LV1000;
		else	if(HONEYWELL_IS4125==iptparam->SetParam)	iptparam->SetParam=HONEYWELL_BRAND;
		else																				iptparam->SetParam=HONEYWELL_IS4125;

		dsp_buffer[0]=iptparam->SetParam;	dsp_len=1;
		dsp(iptparam->DEVDsp, DSP_SET_BARBRAND, dsp_buffer, dsp_len);
		break;

	case KB_BUTTON_DOWN:
		//根据上下键切换选择条码扫描模块品牌
		if(YUANJD_BRAND==iptparam->SetParam)					iptparam->SetParam=YUANJD_LV1000;
		else if(YUANJD_LV1000==iptparam->SetParam)		iptparam->SetParam=HONEYWELL_BRAND;
		else if(HONEYWELL_BRAND==iptparam->SetParam)	iptparam->SetParam=HONEYWELL_IS4125;
		else	if(HONEYWELL_IS4125==iptparam->SetParam)	iptparam->SetParam=0;
		else																				iptparam->SetParam=YUANJD_BRAND;

		dsp_buffer[0]=iptparam->SetParam;	dsp_len=1;
		dsp(iptparam->DEVDsp, DSP_SET_BARBRAND, dsp_buffer, dsp_len);
		break;

	case KB_BUTTON_ACK:
		//保存设置
		istate = barBrandWrite(iptparam->DEVBarcode, iptparam->SetParam);
		if(0!= istate)
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", 8);
			IPT_DSP_WAIT();

			barBrandRead(iptparam->DEVBarcode, dsp_buffer);	dsp_len=1;
			dsp(iptparam->DEVDsp, DSP_SET_BARBRAND, dsp_buffer, dsp_len);
			break;
		}

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", 8);
		IPT_DSP_WAIT();
		dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
		iptPidSet(iptparam, IPT_PID_SET);
		break;

	case KB_BUTTON_CHG:
	case KB_BUTTON_BACK:
		//放弃设置，返回设置项选择界面
		dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
		iptPidSet(iptparam, IPT_PID_SET);
		break;

	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptSetTaxWait
*Description		:税控设置结果等待处理
*Input				:None
*Output			:None
*Return				:None
*History			:2014-02-18,modified by syj  */

static void iptSetTaxWait(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	if(KB_BUTTON_NO!=iptparam->Button || iptparam->NousedTimer>=30*ONE_SECOND)
	{
		//大屏显示当次明细
		jlNoteDsp(iptparam->JlNozzle); //fj:

		//显示并返回设置项选择界面
		dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_SET);
	}

	return;
}

/*******************************************************************
*Name				:iptSetConnectType
*Description		:后台连接方式查询
*Input				:None
*Output			:None
*Return				:None
*History			:2016-06-20,modified by syj  */

static void iptSetConnectType(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	switch(iptparam->Button)
	{
	case KB_BUTTON_CHG:
	case KB_BUTTON_BACK:
		//显示并返回设置项选择界面
		dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_SET);
		break;
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptSetLocalNetInfo
*Description		:本地网络信息设置项选择界面
*Input				:None
*Output			:None
*Return				:None
*History			:2016-01-20,modified by syj  */

static void iptSetLocalNetInfo(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	char dsp_buffer[128] = {0};
	unsigned int iMask = 0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_1:	//IP地址
		usrNetIpGet("eth0", dsp_buffer); //fj:
		dsp(iptparam->DEVDsp, DSP_LOCAL_IP, dsp_buffer, strlen(dsp_buffer));

		iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_SET_LOCAL_IP);
		break;
	case KB_BUTTON_2:	//子网掩码
		usrNetMaskGet("eth0", &iMask); //fj:
		//sprintf(dsp_buffer + strlen(dsp_buffer), "%d.", (iMask>>24)&0xff);
		//sprintf(dsp_buffer + strlen(dsp_buffer), "%d.", (iMask>>16)&0xff);
		//sprintf(dsp_buffer + strlen(dsp_buffer), "%d.", (iMask>>8)&0xff);
		//sprintf(dsp_buffer + strlen(dsp_buffer), "%d", (iMask>>0)&0xff);
		sprintf(dsp_buffer + strlen(dsp_buffer), "%d.", (iMask>>0)&0xff);
		sprintf(dsp_buffer + strlen(dsp_buffer), "%d.", (iMask>>8)&0xff);
		sprintf(dsp_buffer + strlen(dsp_buffer), "%d.", (iMask>>16)&0xff);
		sprintf(dsp_buffer + strlen(dsp_buffer), "%d", (iMask>>24)&0xff);

		dsp(iptparam->DEVDsp, DSP_LOCAL_MASK, dsp_buffer, strlen(dsp_buffer));

		iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_SET_LOCAL_MASK);
		break;
	case KB_BUTTON_3:	//默认网关
		usrNetHostGatewayGet("eth0", dsp_buffer); //fj:
		dsp(iptparam->DEVDsp, DSP_LOCAL_GATEWAY, dsp_buffer, strlen(dsp_buffer));

		iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_SET_LOCAL_GATE);
		break;
	case KB_BUTTON_CHG:
	case KB_BUTTON_BACK:
		//显示并返回设置项选择界面
		dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_SET);
		break;
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptSetLocalIP
*Description		:本地IP地址界面
*Input				:None
*Output			:None
*Return				:None
*History			:2016-01-20,modified by syj  */

static void iptSetLocalIP(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	char dsp_buffer[128] = {0};
	int dsp_len = 0;
	unsigned int button = 0;
	int istate = 0;
	int OptNet1,OptNet2;
	unsigned char IpAdd[10] = {0},i=0,ip[3] = {0};

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0 == button)	button = '0';
	case KB_BUTTON_1:
		if(0 == button)	button = '1';
	case KB_BUTTON_2:
		if(0 == button)	button = '2';
	case KB_BUTTON_3:
		if(0 == button)	button = '3';
	case KB_BUTTON_4:
		if(0 == button)	button = '4';
	case KB_BUTTON_5:
		if(0 == button)	button = '5';
	case KB_BUTTON_6:
		if(0 == button)	button = '6';
	case KB_BUTTON_7:
		if(0 == button)	button = '7';
	case KB_BUTTON_8:
		if(0 == button)	button = '8';
	case KB_BUTTON_9:
		if(0 == button)	button = '9';
	case KB_BUTTON_CZ:
		if(0 == button)	button = '.';
		//输入配置数据
		if(iptparam->SetButtonLen >= 15)
			break;

		*(iptparam->SetButton + iptparam->SetButtonLen) = button;	iptparam->SetButtonLen++;
		dsp(iptparam->DEVDsp, DSP_LOCAL_IP, iptparam->SetButton, iptparam->SetButtonLen);
		break;

	case KB_BUTTON_CHG:
		//清除输入的数据
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_LOCAL_IP, iptparam->SetButton, iptparam->SetButtonLen);
		break;
		
	case KB_BUTTON_BACK:
		//显示并返回查询项选择界面
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_LOCAL_NETINFO, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_SET_LOCAL_NET);
		break;

	case KB_BUTTON_ACK:
		//判断输入点分十进制地址是否合法
		if(ERROR == myNetDotAddrCheck(iptparam->SetButton))
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "您输入的地址非法", strlen("您输入的地址非法"));
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_LOCAL_IP, iptparam->SetButton, iptparam->SetButtonLen);
			break;
		}
		//保存配置并判断是否配置失败,fj:
		//if(OK != usrNetIpSet("eth0", iptparam->SetButton))
		//{
		//	dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置失败", strlen("设置失败"));
		//	IPT_DSP_WAIT();

		//	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		//	dsp(iptparam->DEVDsp, DSP_LOCAL_IP, iptparam->SetButton, iptparam->SetButtonLen);
		//	break;
		//}
		
		OptNet1=usrNetIpSet("eth0", iptparam->SetButton);

		if(OptNet1 == OK)
		{
			kjldLocalIpSet(iptparam->SetButton);
		}

		for(i=0;i<3;i++)
		{
			if(iptparam->SetButton[strlen(iptparam->SetButton)-(i+1)]!='.')
				ip[2-i]=(iptparam->SetButton[strlen(iptparam->SetButton)-(i+1)]-0x30);
			else
				break;
		}
		IpAdd[0]=0x00;IpAdd[1]=0x5e,IpAdd[2]=0x00;
		memcpy(IpAdd+3,ip,3);
		OptNet2=usrNetEMACSet("eth0", IpAdd);
		//保存配置并判断是否配置失败
		if((OK != OptNet2)  || (OK != OptNet1))
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置失败", strlen("设置失败"));
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_LOCAL_IP, iptparam->SetButton, iptparam->SetButtonLen);
			break;
		}


		//设置成功后，提示成功信息并返回本地ip地址设置项选择界面
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置成功", strlen("设置成功"));
		IPT_DSP_WAIT();
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_LOCAL_NETINFO, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_SET_LOCAL_NET);
		break;

	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptSetLocalMASK
*Description		:本地子网掩码界面
*Input				:None
*Output			:None
*Return				:None
*History			:2016-01-20,modified by syj  */

static void iptSetLocalMASK(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	//fj:
	char dsp_buffer[128] = {0};
	int dsp_len = 0,NetMask=0;
	struct in_addr AddrMask;
	unsigned char Mask[4]={0};
	unsigned int button = 0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0 == button)	button = '0';
	case KB_BUTTON_1:
		if(0 == button)	button = '1';
	case KB_BUTTON_2:
		if(0 == button)	button = '2';
	case KB_BUTTON_3:
		if(0 == button)	button = '3';
	case KB_BUTTON_4:
		if(0 == button)	button = '4';
	case KB_BUTTON_5:
		if(0 == button)	button = '5';
	case KB_BUTTON_6:
		if(0 == button)	button = '6';
	case KB_BUTTON_7:
		if(0 == button)	button = '7';
	case KB_BUTTON_8:
		if(0 == button)	button = '8';
	case KB_BUTTON_9:
		if(0 == button)	button = '9';
	case KB_BUTTON_CZ:
		if(0 == button)	button = '.';
		//输入配置数据
		if(iptparam->SetButtonLen >= 15)
			break;

		*(iptparam->SetButton + iptparam->SetButtonLen) = button;	iptparam->SetButtonLen++;
		dsp(iptparam->DEVDsp, DSP_LOCAL_MASK, iptparam->SetButton, iptparam->SetButtonLen);
		break;

	case KB_BUTTON_CHG:
		//清除输入的数据
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_LOCAL_MASK, iptparam->SetButton, iptparam->SetButtonLen);
		break;
		
	case KB_BUTTON_BACK:
		//显示并返回查询项选择界面
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_LOCAL_NETINFO, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_SET_LOCAL_NET);
		break;

	case KB_BUTTON_ACK:
		//判断输入点分十进制地址是否合法
		if(ERROR == myNetDotAddrCheck(iptparam->SetButton))
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "您输入的地址非法", strlen("您输入的地址非法"));
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_LOCAL_MASK, iptparam->SetButton, iptparam->SetButtonLen);
			break;
		}
		//保存配置并判断是否配置失败,fj:
		inet_aton((char *)iptparam->SetButton,&AddrMask);
		
		Mask[0]=AddrMask.s_addr;
		Mask[1]=(AddrMask.s_addr>>8);
		Mask[2]=(AddrMask.s_addr>>16);
		Mask[3]=(AddrMask.s_addr>>24);
		NetMask=(Mask[0]<<24)|(Mask[1]<<16)|(Mask[2]<<8)|(Mask[3]<<0);
		if(OK != usrNetMaskSet("eth0", NetMask))
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置失败", strlen("设置失败"));
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_LOCAL_MASK, iptparam->SetButton, iptparam->SetButtonLen);
			break;
		}

		kjldLocalMaskSet(NetMask);

		//设置成功后，提示成功信息并返回本地ip地址设置项选择界面
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置成功", strlen("设置成功"));
		IPT_DSP_WAIT();

		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_LOCAL_NETINFO, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_SET_LOCAL_NET);
		break;

	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptSetLocalGateway
*Description		:本地默认网关界面
*Input				:None
*Output			:None
*Return				:None
*History			:2016-01-20,modified by syj  */

static void iptSetLocalGateway(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	char dsp_buffer[128] = {0};
	int dsp_len = 0;
	unsigned int button = 0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0 == button)	button = '0';
	case KB_BUTTON_1:
		if(0 == button)	button = '1';
	case KB_BUTTON_2:
		if(0 == button)	button = '2';
	case KB_BUTTON_3:
		if(0 == button)	button = '3';
	case KB_BUTTON_4:
		if(0 == button)	button = '4';
	case KB_BUTTON_5:
		if(0 == button)	button = '5';
	case KB_BUTTON_6:
		if(0 == button)	button = '6';
	case KB_BUTTON_7:
		if(0 == button)	button = '7';
	case KB_BUTTON_8:
		if(0 == button)	button = '8';
	case KB_BUTTON_9:
		if(0 == button)	button = '9';
	case KB_BUTTON_CZ:
		if(0 == button)	button = '.';
		//输入配置数据
		if(iptparam->SetButtonLen >= 15)
			break;

		*(iptparam->SetButton + iptparam->SetButtonLen) = button;	iptparam->SetButtonLen++;
		dsp(iptparam->DEVDsp, DSP_LOCAL_GATEWAY, iptparam->SetButton, iptparam->SetButtonLen);
		break;

	case KB_BUTTON_CHG:
		//清除输入的数据
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_LOCAL_GATEWAY, iptparam->SetButton, iptparam->SetButtonLen);
		break;
		
	case KB_BUTTON_BACK:
		//显示并返回查询项选择界面
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_LOCAL_NETINFO, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_SET_LOCAL_NET);
		break;

	case KB_BUTTON_ACK:
		//判断输入点分十进制地址是否合法
		if(ERROR == myNetDotAddrCheck(iptparam->SetButton))
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "您输入的地址非法", strlen("您输入的地址非法"));
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_LOCAL_GATEWAY, iptparam->SetButton, iptparam->SetButtonLen);
			break;
		}

		//保存配置并判断是否配置失败,fj:
		if(OK != usrNetHostGatewaySet("eth0", iptparam->SetButton))
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置失败", strlen("设置失败"));
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_LOCAL_GATEWAY, iptparam->SetButton, iptparam->SetButtonLen);
			break;
		}

		kjldLocalGatewaySet(iptparam->SetButton);

		//设置成功后，提示成功信息并返回本地ip地址设置项选择界面
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置成功", strlen("设置成功"));
		IPT_DSP_WAIT();

		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_LOCAL_NETINFO, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_SET_LOCAL_NET);
		break;

	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptSetBackstageInfo
*Description		:石化后台配置设置信息项选择界面
*Input				:None
*Output			:None
*Return				:None
*History			:2016-01-20,modified by syj  */

static void iptSetBackstageInfo(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	char dsp_buffer[128] = {0};
	int dsp_len = 0, port = 0;
	char iip[32] = {0}, imask[32] = {0};
	unsigned int iMask = 0;
	int itype = 0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_1:
		//联网方式
		itype = kjldChannelGet();
		if(KJLD_CHANNEL_COM == itype)	dsp_buffer[0] = '0';
		if(KJLD_CHANNEL_NET == itype)	dsp_buffer[0] = '1';
		dsp_len = 1;
		dsp(iptparam->DEVDsp, DSP_CONNECT_TYPE_SET, dsp_buffer, dsp_len);

		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;	iptparam->NousedTimer = 0;
		iptPidSet(iptparam, IPT_PID_SET_BACK_CONNECT);
		break;

	case KB_BUTTON_2:	
		//后台IP地址
		kjldServerNetGet(iip, imask);
		dsp(iptparam->DEVDsp, DSP_BACKSTAGE_IP, iip, strlen(iip));

		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_SET_BACK_IP);
		break;
		
	case KB_BUTTON_3:	
		//后台端口号
		kjldServerNetGet(iip, imask);
		dsp(iptparam->DEVDsp, DSP_BACKSTAGE_PORT, imask, strlen(imask));
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_SET_BACK_PORT);
		break;

	case KB_BUTTON_4:
		//本地端口号
		port = kjldLocalPortGet();
		sprintf(dsp_buffer, "%d", port);
		dsp(iptparam->DEVDsp, DSP_BACKSTAGE_LOCAL_PORT, dsp_buffer, strlen(dsp_buffer));

		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_SET_BACK_LOCAL_PORT);
		break;
		
	case KB_BUTTON_CHG:
	case KB_BUTTON_BACK:
		//显示并返回设置项选择界面
		dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_SET);
		break;
		
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptSetBackstageConnect
*Description		:石化后台服务器联网方式设置
*Input				:None
*Output			:None
*Return			:None
*History			:2016-01-20,modified by syj  */

static void iptSetBackstageConnect(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	char dsp_buffer[128] = {0};
	int dsp_len = 0;
	int istate = 0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_1:
	case KB_BUTTON_2:
		if(KB_BUTTON_1 == iptparam->Button)	istate = kjldChannelSet(KJLD_CHANNEL_COM);
		else																istate = kjldChannelSet(KJLD_CHANNEL_NET);

		if(0 == istate)	dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", strlen("操作成功"));
		else					dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", strlen("操作失败"));
		IPT_DSP_WAIT();

		dsp(iptparam->DEVDsp, DSP_BACKSTAGE_INFO, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_SET_BACKSTAGE);
		break;
		
	case KB_BUTTON_CHG:
	case KB_BUTTON_BACK:
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_BACKSTAGE_INFO, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_SET_BACKSTAGE);
		break;
	default:
		break;
	}
	
	return;
}


/*******************************************************************
*Name				:iptSetBackstageIP
*Description		:石化后台服务器IP地址设置
*Input				:None
*Output			:None
*Return				:None
*History			:2016-01-20,modified by syj  */

static void iptSetBackstageIP(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	char dsp_buffer[128] = {0}, iip[32] = {0}, imask[32] = {0};
	int dsp_len = 0;
	unsigned int button = 0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0 == button)	button = '0';
	case KB_BUTTON_1:
		if(0 == button)	button = '1';
	case KB_BUTTON_2:
		if(0 == button)	button = '2';
	case KB_BUTTON_3:
		if(0 == button)	button = '3';
	case KB_BUTTON_4:
		if(0 == button)	button = '4';
	case KB_BUTTON_5:
		if(0 == button)	button = '5';
	case KB_BUTTON_6:
		if(0 == button)	button = '6';
	case KB_BUTTON_7:
		if(0 == button)	button = '7';
	case KB_BUTTON_8:
		if(0 == button)	button = '8';
	case KB_BUTTON_9:
		if(0 == button)	button = '9';
	case KB_BUTTON_CZ:
		if(0 == button)	button = '.';

		if(iptparam->SetButtonLen >= 15)
			break;

		*(iptparam->SetButton + iptparam->SetButtonLen) = button;	iptparam->SetButtonLen++;
		dsp(iptparam->DEVDsp, DSP_BACKSTAGE_IP, iptparam->SetButton, iptparam->SetButtonLen);
		break;

	case KB_BUTTON_CHG:
		//清除输入的数据
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_BACKSTAGE_IP, iptparam->SetButton, iptparam->SetButtonLen);
		break;

	case KB_BUTTON_BACK:
		//显示并返回石化后台配置设置信息项选择界面
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_BACKSTAGE_INFO, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_SET_BACKSTAGE);
		break;
		
	case KB_BUTTON_ACK:
		//检查输入的地址合法性
		if(ERROR == myNetDotAddrCheck(iptparam->SetButton))
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "您输入的地址非法", strlen("您输入的地址非法"));
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_BACKSTAGE_IP, iptparam->SetButton, iptparam->SetButtonLen);
			break;
		}
		
		//保存配置
		kjldServerNetGet(iip, imask);
		if(0 != kjldServerNetSet(iptparam->SetButton, imask))
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置失败", 8);
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_BACKSTAGE_IP, iptparam->SetButton, iptparam->SetButtonLen);
			break;
		}

		//设置成功，提示信息并返回石化后台配置设置信息项选择界面
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置成功", 8);
		IPT_DSP_WAIT();
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_BACKSTAGE_INFO, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_SET_BACKSTAGE);
		break;
	default:
		break;
	}
	
	return;
}


/*******************************************************************
*Name				:iptSetBackstagePort
*Description		:石化后台服务器端口号设置
*Input				:None
*Output			:None
*Return			:None
*History			:2016-01-20,modified by syj  */

static void iptSetBackstagePort(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	char dsp_buffer[128] = {0}, iip[32] = {0}, imask[32] = {0};
	int dsp_len = 0;
	unsigned int button = 0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0 == button)	button = '0';
	case KB_BUTTON_1:
		if(0 == button)	button = '1';
	case KB_BUTTON_2:
		if(0 == button)	button = '2';
	case KB_BUTTON_3:
		if(0 == button)	button = '3';
	case KB_BUTTON_4:
		if(0 == button)	button = '4';
	case KB_BUTTON_5:
		if(0 == button)	button = '5';
	case KB_BUTTON_6:
		if(0 == button)	button = '6';
	case KB_BUTTON_7:
		if(0 == button)	button = '7';
	case KB_BUTTON_8:
		if(0 == button)	button = '8';
	case KB_BUTTON_9:
		if(0 == button)	button = '9';
	case KB_BUTTON_CZ:

		if(iptparam->SetButtonLen >= 5)
			break;

		*(iptparam->SetButton + iptparam->SetButtonLen) = button;	iptparam->SetButtonLen++;
		dsp(iptparam->DEVDsp, DSP_BACKSTAGE_PORT, iptparam->SetButton, iptparam->SetButtonLen);
		break;

	case KB_BUTTON_CHG:
		//清除输入的数据
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_BACKSTAGE_PORT, iptparam->SetButton, iptparam->SetButtonLen);
		break;

	case KB_BUTTON_BACK:
		//显示并返回石化后台配置设置信息项选择界面
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_BACKSTAGE_INFO, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_SET_BACKSTAGE);
		break;
		
	case KB_BUTTON_ACK:
		//保存配置
		kjldServerNetGet(iip, imask);
		if(0 != kjldServerNetSet(iip, iptparam->SetButton))
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置失败", 8);
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_BACKSTAGE_PORT, iptparam->SetButton, iptparam->SetButtonLen);
			break;
		}

		//设置成功，提示信息并返回石化后台配置设置信息项选择界面
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置成功", 8);
		IPT_DSP_WAIT();
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_BACKSTAGE_INFO, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_SET_BACKSTAGE);
		break;
	default:
		break;
	}
	return;
}


/*******************************************************************
*Name				:iptSetBackstageLocalPort
*Description		:石化后台服务器本地服务器通讯端口号设置
*Input				:None
*Output			:None
*Return			:None
*History			:2016-01-20,modified by syj  */

static void iptSetBackstageLocalPort(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	char dsp_buffer[128] = {0}, iip[32] = {0}, imask[32] = {0};
	int dsp_len = 0;
	unsigned int button = 0, myport = 0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0 == button)	button = '0';
	case KB_BUTTON_1:
		if(0 == button)	button = '1';
	case KB_BUTTON_2:
		if(0 == button)	button = '2';
	case KB_BUTTON_3:
		if(0 == button)	button = '3';
	case KB_BUTTON_4:
		if(0 == button)	button = '4';
	case KB_BUTTON_5:
		if(0 == button)	button = '5';
	case KB_BUTTON_6:
		if(0 == button)	button = '6';
	case KB_BUTTON_7:
		if(0 == button)	button = '7';
	case KB_BUTTON_8:
		if(0 == button)	button = '8';
	case KB_BUTTON_9:
		if(0 == button)	button = '9';
	case KB_BUTTON_CZ:

		if(iptparam->SetButtonLen >= 5)
			break;

		*(iptparam->SetButton + iptparam->SetButtonLen) = button;	iptparam->SetButtonLen++;
		dsp(iptparam->DEVDsp, DSP_BACKSTAGE_LOCAL_PORT, iptparam->SetButton, iptparam->SetButtonLen);
		break;

	case KB_BUTTON_CHG:
		//清除输入的数据
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_BACKSTAGE_LOCAL_PORT, iptparam->SetButton, iptparam->SetButtonLen);
		break;

	case KB_BUTTON_BACK:
		//显示并返回石化后台配置设置信息项选择界面
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_BACKSTAGE_INFO, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_SET_BACKSTAGE);
		break;
		
	case KB_BUTTON_ACK:
		//保存配置
		myport = atoi(iptparam->SetButton);
		if(0 != kjldLocalPortSet(myport))
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置失败", 8);
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_BACKSTAGE_LOCAL_PORT, iptparam->SetButton, iptparam->SetButtonLen);
			break;
		}

		//设置成功，提示信息并返回石化后台配置设置信息项选择界面
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置成功", 8);
		IPT_DSP_WAIT();
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_BACKSTAGE_INFO, "\x00", 0);
		iptPidSet(iptparam, IPT_PID_SET_BACKSTAGE);
		break;
	default:
		break;
	}
	return;
}



/*******************************************************************
*Name				:iptSetTabletInfo
*Description		:平板电脑配置信息设置项选择界面
*Input				:None
*Output			:None
*Return				:None
*History			:2016-01-20,modified by syj  */

static void iptSetTabletInfo(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	char dsp_buffer[128] = {0};
	int dsp_len = 0;
	char serverip[32]= {0}, telephoneip[32] = {0};
	unsigned char volume = 0;
	unsigned int button = 0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0 == button)	button = '0';
	case KB_BUTTON_1:
		if(0 == button)	button = '1';
	case KB_BUTTON_2:
		if(0 == button)	button = '2';
	case KB_BUTTON_3:
		if(0 == button)	button = '3';
	case KB_BUTTON_4:
		if(0 == button)	button = '4';
	case KB_BUTTON_5:
		if(0 == button)	button = '5';
	case KB_BUTTON_6:
		if(0 == button)	button = '6';
	case KB_BUTTON_7:
		if(0 == button)	button = '7';
	case KB_BUTTON_8:
		if(0 == button)	button = '8';
	case KB_BUTTON_9:
		if(0 == button)	button = '9';
		
		iptparam->SetButton[0]=iptparam->SetButton[1];	iptparam->SetButton[1]=button;

		//平板电脑IP地址
		if(0==iptparam->SetPage2 && '1'==iptparam->SetButton[1])
		{
			if(0 != pcNetInfoGet(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TabletIP, iptparam->TabletMask, iptparam->TabletGateway))
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "查询失败", 8);
				IPT_DSP_WAIT();
		
				memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
				dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, &iptparam->SetPage2, 1);
				break;
			}

			dsp(iptparam->DEVDsp, DSP_TABLETPC_IP, iptparam->TabletIP, strlen(iptparam->TabletIP));

			iptparam->SetButtonFlag = 0;
			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_SET_PC_IP);
		}
		//平板子网掩码
		else if(0==iptparam->SetPage2 && '2'==iptparam->SetButton[1])
		{
			if(0 != pcNetInfoGet(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TabletIP, iptparam->TabletMask, iptparam->TabletGateway))
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "查询失败", 8);
				IPT_DSP_WAIT();
		
				memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
				dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, &iptparam->SetPage2, 1);
				break;
			}

			dsp(iptparam->DEVDsp, DSP_TABLETPC_MASK, iptparam->TabletMask, strlen(iptparam->TabletMask));

			iptparam->SetButtonFlag = 0;
			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_SET_PC_MASK);
		}
		//平板默认网关
		else if(0==iptparam->SetPage2 && '3'==iptparam->SetButton[1])
		{
			if(0 != pcNetInfoGet(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TabletIP, iptparam->TabletMask, iptparam->TabletGateway))
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "查询失败", 8);
				IPT_DSP_WAIT();
		
				memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
				dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, &iptparam->SetPage2, 1);
				break;
			}

			dsp(iptparam->DEVDsp, DSP_TABLETPC_GATEWAY, iptparam->TabletGateway, strlen(iptparam->TabletGateway));

			iptparam->SetButtonFlag = 0;
			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_SET_PC_GATEWAY);
		}
		//平板电脑首选DNS
		else if(1==iptparam->SetPage2 && '4'==iptparam->SetButton[1])
		{
			if(0 != pcDNSInfoGet(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TabletFirstDNS, iptparam->TabletSecondDNS))
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "查询失败", 8);
				IPT_DSP_WAIT();
		
				memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
				dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, &iptparam->SetPage2, 1);
				break;
			}

			dsp(iptparam->DEVDsp, DSP_TABLETPC_FIRSTDNS, iptparam->TabletFirstDNS, strlen(iptparam->TabletFirstDNS));

			iptparam->SetButtonFlag = 0;
			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_SET_PC_DNS1);
		}
		//平板电脑备用DNS
		else if(1==iptparam->SetPage2 && '5'==iptparam->SetButton[1])
		{
			if(0 != pcDNSInfoGet(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TabletFirstDNS, iptparam->TabletSecondDNS))
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "查询失败", 8);
				IPT_DSP_WAIT();
		
				memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
				dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, &iptparam->SetPage2, 1);
				break;
			}

			dsp(iptparam->DEVDsp, DSP_TABLETPC_SECONDDNS, iptparam->TabletSecondDNS, strlen(iptparam->TabletSecondDNS));

			iptparam->SetButtonFlag = 0;
			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_SET_PC_DNS2);
		}
		//平板电脑FTP服务器地址
		else if(1==iptparam->SetPage2 && '6'==iptparam->SetButton[1])
		{
			if(0 != pcFtpServerInfoGet(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TabletFtpIP, iptparam->TabletFtpPort))
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "查询失败", 8);
				IPT_DSP_WAIT();
		
				memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
				dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, &iptparam->SetPage2, 1);
				break;
			}

			dsp(iptparam->DEVDsp, DSP_TABLETPC_FTP_IP, iptparam->TabletFtpIP, strlen(iptparam->TabletFtpIP));

			iptparam->SetButtonFlag = 0;
			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_SET_PC_FTP_IP);
		}
		//平板电脑FTP服务器端口号
		else if(2==iptparam->SetPage2 && '7'==iptparam->SetButton[1])
		{
			if(0 != pcFtpServerInfoGet(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TabletFtpIP, iptparam->TabletFtpPort))
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "查询失败", 8);
				IPT_DSP_WAIT();
		
				memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
				dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, &iptparam->SetPage2, 1);
				break;
			}

			dsp(iptparam->DEVDsp, DSP_TABLETPC_FTP_PORT, iptparam->TabletFtpPort, strlen(iptparam->TabletFtpPort));

			iptparam->SetButtonFlag = 0;
			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_SET_PC_FTP_PORT);
		}
		//平板电脑后台服务器地址
		else if(2==iptparam->SetPage2 && '8'==iptparam->SetButton[1])
		{
			if(0 != pcServerInfoGet(iptparam->TabletPanel, iptparam->LogicNozzle, serverip))
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "查询失败", 8);
				IPT_DSP_WAIT();
		
				memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
				dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, &iptparam->SetPage2, 1);
				break;
			}

			dsp(iptparam->DEVDsp, DSP_TABLETPC_SERVERIP, serverip, strlen(serverip));

			iptparam->SetButtonFlag = 0;
			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_SET_PC_SERVER);
		}
		//平板电脑音量
		else if(2==iptparam->SetPage2 && '9'==iptparam->SetButton[1])
		{
			if(0 != pcVolumeGet(iptparam->TabletPanel, iptparam->LogicNozzle, &volume))
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "查询失败", 8);
				IPT_DSP_WAIT();
		
				memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
				dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, &iptparam->SetPage2, 1);
				break;
			}

			dsp(iptparam->DEVDsp, DSP_TABLETPC_VOLUME, &volume, 1);

			iptparam->SetButtonFlag = 0;
			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_SET_PC_VOLUME);
		}
		//平板电脑对讲后台IP
		else if(3==iptparam->SetPage2 && '1'==iptparam->SetButton[0] && '0'==iptparam->SetButton[1])
		{
			if(0 != pcTelephoneIPGet(iptparam->TabletPanel, iptparam->LogicNozzle, telephoneip))
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "查询失败", 8);
				IPT_DSP_WAIT();
		
				memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
				dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, &iptparam->SetPage2, 1);
				break;
			}

			dsp(iptparam->DEVDsp, DSP_TABLETPC_TELE_IP, telephoneip, strlen(telephoneip));

			iptparam->SetButtonFlag = 0;
			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_SET_PC_TELE_IP);
		}
		//是否启用促销功能
		else if(3==iptparam->SetPage2 && '1'==iptparam->SetButton[0] && '1'==iptparam->SetButton[1])
		{
			iptparam->SetParam = paramPromotionGet();
		
			 *(dsp_buffer + 0) = iptparam->SetParam;
			 *(dsp_buffer + 1) = 1;
			dsp_len = 2;
			dsp(iptparam->DEVDsp, DSP_PROMOTION, dsp_buffer, dsp_len);

			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_SET_PROMOTION);
		}
		//是否启用油品确认功能
		else if(3==iptparam->SetPage2 && '1'==iptparam->SetButton[0] && '2'==iptparam->SetButton[1])
		{
		
			 *(dsp_buffer + 0) = iptparam->TabletGradeTag;
			 *(dsp_buffer + 1) = 1;
			dsp_len = 2;
			dsp(iptparam->DEVDsp, DSP_YuLe_Grade_Fun, dsp_buffer, dsp_len);

			iptparam->NousedTimer=0;	memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_SET_GRADE_FUN);
		}
		break;

	case KB_BUTTON_UP:
	case KB_BUTTON_DOWN:
		if(KB_BUTTON_UP==iptparam->Button  && 0==iptparam->SetPage2)
		{
			iptparam->SetPage2 = 3;
		}
		else if(KB_BUTTON_UP==iptparam->Button  && 0!=iptparam->SetPage2)
		{
			iptparam->SetPage2--;
		}
		else if(KB_BUTTON_DOWN==iptparam->Button  && iptparam->SetPage2<3)
		{
			iptparam->SetPage2++;
		}
		else if(KB_BUTTON_DOWN==iptparam->Button  && iptparam->SetPage2>=3)
		{
			iptparam->SetPage2 = 0;
		}

		*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);
		break;
	case KB_BUTTON_CHG:
	case KB_BUTTON_BACK:
		//显示并返回查询项选择界面
		dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_SET);
		break;
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptSetTabletIp
*Description		:平板电脑IP地址界面
*Input				:None
*Output			:None
*Return				:None
*History			:2016-01-20,modified by syj  */

static void iptSetTabletIp(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	char dsp_buffer[128] = {0};
	int dsp_len = 0;
	int istate = 0;
	unsigned int button = 0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0 == button)	button = '0';
	case KB_BUTTON_1:
		if(0 == button)	button = '1';
	case KB_BUTTON_2:
		if(0 == button)	button = '2';
	case KB_BUTTON_3:
		if(0 == button)	button = '3';
	case KB_BUTTON_4:
		if(0 == button)	button = '4';
	case KB_BUTTON_5:
		if(0 == button)	button = '5';
	case KB_BUTTON_6:
		if(0 == button)	button = '6';
	case KB_BUTTON_7:
		if(0 == button)	button = '7';
	case KB_BUTTON_8:
		if(0 == button)	button = '8';
	case KB_BUTTON_9:
		if(0 == button)	button = '9';
	case KB_BUTTON_CZ:
		if(0 == button)	button = '.';

		if(iptparam->SetButtonLen >= 15)
			break;

		iptparam->SetButtonFlag = 1;

		*(iptparam->SetButton + iptparam->SetButtonLen) = button;	iptparam->SetButtonLen++;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_IP, iptparam->SetButton, iptparam->SetButtonLen);
		break;

	case KB_BUTTON_CHG:
		//清除输入的数据
		iptparam->SetButtonFlag = 1;
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_IP, iptparam->SetButton, iptparam->SetButtonLen);
		break;

	case KB_BUTTON_BACK:
		//显示并返回查询项选择界面
		*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_SET_PC_INFO);
		break;
	case KB_BUTTON_ACK:
		//判断转入此界面后是否有操作，无操作直接退出
		if(0 == iptparam->SetButtonFlag)
		{
			*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
			dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);
		
			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_SET_PC_INFO);
			break;
		}
		
		//判断输入点分十进制地址是否合法
		if(ERROR == myNetDotAddrCheck(iptparam->SetButton))
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "您输入的地址非法", strlen("您输入的地址非法"));
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_TABLETPC_IP, iptparam->SetButton, iptparam->SetButtonLen);
			break;
		}
		
		//保存配置
		istate = pcNetInfoSet(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->SetButton, iptparam->TabletMask, iptparam->TabletGateway);
		if(0 != istate)
		{
			if(1 == istate)	dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置超时", 8);
			else					dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置失败", 8);
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_TABLETPC_IP, iptparam->SetButton, iptparam->SetButtonLen);
			break;
		}

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置成功", 8);
		IPT_DSP_WAIT();
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);
		iptPidSet(iptparam, IPT_PID_SET_PC_INFO);
		break;
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptSetTabletMask
*Description		:平板电脑子网掩码界面
*Input				:None
*Output			:None
*Return				:None
*History			:2016-01-20,modified by syj  */

static void iptSetTabletMask(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	char dsp_buffer[128] = {0};
	int dsp_len = 0;
	int istate = 0;
	unsigned int button = 0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0 == button)	button = '0';
	case KB_BUTTON_1:
		if(0 == button)	button = '1';
	case KB_BUTTON_2:
		if(0 == button)	button = '2';
	case KB_BUTTON_3:
		if(0 == button)	button = '3';
	case KB_BUTTON_4:
		if(0 == button)	button = '4';
	case KB_BUTTON_5:
		if(0 == button)	button = '5';
	case KB_BUTTON_6:
		if(0 == button)	button = '6';
	case KB_BUTTON_7:
		if(0 == button)	button = '7';
	case KB_BUTTON_8:
		if(0 == button)	button = '8';
	case KB_BUTTON_9:
		if(0 == button)	button = '9';
	case KB_BUTTON_CZ:
		if(0 == button)	button = '.';

		if(iptparam->SetButtonLen >= 15)
			break;

		iptparam->SetButtonFlag = 1;
		*(iptparam->SetButton + iptparam->SetButtonLen) = button;	iptparam->SetButtonLen++;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_MASK, iptparam->SetButton, iptparam->SetButtonLen);
		break;

	case KB_BUTTON_CHG:
		//清除输入的数据
		iptparam->SetButtonFlag = 1;
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_MASK, iptparam->SetButton, iptparam->SetButtonLen);
		break;

	case KB_BUTTON_BACK:
		//显示并返回查询项选择界面
		*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_SET_PC_INFO);
		break;
	case KB_BUTTON_ACK:
		//判断转入此界面后是否有操作，无操作直接退出
		if(0 == iptparam->SetButtonFlag)
		{
			*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
			dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);
		
			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_SET_PC_INFO);
			break;
		}
		
		//判断输入点分十进制地址是否合法
		if(ERROR == myNetDotAddrCheck(iptparam->SetButton))
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "您输入的地址非法", strlen("您输入的地址非法"));
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_TABLETPC_MASK, iptparam->SetButton, iptparam->SetButtonLen);
			break;
		}
		
		//保存配置
		istate = pcNetInfoSet(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TabletIP, iptparam->SetButton, iptparam->TabletGateway);
		if(0 != istate)
		{
			if(1 == istate)	dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置超时", 8);
			else					dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置失败", 8);
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_TABLETPC_MASK, iptparam->SetButton, iptparam->SetButtonLen);
			break;
		}

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置成功", 8);
		IPT_DSP_WAIT();
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);
		iptPidSet(iptparam, IPT_PID_SET_PC_INFO);
		break;
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptSetTabletGateway
*Description		:平板电脑默认网关界面
*Input				:None
*Output			:None
*Return				:None
*History			:2016-01-20,modified by syj  */

static void iptSetTabletGateway(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	char dsp_buffer[128] = {0};
	int dsp_len = 0;
	int istate = 0;
	unsigned int button = 0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0 == button)	button = '0';
	case KB_BUTTON_1:
		if(0 == button)	button = '1';
	case KB_BUTTON_2:
		if(0 == button)	button = '2';
	case KB_BUTTON_3:
		if(0 == button)	button = '3';
	case KB_BUTTON_4:
		if(0 == button)	button = '4';
	case KB_BUTTON_5:
		if(0 == button)	button = '5';
	case KB_BUTTON_6:
		if(0 == button)	button = '6';
	case KB_BUTTON_7:
		if(0 == button)	button = '7';
	case KB_BUTTON_8:
		if(0 == button)	button = '8';
	case KB_BUTTON_9:
		if(0 == button)	button = '9';
	case KB_BUTTON_CZ:
		if(0 == button)	button = '.';

		if(iptparam->SetButtonLen >= 15)
			break;

		iptparam->SetButtonFlag = 1;
		*(iptparam->SetButton + iptparam->SetButtonLen) = button;	iptparam->SetButtonLen++;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_GATEWAY, iptparam->SetButton, iptparam->SetButtonLen);
		break;

	case KB_BUTTON_CHG:
		//清除输入的数据
		iptparam->SetButtonFlag = 1;
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_GATEWAY, iptparam->SetButton, iptparam->SetButtonLen);
		break;

	case KB_BUTTON_BACK:
		//显示并返回查询项选择界面
		*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_SET_PC_INFO);
		break;
	case KB_BUTTON_ACK:
		//判断转入此界面后是否有操作，无操作直接退出
		if(0 == iptparam->SetButtonFlag)
		{
			*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
			dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);
		
			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_SET_PC_INFO);
			break;
		}
		
		//判断输入点分十进制地址是否合法
		if(ERROR == myNetDotAddrCheck(iptparam->SetButton))
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "您输入的地址非法", strlen("您输入的地址非法"));
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_TABLETPC_GATEWAY, iptparam->SetButton, iptparam->SetButtonLen);
			break;
		}
		
		//保存配置
		istate = pcNetInfoSet(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TabletIP, iptparam->TabletMask, iptparam->SetButton);
		if(0 != istate)
		{
			if(1 == istate)	dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置超时", 8);
			else					dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置失败", 8);
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_TABLETPC_GATEWAY, iptparam->SetButton, iptparam->SetButtonLen);
			break;
		}

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置成功", 8);
		IPT_DSP_WAIT();
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);
		iptPidSet(iptparam, IPT_PID_SET_PC_INFO);
		break;
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptSetTabletDNS1
*Description		:平板电脑首选DNS界面
*Input				:None
*Output			:None
*Return				:None
*History			:2016-01-20,modified by syj  */

static void iptSetTabletDNS1(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	char dsp_buffer[128] = {0};
	int dsp_len = 0;
	int istate = 0;
	unsigned int button = 0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0 == button)	button = '0';
	case KB_BUTTON_1:
		if(0 == button)	button = '1';
	case KB_BUTTON_2:
		if(0 == button)	button = '2';
	case KB_BUTTON_3:
		if(0 == button)	button = '3';
	case KB_BUTTON_4:
		if(0 == button)	button = '4';
	case KB_BUTTON_5:
		if(0 == button)	button = '5';
	case KB_BUTTON_6:
		if(0 == button)	button = '6';
	case KB_BUTTON_7:
		if(0 == button)	button = '7';
	case KB_BUTTON_8:
		if(0 == button)	button = '8';
	case KB_BUTTON_9:
		if(0 == button)	button = '9';
	case KB_BUTTON_CZ:
		if(0 == button)	button = '.';

		if(iptparam->SetButtonLen >= 15)
			break;

		iptparam->SetButtonFlag = 1;
		*(iptparam->SetButton + iptparam->SetButtonLen) = button;	iptparam->SetButtonLen++;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_FIRSTDNS, iptparam->SetButton, iptparam->SetButtonLen);
		break;

	case KB_BUTTON_CHG:
		//清除输入的数据
		iptparam->SetButtonFlag = 1;
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_FIRSTDNS, iptparam->SetButton, iptparam->SetButtonLen);
		break;

	case KB_BUTTON_BACK:
		//显示并返回查询项选择界面
		*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_SET_PC_INFO);
		break;
	case KB_BUTTON_ACK:
		//判断转入此界面后是否有操作，无操作直接退出
		if(0 == iptparam->SetButtonFlag)
		{
			*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
			dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);
		
			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_SET_PC_INFO);
			break;
		}
		
		//判断输入点分十进制地址是否合法
		if(ERROR == myNetDotAddrCheck(iptparam->SetButton))
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "您输入的地址非法", strlen("您输入的地址非法"));
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_TABLETPC_FIRSTDNS, iptparam->SetButton, iptparam->SetButtonLen);
			break;
		}
		
		//保存配置
		istate = pcDNSInfoSet(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->SetButton, iptparam->TabletSecondDNS);
		if(0 != istate)
		{
			if(1 == istate)	dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置超时", 8);
			else					dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置失败", 8);
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_TABLETPC_FIRSTDNS, iptparam->SetButton, iptparam->SetButtonLen);
			break;
		}

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置成功", 8);
		IPT_DSP_WAIT();
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);
		iptPidSet(iptparam, IPT_PID_SET_PC_INFO);
		break;
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptSetTabletDNS2
*Description		:平板电脑备用DNS界面
*Input				:None
*Output			:None
*Return				:None
*History			:2016-01-20,modified by syj  */

static void iptSetTabletDNS2(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	char dsp_buffer[128] = {0};
	int dsp_len = 0;
	int istate = 0;
	unsigned int button = 0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0 == button)	button = '0';
	case KB_BUTTON_1:
		if(0 == button)	button = '1';
	case KB_BUTTON_2:
		if(0 == button)	button = '2';
	case KB_BUTTON_3:
		if(0 == button)	button = '3';
	case KB_BUTTON_4:
		if(0 == button)	button = '4';
	case KB_BUTTON_5:
		if(0 == button)	button = '5';
	case KB_BUTTON_6:
		if(0 == button)	button = '6';
	case KB_BUTTON_7:
		if(0 == button)	button = '7';
	case KB_BUTTON_8:
		if(0 == button)	button = '8';
	case KB_BUTTON_9:
		if(0 == button)	button = '9';
	case KB_BUTTON_CZ:
		if(0 == button)	button = '.';

		if(iptparam->SetButtonLen >= 15)
			break;

		iptparam->SetButtonFlag = 1;
		*(iptparam->SetButton + iptparam->SetButtonLen) = button;	iptparam->SetButtonLen++;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_SECONDDNS, iptparam->SetButton, iptparam->SetButtonLen);
		break;

	case KB_BUTTON_CHG:
		//清除输入的数据
		iptparam->SetButtonFlag = 1;
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_SECONDDNS, iptparam->SetButton, iptparam->SetButtonLen);
		break;

	case KB_BUTTON_BACK:
		//显示并返回查询项选择界面
		*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_SET_PC_INFO);
		break;
	case KB_BUTTON_ACK:
		//判断转入此界面后是否有操作，无操作直接退出
		if(0 == iptparam->SetButtonFlag)
		{
			*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
			dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);
		
			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_SET_PC_INFO);
			break;
		}
		
		//判断输入点分十进制地址是否合法
		if(ERROR == myNetDotAddrCheck(iptparam->SetButton))
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "您输入的地址非法", strlen("您输入的地址非法"));
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_TABLETPC_SECONDDNS, iptparam->SetButton, iptparam->SetButtonLen);
			break;
		}
		
		//保存配置
		istate = pcDNSInfoSet(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TabletFirstDNS, iptparam->SetButton);
		if(0 != istate)
		{
			if(1 == istate)	dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置超时", 8);
			else					dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置失败", 8);
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_TABLETPC_SECONDDNS, iptparam->SetButton, iptparam->SetButtonLen);
			break;
		}

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置成功", 8);
		IPT_DSP_WAIT();
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);
		iptPidSet(iptparam, IPT_PID_SET_PC_INFO);
		break;
	default:
		break;
	}
	
	return;
}


/*******************************************************************
*Name				:iptSetTabletFTPIP
*Description		:平板电脑连接的FTP服务器IP地址界面
*Input				:None
*Output			:None
*Return				:None
*History			:2016-01-20,modified by syj  */

static void iptSetTabletFTPIP(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	char dsp_buffer[128] = {0};
	int dsp_len = 0;
	int istate = 0;
	unsigned int button = 0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0 == button)	button = '0';
	case KB_BUTTON_1:
		if(0 == button)	button = '1';
	case KB_BUTTON_2:
		if(0 == button)	button = '2';
	case KB_BUTTON_3:
		if(0 == button)	button = '3';
	case KB_BUTTON_4:
		if(0 == button)	button = '4';
	case KB_BUTTON_5:
		if(0 == button)	button = '5';
	case KB_BUTTON_6:
		if(0 == button)	button = '6';
	case KB_BUTTON_7:
		if(0 == button)	button = '7';
	case KB_BUTTON_8:
		if(0 == button)	button = '8';
	case KB_BUTTON_9:
		if(0 == button)	button = '9';
	case KB_BUTTON_CZ:
		if(0 == button)	button = '.';

		if(iptparam->SetButtonLen >= 15)
			break;
		
		iptparam->SetButtonFlag = 1;
		*(iptparam->SetButton + iptparam->SetButtonLen) = button;	iptparam->SetButtonLen++;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_FTP_IP, iptparam->SetButton, iptparam->SetButtonLen);
		break;

	case KB_BUTTON_CHG:
		//清除输入的数据
		iptparam->SetButtonFlag = 1;
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_FTP_IP, iptparam->SetButton, iptparam->SetButtonLen);
		break;

	case KB_BUTTON_BACK:
		//显示并返回查询项选择界面
		*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_SET_PC_INFO);
		break;
	case KB_BUTTON_ACK:
		//判断转入此界面后是否有操作，无操作直接退出
		if(0 == iptparam->SetButtonFlag)
		{
			*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
			dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);
		
			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_SET_PC_INFO);
			break;
		}
		
		//判断输入点分十进制地址是否合法
		if(ERROR == myNetDotAddrCheck(iptparam->SetButton))
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "您输入的地址非法", strlen("您输入的地址非法"));
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_TABLETPC_FTP_IP, iptparam->SetButton, iptparam->SetButtonLen);
			break;
		}
		
		//保存配置
		istate = pcFtpServerInfoSet(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->SetButton, iptparam->TabletFtpPort);
		if(0 != istate)
		{
			if(1 == istate)	dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置超时", 8);
			else					dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置失败", 8);
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_TABLETPC_FTP_IP, iptparam->SetButton, iptparam->SetButtonLen);
			break;
		}

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置成功", 8);
		IPT_DSP_WAIT();
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);
		iptPidSet(iptparam, IPT_PID_SET_PC_INFO);
		break;
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptSetTabletFTPPort
*Description		:平板电脑连接的FTP服务器端口号界面
*Input				:None
*Output			:None
*Return				:None
*History			:2016-01-20,modified by syj  */

static void iptSetTabletFTPPort(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	char dsp_buffer[128] = {0};
	int dsp_len = 0;
	int istate = 0;
	unsigned int button = 0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0 == button)	button = '0';
	case KB_BUTTON_1:
		if(0 == button)	button = '1';
	case KB_BUTTON_2:
		if(0 == button)	button = '2';
	case KB_BUTTON_3:
		if(0 == button)	button = '3';
	case KB_BUTTON_4:
		if(0 == button)	button = '4';
	case KB_BUTTON_5:
		if(0 == button)	button = '5';
	case KB_BUTTON_6:
		if(0 == button)	button = '6';
	case KB_BUTTON_7:
		if(0 == button)	button = '7';
	case KB_BUTTON_8:
		if(0 == button)	button = '8';
	case KB_BUTTON_9:
		if(0 == button)	button = '9';

		if(iptparam->SetButtonLen >= 5)
			break;

		iptparam->SetButtonFlag = 1;
		*(iptparam->SetButton + iptparam->SetButtonLen) = button;	iptparam->SetButtonLen++;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_FTP_PORT, iptparam->SetButton, iptparam->SetButtonLen);
		break;

	case KB_BUTTON_CHG:
		//清除输入的数据
		iptparam->SetButtonFlag = 1;
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_FTP_PORT, iptparam->SetButton, iptparam->SetButtonLen);
		break;

	case KB_BUTTON_BACK:
		//显示并返回查询项选择界面
		*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_SET_PC_INFO);
		break;
	case KB_BUTTON_ACK:
		//判断转入此界面后是否有操作，无操作直接退出
		if(0 == iptparam->SetButtonFlag)
		{
			*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
			dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);
		
			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_SET_PC_INFO);
			break;
		}
		
		//保存配置
		istate = pcFtpServerInfoSet(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->TabletFtpIP, iptparam->SetButton);
		if(0 != istate)
		{
			if(1 == istate)	dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置超时", 8);
			else					dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置失败", 8);
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_TABLETPC_FTP_PORT, iptparam->SetButton, iptparam->SetButtonLen);
			break;
		}

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置成功", 8);
		IPT_DSP_WAIT();
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);
		iptPidSet(iptparam, IPT_PID_SET_PC_INFO);
		break;
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptSetTabletServerIP
*Description		:平板电脑连接的后台服务器IP地址界面
*Input				:None
*Output			:None
*Return				:None
*History			:2016-01-20,modified by syj  */

static void iptSetTabletServerIP(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	char dsp_buffer[128] = {0};
	int dsp_len = 0;
	int istate = 0;
	unsigned int button = 0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0 == button)	button = '0';
	case KB_BUTTON_1:
		if(0 == button)	button = '1';
	case KB_BUTTON_2:
		if(0 == button)	button = '2';
	case KB_BUTTON_3:
		if(0 == button)	button = '3';
	case KB_BUTTON_4:
		if(0 == button)	button = '4';
	case KB_BUTTON_5:
		if(0 == button)	button = '5';
	case KB_BUTTON_6:
		if(0 == button)	button = '6';
	case KB_BUTTON_7:
		if(0 == button)	button = '7';
	case KB_BUTTON_8:
		if(0 == button)	button = '8';
	case KB_BUTTON_9:
		if(0 == button)	button = '9';
	case KB_BUTTON_CZ:
		if(0 == button)	button = '.';

		if(iptparam->SetButtonLen >= 15)
			break;

		iptparam->SetButtonFlag = 1;
		*(iptparam->SetButton + iptparam->SetButtonLen) = button;	iptparam->SetButtonLen++;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_SERVERIP, iptparam->SetButton, iptparam->SetButtonLen);
		break;

	case KB_BUTTON_CHG:
		//清除输入的数据
		iptparam->SetButtonFlag = 1;
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_SERVERIP, iptparam->SetButton, iptparam->SetButtonLen);
		break;

	case KB_BUTTON_BACK:
		//显示并返回查询项选择界面
		*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_SET_PC_INFO);
		break;
	case KB_BUTTON_ACK:
		//判断转入此界面后是否有操作，无操作直接退出
		if(0 == iptparam->SetButtonFlag)
		{
			*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
			dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);
		
			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_SET_PC_INFO);
			break;
		}
		
		//判断输入点分十进制地址是否合法
		if(ERROR == myNetDotAddrCheck(iptparam->SetButton))
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "您输入的地址非法", strlen("您输入的地址非法"));
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_TABLETPC_SERVERIP, iptparam->SetButton, iptparam->SetButtonLen);
			break;
		}
		
		//保存配置
		istate = pcServerInfoSet(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->SetButton);
		if(0 != istate)
		{
			if(1 == istate)	dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置超时", 8);
			else					dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置失败", 8);
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_TABLETPC_SERVERIP, iptparam->SetButton, iptparam->SetButtonLen);
			break;
		}

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置成功", 8);
		IPT_DSP_WAIT();
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);
		iptPidSet(iptparam, IPT_PID_SET_PC_INFO);
		break;
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptSetTabletVolume
*Description		:平板电脑连接的语音设置界面
*Input				:None
*Output			:None
*Return				:None
*History			:2016-01-20,modified by syj  */

static void iptSetTabletVolume(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	char dsp_buffer[128] = {0};
	int dsp_len = 0;
	int istate = 0, volume = 0;
	unsigned int button = 0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0 == button)	button = '0';
	case KB_BUTTON_1:
		if(0 == button)	button = '1';
	case KB_BUTTON_2:
		if(0 == button)	button = '2';
	case KB_BUTTON_3:
		if(0 == button)	button = '3';
	case KB_BUTTON_4:
		if(0 == button)	button = '4';
	case KB_BUTTON_5:
		if(0 == button)	button = '5';
	case KB_BUTTON_6:
		if(0 == button)	button = '6';
	case KB_BUTTON_7:
		if(0 == button)	button = '7';
	case KB_BUTTON_8:
		if(0 == button)	button = '8';
	case KB_BUTTON_9:
		if(0 == button)	button = '9';

		iptparam->SetButtonFlag = 1;
		iptparam->SetButton[0] = iptparam->SetButton[1];		iptparam->SetButton[1] = button;
		dsp_buffer[0] = (iptparam->SetButton[0]&0x0f)*10 + (iptparam->SetButton[1]&0x0f)*1;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_VOLUME, dsp_buffer, 1);
		break;

	case KB_BUTTON_CHG:
		//清除输入的数据
		iptparam->SetButtonFlag = 1;
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp_buffer[0] = (iptparam->SetButton[0]&0x0f)*10 + (iptparam->SetButton[1]&0x0f)*1;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_VOLUME, dsp_buffer, 1);
		break;

	case KB_BUTTON_BACK:
		//显示并返回查询项选择界面
		*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_SET_PC_INFO);
		break;
	case KB_BUTTON_ACK:
		//判断转入此界面后是否有操作，无操作直接退出
		if(0 == iptparam->SetButtonFlag)
		{
			*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
			dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);
		
			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_SET_PC_INFO);
			break;
		}
		
		//保存配置
		volume = (iptparam->SetButton[0]&0x0f)*10 + (iptparam->SetButton[1]&0x0f)*1;
		if(volume <0 || volume > 15)
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "请输入0~15的值", strlen("请输入0~15的值"));
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp_buffer[0] = (iptparam->SetButton[0]&0x0f)*10 + (iptparam->SetButton[1]&0x0f)*1;
			dsp(iptparam->DEVDsp, DSP_TABLETPC_VOLUME, dsp_buffer, 1);
			break;
		}

		istate = pcVolumeSet(iptparam->TabletPanel, iptparam->LogicNozzle, volume);
		if(0 != istate)
		{
			if(1 == istate)	dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置超时", 8);
			else					dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置失败", 8);
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp_buffer[0] = (iptparam->SetButton[0]&0x0f)*10 + (iptparam->SetButton[1]&0x0f)*1;
			dsp(iptparam->DEVDsp, DSP_TABLETPC_VOLUME, dsp_buffer, 1);
			break;
		}

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置成功", 8);
		IPT_DSP_WAIT();
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);
		iptPidSet(iptparam, IPT_PID_SET_PC_INFO);
		break;
	default:
		break;
	}
	
	return;
}


/*******************************************************************
*Name				:iptSetTabletTelephoneIP
*Description		:平板电脑连接的语音对讲后台IP地址界面
*Input				:None
*Output			:None
*Return				:None
*History			:2016-01-20,modified by syj  */

static void iptSetTabletTelephoneIP(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	char dsp_buffer[128] = {0};
	int dsp_len = 0;
	int istate = 0;
	unsigned int button = 0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0 == button)	button = '0';
	case KB_BUTTON_1:
		if(0 == button)	button = '1';
	case KB_BUTTON_2:
		if(0 == button)	button = '2';
	case KB_BUTTON_3:
		if(0 == button)	button = '3';
	case KB_BUTTON_4:
		if(0 == button)	button = '4';
	case KB_BUTTON_5:
		if(0 == button)	button = '5';
	case KB_BUTTON_6:
		if(0 == button)	button = '6';
	case KB_BUTTON_7:
		if(0 == button)	button = '7';
	case KB_BUTTON_8:
		if(0 == button)	button = '8';
	case KB_BUTTON_9:
		if(0 == button)	button = '9';
	case KB_BUTTON_CZ:
		if(0 == button)	button = '.';

		if(iptparam->SetButtonLen >= 15)
			break;

		iptparam->SetButtonFlag = 1;
		*(iptparam->SetButton + iptparam->SetButtonLen) = button;	iptparam->SetButtonLen++;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_TELE_IP, iptparam->SetButton, iptparam->SetButtonLen);
		break;

	case KB_BUTTON_CHG:
		//清除输入的数据
		iptparam->SetButtonFlag = 1;
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_TELE_IP, iptparam->SetButton, iptparam->SetButtonLen);
		break;

	case KB_BUTTON_BACK:
		//显示并返回查询项选择界面
		*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_SET_PC_INFO);
		break;
	case KB_BUTTON_ACK:
		//判断转入此界面后是否有操作，无操作直接退出
		if(0 == iptparam->SetButtonFlag)
		{
			*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
			dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);
		
			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			iptPidSet(iptparam, IPT_PID_SET_PC_INFO);
			break;
		}
		
		//判断输入点分十进制地址是否合法
		if(ERROR == myNetDotAddrCheck(iptparam->SetButton))
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "您输入的地址非法", strlen("您输入的地址非法"));
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_TABLETPC_TELE_IP, iptparam->SetButton, iptparam->SetButtonLen);
			break;
		}
		
		//保存配置
		istate = pcTelephoneIPSet(iptparam->TabletPanel, iptparam->LogicNozzle, iptparam->SetButton);
		if(0 != istate)
		{
			if(1 == istate)	dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置超时", 8);
			else					dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置失败", 8);
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			dsp(iptparam->DEVDsp, DSP_TABLETPC_TELE_IP, iptparam->SetButton, iptparam->SetButtonLen);
			break;
		}

		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置成功", 8);
		IPT_DSP_WAIT();
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);
		iptPidSet(iptparam, IPT_PID_SET_PC_INFO);
		break;
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptSetPromotion
*Description		:设置促销功能是否启用界面
*Input				:None
*Output			:None
*Return				:None
*History			:2016-01-20,modified by syj  */

static void iptSetPromotion(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	char dsp_buffer[128] = {0};
	int dsp_len = 0;
	int istate = 0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_UP:
	case KB_BUTTON_DOWN:
		//切换设置项
		if(0 == iptparam->SetParam)	iptparam->SetParam = 1;
		else											iptparam->SetParam = 0;
		
		*(dsp_buffer + 0) = iptparam->SetParam;
		*(dsp_buffer + 1) = 1;
		dsp_len = 2;
		dsp(iptparam->DEVDsp, DSP_PROMOTION, dsp_buffer, dsp_len);
		break;
	
	case KB_BUTTON_CHG:
	case KB_BUTTON_BACK:
		//显示并返回查询项选择界面
		*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_SET_PC_INFO);
		break;
		
	case KB_BUTTON_ACK:
		//保存设置数据，设置成功提示信息并返回平板信息设置项选择界面，设置失败提示信息并重新显示设置界面
		istate = paramPromotionSet(iptparam->SetParam);
		if(0 == istate)
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置成功", 8);
			IPT_DSP_WAIT();
		
			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
			dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);
			iptPidSet(iptparam, IPT_PID_SET_PC_INFO);
		}
		else
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置失败", 8);
			IPT_DSP_WAIT();

			*(dsp_buffer + 0) = iptparam->SetParam;
			*(dsp_buffer + 1) = 1;
			dsp_len = 2;
			dsp(iptparam->DEVDsp, DSP_PROMOTION, dsp_buffer, dsp_len);
		}
		break;
	default:
		break;
	}

	return;
}

//设置:设置油品确认功能是否启用
static void iptSetGradeFun(IptParamStructType *iptparam, char *msg_buffer, int msg_len)
{
	char dsp_buffer[128] = {0};
	int dsp_len = 0;
	int istate = 0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_UP:
	case KB_BUTTON_DOWN:
		//切换设置项
		if(PC_FUN_GRADE_OK == iptparam->TabletGradeTag)	iptparam->TabletGradeTag = PC_FUN_GRADE_NO;
		else											iptparam->TabletGradeTag = PC_FUN_GRADE_OK;
		
		*(dsp_buffer + 0) = iptparam->TabletGradeTag;
		*(dsp_buffer + 1) = 1;
		dsp_len = 2;
		dsp(iptparam->DEVDsp, DSP_YuLe_Grade_Fun, dsp_buffer, dsp_len);
		break;
	
	case KB_BUTTON_CHG:
	case KB_BUTTON_BACK:
		//显示并返回查询项选择界面
		*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
		dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);
		
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		iptPidSet(iptparam, IPT_PID_SET_PC_INFO);
		break;
		
	case KB_BUTTON_ACK:
		//保存设置数据，设置成功提示信息并返回平板信息设置项选择界面，设置失败提示信息并重新显示设置界面
		dsp_buffer[0]=iptparam->TabletGradeTag;
		istate =paramSetupWrite(PRM_YuLe_Grade_OK, dsp_buffer, 1);
		if(0 == istate)
		{
			IptParamA.TabletGradeTag=iptparam->TabletGradeTag;
			IptParamB.TabletGradeTag=iptparam->TabletGradeTag;
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置成功", 8);
			IPT_DSP_WAIT();
		
			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			*(dsp_buffer + 0) = iptparam->SetPage2;	dsp_len = 1;
			dsp(iptparam->DEVDsp, DSP_TABLETPC_INFO, dsp_buffer, dsp_len);
			iptPidSet(iptparam, IPT_PID_SET_PC_INFO);
		}
		else
		{
			paramSetupRead(PRM_YuLe_Grade_OK, dsp_buffer, 1);
			iptparam->TabletGradeTag=dsp_buffer[0];
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置失败", 8);
			IPT_DSP_WAIT();

			*(dsp_buffer + 0) = iptparam->TabletGradeTag;
			*(dsp_buffer + 1) = 1;
			dsp_len = 2;
			dsp(iptparam->DEVDsp, DSP_PROMOTION, dsp_buffer, dsp_len);
		}
		break;
	default:
		break;
	}

	return;
}

//szb_fj_20171120:设置ETC功能
static void iptSetEtcFun(IptParamStructType *iptparam)
{
	unsigned char dsp_buffer[128]={0},button=0;
	unsigned int istate=0;
		
	switch(iptparam->Button)
		{
			case KB_BUTTON_1:
				if(0 == button)	button = ETC_FUN_NO;
			case KB_BUTTON_2:
				if(0 == button)	button = ETC_FUN_OK;
				
				istate =paramSetupWrite(PRM_ETC_FUN_SET, &button, 1);
				if(istate==0)
					{
						IptParamA.etc_set_flg=button;
						IptParamB.etc_set_flg=button;
						dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置成功", 8);
						IPT_DSP_WAIT();
					
						memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
						dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
						iptPidSet(iptparam, IPT_PID_SET);
					}
				else
					{
						dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置失败", 8);
						IPT_DSP_WAIT();
					
						memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
						dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
						iptPidSet(iptparam, IPT_PID_SET);
					}
				break;
			case KB_BUTTON_BACK:
				//放弃设置，返回设置项选择界面
				dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
				iptPidSet(iptparam, IPT_PID_SET);
				break;
			default:
				break;
		}
}

/*******************************************************************
*Name				:iptSetContrast
*Description		:设置键盘显示对比度
*Input				:None
*Output			:None
*Return				:None
*History			:2016-01-20,modified by syj  */

void iptSetContrast(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char dsp_buffer[128]={0}, iContrast = 0;
	int dsp_len = 0, i_offset = 0, istate = 0, button = 0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0 == button)	button = '0';
	case KB_BUTTON_1:
		if(0 == button)	button = '1';
	case KB_BUTTON_2:
		if(0 == button)	button = '2';
	case KB_BUTTON_3:
		if(0 == button)	button = '3';
	case KB_BUTTON_4:
		if(0 == button)	button = '4';
	case KB_BUTTON_5:
		if(0 == button)	button = '5';
	case KB_BUTTON_6:
		if(0 == button)	button = '6';
	case KB_BUTTON_7:
		if(0 == button)	button = '7';
	case KB_BUTTON_8:
		if(0 == button)	button = '8';
	case KB_BUTTON_9:
		if(0 == button)	button = '9';

		//输入设置值
		iptparam->SetButton[0] = iptparam->SetButton[1];	iptparam->SetButton[1] = button;

		*(dsp_buffer+0) = (iptparam->SetButton[0]&0x0f)*10 + (iptparam->SetButton[1]&0x0f)*1;	dsp_len = 1;
		dsp(iptparam->DEVDsp, DSP_CONTRAST, dsp_buffer, dsp_len);
		break;

	case KB_BUTTON_CHG:
		//输入清零，如果此时输入值为空则直接退出
		iContrast = (iptparam->SetButton[0]&0x0f)*10 + (iptparam->SetButton[1]&0x0f)*1;
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;

		if(0 == iContrast){

			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
			break;
		}

		*(dsp_buffer+0) = (iptparam->SetButton[0]&0x0f)*10 + (iptparam->SetButton[1]&0x0f)*1;	dsp_len = 1;
		dsp(iptparam->DEVDsp, DSP_CONTRAST, dsp_buffer, dsp_len);
		break;

	case KB_BUTTON_ACK:
		//保存设置，设置值为空时不作操作，设置值非法时提示错误
		iContrast = (iptparam->SetButton[0]&0x0f)*10 + (iptparam->SetButton[1]&0x0f)*1;
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;

		if(0 == iContrast){

			dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
			iptPidSet(iptparam, IPT_PID_SET);
			break;
		}
		if(iContrast<IPT_DSPCONTRAST_MIN || iContrast>IPT_DSPCONTRAST_MAX){

			strcpy(dsp_buffer, "有效范围");
			sprintf(dsp_buffer+strlen(dsp_buffer), "%d~%d", IPT_DSPCONTRAST_MIN, IPT_DSPCONTRAST_MAX);
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, strlen(dsp_buffer));
			IPT_DSP_WAIT();

			*(dsp_buffer+0) = 0;	dsp_len = 1;
			dsp(iptparam->DEVDsp, DSP_CONTRAST, dsp_buffer, dsp_len);
			break;
		}

		//设置键盘显示对比度，设置失败是提示错误信息，成功时将当前设置值存入配置文件并更新内存数据
		if(IPT_NOZZLE_1==iptparam->Id)	istate = kbDspContrastSet(DEV_DSP_KEYA, iContrast);
		else													istate = kbDspContrastSet(DEV_DSP_KEYB, iContrast);
		if(0 != istate){

			strcpy(dsp_buffer, "设置失败");
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, strlen(dsp_buffer));
			IPT_DSP_WAIT();

			*(dsp_buffer+0) = 0;	dsp_len = 1;
			dsp(iptparam->DEVDsp, DSP_CONTRAST, dsp_buffer, dsp_len);
			break;
		}

		paramSetupWrite(IPT0_CONTRAST, &iContrast, 1);
		iptparam->Contrast = iContrast;

		//提示设置成功信息后返回设置项选择界面
		strcpy(dsp_buffer, "设置成功");
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, strlen(dsp_buffer));
		IPT_DSP_WAIT();

		dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
		iptPidSet(iptparam, IPT_PID_SET);
		break;

	case KB_BUTTON_BACK:
		//放弃设置，返回设置项选择界面
		dsp(iptparam->DEVDsp, DSP_SET_SELECT, &iptparam->SetPage, 1);
		iptPidSet(iptparam, IPT_PID_SET);
		break;

	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptOtherPassInput
*Description		:油机其他操作准入密码验证界面
*Input				:None
*Output			:None
*Return				:None
*History			:2014-02-18,modified by syj  */

static void iptOtherPassInput(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char miwen[6]={0}, password[4]={0}, dsp_buffer[64]={0}, dsp_len=0, button=0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0==button)	button='0';
	case KB_BUTTON_1:
		if(0==button)	button='1';
	case KB_BUTTON_2:
		if(0==button)	button='2';
	case KB_BUTTON_3:
		if(0==button)	button='3';
	case KB_BUTTON_4:
		if(0==button)	button='4';
	case KB_BUTTON_5:
		if(0==button)	button='5';
	case KB_BUTTON_6:
		if(0==button)	button='6';
	case KB_BUTTON_7:
		if(0==button)	button='7';
	case KB_BUTTON_8:
		if(0==button)	button='8';
	case KB_BUTTON_9:
		if(0==button)	button='9';

		//记录按键动作
		iptparam->SetButtonFlag=1;

		//按数字键保存密码ASCII值
		if(iptparam->SetButtonLen<6)
		{
			iptparam->SetButton[iptparam->SetButtonLen++]=button;

			dsp_buffer[0]=((iptparam->PassRandom[0]&0x0f)<<4)|((iptparam->PassRandom[1]&0x0f)<<0);
			dsp_buffer[1]=((iptparam->PassRandom[2]&0x0f)<<4)|((iptparam->PassRandom[3]&0x0f)<<0);
			dsp_buffer[2]=((iptparam->PassRandom[4]&0x0f)<<4)|((iptparam->PassRandom[5]&0x0f)<<0);
			dsp_buffer[3]=iptparam->SetButtonLen;	dsp_len=4;
			dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE_PASSSIN, dsp_buffer, dsp_len);
		}
		break;

	case KB_BUTTON_CHG:
		//记录按键动作
		iptparam->SetButtonFlag=1;

		//按"清除/退出"键，有密码时清除密码，无密码时返回服务选择界面
		if(0==iptparam->SetButtonLen)
		{
			iptMainInterface(iptparam);
		}
		else
		{
			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;

			dsp_buffer[0]=((iptparam->PassRandom[0]&0x0f)<<4)|((iptparam->PassRandom[1]&0x0f)<<0);
			dsp_buffer[1]=((iptparam->PassRandom[2]&0x0f)<<4)|((iptparam->PassRandom[3]&0x0f)<<0);
			dsp_buffer[2]=((iptparam->PassRandom[4]&0x0f)<<4)|((iptparam->PassRandom[5]&0x0f)<<0);
			dsp_buffer[3]=iptparam->SetButtonLen;	dsp_len=4;
			dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE_PASSSIN, dsp_buffer, dsp_len);
		}
		break;

	case KB_BUTTON_BACK:
		//按"退卡"键退出，返回待机界面
		iptMainInterface(iptparam);
		break;
		
	case KB_BUTTON_ACK:
		//
		//	输入四位密码时判断维护密码，输入六位密码时判断开发密码
		//	当以开发密码操作且操作成功时将维护密码初始化为默认密码"9999"
		
		//计算维护密码的ASCII码形式并验证输入的密码
		password[0]=((iptparam->ServicePass[0]>>4)&0x0f)+0x30;	password[1]=((iptparam->ServicePass[0]>>0)&0x0f)+0x30;
		password[2]=((iptparam->ServicePass[1]>>4)&0x0f)+0x30;	password[3]=((iptparam->ServicePass[1]>>0)&0x0f)+0x30;
		if(4==iptparam->SetButtonLen && 0==memcmp(iptparam->SetButton, password, 4))
		{
			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			memset(&dsp_buffer[0], ' ', 16);	dsp_len=16;
			dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
			iptPidSet(iptparam, IPT_PID_OTHER);
			break;
		}

		//计算开发维护密码并验证输入的密码
		iptPassCalculate(iptparam->PassRandom, miwen);
		miwen[0]=(miwen[0]&0x0f)+0x30;	miwen[1]=(miwen[1]&0x0f)+0x30;	miwen[2]=(miwen[2]&0x0f)+0x30;	
		miwen[3]=(miwen[3]&0x0f)+0x30;	miwen[4]=(miwen[4]&0x0f)+0x30;	miwen[5]=(miwen[5]&0x0f)+0x30;
		if(5==iptparam->SetButtonLen && '9'==iptparam->SetButton[0] && 0==memcmp(&iptparam->SetButton[1], miwen, 4))
		{
			if(0==iptparam->Id)
			{paramSetupWrite(IPT0_SERVICE_PASS, IPT_SERVEPASS_DEFAULT, 2);	paramSetupRead(IPT0_SERVICE_PASS, iptparam->ServicePass, 2);}
			else							
			{paramSetupWrite(IPT1_SERVICE_PASS, IPT_SERVEPASS_DEFAULT, 2);	paramSetupRead(IPT1_SERVICE_PASS, iptparam->ServicePass, 2);}

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			memset(&dsp_buffer[0], ' ', 16);	dsp_len=16;
			dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
			iptPidSet(iptparam, IPT_PID_OTHER);
			break;
		}

		//清除输入
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;

		//上述密码验证失败则提示后重新输入
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "密码错误", 8);
		IPT_DSP_WAIT();

		dsp_buffer[0]=((iptparam->PassRandom[0]&0x0f)<<4)|((iptparam->PassRandom[1]&0x0f)<<0);
		dsp_buffer[1]=((iptparam->PassRandom[2]&0x0f)<<4)|((iptparam->PassRandom[3]&0x0f)<<0);
		dsp_buffer[2]=((iptparam->PassRandom[4]&0x0f)<<4)|((iptparam->PassRandom[5]&0x0f)<<0);
		dsp_buffer[3]=iptparam->SetButtonLen;	dsp_len=4;
		dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE_PASSSIN, dsp_buffer, dsp_len);
		break;

	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptOtherOperat
*Description		:其它操作，操作成功提示，操作失败或无意义代码无提示
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptOtherOperat(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char password[16]={0}, dsp_buffer[64]={0}, wrbuffer[64]={0}, button=0;
	int i=0, dsp_len=0, istate=0;
	unsigned int data=0, uint_tmp = 0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0==button)	button='0';
	case KB_BUTTON_1:
		if(0==button)	button='1';
	case KB_BUTTON_2:
		if(0==button)	button='2';
	case KB_BUTTON_3:
		if(0==button)	button='3';
	case KB_BUTTON_4:
		if(0==button)	button='4';
	case KB_BUTTON_5:
		if(0==button)	button='5';
	case KB_BUTTON_6:
		if(0==button)	button='6';
	case KB_BUTTON_7:
		if(0==button)	button='7';
	case KB_BUTTON_8:
		if(0==button)	button='8';
	case KB_BUTTON_9:
		if(0==button)	button='9';
		//保存按键代码
		if(iptparam->SetButtonLen<16)
		{
			iptparam->SetButton[iptparam->SetButtonLen++]=button;

			memset(dsp_buffer, ' ', 16);	memcpy(&dsp_buffer[16-iptparam->SetButtonLen], iptparam->SetButton, iptparam->SetButtonLen);
			dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
		}
		break;

	case KB_BUTTON_CHG:
		//无按键时返回待机界面，有按键时清空按键并清空显示
		if(0==iptparam->SetButtonLen)
		{
			iptMainInterface(iptparam);
		}
		else
		{
			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			memset(dsp_buffer, ' ', 16);	dsp_len=16;
			dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
		}
		break;

	case KB_BUTTON_BACK:
		//返回待机界面
		iptMainInterface(iptparam);
		break;

	case KB_BUTTON_ACK:
		//根据输入代码确定操作，输入有效时根据操作结果进行提示

#if _IPT_DEBUG_
		//测试状态，清除待传账单
		if((8==iptparam->SetButtonLen)&&(0==memcmp(iptparam->SetButton, "98765431", 8)))
		{
			///
			pcdFmWrite(PCD_FM_UNLOAD, "\x00\x00\x00\x00", 4);
			pcdFmWrite(PCD_FM_UNLOAD1, "\x00\x00\x00\x00", 4);
			pcdFmWrite(PCD_FM_UNLOAD2, "\x00\x00\x00\x00", 4);
			pcdFmWrite(PCD_FM_UNLOAD3, "\x00\x00\x00\x00", 4);
			pcdFmWrite(PCD_FM_UNLOAD4, "\x00\x00\x00\x00", 4);
			pcdFmWrite(PCD_FM_UNLOAD5, "\x00\x00\x00\x00", 4);
			pcdFmWrite(PCD_FM_UNLOAD6, "\x00\x00\x00\x00", 4);
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", 8);
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			memset(dsp_buffer, ' ', 16);	dsp_len=16;
			dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
		}
#endif

//查询部分操作************************************************
		//"96122141":显示计量机型
		if(8==iptparam->SetButtonLen && 0==memcmp(iptparam->SetButton, "96122141", 8))
		{
			printf("jlTypeRead:\n"); //fj:20171013
			istate=jlTypeRead(iptparam->JlNozzle); 
			dsp_buffer[0]=(char)istate;
			dsp(iptparam->DEVDsp, DSP_INQ_JLTYPE, dsp_buffer, 1);

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;	iptparam->NousedTimer=0;
			iptPidSet(iptparam, IPT_PID_OTHER_WAIT);
			break;
		}

		//"96122142":显示屏蔽量及过冲屏蔽量
		if(8==iptparam->SetButtonLen && 0==memcmp(iptparam->SetButton, "96122142", 8))
		{	
			jlShieldRead(iptparam->JlNozzle, &data); //fj:
	        printf("jlShieldRead = %d\n",data);
			dsp_buffer[0]=(char)(data>>24);	dsp_buffer[1]=(char)(data>>16);	dsp_buffer[2]=(char)(data>>8);	dsp_buffer[3]=(char)(data>>0);
			jlOverShieldRead(iptparam->JlNozzle, &data);//fj:
            printf("jlOverShieldRead = %d\n",data);
			dsp_buffer[4]=(char)(data>>24);	dsp_buffer[5]=(char)(data>>16);	dsp_buffer[6]=(char)(data>>8);	dsp_buffer[7]=(char)(data>>0);
			dsp_len=8;
			dsp(iptparam->DEVDsp, DSP_INQ_SHILED, dsp_buffer, dsp_len);

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;	iptparam->NousedTimer=0;
			iptPidSet(iptparam, IPT_PID_OTHER_WAIT);
			break;
		}

		//"96122143":显示当量
		if(8==iptparam->SetButtonLen && 0==memcmp(iptparam->SetButton, "96122143", 8))
		{
			jlEquivalentRead(iptparam->JlNozzle, &data);
			dsp_buffer[0]=(char)(data>>24);	dsp_buffer[1]=(char)(data>>16);	dsp_buffer[2]=(char)(data>>8);	dsp_buffer[3]=(char)(data>>0);
			dsp_len=4;
			dsp(iptparam->DEVDsp, DSP_INQ_EQUIVALENT, dsp_buffer, dsp_len);

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;	iptparam->NousedTimer=0;
			iptPidSet(iptparam, IPT_PID_OTHER_WAIT);
			break;
		}

		//代码"96122144":显示允许开启大阀屏蔽量
		if(8==iptparam->SetButtonLen && 0==memcmp(iptparam->SetButton, "96122144", 8))
		{
			printf("jlValveVolumeRead:\n"); //fj:20171013
			jlValveVolumeRead(iptparam->JlNozzle, &data);
			dsp_buffer[0]=(char)(data>>24);	dsp_buffer[1]=(char)(data>>16);	dsp_buffer[2]=(char)(data>>8);	dsp_buffer[3]=(char)(data>>0);
			dsp_len=4;
			dsp(iptparam->DEVDsp, DSP_INQ_VALVE_VOLUME, dsp_buffer, dsp_len);

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;	iptparam->NousedTimer=0;
			iptPidSet(iptparam, IPT_PID_OTHER_WAIT);
			break;
		}

		//代码"96122145":显示无脉冲超时关闭大阀时间，单位为秒
		if(8==iptparam->SetButtonLen && 0==memcmp(iptparam->SetButton, "96122145", 8))
		{
			printf("jlValveStopTimeRead: \n"); //fj:20171013
			jlValveStopTimeRead(iptparam->JlNozzle, &data);
			dsp_buffer[0]=(char)(data>>24);	dsp_buffer[1]=(char)(data>>16);	dsp_buffer[2]=(char)(data>>8);	dsp_buffer[3]=(char)(data>>0);
			dsp_len=4;
			dsp(iptparam->DEVDsp, DSP_INQ_UNPULSE_OVERTIME, dsp_buffer, dsp_len);

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;	iptparam->NousedTimer=0;
			iptPidSet(iptparam, IPT_PID_OTHER_WAIT);
			break;
		}

		//代码"96122146":显示IC卡认证方式
		if(8==iptparam->SetButtonLen && 0==memcmp(iptparam->SetButton, "96122146", 8))
		{
			sprintf(dsp_buffer, "R=%2X", iptparam->DESAuthen);//fj:
			dsp_len=4;
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;	iptparam->NousedTimer=0;
			iptPidSet(iptparam, IPT_PID_OTHER_WAIT);
			break;
		}
		
		//代码"97122141":显示并转入密钥卡下载密钥过程
		if(8==iptparam->SetButtonLen && 0==memcmp(iptparam->SetButton, "97122141", 8))
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "请插入密钥卡", 12);

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;	iptparam->NousedTimer=0;
			iptPidSet(iptparam, IPT_PID_OTHER_KEYLOAD);
			break;
		}

		//代码"97122142":显示主板号
		if(8==iptparam->SetButtonLen && 0==memcmp(iptparam->SetButton, "97122142", 8))
		{
			memcpy(&dsp_buffer[0], "     主板ID     ", 16);	hex2Ascii(MboardID, 8, &dsp_buffer[16], 16);
			dsp_len=32;
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;	iptparam->NousedTimer=0;
			iptPidSet(iptparam, IPT_PID_OTHER_WAIT);
			break;
		}

		//代码"97122143":显示密钥，两位数据为一列，第1、3、4、8列为密钥
		//	M1	+X	+M5	+M9	+X	+X	+X	+M13
		//	M2	+X	+M6	+M10	+X	+X	+X	+M14
	  	//  M3	+X	+M7	+M11	+X	+X	+X	+M15
		//	M4	+X	+M8	+M12	+X	+X	+X	+M16


		//代码"97122144":显示税控当量
		if(8==iptparam->SetButtonLen && 0==memcmp(iptparam->SetButton, "97122144", 8))
		{
			printf("jlTaxEquivalentRead: \n");  //fj:20171013
			istate = jlTaxEquivalentRead(iptparam->JlNozzle, &uint_tmp);
			if(0 != istate)
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "查询失败", strlen("查询失败"));
				IPT_DSP_WAIT();
			
				memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
				memset(dsp_buffer, ' ', 16);	dsp_len=16;
				dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
				break;
			}

			memset(dsp_buffer, 0 , sizeof(dsp_buffer));
			strcpy(dsp_buffer+strlen(dsp_buffer), "K=");
			sprintf(dsp_buffer+strlen(dsp_buffer), "%X", uint_tmp);
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, strlen(dsp_buffer));

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;	iptparam->NousedTimer=0;
			iptPidSet(iptparam, IPT_PID_OTHER_WAIT);
			break;
		}

		//代码"97122145"：显示计量算法
		if(8==iptparam->SetButtonLen && 0==memcmp(iptparam->SetButton, "97122145", 8))
		{
			printf("jlAlgorithmRead\n"); //fj:20171013
			jlAlgorithmRead(iptparam->JlNozzle, &data);
			strcpy(dsp_buffer + strlen(dsp_buffer), "<<计量算法标准>>");
			strcpy(dsp_buffer + strlen(dsp_buffer), "                ");
			if(JL_ALGORITHM_UP == data)	strcpy(dsp_buffer + strlen(dsp_buffer), "   新标准算法   ");
			if(JL_ALGORITHM_45 == data)	strcpy(dsp_buffer + strlen(dsp_buffer), "  四舍五入算法  ");
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, strlen(dsp_buffer));

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;	iptparam->NousedTimer=0;
			iptPidSet(iptparam, IPT_PID_OTHER_WAIT);
			break;
		}

		//szb_fj_20171120:update,2017-02-13代码"96222142":显示油品验证方式
		if(8==iptparam->SetButtonLen && 0==memcmp(iptparam->SetButton, "96222142", 8))
		{
			if(iptparam->IptOilLimitStyleTag==IPT_SET_OILLIMIT_0)
				{
					memcpy(dsp_buffer,"社会标准",strlen("社会标准"));
					dsp_len=strlen("社会标准");
				}
			else if(iptparam->IptOilLimitStyleTag==IPT_SET_OILLIMIT_F)
				{
					memcpy(dsp_buffer,"石化标准",strlen("石化标准"));
					dsp_len=strlen("石化标准");
				}
			else if(iptparam->IptOilLimitStyleTag==IPT_SET_OILLIMIT_0F)
				{
					memcpy(dsp_buffer,"兼容标准",strlen("兼容标准"));
					dsp_len=strlen("兼容标准");
				}
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;	iptparam->NousedTimer=0;
			iptPidSet(iptparam, IPT_PID_OTHER_WAIT);
			break;
		}
		//szb_fj_20171120:add 双编码器大流量无脉冲超时时间控制1BCD 秒5-20默认8
	/*	if(8==iptparam->SetButtonLen && 0==memcmp(iptparam->SetButton, "96222143", 8))
		{
			istate = jlBigVolTimeRead(iptparam->JlNozzle, &data);
			if(0 != istate)
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "查询失败", strlen("查询失败"));
				IPT_DSP_WAIT();
			
				memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
				memset(dsp_buffer, ' ', 16);	dsp_len=16;
				dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
				break;
			}
			dsp_buffer[0]=(data/10)+0x30;
			dsp_buffer[1]=(data%10)+0x30;
			memcpy(dsp_buffer+2,"??",strlen("??"));
			dsp_len=2+strlen("??");
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;	iptparam->NousedTimer=0;
			iptPidSet(iptparam, IPT_PID_OTHER_WAIT);
			break;
		}
		//szb_fj_20171120,add 双编码器大流量流速控制1BCD L/分 10-80默认15
		if(8==iptparam->SetButtonLen && 0==memcmp(iptparam->SetButton, "96222144", 8))
		{
			istate = jlBigVolSpeedRead(iptparam->JlNozzle, &data);
			if(0 != istate)
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "查询失败", strlen("查询失败"));
				IPT_DSP_WAIT();
			
				memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
				memset(dsp_buffer, ' ', 16);	dsp_len=16;
				dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
				break;
			}
			dsp_buffer[0]=(data/10)+0x30;
			dsp_buffer[1]=(data%10)+0x30;
			memcpy(dsp_buffer+2,"升/分",strlen("升/分"));
			dsp_len=2+strlen("升/分");
			
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;	iptparam->NousedTimer=0;
			iptPidSet(iptparam, IPT_PID_OTHER_WAIT);
			break;
		}*/



//设置部分操作************************************************

		//"961352210X":设置主板号
		if(KB_KEYLOCK_OIL!=iptparam->KeyLock && 10==iptparam->SetButtonLen && 0==memcmp(iptparam->SetButton, "961352210", 9))
		{
			data=iptparam->SetButton[9]&0x0f;
			if(0==pcdMboardIDWrite(data))
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", 8);
			}
			else
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", 8);
			}
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			memset(dsp_buffer, ' ', 16);	dsp_len=16;
			dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
			break;
		}

		//"96135331XX":设置计量机型
		if(KB_KEYLOCK_OIL!=iptparam->KeyLock && 10==iptparam->SetButtonLen && 0==memcmp(iptparam->SetButton, "96135331", 8))
		{
			data=((iptparam->SetButton[8]&0x0f)<<4)|((iptparam->SetButton[9]&0x0f)<<0);
			//fj:
			if(0==jlTypeWrite(iptparam->JlNozzle, data))
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", 8);
			}
			else
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", 8);
			}
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			memset(dsp_buffer, ' ', 16);	dsp_len=16;
			dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
			break;
		}

		//"96135441XX":设置屏蔽量
		if(KB_KEYLOCK_OIL!=iptparam->KeyLock && 10==iptparam->SetButtonLen && 0==memcmp(iptparam->SetButton, "96135441", 8))
		{
			data=(iptparam->SetButton[8]&0x0f)*10+(iptparam->SetButton[9]&0x0f)*1;
			//fj:
			if(0==jlShieldWrite(iptparam->JlNozzle, data))
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", 8);
			}
			else
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", 8);
			}
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			memset(dsp_buffer, ' ', 16);	dsp_len=16;
			dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
			break;
		}

		//"96135551XX":设置计量过冲屏蔽量
		if(KB_KEYLOCK_OIL!=iptparam->KeyLock && 10==iptparam->SetButtonLen && 0==memcmp(iptparam->SetButton, "96135551", 8))
		{
			data=(iptparam->SetButton[8]&0x0f)*10+(iptparam->SetButton[9]&0x0f)*1;
			//fj:
			if(0==jlOverShieldWrite(iptparam->JlNozzle, data))
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", 8);
			}
			else
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", 8);
			}
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			memset(dsp_buffer, ' ', 16);	dsp_len=16;
			dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
			break;
		}

		//"961356610X":设置认证方式
		if(KB_KEYLOCK_OIL!=iptparam->KeyLock && 10==iptparam->SetButtonLen && 0==memcmp(iptparam->SetButton, "961356610", 9))
		{
			data=iptparam->SetButton[9]&0x0f;
			if(0==iptparam->Id)	istate=paramSetupWrite(IPT0_AUTHEN, (char*)&data, 1);
			else								istate=paramSetupWrite(IPT1_AUTHEN, (char*)&data, 1);
			if(0==istate)
			{
				//更新认证方式
				iptparam->DESAuthen=data;
			
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", 8);
			}
			else
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", 8);
			}
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			memset(dsp_buffer, ' ', 16);	dsp_len=16;
			dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
			break;
		}

		//"96135771XX":设置开启大阀时的油量，单位0.01升，范围00~99
		if(KB_KEYLOCK_OIL!=iptparam->KeyLock && 10==iptparam->SetButtonLen && 0==memcmp(iptparam->SetButton, "96135771", 8))
		{
			data=(iptparam->SetButton[8]&0x0f)*10+(iptparam->SetButton[9]&0x0f)*1;
			if(0==jlValveVolumeWrite(iptparam->JlNozzle, data))
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", 8);
			}
			else
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", 8);
			}
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			memset(dsp_buffer, ' ', 16);	dsp_len=16;
			dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
			break;
		}

		//"96135881XX":设置无脉冲超时关闭大阀时间，单位 秒，范围10~99
		if(KB_KEYLOCK_OIL!=iptparam->KeyLock && 10==iptparam->SetButtonLen && 0==memcmp(iptparam->SetButton, "96135881", 8))
		{
			data=(iptparam->SetButton[8]&0x0f)*10+(iptparam->SetButton[9]&0x0f)*1;
			if(0==jlValveStopTimeWrite(iptparam->JlNozzle, data))
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", 8);
			}
			else
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", 8);
			}
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			memset(dsp_buffer, ' ', 16);	dsp_len=16;
			dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
			break;
		}

		//"96135991XX":设置计量算法标准 00 = 四舍五入；01 = 新标准算法
		if(KB_KEYLOCK_OIL!=iptparam->KeyLock && 10==iptparam->SetButtonLen && 0==memcmp(iptparam->SetButton, "96135991", 8))
		{
			data = ((iptparam->SetButton[8]&0x0f)<<8)|((iptparam->SetButton[9]&0x0f)<<0);
			if(0x00 != data && 0x01 != 0x01)
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置值非法", strlen("设置值非法"));
				IPT_DSP_WAIT();
			
				memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
				memset(dsp_buffer, ' ', 16);	dsp_len=16;
				dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
				break;
			}
			
			//fj:
			if(0x00 == data)
			{
				istate = jlAlgorithmWrite(iptparam->JlNozzle, JL_ALGORITHM_45);
			}
			else		
			{
				istate = jlAlgorithmWrite(iptparam->JlNozzle, JL_ALGORITHM_UP);
			}

			if(0 == istate)		
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置成功", strlen("设置成功"));
			else						
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置失败", strlen("设置失败"));
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			memset(dsp_buffer, ' ', 16);	dsp_len=16;
			dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
			break;
		}

		//"96158KKKKKKXXXXX":设置当量,KKKKKK为开发维护密码,XXXXX为当量
		if(KB_KEYLOCK_OIL!=iptparam->KeyLock && 16==iptparam->SetButtonLen && 0==memcmp(iptparam->SetButton, "96158", 5))
		{
			//判断加油状态，应不在加油状态
			if(IPT_OIL_IDLE!=iptparam->OilState)
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "主板油枪非空闲", 14);
				IPT_DSP_WAIT();

				memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
				memset(dsp_buffer, ' ', 16);	dsp_len=16;
				dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
				break;
			}

			//判断开发维护密码
			iptPassCalculate(iptparam->PassRandom, password);
			for(i=0; i<6; i++)	password[i]=(password[i]&0x0f)+0x30;
			if(0!=memcmp(password, &iptparam->SetButton[5], 6))
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "开发密码错误", 12);
				IPT_DSP_WAIT();

				memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
				memset(dsp_buffer, ' ', 16);	dsp_len=16;
				dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
				break;
			}
			
			//设置当量并判断操作结果
			data=(iptparam->SetButton[11]&0x0f)*10000+(iptparam->SetButton[12]&0x0f)*1000+\
					(iptparam->SetButton[13]&0x0f)*100+(iptparam->SetButton[14]&0x0f)*10+(iptparam->SetButton[15]&0x0f)*1;
			
			printf("set jl param ,k = %d\n",data);
			if(0==jlEquivalentWrite(iptparam->JlNozzle, data))
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", 8);
			}
			else
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", 8);
			}
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			memset(dsp_buffer, ' ', 16);	dsp_len=16;
			dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
			break;
		}

		//"967111KKKKXXXX":设置售后维护密码,KKKK为新密码, XXXX为确认的新密码
		if(KB_KEYLOCK_OIL!=iptparam->KeyLock && 14==iptparam->SetButtonLen && 0==memcmp(iptparam->SetButton, "967111", 6) && 0==memcmp(&iptparam->SetButton[6], &iptparam->SetButton[10], 4))
		{		
			password[0]=((iptparam->SetButton[6]&0x0f)<<4)|((iptparam->SetButton[7]&0x0f)<<0);
			password[1]=((iptparam->SetButton[8]&0x0f)<<4)|((iptparam->SetButton[9]&0x0f)<<0);
			if(0==iptparam->Id)	istate=paramSetupWrite(IPT0_SERVICE_PASS, password, 2);
			else								istate=paramSetupWrite(IPT1_SERVICE_PASS, password, 2);
			if(0==istate)
			{
				//更新维护密码
				memcpy(iptparam->ServicePass, password, 2);
				
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", 8);
			}
			else
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", 8);
			}
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			memset(dsp_buffer, ' ', 16);	dsp_len=16;
			dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
			break;
		}
		
		//"967222KKKKXXXX":设置油站操作密码,KKKK为新密码, XXXX为确认的新密码
		if(KB_KEYLOCK_OIL!=iptparam->KeyLock && 14==iptparam->SetButtonLen && 0==memcmp(iptparam->SetButton, "967222", 6) && 0==memcmp(&iptparam->SetButton[6], &iptparam->SetButton[10], 4))
		{
			password[0]=((iptparam->SetButton[6]&0x0f)<<4)|((iptparam->SetButton[7]&0x0f)<<0);
			password[1]=((iptparam->SetButton[8]&0x0f)<<4)|((iptparam->SetButton[9]&0x0f)<<0);
			if(0==iptparam->Id)	istate=paramSetupWrite(IPT0_PASSWORD, password, 2);
			else								istate=paramSetupWrite(IPT1_PASSWORD, password, 2);
			if(0==istate)
			{
				//更新油站操作密码
				memcpy(iptparam->Password, password, 2);
			
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", 8);
			}
			else
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", 8);
			}
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			memset(dsp_buffer, ' ', 16);	dsp_len=16;
			dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
			break;
		}

		//"961811YYYYMMDD":销售锁定，YYYYMMDD为锁定时间，加油机至此时间时锁定，全零表示解除锁定操作
		if(KB_KEYLOCK_OIL!=iptparam->KeyLock && 14==iptparam->SetButtonLen && 0==memcmp(iptparam->SetButton, "961811", 6))
		{
			wrbuffer[0]=((iptparam->SetButton[6]&0x0f)<<4)|((iptparam->SetButton[7]&0x0f)<<0);
			wrbuffer[1]=((iptparam->SetButton[8]&0x0f)<<4)|((iptparam->SetButton[9]&0x0f)<<0);
			wrbuffer[2]=((iptparam->SetButton[10]&0x0f)<<4)|((iptparam->SetButton[11]&0x0f)<<0);
			wrbuffer[3]=((iptparam->SetButton[12]&0x0f)<<4)|((iptparam->SetButton[13]&0x0f)<<0);
			wrbuffer[4]=0;
			istate=paramSetupWrite(PRM_SELL_LOCK_TIME, wrbuffer, 5);
			if(0==istate)
			{
				IptParamA.SellLock=0;	IptParamB.SellLock=0;
				memcpy(IptParamA.SLockTime, wrbuffer, 4);	memcpy(IptParamB.SLockTime, wrbuffer, 4);
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", 8);
			}
			else
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", 8);
			}
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			memset(dsp_buffer, ' ', 16);	dsp_len=16;
			dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
			break;
		}

		//"9731700001":设置机型
		if(KB_KEYLOCK_OIL!=iptparam->KeyLock && 10==iptparam->SetButtonLen && 0==memcmp(iptparam->SetButton, "9731700001", 10))
		{
			iptparam->SetParam = paramModelGet();
		
			strcpy(dsp_buffer, " 请按↑↓键设置 ");
			strcpy(dsp_buffer + strlen(dsp_buffer), ModelParam[iptparam->SetParam]);
			if(strlen(dsp_buffer) < 3*16)	memset(dsp_buffer + strlen(dsp_buffer), ' ', 3*16 - strlen(dsp_buffer));
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, strlen(dsp_buffer));

			iptPidSet(iptparam, IPT_PID_OTHER_MODEL);
			break;
		}

		//"117433KKKKKK"：转入累计数修改界面，KKKKKK为6位开发维护密码
		if(KB_KEYLOCK_OIL!=iptparam->KeyLock && 12==iptparam->SetButtonLen && 0==memcmp(iptparam->SetButton, "117433", 6))
		{
			//判断开发维护密码
			iptPassCalculate(iptparam->PassRandom, password);
			for(i=0; i<6; i++)	password[i]=(password[i]&0x0f)+0x30;
			if(0!=memcmp(password, &iptparam->SetButton[6], 6))
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "开发密码错误", 12);
				IPT_DSP_WAIT();

				memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
				memset(dsp_buffer, ' ', 16);	dsp_len=16;
				dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
				break;
			}

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;

			strncpy(dsp_buffer, "  请输入修改值  ", 16);
			memset(dsp_buffer + 16, ' ', 16);	
			memcpy(&dsp_buffer[16 - iptparam->SetButtonLen + 16], iptparam->SetButton, iptparam->SetButtonLen);
			dsp_len = 32;
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);

			iptPidSet(iptparam, IPT_PID_OTHER_SUMWRITE);
			break;
		}

#if 0
		//"117433KKKKKK"：清空油机总累及当次数据，KKKKKK为6位开发维护密码

		if(KB_KEYLOCK_OIL!=iptparam->KeyLock && 12==iptparam->SetButtonLen && 0==memcmp(iptparam->SetButton, "117433", 6))
		{
			//判断开发维护密码
			iptPassCalculate(iptparam->PassRandom, password);
			for(i=0; i<6; i++)	password[i]=(password[i]&0x0f)+0x30;
			if(0!=memcmp(password, &iptparam->SetButton[6], 6))
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "开发密码错误", 12);
				IPT_DSP_WAIT();

				memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
				memset(dsp_buffer, ' ', 16);	dsp_len=16;
				dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
				break;
			}

			if(0 == jlOilDataClr())
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", 8);
			}
			else
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", 8);
			}
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			memset(dsp_buffer, ' ', 16);	dsp_len=16;
			dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
			break;
		}
#endif

		#if _TYPE_BIG260_
		//"99260XXXXX":（仅260升大流量）设置计量当量，XXXXX为5位当量，
		使用油枪3开关控制使用，开关闭合时可以设置，未接或断开时不可设置
		if(10==iptparam->SetButtonLen && 0==memcmp(iptparam->SetButton, "99260", 5))
		{
			//判断GUN3状态，闭合时允许操作
			istate = spi1GunRead(DEV_GUNA2, (char *)&i);
			printf("操作当量[%s][%d][istate = %x][i = %x].\n", __FUNCTION__, __LINE__, istate, i);
			if(0 != istate)
			{
				break;
			}
		
			//判断加油状态，应不在加油状态
			if(IPT_OIL_IDLE!=iptparam->OilState)
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "主板油枪非空闲", 14);
				IPT_DSP_WAIT();

				memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
				memset(dsp_buffer, ' ', 16);	dsp_len=16;
				dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
				break;
			}
			
			//设置当量并判断操作结果
			data=(iptparam->SetButton[5]&0x0f)*10000+(iptparam->SetButton[6]&0x0f)*1000+\
					(iptparam->SetButton[7]&0x0f)*100+(iptparam->SetButton[8]&0x0f)*10+(iptparam->SetButton[9]&0x0f)*1;
			if(0==jlEquivalentWrite(iptparam->JlNozzle, data))
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", 8);
			}
			else
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", 8);
			}
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			memset(dsp_buffer, ' ', 16);	dsp_len=16;
			dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
			break;
		}
		#endif


		//"375000KKKKKK"：油机初始化（当量5000），KKKKKK为6位开发维护密码
		if(KB_KEYLOCK_OIL!=iptparam->KeyLock && 12==iptparam->SetButtonLen && 0==memcmp(iptparam->SetButton, "375000", 6))
		{
			//判断加油状态，应不在加油状态
			if(IPT_OIL_IDLE!=IptParamA.OilState || IPT_OIL_IDLE!=IptParamB.OilState)
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "主板油枪非空闲", 14);
				IPT_DSP_WAIT();

				memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
				memset(dsp_buffer, ' ', 16);	dsp_len=16;
				dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
				break;
			}

			//判断开发维护密码
			iptPassCalculate(iptparam->PassRandom, password);
			for(i=0; i<6; i++)	password[i]=(password[i]&0x0f)+0x30;
			if(0!=memcmp(password, &iptparam->SetButton[6], 6))
			{	
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "开发密码错误", 12);
				IPT_DSP_WAIT();

				memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
				memset(dsp_buffer, ' ', 16);	dsp_len=16;
				dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
				break;
			}

			//清除输入
			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;

			printf("start jlParamInit ------\n");

			//初始化
			if(0 != paramSetupClr())
			{
				printf("paramSetupClr failure!\n");
				istate=1;
			}
			if(0 != jlParamInit(0))	
			{
				printf("jlParamInit 0  failure!\n");
				istate=1;
			}
			if(0 != jlParamInit(1))		
			{
				printf("jlParamInit 1 failure!\n");
				istate=1;
			}
			if(0 != iptParamInit(0))	
			{
				printf("iptParamInit 0 failure!\n");
				istate=1;
			}
			if(0 != iptParamInit(1))		
			{
				printf("iptParamInit 1 failure!\n");
				istate=1;
			}
			if(0 != pcdParamInit())	
			{
				printf("pcdParamInit failure!\n");
				istate=1;
			}
			if(0==istate)
			{
				memcpy(&dsp_buffer[0], "初始化成功，    ", 16);
				memcpy(&dsp_buffer[16], "    请重启加油机", 16);
				dsp_len=32;
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);
			}
			else
			{
				memcpy(&dsp_buffer[0], "初始化失败，    ", 16);
				memcpy(&dsp_buffer[16], "      请停机检查", 16);
				dsp_len=32;
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);
			}

			break;
		}

		//2017-02-13油品设置方式设置1hex
		if(KB_KEYLOCK_OIL!=iptparam->KeyLock && 10==iptparam->SetButtonLen && 0==memcmp(iptparam->SetButton, "96136221", 8))
		{
			if(0==memcmp(iptparam->SetButton+8,"00",2))
			{
				if(0==paramSetupWrite(PRM_OilLimit_Style_Set, "\x30", 1))
				{
					//IptParamA.IptOilLimitStyleTag=IPT_SET_OILLIMIT_ZSH;
					//IptParamB.IptOilLimitStyleTag=IPT_SET_OILLIMIT_ZSH;
					IptParamA.IptOilLimitStyleTag=IPT_SET_OILLIMIT_F;
					IptParamB.IptOilLimitStyleTag=IPT_SET_OILLIMIT_F;
					dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", 8);
				}
				else
					dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", 8);
				IPT_DSP_WAIT();
			}
			else if(0==memcmp(iptparam->SetButton+8,"01",2))
			{
				if(0==paramSetupWrite(PRM_OilLimit_Style_Set, "\x31", 1))
				{
					IptParamA.IptOilLimitStyleTag=IPT_SET_OILLIMIT_0;
					IptParamB.IptOilLimitStyleTag=IPT_SET_OILLIMIT_0;
					dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", 8);
				}
				else
					dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", 8);
				IPT_DSP_WAIT();
			}
			else if(0==memcmp(iptparam->SetButton+8,"02",2)) //szb_fj_20171120:add
			{
				if(0==paramSetupWrite(PRM_OilLimit_Style_Set, "\x32", 1))
				{
					IptParamA.IptOilLimitStyleTag=IPT_SET_OILLIMIT_0F;
					IptParamB.IptOilLimitStyleTag=IPT_SET_OILLIMIT_0F;
					dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", 8);
				}
				else
					dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", 8);
				IPT_DSP_WAIT();
			}
			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			memset(dsp_buffer, ' ', 16);	dsp_len=16;
			dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
		}

		//fj:先注释
		//szb_fj_20171120:add ,双编码器大流量无脉冲超时时间控制1BCD 秒5-20 默认8
	/*	if(KB_KEYLOCK_OIL!=iptparam->KeyLock && 10==iptparam->SetButtonLen && 0==memcmp(iptparam->SetButton, "96136222", 8))
		{
			data=((iptparam->SetButton[8]-0x30)<<4)+(iptparam->SetButton[9]-0x30);
			if((data>=0x05) && (data<=0x20))
			{
				istate=jlBigVolTimeWrite(iptparam->JlNozzle,data);
				if(istate==0)
				{
					dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", 8);
					IPT_DSP_WAIT();
				}
				else
				{
					dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", 8);
					IPT_DSP_WAIT();
				}	
			}
			else
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "输入值5-20", strlen("输入值5-20"));
				IPT_DSP_WAIT();
			}

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			memset(dsp_buffer, ' ', 16);	dsp_len=16;
			dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
		}
		//szb_fj_20171120,add 双编码器大流量流速控制1BCD L/分 10 - 80 默认15
		if(KB_KEYLOCK_OIL!=iptparam->KeyLock && 10==iptparam->SetButtonLen && 0==memcmp(iptparam->SetButton, "96136223", 8))
		{
			data=((iptparam->SetButton[8]-0x30)<<4)+(iptparam->SetButton[9]-0x30);
			if((data>=0x10) && (data<=0x80))
			{
				istate=jlBigVolSpeedWrite(iptparam->JlNozzle,data);
				if(istate==0)
				{
					dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", 8);
					IPT_DSP_WAIT();
				}
				else
				{
					dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", 8);
					IPT_DSP_WAIT();
				}	
			}
			else
			{
				dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "输入值10-80", strlen("输入值10-80"));
				IPT_DSP_WAIT();
			}

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			memset(dsp_buffer, ' ', 16);	dsp_len=16;
			dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);

		}*/

		break;

	default:
		break;
	}
	return;
}


/*******************************************************************
*Name				:iptKeyDDownload
*Description		:密钥下载
*Input				:None
*Output			:None
*Return				:None
*History			:2014-04-17,modified by syj  */

static void iptKeyDDownload(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	char outbuffer[512]={0}, dsp_buffer[64]={0}, dsp_len=0, board_id[8]={0}, board_key[16]={0};
	int istate=0, apdu_len=0, key_shengyu_len=0, key_all_len=0, i=0;
	unsigned long long bcd_value=0;


	//有卡插入时开始下载密钥
	if(0x30==iptparam->IcState.DeckStateS1)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "密钥下载中...", 13);

		//复位IC卡
		istate=ICReset(iptparam->DEVIC, 0);
		if(0!=istate)
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡复位失败", 12);
			ICShoot(iptparam->DEVIC);

			iptPidSet(iptparam, IPT_PID_OTHER_WAIT);	iptparam->NousedTimer=0;
			return;
		}

		//ADF选择
		istate=ICKeyADFSelect(iptparam->DEVIC, outbuffer, 512);
		if(0==istate)
		{
			apdu_len=(outbuffer[0]<<8)|(outbuffer[1]<<0);
			if(0!=memcmp(&outbuffer[2+apdu_len-2], "\x90\x00", 2)){
					
				memcpy(&dsp_buffer[0], &outbuffer[2+apdu_len-2], 2);
				dsp_buffer[2]=13;	memcpy(&dsp_buffer[3], "IC卡选择ADF错", 13);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				ICShoot(iptparam->DEVIC);

				iptPidSet(iptparam, IPT_PID_OTHER_WAIT);	iptparam->NousedTimer=0;
				return;
			}
		}
		else
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡选择ADF失败", 15);
			ICShoot(iptparam->DEVIC);

			iptPidSet(iptparam, IPT_PID_OTHER_WAIT);	iptparam->NousedTimer=0;
			return;
		}

		//验证PIN，默认PIN为"373531383531"
		istate=ICPinCheck(iptparam->DEVIC, 0, outbuffer, 512, "373531383531", 12);
		if(0==istate)
		{
			apdu_len=(outbuffer[0]<<8)|(outbuffer[1]<<0);
			if(0!=memcmp(&outbuffer[2+apdu_len-2], "\x90\x00", 2))
			{		
				memcpy(&dsp_buffer[0], &outbuffer[2+apdu_len-2], 2);
				dsp_buffer[2]=14;	memcpy(&dsp_buffer[3], "IC卡密码验证错", 14);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				ICShoot(iptparam->DEVIC);

				iptPidSet(iptparam, IPT_PID_OTHER_WAIT);	iptparam->NousedTimer=0;
				return;
			}
		}
		else
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡密码验证失败", 16);
			ICShoot(iptparam->DEVIC);

			iptPidSet(iptparam, IPT_PID_OTHER_WAIT);	iptparam->NousedTimer=0;
			return;
		}

		//选择EF 01文件
		istate=ICKeyEF01Select(iptparam->DEVIC, outbuffer, 512);
		if(0==istate)
		{
			apdu_len=(outbuffer[0]<<8)|(outbuffer[1]<<0);
			if(0!=memcmp(&outbuffer[2+apdu_len-2], "\x90\x00", 2))
			{		
				memcpy(&dsp_buffer[0], &outbuffer[2+apdu_len-2], 2);
				dsp_buffer[2]=14;	memcpy(&dsp_buffer[3], "IC卡选择EF01错", 14);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				ICShoot(iptparam->DEVIC);

				iptPidSet(iptparam, IPT_PID_OTHER_WAIT);	iptparam->NousedTimer=0;
				return;
			}
		}
		else
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡选择EF01失败", 16);
			ICShoot(iptparam->DEVIC);

			iptPidSet(iptparam, IPT_PID_OTHER_WAIT);	iptparam->NousedTimer=0;
			return;
		}

		//读取EF 01文件
		istate=ICKeyEF01Read(iptparam->DEVIC, outbuffer, 512);
		if(0==istate)
		{
			apdu_len=(outbuffer[0]<<8)|(outbuffer[1]<<0);
			if(0==memcmp(&outbuffer[2+apdu_len-2], "\x90\x00", 2))
			{
				key_all_len=(outbuffer[2]<<8)|(outbuffer[3]<<0);
				key_shengyu_len=(outbuffer[4]<<8)|(outbuffer[5]<<0);
			}
			else
			{		
				memcpy(&dsp_buffer[0], &outbuffer[2+apdu_len-2], 2);
				dsp_buffer[2]=12;	memcpy(&dsp_buffer[3], "IC卡读EF01错", 12);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				ICShoot(iptparam->DEVIC);

				iptPidSet(iptparam, IPT_PID_OTHER_WAIT);	iptparam->NousedTimer=0;
				return;
			}
		}
		else
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡读EF01失败", 14);
			ICShoot(iptparam->DEVIC);
			
			iptPidSet(iptparam, IPT_PID_OTHER_WAIT);	iptparam->NousedTimer=0;
			return;
		}

		//判断是否有未下载数据
		if(key_shengyu_len<=0)
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "卡内剩余条数为0", 15);
			ICShoot(iptparam->DEVIC);

			iptPidSet(iptparam, IPT_PID_OTHER_WAIT);	iptparam->NousedTimer=0;
			return;
		}

		//判断剩余条数不能超过总条数
		if(key_shengyu_len>key_all_len)
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "卡内剩余条数非法", 16);
			ICShoot(iptparam->DEVIC);

			iptPidSet(iptparam, IPT_PID_OTHER_WAIT);	iptparam->NousedTimer=0;
			return;
		}

		//选择EF 02文件
		istate=ICKeyEF02Select(iptparam->DEVIC, outbuffer, 512);
		if(0==istate)
		{
			apdu_len=(outbuffer[0]<<8)|(outbuffer[1]<<0);
			if(0!=memcmp(&outbuffer[2+apdu_len-2], "\x90\x00", 2))
			{		
				memcpy(&dsp_buffer[0], &outbuffer[2+apdu_len-2], 2);
				dsp_buffer[2]=14;	memcpy(&dsp_buffer[3], "IC卡选择EF02错", 14);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				ICShoot(iptparam->DEVIC);

				iptPidSet(iptparam, IPT_PID_OTHER_WAIT);	iptparam->NousedTimer=0;
				return;
			}
		}
		else
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡选择EF02失败", 16);
			ICShoot(iptparam->DEVIC);

			iptPidSet(iptparam, IPT_PID_OTHER_WAIT);	iptparam->NousedTimer=0;
			return;
		}

		//读取EF 02文件
		istate=ICKeyEF02Read(iptparam->DEVIC, outbuffer, 512, (key_all_len-key_shengyu_len)*26, 26);
		if(0==istate)
		{
			apdu_len=(outbuffer[0]<<8)|(outbuffer[1]<<0);
			if(0==memcmp(&outbuffer[2+apdu_len-2], "\x90\x00", 2))
			{
				memcpy(board_id, &outbuffer[2], 8);			//主板号
				memcpy(board_key, &outbuffer[10], 16);		//密钥
			}
			else
			{
				memcpy(&dsp_buffer[0], &outbuffer[2+apdu_len-2], 2);
				dsp_buffer[2]=12;	memcpy(&dsp_buffer[3], "IC卡读EF02错", 12);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				ICShoot(iptparam->DEVIC);

				iptPidSet(iptparam, IPT_PID_OTHER_WAIT);	iptparam->NousedTimer=0;
				return;
			}
		}
		else
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡读EF02失败", 14);
			ICShoot(iptparam->DEVIC);
			
			iptPidSet(iptparam, IPT_PID_OTHER_WAIT);	iptparam->NousedTimer=0;
			return;
		}

		//密钥存储，主板号及存储在铁电中
		//	存储在配置信息区域的前8字节存储主板号
		//	密钥通过一定的处理存储在后32字节中，使其在键盘上显示时按照四行八列的规则第1、3、4、8列为密钥，显示如下:
		//	M1	+X	+M5	+M9	+X	+X	+X	+M13
		//	M2	+X	+M6	+M10	+X	+X	+X	+M14
		//	M3	+X	+M7	+M11	+X	+X	+X	+M15
		//	M4	+X	+M8	+M12	+X	+X	+X	+M16
		//	存储顺序自第一行左起第一位至第四行最末尾依次存储，其中的X为随机数
		
		memcpy(&outbuffer[0], board_id, 8);
		
		outbuffer[8+0]=board_key[0];							outbuffer[8+1]=iptparam->Time.century+100;		
		outbuffer[8+2]=board_key[4];							outbuffer[8+3]=board_key[8];	
		outbuffer[8+4]=iptparam->Time.minute+89;	outbuffer[8+5]=iptparam->Time.minute+66;	
		outbuffer[8+6]=iptparam->Time.second+3;	outbuffer[8+7]=board_key[12];

		outbuffer[8+8]=board_key[1];							outbuffer[8+9]=iptparam->Time.date+100;			
		outbuffer[8+10]=board_key[5];						outbuffer[8+11]=board_key[9];
		outbuffer[8+12]=iptparam->Time.minute+4;	outbuffer[8+13]=iptparam->Time.second+66;	
		outbuffer[8+14]=iptparam->Time.second+3;	outbuffer[8+15]=board_key[13];

		outbuffer[8+16]=board_key[2];						outbuffer[8+17]=iptparam->Time.century+100;	
		outbuffer[8+18]=board_key[6];						outbuffer[8+19]=board_key[10];	
		outbuffer[8+20]=iptparam->Time.year+89;	outbuffer[8+21]=iptparam->Time.minute+66;	
		outbuffer[8+22]=iptparam->Time.minute+3;	outbuffer[8+23]=board_key[14];

		outbuffer[8+24]=board_key[3];						outbuffer[8+25]=iptparam->Time.century+125;	
		outbuffer[8+26]=board_key[7];						outbuffer[8+27]=board_key[11];	
		outbuffer[8+28]=iptparam->Time.hour+89;	outbuffer[8+29]=iptparam->Time.minute+44;	
		outbuffer[8+30]=iptparam->Time.century+3;	outbuffer[8+31]=board_key[15];
		if(0==framWrite(FM_ADDR_CONFIG, 0, outbuffer, 40))
		{
			//更新密钥
			memcpy(MboardID, &outbuffer[0], 8);
			memcpy(KeyData, &outbuffer[8], 32);
			Key[0]=KeyData[0];		Key[1]=KeyData[8];		Key[2]=KeyData[16];		Key[3]=KeyData[24];
			Key[4]=KeyData[2];		Key[5]=KeyData[10];		Key[6]=KeyData[18];		Key[7]=KeyData[26];
			Key[8]=KeyData[3];		Key[9]=KeyData[11];		Key[10]=KeyData[19];	Key[11]=KeyData[27];
			Key[12]=KeyData[7];		Key[13]=KeyData[15];	Key[14]=KeyData[23];	Key[15]=KeyData[31];
		}
		else
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "密钥存储错误", 12);
			ICShoot(iptparam->DEVIC);

			iptPidSet(iptparam, IPT_PID_OTHER_WAIT);	iptparam->NousedTimer=0;
			return;
		}

		//选择EF 01文件
		istate=ICKeyEF01Select(iptparam->DEVIC, outbuffer, 512);
		if(0==istate)
		{
			apdu_len=(outbuffer[0]<<8)|(outbuffer[1]<<0);
			if(0!=memcmp(&outbuffer[2+apdu_len-2], "\x90\x00", 2))
			{		
				memcpy(&dsp_buffer[0], &outbuffer[2+apdu_len-2], 2);
				dsp_buffer[2]=12;	memcpy(&dsp_buffer[3], "选择01文件错", 12);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				ICShoot(iptparam->DEVIC);

				iptPidSet(iptparam, IPT_PID_OTHER_WAIT);	iptparam->NousedTimer=0;
				return;
			}
		}
		else
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "选择01文件失败", 14);
			ICShoot(iptparam->DEVIC);
			
			iptPidSet(iptparam, IPT_PID_OTHER_WAIT);	iptparam->NousedTimer=0;
			return;
		}

		//修改EF 01文件未下载条数
		key_shengyu_len--;
		istate=ICKeyEF01Write(iptparam->DEVIC, outbuffer, 512, key_shengyu_len);
		if(0==istate)
		{
			apdu_len=(outbuffer[0]<<8)|(outbuffer[1]<<0);
			if(0==memcmp(&outbuffer[2+apdu_len-2], "\x90\x00", 2))
			{}
			else
			{		
				memcpy(&dsp_buffer[0], &outbuffer[2+apdu_len-2], 2);
				dsp_buffer[2]=12;	memcpy(&dsp_buffer[3], "IC卡写EF01错", 12);
				dsp(iptparam->DEVDsp, DSP_CARD_ERR_INFO, dsp_buffer, 3+dsp_buffer[2]);
				ICShoot(iptparam->DEVIC);

				iptPidSet(iptparam, IPT_PID_OTHER_WAIT);	iptparam->NousedTimer=0;
				return;
			}
		}
		else
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "IC卡写EF01失败", 14);
			ICShoot(iptparam->DEVIC);

			iptPidSet(iptparam, IPT_PID_OTHER_WAIT);	iptparam->NousedTimer=0;
			return;
		}

		//下载成功
		memcpy(&dsp_buffer[0], "  密钥下载成功  ", 16);
		memset(&dsp_buffer[16], ' ', 32);
		bcd_value=hex2Bcd(key_all_len);
		memcpy(&dsp_buffer[16], "总计:", 5);
		dsp_buffer[21]=(char)((bcd_value>>16)&0x0f)+0x30;dsp_buffer[22]=(char)((bcd_value>>12)&0x0f)+0x30;
		dsp_buffer[23]=(char)((bcd_value>>8)&0x0f)+0x30;	dsp_buffer[24]=(char)((bcd_value>>4)&0x0f)+0x30;
		for(i=0; i<4; i++)
		{
			if('0'==dsp_buffer[21+i])	dsp_buffer[21+i]=' ';
			else									break;
		}
		dsp_buffer[25]=(char)((bcd_value>>0)&0x0f)+0x30;	memcpy(&dsp_buffer[26], "条", 2);
		bcd_value=hex2Bcd(key_shengyu_len);
		memcpy(&dsp_buffer[32], "剩余:", 5);
		dsp_buffer[37]=(char)((bcd_value>>16)&0x0f)+0x30;	dsp_buffer[38]=(char)((bcd_value>>12)&0x0f)+0x30;
		dsp_buffer[39]=(char)((bcd_value>>8)&0x0f)+0x30;	dsp_buffer[40]=(char)((bcd_value>>4)&0x0f)+0x30;
		for(i=0; i<4; i++)
		{
			if('0'==dsp_buffer[37+i])	dsp_buffer[37+i]=' ';
			else									break;
		}
		dsp_buffer[41]=(char)((bcd_value>>0)&0x0f)+0x30;	memcpy(&dsp_buffer[42], "条", 2);
		dsp_len=48;
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);
		IPT_DSP_WAIT();

		ICShoot(iptparam->DEVIC);
		iptPidSet(iptparam, IPT_PID_OTHER_WAIT);	iptparam->NousedTimer=0;
		return;
	}

	//按"更改"键返回其他操作代码输入界面
	if(KB_BUTTON_CHG==iptparam->Button)
	{
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		memset(&dsp_buffer[0], ' ', 16);	dsp_len=16;
		dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
		iptPidSet(iptparam, IPT_PID_OTHER);
		return;
	}
	
	return;
}


/*******************************************************************
*Name				:iptModelSet
*Description		:机型设置
*Input				:None
*Output			:None
*Return				:None
*History			:2014-04-17,modified by syj  */

static void iptModelSet(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	char dsp_buffer[128] = {0};
	int dsp_len = 0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_UP:
	case KB_BUTTON_DOWN:

		if(KB_BUTTON_UP == iptparam->Button && iptparam->SetParam <= MODEL_PARAM_MIN)
		{
			iptparam->SetParam = MODEL_PARAM_MAX;
		}
		else if(KB_BUTTON_UP == iptparam->Button && iptparam->SetParam > MODEL_PARAM_MIN)
		{
			iptparam->SetParam--;
		}
		else if(KB_BUTTON_DOWN == iptparam->Button && iptparam->SetParam >= MODEL_PARAM_MAX)
		{
			iptparam->SetParam = MODEL_PARAM_MIN;
		}
		else if(KB_BUTTON_DOWN == iptparam->Button && iptparam->SetParam < MODEL_PARAM_MAX)
		{
			iptparam->SetParam++;
		}

		strcpy(dsp_buffer, " 请按↑↓键设置 ");
		strcpy(dsp_buffer + strlen(dsp_buffer), ModelParam[iptparam->SetParam]);
		if(strlen(dsp_buffer) < 3*16)	memset(dsp_buffer + strlen(dsp_buffer), ' ', 3*16 - strlen(dsp_buffer));
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, strlen(dsp_buffer));
		break;
	case KB_BUTTON_ACK:
		if(0 == paramModelSet(iptparam->SetParam))
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置成功，重启油机后生效!", strlen("设置成功，重启油机后生效!"));
			IPT_DSP_WAIT();
		
			//返回其它操作代码输入界面
			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
			memset(&dsp_buffer[0], ' ', 16);	dsp_len=16;
			dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
			iptPidSet(iptparam, IPT_PID_OTHER);
		}
		else
		{
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "设置失败", strlen("设置失败"));
			IPT_DSP_WAIT();
		
			strcpy(dsp_buffer, " 请按↑↓键设置 ");
			strcpy(dsp_buffer + strlen(dsp_buffer), ModelParam[iptparam->SetParam]);
			if(strlen(dsp_buffer) < 3*16)	memset(dsp_buffer + strlen(dsp_buffer), ' ', 3*16 - strlen(dsp_buffer));
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, strlen(dsp_buffer));
		}
		break;
	case KB_BUTTON_CHG:
	case KB_BUTTON_BACK:
		//返回其它操作代码输入界面
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		memset(&dsp_buffer[0], ' ', 16);	dsp_len=16;
		dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
		iptPidSet(iptparam, IPT_PID_OTHER);
		break;
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptOtherSumWrite
*Description		:累计数修改过程
*Input				:None
*Output			:None
*Return				:None
*History			:2016-06-12,modified by syj  */

static void iptOtherSumWrite(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char button = 0;
	char dsp_buffer[128] = {0};

	int istate = 0;
	int dsp_len = 0;
	int element = 0;
	unsigned long long value = 0, pdata = 0;

	switch(iptparam->Button)
	{
	case KB_BUTTON_0:
		if(0==button)	button='0';
	case KB_BUTTON_1:
		if(0==button)	button='1';
	case KB_BUTTON_2:
		if(0==button)	button='2';
	case KB_BUTTON_3:
		if(0==button)	button='3';
	case KB_BUTTON_4:
		if(0==button)	button='4';
	case KB_BUTTON_5:
		if(0==button)	button='5';
	case KB_BUTTON_6:
		if(0==button)	button='6';
	case KB_BUTTON_7:
		if(0==button)	button='7';
	case KB_BUTTON_8:
		if(0==button)	button='8';
	case KB_BUTTON_9:
		if(0==button)	button='9';
		//保存按键代码
		if(iptparam->SetButtonLen < 14)
		{
			iptparam->SetButton[iptparam->SetButtonLen++] = button;

			strncpy(dsp_buffer, "  请输入修改值  ", 16);
			memset(dsp_buffer + 16, ' ', 16);	
			memcpy(&dsp_buffer[16 - iptparam->SetButtonLen + 16], iptparam->SetButton, iptparam->SetButtonLen);
			dsp_len = 32;
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);
		}
		break;

	case KB_BUTTON_ACK:
		//确认修改，修改累计升数/金额，计算修改值
		if(14 == iptparam->SetButtonLen && 0 == memcmp(iptparam->SetButton, "11", 2))	element = 1;
		if(14 == iptparam->SetButtonLen && 0 == memcmp(iptparam->SetButton, "22", 2))	element = 2;
		if(1 == element || 2 == element)
		{
			pdata = (iptparam->SetButton[2])&0x0F;		pdata = pdata*100000000000;
			value += pdata;
			pdata = (iptparam->SetButton[3])&0x0F;		pdata = pdata*10000000000;
			value += pdata;
			pdata = (iptparam->SetButton[4])&0x0F;		pdata = pdata*1000000000;
			value += pdata;
			pdata = (iptparam->SetButton[5])&0x0F;		pdata = pdata*100000000;
			value += pdata;
			pdata = (iptparam->SetButton[6])&0x0F;		pdata = pdata*10000000;
			value += pdata;
			pdata = (iptparam->SetButton[7])&0x0F;		pdata = pdata*1000000;
			value += pdata;
			pdata = (iptparam->SetButton[8])&0x0F;		pdata = pdata*100000;
			value += pdata;
			pdata = (iptparam->SetButton[9])&0x0F;		pdata = pdata*10000;
			value += pdata;
			pdata = (iptparam->SetButton[10])&0x0F;		pdata = pdata*1000;
			value += pdata;
			pdata = (iptparam->SetButton[11])&0x0F;		pdata = pdata*100;
			value += pdata;
			pdata = (iptparam->SetButton[12])&0x0F;		pdata = pdata*10;
			value += pdata;
			pdata = (iptparam->SetButton[13])&0x0F;		pdata = pdata*1;
			value += pdata;
		}

		//修改数据并判断修改结果
		//if(1 == element)	istate = jlSumWrite(iptparam->JlNozzle, 0, value);
		//if(2 == element)	istate = jlSumWrite(iptparam->JlNozzle, 1, value);
		if(1 == element || 2 == element)
		{
			if(0 == istate)	dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作成功", strlen("操作成功"));
			else					dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "操作失败", strlen("操作失败"));
			IPT_DSP_WAIT();

			memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		
			strncpy(dsp_buffer, "  请输入修改值  ", 16);
			memset(dsp_buffer + 16, ' ', 16);
			memcpy(&dsp_buffer[16-iptparam->SetButtonLen + 16], iptparam->SetButton, iptparam->SetButtonLen);
			dsp_len = 32;
			dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);
			break;
		}
		break;
		
	case KB_BUTTON_CHG:
		//清除输入值
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		
		strncpy(dsp_buffer, "  请输入修改值  ", 16);
		memset(dsp_buffer + 16, ' ', 16);
		memcpy(&dsp_buffer[16-iptparam->SetButtonLen + 16], iptparam->SetButton, iptparam->SetButtonLen);
		dsp_len = 32;
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, dsp_buffer, dsp_len);
		break;
		
	case KB_BUTTON_BACK:
		//返回其它操作代码输入界面
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		memset(&dsp_buffer[0], ' ', 16);	dsp_len=16;
		dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
		iptPidSet(iptparam, IPT_PID_OTHER);
		break;
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptOtherOperatWait
*Description		:其它操作显示结果后转入本过程等待操作，
*						:按任意键或超时无操作则退出到
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptOtherOperatWait(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	unsigned char dsp_buffer[64]={0}, dsp_len=0;

	if(KB_BUTTON_NO!=iptparam->Button || iptparam->NousedTimer>=60*ONE_SECOND)
	{
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		memset(&dsp_buffer[0], ' ', 16);	dsp_len=16;
		dsp(iptparam->DEVDsp, DSP_OTHER_OPERATE, dsp_buffer, dsp_len);
		iptPidSet(iptparam, IPT_PID_OTHER);
	}

	return;
}


/*******************************************************************
*Name				:iptWarning
*Description		:支付终端报警等到操作过程
*Input				:None
*Output			:None
*Return				:None
*History			:2014-11-03,modified by syj  */

static void iptWarning(IptParamStructType *iptparam, char *msg_buffer,	int msg_len)
{
	if(KB_BUTTON_NO!=iptparam->Button)
	{
		ICShoot(iptparam->DEVIC);
		iptMainInterface(iptparam);
	}

	return;
}


/*******************************************************************
*Name				:iptActionProcess
*Description		:处理油机上传给平板电脑的动作
*Input				:None
*Output			:None
*Return			:None
*History			:2013-07-01,modified by syj  */

static void iptActionProcess(IptParamStructType *iptparam, unsigned char *msg_buffer,	int msg_len)
{
	int play_state = 0, play_chg = 0;
	int iaction = ERROR;

	//非促销机不处理后续操作
	if(1 != paramPromotionGet())
	{
		return;
	}

	//判断如果有动作时通知平板电脑 (人体感应、拍奖按钮、油品选择、按键、提挂枪)
	iptparam->SensorState = kbPIRSateRead(iptparam->DEVSensor);
	if(iptparam->SensorStateLast != iptparam->SensorState && 0 == iptparam->SensorState)	
	{
		iaction = PC_ACTION_SENSOR;
	}
	iptparam->SensorStateLast = iptparam->SensorState;
	if(1 == iptparam->ValuePlayButton)			iaction = PC_ACTION_PLAY;
	if(KB_BUTTON_ACK == iptparam->Button)	iaction = PC_ACTION_BUTTON;
	if(0 != iptparam->GunStateChg)					iaction = PC_ACTION_GUN;
	if(ERROR != iaction)
	{
		pcActionUpload(iptparam->TabletPanel, iptparam->LogicNozzle, iaction);
	}

	//读取PLAY按钮状态，如果PLAY按钮从抬起状态变为按下状态时记录一次操作，此操作持续4秒时上传长按钮动作
	play_state = kbSwitchRead(iptparam->DEVPlayButton, &play_chg);
	if(0 != play_state)	iptparam->PlayLongTimer = 0;
	if(0 == play_state && 0 != iptparam->PlayLongLast)	iptparam->PlayLong = 1;
	iptparam->PlayLongLast = play_state;
	if(1 == iptparam->PlayLong && iptparam->PlayLongTimer >= 4*1000)
	{
		iptparam->PlayLong = 0;
		pcActionUpload(iptparam->TabletPanel, iptparam->LogicNozzle, PC_ACTION_PLAY_4SECOND);
	}

	return;
}


/*******************************************************************
*Name				:iptPollProcess
*Description		:支付终端在大循环中需要读取状态等处理
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptPollProcess(IptParamStructType *iptparam,char *msg_buffer,	int msg_len)
{
	unsigned char ibuffer[64]={0};
	int ilength=0;
	char dsp_buffer[128] = {0};
	int dsp_len = 0;
	//int play_state = 0, play_chg = 0;
	PCOilInfoType oilinfo;
	//int iaction = ERROR;

	//读取按键
	iptparam->Button=tdButtonRead(iptparam->DEVButton);
	if(KB_BUTTON_NO != iptparam->Button) 
		iptparam->NousedTimer = 0;

	//促销机获取PLAY按钮
	tdYPRead(iptparam->DEVPlayButton, &(iptparam->ValuePlayButton));
	if(1 == iptparam->ValuePlayButton)
	{
		iptparam->YPSelect = 1;
		if((IPT_NOZZLE_1 == iptparam->Id) && (PANEL_NOZZLE_DOUBLE == paramPanelNozzleGet()))
		{
			IptParamB.YPSelect = 1;
		}
	}

	//读取设置锁状态
	iptparam->KeyLock=spi1LockRead(&iptparam->KeyLockChg);
	
	//读取油枪状态
	iptparam->GunState=spi1GunRead(iptparam->DEVGun, &iptparam->GunStateChg);
	//printf("ipt GunState = %d,DEVGunNo = %d\n",iptparam->GunState,iptparam->DEVGun);

	//读取时钟
	timeRead(&iptparam->Time);
	
	//IPT<->PCD普通通讯处理
	ipt2PcdPoll(iptparam, msg_buffer, msg_len);
    //printf("ipt2PcdPoll\n");

	//printf("DEVIC = %d\n",iptparam->DEVIC);
	
	//读取卡状态，无卡时清除卡有效状态
	ICStateRead(iptparam->DEVIC, &iptparam->IcState);
	if((0x30!=iptparam->IcState.DeckStateS1) && (0!=iptparam->IcValid) && iptparam->EtcOilFlg == 0)
	{
		iptparam->IcValid=0;
	}

	//判断是否有销售锁定，销售锁定标识未立，销售锁定时间非0且合法，当前时间已达到销售锁定时间则置位将销售锁定标识
	ibuffer[0]=iptparam->Time.century;	ibuffer[1]=iptparam->Time.year;
	ibuffer[2]=iptparam->Time.month;		ibuffer[3]=iptparam->Time.date;
	if(IPT_SELL_UNLOCK==iptparam->SellLock &&\
		0!=memcmp(iptparam->SLockTime, "\x00\x00\x00\x00", 4) &&\
		0==timeVerification(ibuffer, 4) &&\
		memcmp(iptparam->SLockTime, ibuffer, 4)>=0)
	{
		iptparam->SellLock=IPT_SELL_LOCK;
		memcpy(ibuffer, iptparam->SLockTime, 4);	ibuffer[4]=IPT_SELL_LOCK;
		paramSetupWrite(PRM_SELL_LOCK_TIME, ibuffer, 5);
	}

	//提枪，处于操作界面且不禁止强制更改PID时强制转入待机界面
	if((IPT_GUN_PUTUP == iptparam->GunState && 0 != iptparam->GunStateChg) &&\
		(0x00000100 == (iptparam->ProcessId & 0x0000ff00) &&\
		0 == iptChgPidForce(iptparam->Id)))
	{
		iptMainInterface(iptparam);
	}

	//按"↓"键重打印当次条码加油小
	if(KB_BUTTON_DOWN == iptparam->Button && 1 == iptparam->BarBillPrintRepeat)
	{
		iptparam->BarBillPrintRepeat = 0;
		iptPrint(iptparam, 4, iptparam->BarOilBill, IPT_BAR_BILL_SIZE);
	}

	//按"↑"键重打印当次IC卡加油小票
	if(KB_BUTTON_UP == iptparam->Button && 1 == iptparam->OilBillPrintRepeat)
	{
		iptparam->OilBillPrintRepeat = 0;
		iptPrint(iptparam, iptparam->PrintUnion, iptparam->OilBill, IPT_BILL_SIZE);
	}
	
	//判断输入密码界面，待机界面、授权界面或操作界面且不禁止强制更改PID时转入输入密码界面
	if(1 == iptparam->PassInputAsk &&\
		(IPT_PID_STANDBY == iptparam->ProcessId || IPT_PID_AUTH_BALANCE == iptparam->ProcessId || (0x00000100 == (iptparam->ProcessId & 0x0000ff00) && 0 == iptChgPidForce(iptparam->Id))))
	{
		memset(iptparam->AuthorizeData, 0, sizeof(iptparam->AuthorizeData));
		authorizeWrite(iptparam->Id, iptparam->AuthorizeData); //fj:
	
		memset(iptparam->SetButton, 0, 16);	iptparam->SetButtonLen=0;
		dsp(iptparam->DEVDsp, DSP_PASSWORD_INPUT, "\x00", 1);
		iptPidSet(iptparam, IPT_PID_AUTH_PASS_INPUT);

		jljUserLog("有外部请求转入密码输入界面!\n");
		
		iptparam->PassInputAsk = 0;
	}

	//判断授权，待机界面或操作界面且不禁止强制更改PID时转入授权界面
	if(1 == iptparam->AuthorizeAsk &&\
		(IPT_PID_STANDBY == iptparam->ProcessId || (0x00000100 == (iptparam->ProcessId & 0x0000ff00) && 0 == iptChgPidForce(iptparam->Id))))
	{
		authorizeWrite(iptparam->Id, iptparam->AuthorizeData); //fj:
		iptPidSet(iptparam, IPT_PID_AUTH_PRETREAT);

		jljUserLog("有外部请求进行授权!\n");

		iptparam->AuthorizeAsk = 0;
	}

	//判断取消授权，如果处于待机界面且不禁止强制更改PID时取消授权并返回待机界面
	if(2 == iptparam->AuthorizeAsk && IPT_PID_AUTH_BALANCE == iptparam->ProcessId)
	{
		authorizeWrite(iptparam->Id, iptparam->AuthorizeData); //fj:
		iptMainInterface(iptparam);

		jljUserLog("有外部请求取消授权!\n");

		iptparam->AuthorizeAsk = 0;
	}

	//判断进入支付流程
	if(1 == iptparam->CardDebitAsk && IPT_PID_IC_BALANCE == iptparam->ProcessId)
	{
		dsp(iptparam->DEVDsp, DSP_TEXT_INFO, "非油消费卡支付", strlen("非油消费卡支付"));
		
		iptPidSet(iptparam, IPT_PID_IC_DEBIT_START);

		jljUserLog("有外部请求进入支付流程!\n");

		iptparam->CardDebitAsk = 0;
	}

	//判断退出支付流程
	if(2 == iptparam->CardDebitAsk &&\
		(IPT_PID_IC_DEBIT_START == iptparam->ProcessId || IPT_PID_IC_DEBIT_DONE == iptparam->ProcessId))
	{
		iptPidSet(iptparam, IPT_PID_IC_BAL_READ);

		jljUserLog("有外部请求退出支付流程!\n");

		iptparam->CardDebitAsk = 0;
	}

	//判断非油消费扣款，卡余额界面或已进入卡支付过程则转入非油消费卡支付过程
	if(3 == iptparam->CardDebitAsk &&\
		(IPT_PID_IC_BALANCE == iptparam->ProcessId || IPT_PID_IC_DEBIT_START == iptparam->ProcessId))
	{
		*(dsp_buffer + 0) = (char)(iptparam->CardDebitAmount>>24);
		*(dsp_buffer + 1) = (char)(iptparam->CardDebitAmount>>16);
		*(dsp_buffer + 2) = (char)(iptparam->CardDebitAmount>>8);
		*(dsp_buffer + 3) = (char)(iptparam->CardDebitAmount>>0);
		dsp_len = 4;
		dsp(iptparam->DEVDsp, DSP_CARD_DEBIT, dsp_buffer, dsp_len);
		
		iptPidSet(iptparam, IPT_PID_IC_DEBIT_DONE);

		jljUserLog("有外部请求进行非油消费卡支付!\n");

		iptparam->CardDebitAsk = 0;
	}

	//判断开始条码扫描，待机界面或操作界面且不禁止强制更改PID时转入条码扫描过程
	if(1 == iptparam->TMScanAsk &&\
		(IPT_PID_STANDBY == iptparam->ProcessId || (0x00000100 == (iptparam->ProcessId & 0x0000ff00) && 0 == iptChgPidForce(iptparam->Id))))
	{
		iptPidSet(iptparam, IPT_PID_TM_PRETREAT);

		jljUserLog("有外部请求启动条码扫描!\n");

		iptparam->TMScanRep = 0;	iptparam->TMScanAsk = 0;	
	}

	//判断开始条码扫描，待机界面或操作界面且不禁止强制更改PID时转入条码扫描过程
	if(2 == iptparam->TMScanAsk &&\
		(IPT_PID_TM_PRETREAT == iptparam->ProcessId || IPT_PID_TM_SCAN == iptparam->ProcessId))
	{
		barStop(iptparam->DEVBarcode, BARCODE_USER_NO);
		iptMainInterface(iptparam);

		jljUserLog("有外部请求退出条码扫描状态!\n");

		iptparam->TMScanRep = 0;	iptparam->TMScanAsk = 0;	
	}

	EtcFreeObuCourse(iptparam->Id); //szb_fj_20171120,add 释放OBU

	return;
}

//szb_fj_20171120:add 计量连续超过6次异常停机处理
int iptAbnormalStopHandle(IptParamStructType *iptparam,unsigned char stopcode,unsigned int money)
{
	//异常停机缺一路脉冲
	if(stopcode==1 || ((stopcode>=0x06) && (stopcode<=0x09)))
	{
		iptparam->JlErr_QYL++;
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+FM_ERR_QUEYILU_PULSE,&iptparam->JlErr_QYL, 1);
	}
	//异常停机无脉冲超时
	else if(stopcode==4)
	{
		iptparam->JlErr_WMCCS++;
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+FM_ERR_WU_PULSE,&iptparam->JlErr_WMCCS, 1);
	}
	//异常停机缺一组脉冲
	else if((stopcode>=0x10) && (stopcode<=0x13))
	{
		iptparam->JlErr_QYZ++;
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+FM_ERR_QUEYIZU_PULSE,&iptparam->JlErr_QYZ, 1);
	}
	//异常停机零加油
	else if(money==0)
	{
		iptparam->JlErr_ZERO++;
		framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+FM_ERR_LING_JIAYOU,&iptparam->JlErr_ZERO, 1);
	}
	else
	{
		//异常停机缺一路脉冲
		if(iptparam->JlErr_QYL>0)
		{
			iptparam->JlErr_QYL=0;
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+FM_ERR_QUEYILU_PULSE,&iptparam->JlErr_QYL, 1);
		}
		//异常停机无脉冲超时
		if(iptparam->JlErr_WMCCS>0)
		{
			iptparam->JlErr_WMCCS=0;
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+FM_ERR_WU_PULSE,&iptparam->JlErr_WMCCS, 1);
		}
		//异常停机缺一组脉冲
		if(iptparam->JlErr_QYZ>0)
		{
			iptparam->JlErr_QYZ=0;
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+FM_ERR_QUEYIZU_PULSE,&iptparam->JlErr_QYZ, 1);
		}
		//异常停机零加油
		if(iptparam->JlErr_ZERO>0)
		{
			iptparam->JlErr_ZERO=0;
			framWrite(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+FM_ERR_LING_JIAYOU,&iptparam->JlErr_ZERO, 1);
		}		
	}
}


/*******************************************************************
*Name				:iptPreProcess
*Description		:支付终端功能预处理
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

static void iptPreProcess(IptParamStructType *iptparam,unsigned char *msg_buffer,	int msg_len)
{
	switch(iptparam->ProcessId)
	{
	case IPT_PID_PRETREAT:				//上电预处理
		iptPretreat(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_STANDBY:				//待机过程
		iptStandby(iptparam, msg_buffer, msg_len);
		//printf("iptStandby \n");
		break;
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptIcProcess
*Description		:支付终端加油卡加油处理
*Input				:None
*Output			:None
*Return				:None
*History			:2014-11-03,modified by syj  */

static void iptIcProcess(IptParamStructType *iptparam,unsigned char *msg_buffer,	int msg_len)
{
	switch(iptparam->ProcessId)
	{
	case IPT_PID_IC_PRETREAT:					//IC卡预处理过程
		//printf("iptIcPretreat: \n");
		iptIcPretreat(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_PSAM_PRETREAT:			//PSAM预处理过程
		//printf("IPT_PID_PSAM_PRETREAT\n");
		iptIcPsamPretreat(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_CHECK:						//IC卡及PSAM卡合法性检查过程
		//printf("iptIcCheck:\n");
		iptIcCheck(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_DISCOUNT_ASK:		//(联达系统)向后台申请本次加油需要的数据
		//printf("IPT_PID_IC_DISCOUNT_ASK:\n");
		iptIcDiscountAsk(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_PIN_INPUT:				//IC卡用户密码输入界面
	    //printf("IPT_PID_IC_INPUT:\n");
		iptIcPinInput(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_PIN_CHECK:				//IC卡密码校验
	    //printf("IPT_PID_IC_PIN_CHECK:\n");
		iptIcPinCheck(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_STAF_PASSIN:			//限车号卡输入员工密码界面
	    //printf("IPT_PID_IC_STAF_PASSIN:\n");
		iptIcStaffPinInput(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_NOTES:						//IC卡历史交易记录查询
	    //printf("IPT_PID_IC_NOTES:\n");
		iptIcNotesRead(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_NOTES_CHECK:			//IC卡交易记录检查过程
	    //printf("IPT_PID_IC_NOTES_CHECK:\n");
		iptIcNotesCheck(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_BL_CHECK:				//IC卡黑/白名单查询
	    //printf("IPT_PID_IC_BL_CHECK:\n");
		iptIcBLCheck(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_LOCK_INFO:				//IC卡灰锁信息读取
		//printf("IPT_PID_LOCK_INFO\n");
		iptIcLockInfo(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_LOCKRECORD:			//灰记录查询
	    //printf("IPT_PID_IC_LOCKRECORD:\n");
		iptLockRecordGet(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_BAL_READ:				//IC卡余额读取
		//printf("iptIcBalanceRead:\n");
		iptIcBalanceRead(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_USER_ACK:				//用户卡显示余额确认界面
		iptIcBalanceUserAck(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_BALANCE:					//IC卡余额待机界面
		//printf("iptIcBalance:\n");
		iptIcBalance(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_PAY_UNIT:					//结算单位选择
		iptIcPayUnitSelect(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_PAY_MODE:				//结算方式选择
		iptIcPayModeSelect(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_LOGIN:						//员工上班登陆过程
		iptIcLogin(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_LOG_PASSIN:			//员工卡上班员工密码输入界面
		printf("iptIcLogPassin:\n");
		iptIcLogPassin(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_LOGOUT:					//加油卡:下班确认界面
		iptIcWorkOff(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_LOGOUT_PASSIN:		//加油卡:下班密码输入界面
		iptIcWorkOffPassin(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_OIL_ACK:					//加油卡:油品确认界面
		printf("iptIcOilAck:\n");
		iptIcOilAck(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_OILCHECK:				//加油数据/条件合法性检查
		printf("iptIcOilCheck:\n");
		iptIcOilCheck(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_OIL_AUTHEN:				//IC卡加油启动认证
		//printf("iptIcOilAuthen:\n");
		iptIcOilAuthen(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_LOCK_INIT:				//灰锁初始化
		//printf("iptIcLockInit:\n");
		iptIcLockInit(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_MAC1:						//PSAM计算MAC1
		//printf("iptIcMac1:\n");
		iptIcMac1(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_LOCK:						//IC卡灰锁
		//printf("iptIcLock:\n");
		iptIcLock(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_LOCK_GREYINFO:		//加油卡:IC卡灰锁超时后读取灰锁状态
		//printf("iptIcOilLockInfo:\n");
		iptIcOilLockInfo(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_ZD_ESCAPE:				//加油卡:加油过程产生逃卡账单
		//printf("iptIcZDEscape:\n");
		iptIcZDEscape(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_MAC2:						//PSAM验证MAC2
		//printf("iptIcMac2:\n");
		iptIcMac2(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_OILSTART:					//申请计量加油启动
		printf("iptIcOilStart:\n");
		iptIcOilStart(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_OILLING:					//加油中
		iptIcOilling(iptparam, msg_buffer, msg_len);
		usleep(5000);
		break;
	case IPT_PID_IC_OILFINISH:					//申请计量加油结束
		iptIcOilFinish(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_PSAM_GMAC:			//PSAM计算GMAC
		iptIcPsamGMAC(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_UNLOCK:					//IC卡解扣
		//printf("iptIcUnlock:\n");
		iptIcUnlock(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_TAC_CLEAR:				//IC卡TAC清除
		//printf("iptIcTACClear:\n");
		iptIcTACClear(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_TTC_GET:					//申请账单TTC
		//printf("iptIcTTCGet:\n");
		iptIcTTCGet(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_TMAC:						//计算账单TMAC
		iptIcTMAC(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_ZD_SAVE:					//加油账单保存过程
		iptIcZDSave(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_LASTSTEP:					//加油结束对于下一步操作的判断
		iptIcOilEnd(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_ENDACK:					//加油结束等待操作界面
		iptIcOilEndWait(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_ESCAPE_ERR:			//加油卡:逃卡报警界面
		iptIcEscapeWarning(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_OIL_OVERINFO:			//加油卡:加油过冲信息界面
		iptIcOilOverInfo(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_OIL_OVERSTAFF:		//加油卡:加油过冲员工密码输入界面
		iptIcOilOverStaffPassin(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_ACT_AUTHEN:					//ACT卡认证处理过程
		iptIcACTAuthen(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_RID_AUTHEN:					//RID卡认证处理过程
		iptIcRIDAuthen(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_DEBIT_START:			//加油卡:加油卡支付流程
		iptIcDebitStart(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_IC_DEBIT_DONE:			//加油卡:加油卡支付确认过程
		iptIcDebitDone(iptparam, msg_buffer, msg_len);
		break;
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptOperateProcess
*Description		:加油机查询/设置操作过程
*Input				:None
*Output			:None
*Return				:None
*History			:2014-11-03,modified by syj  */

static void iptOperateProcess(IptParamStructType *iptparam,unsigned char *msg_buffer,	int msg_len)
{
	switch(iptparam->ProcessId)
	{
	case IPT_PID_OPERATE_PASS:					//操作:油机操作准入密码验证界面
		iptOperatPassIn(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_OPERATE_SELECT:				//操作:操作选项选择
		iptOperatSelect(iptparam, msg_buffer, msg_len);
		break;
		
	case IPT_PID_INQUIRY:							//操作:查询选项选择
		iptInqInterface(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_INQ_ZD_SEL:						//操作:账单查询对象选择界面
		iptInqBillSelect(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_INQ_ZD_TTCIN:					//操作:账单查询TTC输入界面
		iptInqBillTTCInput(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_INQ_ZD_CHECK:					//操作:账单查询向PCD读账单数据过程
		iptInqBillFromPcd(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_INQ_ZD_INDEX:					//操作:账单查询索引界面
		iptInqBillIndex(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_INQ_ZD_DETAIL:					//操作:账单查询明细显示界面
		iptInqBillOriginalData(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_INQ_GUNINFO:					//操作:油枪信息查询界面
		iptInqNozzleInfo(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_INQ_BOARDINFO:				//操作:主板信息查询界面
		iptInqMboardInfo(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_INQ_PRN:							//操作:打印信息查询操作界面
		iptInqPrint(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_INQ_PRNCARD:					//操作:自动打印卡类选择
		iptInqPrintCardSelect(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_INQ_PRNTYPE:					//操作:自动打印账单类型
		iptInqPrnType(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_INQ_TAXMSUM:					//操作:税控月累月份输入界面
		iptInqTaxMonth(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_INQ_TAXDSUM:					//操作:税控日累日期输入界面
		iptInqTaxDate(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_INQUIRY_WAIT:					//操作:显示查询结果后等待按键操作返回查询选择界面
		iptInquiryWait(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_INQ_TAXWAIT:					//操作:税控查询结果提示后等待按键操作返回查询选择界面
		iptInquiryTaxWait(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_INQ_OILERRLOG:				//查询:查询加油异常日志
		iptInquiryOilErrLog(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_INQ_LOCAL_NET:				//查询:本地网络信息查询项选择界面
		iptInquiryLocalNetInfo(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_INQ_LOCAL_WAIT:				//查询:本地网络信息查询结果显示后等待过程
		iptInquiryLocalNetInfoWait(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_INQ_BACKSTAGE:				//查询:后台网络通讯配置查询项选择界面
		iptInquiryBackstageInfo(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_INQ_BACKS_WAIT:				//查询:后台网络通讯配置查询结果显示后等待过程
		iptInquiryBackstageInfoWait(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_INQ_TABLETPC:					//查询:平板电脑配置查询项选择界面
		iptInquiryTabletInfo(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_INQ_TABLET_WAIT:				//查询:平板电脑配置查询结果显示后等待过程
		iptInquiryTabletInfoWait(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_INQ_VERSION://szb_fj_20171120,add,查询版本信息	
		iptInquiryVersionInf(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET:									//操作:设置选项选择界面
		iptSetInterface(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_PRICE:							//操作:单价设置
		iptSetPrice(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_TIME:							//操作:时间设置
		iptSetTime(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_SCJD:							//操作:首次检定
		iptSetSCJD(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_CCJD:							//操作:出厂检定
		iptSetCCJD(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_BACKLIT:						//操作:背光设置
		iptSetBacklit(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_NIGHTLOCK:				//操作:夜间锁定设置
		iptSetNightLock(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_PASS_OLD:					//操作:操作密码设置，输入旧密码
		iptSetPasswordOld(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_PASS_NEW:					//操作:操作密码设置，输入新密码
		iptSetPasswordNew(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_PASS_ACK:					//操作:操作密码设置，确认新密码
		iptSetPasswordAck(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_PHYNOZZLE:				//操作:物理枪号设置
		iptSetPhysicalNozzle(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_TAXTIME:					//操作:税务时间设置
		iptSetTaxTime(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_SPEAKER:					//操作:语音扬声器设置
		iptSetSpeaker(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_SPKVOLUME:				//操作:语音音量设置
		iptSetVoiceVolume(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_SPKTYPE:					//操作:语音类型设置
		iptSetVoiceType(iptparam, msg_buffer, msg_len);
		break;				
	case IPT_PID_SET_PRINTER:						//操作:打印机设置
		iptSetPrinter(iptparam, msg_buffer, msg_len);
		break;	
	case IPT_PID_SET_PRNAUTO:					//操作:自动打印设置
		iptSetPrintAuto(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_PRNUNION:					//操作:打印联数设置
		iptSetPrintUnion(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_PRNAUTO_IC:				//操作:自动打印账单卡类型设置
		iptSetPrintCardSelect(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_PRNAUTO_ZD:				//操作:自动打印账单类型设置
		iptSetPrintBillType(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_ADVANCE:					//操作:计量提前量设置
		iptSetAdvance(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_UNPULSE_TIME:			//操作:计量无脉冲超时停机时间设置	
		iptSetUnpulseTime(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_STAFF_LIMIT:				//操作:员工卡是否允许加油设置
		iptSetStaffLimit(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_MODE:						//操作:模式设置
		iptSetMode(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_OILVOICE_SEL:			//操作:油品语音大项选择界面
		iptSetOilVoiceSelect(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_OILVOICE:					//操作:油品语音选择界面
		iptSetOilVoice(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_NOZZLE_NUM:			//设置:单面枪数设置界面
		iptSetNozzleNumber(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_BARBRAND:					//设置:条码扫描模块设置界面
		iptSetBarcodeBrand(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_TAX_WAIT:					//操作:税控设置结果等待处理界面
		iptSetTaxWait(iptparam, msg_buffer, msg_len);
		break;

	case IPT_PID_SET_CONNECT_TYPE:			//设置:后台连接方式设置
		iptSetConnectType(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_LOCAL_NET:				//设置:本地网络信息设置界面
		iptSetLocalNetInfo(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_LOCAL_IP:					//设置:本地网络IP地址设置界面
		iptSetLocalIP(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_LOCAL_MASK:				//设置:本地网络子网掩码设置界面
		iptSetLocalMASK(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_LOCAL_GATE:				//设置:本地网络默认网关设置界面
		iptSetLocalGateway(iptparam, msg_buffer, msg_len);
		break;

	case IPT_PID_SET_BACKSTAGE:				//设置:石化后台网络通讯设置界面
		iptSetBackstageInfo(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_BACK_CONNECT:			//设置:石化后台网络通讯方式设置界面
		iptSetBackstageConnect(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_BACK_IP:						//设置:石化后台网络通讯IP地址设置界面
		iptSetBackstageIP(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_BACK_PORT	:				//设置:石化后台网络通讯端口号设置界面
		iptSetBackstagePort(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_BACK_LOCAL_PORT:	//设置:石化后台网络通讯端口号设置界面
		iptSetBackstageLocalPort(iptparam, msg_buffer, msg_len);
		break;

	case IPT_PID_SET_PC_INFO:					//设置:平板电脑信息设置界面
		iptSetTabletInfo(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_PC_IP:							//设置:平板电脑IP地址设置界面
		iptSetTabletIp(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_PC_MASK:					//设置:平板电脑子网掩码设置界面
		iptSetTabletMask(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_PC_GATEWAY:				//设置:平板电脑默认网关设置界面
		iptSetTabletGateway(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_PC_DNS1:					//设置:平板电脑首选DNS设置界面
		iptSetTabletDNS1(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_PC_DNS2:					//设置:平板电脑备用DNS设置界面
		iptSetTabletDNS2(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_PC_FTP_IP:					//设置:平板电脑FTP服务器地址设置界面
		iptSetTabletFTPIP(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_PC_FTP_PORT:			//设置:平板电脑FTP服务器端口设置界面
		iptSetTabletFTPPort(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_PC_SERVER:				//设置:平板电脑的后台服务器IP地址
		iptSetTabletServerIP(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_PC_VOLUME:				//设置:平板电脑音量设置
		iptSetTabletVolume(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_PC_TELE_IP:				//设置:平板电脑语音对讲后台IP地址设置
		iptSetTabletTelephoneIP(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_PROMOTION:				//设置:设置促销功能是否启用
		iptSetPromotion(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_GRADE_FUN://设置:设置油品确认功能是否启用
		iptSetGradeFun(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_SET_ETC_FUN:  //szb_fj_20171120,add 设置ETC功能
		iptSetEtcFun(iptparam);
		break;
	case IPT_PID_SET_CONTRAST:					//设置:设置键盘显示对比度界面
		iptSetContrast(iptparam, msg_buffer, msg_len);
		break;

	case IPT_PID_OTH_PASS:							//操作:其它操作密码验证界面
		iptOtherPassInput(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_OTHER:								//操作:其它操作界面
		iptOtherOperat(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_OTHER_KEYLOAD:				//操作:密钥下载过程
		iptKeyDDownload(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_OTHER_MODEL:					//操作:机型设置过程
		iptModelSet(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_OTHER_SUMWRITE:			//操作:累计数修改过程
		iptOtherSumWrite(iptparam, msg_buffer, msg_len);
		break;
	case IPT_PID_OTHER_WAIT:						//操作:其它操作显示结果等待操作过程	
		iptOtherOperatWait(iptparam, msg_buffer, msg_len);
		break;
	default:
		break;
	}

	return;
}


/*******************************************************************
*Name				:iptTask
*Description		:IPT处理任务
*Input				:nozzle		枪选0=1号枪(A1枪)；1=2号枪(B1枪)
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

void iptTask(int nozzle)
{
	IptParamStructType *iptparam=NULL;
	unsigned char read_buffer[IPT_MSG_MAX_LEN]={0};
	struct msg_struct msg_stIptRecv;
	msg_stIptRecv.msgType = 0;
	int read_len=0;

	//printf("aaaaa = %d\n",nozzle);

	//选择支付终端
	if(IPT_NOZZLE_1==nozzle)			iptparam=&IptParamA;
	else if(IPT_NOZZLE_2==nozzle)	iptparam=&IptParamB;
	else													return;

	//IPT任务处理
	FOREVER
	{
		//消息接收,fj:20170914
		//read_len=msgQReceive(iptparam->MsgIdRx, read_buffer, IPT_MSG_MAX_LEN, NO_WAIT);
        
		read_len = msgrcv(iptparam->MsgIdRx,&msg_stIptRecv,IPT_MSG_MAX_LEN,0,IPC_NOWAIT);
		if (read_len > 0)
		{
			//memcpy(msg_stIptRecv.msgBuffer,read_buffer,read_len);//20170922
			memcpy(read_buffer,msg_stIptRecv.msgBuffer,read_len);
        	//printf("ipt recv\n");
			//PrintH(read_len,read_buffer);
		}
	    //printf("ce shi aaa \n");

		iptPollProcess(iptparam, read_buffer, read_len);

		//printf("Hex:iptparam->ProcessId = %02x\n",iptparam->ProcessId);

		//IPT过程处理,fj:以下功能暂时不处理。
		switch(iptparam->ProcessId & 0x0000ff00)
		{
		case 0x00000000:
			//预处理及待机界面
			//printf("waiting desktop......\n");
			iptPreProcess(iptparam, read_buffer, read_len);
			break;
		case 0x00000100:
			//查询/设置操作处理
			iptOperateProcess(iptparam, read_buffer, read_len);
			break;
		case 0x00000200:
			//加油卡加油处理
			iptIcProcess(iptparam, read_buffer, read_len);
			break;
		case 0x00000300:
			//非卡加油处理
			iptUnselfProcess(iptparam, read_buffer, read_len);
			break;
		case 0x00000400:
			//条码加油功能
			iptTMProcess(iptparam, read_buffer, read_len);
			break;
		case 0x00000500:
			//授权加油处理
			//authProccess(iptparam->Id, read_buffer, read_len); //fj:
			break;
		case 0x00000600:
			//加油机出错处理
			iptErrProcess(iptparam, read_buffer, read_len);
			break;
		case 0x00000700:
			//银行卡加油处理
			//bankProcess(iptparam->Id, read_buffer, read_len); //fj:
			break;
		case 0x00000800: //szb_fj_20171120,add ETC功能处理
			etc_fun_process(iptparam->Id);
			break;
		default:
			//异常时恢复为待机过程
			iptMainInterface(iptparam);
			break;
		}

		//处理油机上传给平板电脑的动作
		iptActionProcess(iptparam, read_buffer, read_len);

		//账单的存储处理
		iptZDSaveProcess(iptparam, read_buffer, read_len);

		//条码自助加油账单的上传处理
		iptBarZDUploadProcess(iptparam, read_buffer, read_len);

		usleep(1000);

		//sleep(1); //fj:cs 
	}
}


/*******************************************************************
*Name				:iptInit
*Description		:IPT模块功能初始化
*Input				:None
*Output			:None
*Return				:None
*History			:2013-07-01,modified by syj  */

bool iptInit(void)
{
	int istate=0;
	unsigned char read_buffer[128]={0};
	IptParamStructType *iptparam=NULL;

	//调试时读取调试存储的相关信息
#if _IPT_DEBUG_
	framRead(FM_ADDR_IPT_SINO, IptParamA.FMAddrBase+IPT_FM_OIL_ATUO, &IsOilAtuo, 1);
#endif

	//获取主板号及密钥号
	if(0==framRead(FM_ADDR_CONFIG, 0, read_buffer, 40)){
		memcpy(MboardID, &read_buffer[0], 8);
		memcpy(KeyData, &read_buffer[8], 32);
		Key[0]=KeyData[0];		Key[1]=KeyData[8];		Key[2]=KeyData[16];		Key[3]=KeyData[24];
		Key[4]=KeyData[2];		Key[5]=KeyData[10];		Key[6]=KeyData[18];		Key[7]=KeyData[26];
		Key[8]=KeyData[3];		Key[9]=KeyData[11];		Key[10]=KeyData[19];	Key[11]=KeyData[27];
		Key[12]=KeyData[7];		Key[13]=KeyData[15];	Key[14]=KeyData[23];	Key[15]=KeyData[31];
	}
	//背光控制,fj:
	paramSetupRead(PRM_BACKLIT, &IptBacklit, 1);
	if(1==IptBacklit)
	{
		SET_GPIO_HIGH(0x0b);
	}
	else
	{
		SET_GPIO_LOW(0x0b);
	}


	//if(1==IptBacklit)	pioBacklitCtr(0);
	//else						pioBacklitCtr(1);
	
	//获取销售锁定信息
	istate=paramSetupRead(PRM_SELL_LOCK_TIME, read_buffer, 5);
	if(0==istate)
	{
		iptparam=&IptParamA;
		memcpy(iptparam->SLockTime, read_buffer, 4);	iptparam->SellLock=read_buffer[4];
		iptparam=&IptParamB;
		memcpy(iptparam->SLockTime, read_buffer, 4);	iptparam->SellLock=read_buffer[4];
	}

	if(0==paramSetupRead(PRM_YuLe_Grade_OK, read_buffer, 1))
		{
			if(!memcmp(read_buffer,"\x00",1) || !memcmp(read_buffer,"\xFF",1))
				{
					IptParamA.TabletGradeTag=PC_FUN_GRADE_OK;
					IptParamB.TabletGradeTag=PC_FUN_GRADE_OK;
				}
			else
				{
					IptParamA.TabletGradeTag=read_buffer[0];
					IptParamB.TabletGradeTag=read_buffer[0];
				}
		}
	else
		{
			IptParamA.TabletGradeTag=PC_FUN_GRADE_OK;
			IptParamB.TabletGradeTag=PC_FUN_GRADE_OK;
		}

	//2017-02-13油品限制方式设置1HEX
	if(0==paramSetupRead(PRM_OilLimit_Style_Set, read_buffer, 1))
	{
		if(!memcmp(read_buffer,"\x00",1) || !memcmp(read_buffer,"\xFF",1))
		{
			//IptParamA.IptOilLimitStyleTag=IPT_SET_OILLIMIT_ZSH;
			//IptParamB.IptOilLimitStyleTag=IPT_SET_OILLIMIT_ZSH;
			IptParamA.IptOilLimitStyleTag=IPT_SET_OILLIMIT_0F;
			IptParamB.IptOilLimitStyleTag=IPT_SET_OILLIMIT_0F;
		}
		else
		{
			IptParamA.IptOilLimitStyleTag=read_buffer[0];
			IptParamB.IptOilLimitStyleTag=read_buffer[0];
		}
	}
	else
	{
		//IptParamA.IptOilLimitStyleTag=IPT_SET_OILLIMIT_ZSH;
		//IptParamB.IptOilLimitStyleTag=IPT_SET_OILLIMIT_ZSH;
		IptParamA.IptOilLimitStyleTag=IPT_SET_OILLIMIT_0F;
		IptParamB.IptOilLimitStyleTag=IPT_SET_OILLIMIT_0F;	
	}

	//szb_fj_20171120,add ETC功能设置 1hex
	if(0==paramSetupRead(PRM_ETC_FUN_SET, read_buffer, 1))
	{
		if(!memcmp(read_buffer,"\x00",1) || !memcmp(read_buffer,"\xFF",1))
		{
			IptParamA.etc_set_flg=ETC_FUN_NO;
			IptParamB.etc_set_flg=ETC_FUN_NO;
		}
		else
		{
			IptParamA.etc_set_flg=read_buffer[0];
			IptParamB.etc_set_flg=read_buffer[0];
		}
	}
	else
	{
		IptParamA.etc_set_flg=ETC_FUN_NO;
		IptParamB.etc_set_flg=ETC_FUN_NO;
	}

    //1号支付终端初始化
	//基本信息
	iptparam=&IptParamA;
	iptparam->Id=IPT_NOZZLE_1;
	//iptparam->JlNozzle=JL_NOZZLE_1; //fj:在计量里定义
	iptparam->JlNozzle = 0;
	iptparam->UserID = '1';
	iptparam->DEVButton=DEV_BUTTON_KEYA;
	iptparam->DEVGun=DEV_GUNA1;
	iptparam->DEVIC=IC_NOZZLE_1;
	iptparam->DEVDsp=DSP_NOZZLE_1;
	iptparam->DEVPIR=0;
	iptparam->DEVBuzzer=0;
	iptparam->FMAddrBase=0*(FM_SIZE_IPT_SINO/2);
	iptparam->NozzleNumber=1;
	iptparam->OilState=IPT_OIL_IDLE;
	iptparam->DEVPsam=0x00;			//PSAM卡接键盘PSAM0
	iptparam->DEVICInternal=0x33;	//内置卡连结在卡座PSAM3处
	iptparam->OilBillSave=0;	iptparam->OilBillSaveStep=0;
	iptparam->TabletPanel = PC_PANEL_1;
	iptparam->CardShootAsk = 0xFF;
	iptparam->CardAppSelectAsk = 0xFF;
	iptparam->CardTypeSelectAsk = 0xFF;
	iptparam->IsSuspend = 0;
    iptparam->EtcFreeObuflg = 0;

	//fj:add timer
	//iptparam->Time.century = 21;
	//iptparam->Time.year = 17;
	//iptparam->Time.month = 9;
	//iptparam->Time.date = 27;
	//iptparam->Time.hour = 9;
	//iptparam->Time.minute = 30;
	//iptparam->Time.second = 30;
	//iptparam->Time.week = 3;

	//PLAY按钮
	iptparam->DEVPlayButton = DEV_SWITCH_SELA1;
	//油品选择按钮
	iptparam->BarcodeSwitch=DEV_SWITCH_SELA3;
	//条码模块用户ID
	iptparam->BarUserID = 1;			
	//双枪时使用对应的条码，四枪机时使用A面条码模块
	iptparam->DEVBarcode=BARCODE_NOZZLE_1;
	//人体感应开关
	iptparam->DEVSensor = 0;


	//szb_fj_20171120,add 
	framRead(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+FM_ETC_FREE_FLG_A,read_buffer, 5);
	if(read_buffer[0]>2)
	{
		iptparam->EtcFreeflag=0;
		memcpy(iptparam->EtcSelCardInf+16,read_buffer+1,4);
	}
	else
	{
		iptparam->EtcFreeflag=read_buffer[0];
		memcpy(iptparam->EtcSelCardInf+16,read_buffer+1,4);
	}
	//szb_fj_20171120,add 异常停机缺一路脉冲
	framRead(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+FM_ERR_QUEYILU_PULSE,read_buffer, 1);
	if(read_buffer[0]==0xFF)
		iptparam->JlErr_QYL=0;
	else
		iptparam->JlErr_QYL=read_buffer[0];
	//szb_fj_20171120,add 异常停机零加油
	framRead(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+FM_ERR_LING_JIAYOU,read_buffer, 1);
	if(read_buffer[0]==0xFF)
		iptparam->JlErr_ZERO=0;
	else
		iptparam->JlErr_ZERO=read_buffer[0];
	//szb_fj_20171120,异常停机无脉冲超时
	framRead(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+FM_ERR_WU_PULSE,read_buffer, 1);
	if(read_buffer[0]==0xFF)
		iptparam->JlErr_WMCCS=0;
	else
		iptparam->JlErr_WMCCS=read_buffer[0];
	//szb_fj_20171120，异常停机缺一组脉冲
	framRead(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+FM_ERR_QUEYIZU_PULSE,read_buffer, 1);
	if(read_buffer[0]==0xFF)
		iptparam->JlErr_QYZ=0;
	else
		iptparam->JlErr_QYZ=read_buffer[0];

	framRead(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+FM_ERR_BIAN_PRICE,&iptparam->JlErr_BianJia,1);

	
	//参数获取失败或非法时以默认值赋值
	//上/下班信息，默认为下班，其他信息为空
	istate=paramSetupRead(IPT0_DUTY_INFO, read_buffer, 14);
	if(0==istate)
	{
		iptparam->WorkState=read_buffer[0];	
		iptparam->EMP=read_buffer[1];
		memcpy(iptparam->EMPPassword, &read_buffer[2], 2);
		memcpy(iptparam->EMPCardID, &read_buffer[4], 10);
	}
	if((0!=istate)||((0!=read_buffer[0])&&(1!=read_buffer[0])))
	{
		iptparam->WorkState=0;		iptparam->EMP=0;
		memset(iptparam->EMPPassword, 0, 2);
		memset(iptparam->EMPCardID, 0, 10);
	}

	//夜间锁定状态，默认为"正常"状态
	istate=paramSetupRead(IPT0_NIGHT_LOCK, read_buffer, 1);
	if(0==istate)	
	{
		iptparam->NightLock=read_buffer[0];
	}
	if((0!=istate)||((0!=read_buffer[0])&&(1!=read_buffer[0])))
	{
		iptparam->NightLock=IPT_NIGHT_UNLOCK;
	}
	//扬声器选择，默认为A1
	istate=paramSetupRead(IPT0_VOICE_SPEAKER, read_buffer, 1);
	if(0==istate)
	{
		iptparam->Speaker=read_buffer[0];	
	}
	if((0!=istate)||((0x10!=read_buffer[0])&&(0x11!=read_buffer[0])&&(0x20!=read_buffer[0])&&(0x21!=read_buffer[0])&&(0x30!=read_buffer[0])&&(0x31!=read_buffer[0])))
	{
		iptparam->Speaker=0x10;
	}
	//语音类型，默认为"女声"
	istate=paramSetupRead(IPT0_VOICE_TYPE, read_buffer, 1);
	if(0==istate)
	{
		iptparam->VoiceType=read_buffer[0];	
	}
	if((0!=istate)||((0!=read_buffer[0])&&(1!=read_buffer[0])))
	{
		iptparam->VoiceType=0;
	}
	//音量，默认为80
	istate=paramSetupRead(IPT0_VOICE_VOLUME, read_buffer, 1);
	if(0==istate)
	{
		iptparam->VoiceVolume=read_buffer[0];	
	}
	if((0!=istate)||(read_buffer[0]>=100))
	{
		iptparam->VoiceVolume=80;
	}
	//打印机选择，默认为A1								
	istate=paramSetupRead(IPT0_PRINTER, read_buffer, 1);
	if(0==istate)
	{
		iptparam->Printer=read_buffer[0];
	}
	if((0!=istate)||((0x10!=read_buffer[0])&&(0x11!=read_buffer[0])&&(0x20!=read_buffer[0])&&(0x21!=read_buffer[0])&&(0x30!=read_buffer[0])&&(0x31!=read_buffer[0])))
	{
		iptparam->Printer=0x10;
	}

	//是否自动打印，默认为自动打印
	istate=paramSetupRead(IPT0_PRINT_AUTO, read_buffer, 1);
	if(0==istate)
	{
		iptparam->PrintAuto=read_buffer[0];	
	}
	if((0!=istate)||((0!=read_buffer[0])&&(1!=read_buffer[0])))
	{
		iptparam->PrintAuto=1;
	}

	//自动打印联数，默认为只打印一联										
	istate=paramSetupRead(IPT0_PRINT_UNION, read_buffer, 1);
	if(0==istate)
	{
		iptparam->PrintUnion=read_buffer[0];	
	}
	if((0!=istate)||((0!=read_buffer[0])&&(1!=read_buffer[0])))
	{
		iptparam->PrintUnion=0;
	}

	//用户卡自动打印账单类型，默认为所有账单类型均自动打印											
	istate=paramSetupRead(IPT0_PRN_CARD_USER, read_buffer, 2);
	if(0==istate)
	{
		iptparam->PrintCardUser=(read_buffer[0]<<8)|(read_buffer[1]<<0);
	}
	if((0!=istate)||(iptparam->PrintCardUser>0x03ff))
	{
		iptparam->PrintCardUser=(1<<9)|(1<<8)|(1<<7)|(1<<6)|(1<<5)|(1<<4)|(1<<3)|(1<<2)|(1<<1)|(1<<0);
	}

	//管理卡自动打印账单类型，默认为所有账单类型均自动打印											
	istate=paramSetupRead(IPT0_PRN_CARD_MANAGE, read_buffer, 2);
	if(0==istate)
	{
		iptparam->PrintCardManage=(read_buffer[0]<<8)|(read_buffer[1]<<0);
	}
	if((0!=istate)||(iptparam->PrintCardUser>0x03ff))
	{
		iptparam->PrintCardManage=(1<<9)|(1<<8)|(1<<7)|(1<<6)|(1<<5)|(1<<4)|(1<<3)|(1<<2)|(1<<1)|(1<<0);
	}

	//员工卡自动打印账单类型，默认为所有账单类型均自动打印											
	istate=paramSetupRead(IPT0_PRN_CARD_STAFF, read_buffer, 2);
	if(0==istate)
	{
		iptparam->PrintCardStaff=(read_buffer[0]<<8)|(read_buffer[1]<<0);
	}
	if((0!=istate)||(iptparam->PrintCardUser>0x03ff))
	{
		iptparam->PrintCardStaff=(1<<9)|(1<<8)|(1<<7)|(1<<6)|(1<<5)|(1<<4)|(1<<3)|(1<<2)|(1<<1)|(1<<0);
	}	

	//验泵卡自动打印账单类型，默认为所有账单类型均自动打印											
	istate=paramSetupRead(IPT0_PRN_CARD_PUMP, read_buffer, 2);
	if(0==istate)
	{
		iptparam->PrintCardPump=(read_buffer[0]<<8)|(read_buffer[1]<<0);
	}
	if((0!=istate)||(iptparam->PrintCardUser>0x03ff))
	{
		iptparam->PrintCardPump=(1<<9)|(1<<8)|(1<<7)|(1<<6)|(1<<5)|(1<<4)|(1<<3)|(1<<2)|(1<<1)|(1<<0);
	}

	//维修卡自动打印账单类型，默认为所有账单类型均自动打印											
	istate=paramSetupRead(IPT0_PRN_CARD_SERVICE, read_buffer, 2);
	if(0==istate)
	{
		iptparam->PrintCardService=(read_buffer[0]<<8)|(read_buffer[1]<<0);
	}
	if((0!=istate)||(iptparam->PrintCardUser>0x03ff))
	{
		iptparam->PrintCardService=(1<<9)|(1<<8)|(1<<7)|(1<<6)|(1<<5)|(1<<4)|(1<<3)|(1<<2)|(1<<1)|(1<<0);
	}	

	//逻辑枪号，默认为1
	istate=paramSetupRead(IPT0_LOGIC_NOZZLE, read_buffer, 1);
	if(0==istate)
	{
		iptparam->LogicNozzle=read_buffer[0];
	}
	if((0!=istate)||(0==iptparam->LogicNozzle))
	{
		iptparam->LogicNozzle=1;
	}
	//物理枪号，默认为1
	istate=paramSetupRead(IPT0_PHYSICAL_NOZZLE, read_buffer, 1);
	if(0==istate)
	{
		iptparam->PhysicalNozzle=read_buffer[0];
	}
	if((0!=istate)||(0==iptparam->PhysicalNozzle))
	{
		iptparam->PhysicalNozzle=1;
	}
	//操作密码，默认为'0000'
	istate=paramSetupRead(IPT0_PASSWORD, read_buffer, 2);
	if(0==istate)
	{
		memcpy(iptparam->Password, read_buffer, 2);
	}
	if((0!=istate)||(((read_buffer[0]>>0)&0x0f)>9)||(((read_buffer[0]>>4)&0x0f)>9)||(((read_buffer[1]>>0)&0x0f)>9)||(((read_buffer[1]>>4)&0x0f)>9))
	{
		memcpy(iptparam->Password, IPT_STAPASS_DEFAULT, 2);
	}
	//工作模式，默认为'卡机联动模式'，社会站联达加油机默认为"条码自助模式"
	istate=paramSetupRead(IPT0_WORKMODE, read_buffer, 1);
	if(0==istate)
	{
		iptparam->Mode=read_buffer[0];
	}
	if(IPT_MODE_IC!=iptparam->Mode && IPT_MODE_UNSELF!=iptparam->Mode && IPT_MODE_BARCODE!=iptparam->Mode)
	{
		iptparam->Mode=IPT_MODE_IC;
	}
	//维修密码，默认为'9999'
	istate=paramSetupRead(IPT0_SERVICE_PASS, read_buffer, 2);
	if(0==istate)
	{
		memcpy(iptparam->ServicePass, read_buffer, 2);
	}
	if((0!=istate)||(((read_buffer[0]>>0)&0x0f)>9)||(((read_buffer[0]>>4)&0x0f)>9)||(((read_buffer[1]>>0)&0x0f)>9)||(((read_buffer[1]>>4)&0x0f)>9))
	{
		memcpy(iptparam->ServicePass, IPT_SERVEPASS_DEFAULT, 2);
	}
	//加油前是否DES认证，默认为需要DES认证
	istate=paramSetupRead(IPT0_AUTHEN, read_buffer, 1);
	if(0==istate){
		iptparam->DESAuthen=read_buffer[0];
	}
	if(0!=istate ||(0!=read_buffer[0] && 1!=read_buffer[0])){
		iptparam->DESAuthen=0;
	}

	//油品信息
	istate=paramSetupRead(IPT0_PRICE_INFO, read_buffer, 5);
	if(0==istate)
	{
		memcpy(iptparam->OilCode, read_buffer + 0, 2);
		memcpy(iptparam->OilPriceBySNPC, read_buffer + 2, 2);
		iptparam->OilVersion = *(read_buffer + 4);
		
		read_buffer[0]=((iptparam->OilCode[0]>>4)&0x0f)+0x30;	read_buffer[1]=((iptparam->OilCode[0]>>0)&0x0f)+0x30;
		read_buffer[2]=((iptparam->OilCode[1]>>4)&0x0f)+0x30;	read_buffer[3]=((iptparam->OilCode[1]>>0)&0x0f)+0x30;
		memset(iptparam->OilName, 0xff, 16);
		oilNameGet(read_buffer, iptparam->OilName, 16);
	}
	//jlPriceRead(iptparam->JlNozzle, &iptparam->OilPrice); //fj:20171117
	GetjlPriceRead(iptparam->JlNozzle,&iptparam->OilPrice);
	
	//员工卡加油限制信息，默认为允许
	istate=paramSetupRead(IPT0_STAFF_LIMIT, read_buffer, 1);
	if(0==istate)
	{
		iptparam->CardStaffLimit=read_buffer[0];
	}
	if((0!=istate)||((0!=read_buffer[0])&&(1!=read_buffer[0])))
	{
		iptparam->CardStaffLimit=0;
	}
	//获取注册信息
	istate=paramSetupRead(IPT0_BIND_TIME, read_buffer, 7);
	if(0==istate)	memcpy(iptparam->BindTime, read_buffer, 7);
	istate=paramSetupRead(IPT0_BIND_MBOARD_ID, read_buffer, 8);
	if(0==istate)	memcpy(iptparam->BindMboardId, read_buffer, 8);
	istate=paramSetupRead(IPT0_BIND_ACT_APPID, read_buffer, 10);
	if(0==istate)	memcpy(iptparam->BindACTAppId, read_buffer, 10);
	istate=paramSetupRead(IPT0_BIND_RID_APPID, read_buffer, 10);
	if(0==istate)	memcpy(iptparam->BindRIDAppId, read_buffer, 10);
	//获取油品语音代码信息
	istate=paramSetupRead(IPT0_OIL_VOICE, read_buffer, 4);
	if(0==istate)
	{
		memcpy(iptparam->OilVoice, read_buffer, 4);
	}
	//获取键盘显示对比度
	istate=paramSetupRead(IPT0_CONTRAST, read_buffer, 4);
	iptparam->Contrast = *read_buffer;
	if(iptparam->Contrast<IPT_DSPCONTRAST_MIN || iptparam->Contrast>IPT_DSPCONTRAST_MAX)
	{
		iptparam->Contrast = IPT_DSPCONTRAST_DEFAULT;
	}
	kbDspContrastSet(DEV_DSP_KEYA, iptparam->Contrast);
	
	//上电预处理过程
	iptPidSet(iptparam, IPT_PID_PRETREAT);
	
	
	//接收消息队列初始化,fj:20170914
	//iptparam->MsgIdRx=msgQCreate(20, IPT_MSG_MAX_LEN, MSG_Q_FIFO);
	//if(NULL==iptparam->MsgIdRx)	printf("Error!	Creat messages  'IptParamA1.MsgIdRx' failed!\n");
	//IPT任务初始化
	//iptparam->tId=taskSpawn("tIptA", 155, 0, 0x20000, (FUNCPTR)iptTask, 0,1,2,3,4,5,6,7,8,9);
	//if(!(OK==taskIdVerify(iptparam->tId)))		printf("Error!	Creat task 'tIptA' failed!\n");

    iptparam->MsgIdRx = msgget(IPC_PRIVATE,IPC_CREAT|0666);
	if(iptparam->MsgIdRx < 0)
	{
	     printf("Error!	Creat messages  'IptParamA1.MsgIdRx' failed!\n");
		 perror("get IptParamA1.MsgIdRx is error\n");
		 return false;
	}
	else
	{
		printf("------ipt:create message IptParamA1.MsgIdRx is success!\n");
	}






    //2号支付终端初始化
	//基本信息
	iptparam=&IptParamB;
	iptparam->Id=IPT_NOZZLE_2;
	//iptparam->JlNozzle=JL_NOZZLE_2; //fj:在计量里定义
	iptparam->JlNozzle=1;
	iptparam->UserID = '2';
	iptparam->DEVButton=DEV_BUTTON_KEYB;
	iptparam->DEVGun=DEV_GUNB1;
	iptparam->DEVIC=IC_NOZZLE_2;
	iptparam->DEVDsp=DSP_NOZZLE_2;
	iptparam->DEVPIR=1;
	iptparam->DEVBuzzer=1;
	iptparam->FMAddrBase=1*(FM_SIZE_IPT_SINO/2);
	iptparam->NozzleNumber=1;
	iptparam->OilState=IPT_OIL_IDLE;
	iptparam->DEVPsam=0x00;			//PSAM卡接键盘PSAM0
	iptparam->DEVICInternal=0x33;	//内置卡连结在卡座PSAM3处
	iptparam->OilBillSave=0;	iptparam->OilBillSaveStep=0;
	iptparam->TabletPanel = PC_PANEL_2;
	iptparam->CardShootAsk = 0xFF;
	iptparam->CardAppSelectAsk = 0xFF;
	iptparam->CardTypeSelectAsk = 0xFF;
	iptparam->IsSuspend = 0;
	iptparam->EtcFreeObuflg = 0;

	//fj:add timer
	//iptparam->Time.century = 21;
	//iptparam->Time.year = 17;
	//iptparam->Time.month = 9;
	//iptparam->Time.date = 27;
	//iptparam->Time.hour = 9;
	//iptparam->Time.minute = 30;
	//iptparam->Time.second = 30;
	//iptparam->Time.week = 3;

	//PLAY按钮
	iptparam->DEVPlayButton = DEV_SWITCH_SELB1;
	if(PANEL_NOZZLE_DOUBLE == paramPanelNozzleGet())	
		iptparam->DEVPlayButton = DEV_SWITCH_SELA1;
	else																						
		iptparam->DEVPlayButton = DEV_SWITCH_SELB1;
	//油品选择按钮
	iptparam->BarcodeSwitch = DEV_SWITCH_SELB3;
	//条码模块用户ID
	iptparam->BarUserID = 2;
	//双枪时使用对应的条码，四枪机时使用A面条码模块
	if(PANEL_NOZZLE_DOUBLE == paramPanelNozzleGet())	
		iptparam->DEVBarcode=BARCODE_NOZZLE_1;
	else																						
		iptparam->DEVBarcode=BARCODE_NOZZLE_2;
	//人体感应开关
	if(PANEL_NOZZLE_DOUBLE == paramPanelNozzleGet())	
		iptparam->DEVSensor = 0;
	else																						
		iptparam->DEVSensor = 1;

	//szb_fj_20171120,add
	framRead(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+FM_ETC_FREE_FLG_B,read_buffer, 5);
	if(read_buffer[0]>2)
	{
		iptparam->EtcFreeflag=0;
		memcpy(iptparam->EtcSelCardInf+16,read_buffer+1,4);
	}
	else
	{
		iptparam->EtcFreeflag=read_buffer[0];
		memcpy(iptparam->EtcSelCardInf+16,read_buffer+1,4);
	}

	//szb_fj_20171120,add 异常停机缺一路脉冲
	framRead(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+FM_ERR_QUEYILU_PULSE,read_buffer, 1);
	if(read_buffer[0]==0xFF)
		iptparam->JlErr_QYL=0;
	else
		iptparam->JlErr_QYL=read_buffer[0];
	//szb_fj_20171120,add 异常停机零加油
	framRead(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+FM_ERR_LING_JIAYOU,read_buffer, 1);
	if(read_buffer[0]==0xFF)
		iptparam->JlErr_ZERO=0;
	else
		iptparam->JlErr_ZERO=read_buffer[0];
	//szb_fj_20171120,add 异常停机无脉冲超时
	framRead(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+FM_ERR_WU_PULSE,read_buffer, 1);
	if(read_buffer[0]==0xFF)
		iptparam->JlErr_WMCCS=0;
	else
		iptparam->JlErr_WMCCS=read_buffer[0];
	//szb_fj_20171120,add 异常停机缺一组脉冲
	framRead(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+FM_ERR_QUEYIZU_PULSE,read_buffer, 1);
	if(read_buffer[0]==0xFF)
		iptparam->JlErr_QYZ=0;
	else
		iptparam->JlErr_QYZ=read_buffer[0];

	framRead(FM_ADDR_IPT_SINO, iptparam->FMAddrBase+FM_ERR_BIAN_PRICE,&iptparam->JlErr_BianJia,1);
	

	//参数获取失败或非法时以默认值赋值
	//上/下班信息，默认为下班，其他信息为空
	istate=paramSetupRead(IPT1_DUTY_INFO, read_buffer, 14);
	if(0==istate)
	{
		iptparam->WorkState=read_buffer[0];		iptparam->EMP=read_buffer[1];
		memcpy(iptparam->EMPPassword, &read_buffer[2], 2);
		memcpy(iptparam->EMPCardID, &read_buffer[4], 10);
	}
	if((0!=istate)||((0!=read_buffer[0])&&(1!=read_buffer[0])))
	{
		iptparam->WorkState=0;		iptparam->EMP=0;
		memset(iptparam->EMPPassword, 0, 2);
		memset(iptparam->EMPCardID, 0, 10);
	}

	//夜间锁定状态，默认为"正常"状态
	istate=paramSetupRead(IPT1_NIGHT_LOCK, read_buffer, 1);
	if(0==istate)	
	{
		iptparam->NightLock=read_buffer[0];
	}
	if((0!=istate)||((0!=read_buffer[0])&&(1!=read_buffer[0])))
	{
		iptparam->NightLock=IPT_NIGHT_UNLOCK;
	}
	//扬声器选择，默认为A2
	istate=paramSetupRead(IPT1_VOICE_SPEAKER, read_buffer, 1);
	if(0==istate)
	{
		iptparam->Speaker=read_buffer[0];	
	}
	if((0!=istate)||((0x10!=read_buffer[0])&&(0x11!=read_buffer[0])&&(0x20!=read_buffer[0])&&(0x21!=read_buffer[0])&&(0x30!=read_buffer[0])&&(0x31!=read_buffer[0])))
	{
		iptparam->Speaker=0x11;
	}
	//语音类型，默认为"女声"
	istate=paramSetupRead(IPT1_VOICE_TYPE, read_buffer, 1);
	if(0==istate)
	{
		iptparam->VoiceType=read_buffer[0];	
	}
	if((0!=istate)||((0!=read_buffer[0])&&(1!=read_buffer[0])))
	{
		iptparam->VoiceType=0;
	}
	//音量，默认为80
	istate=paramSetupRead(IPT1_VOICE_VOLUME, read_buffer, 1);
	if(0==istate)
	{
		iptparam->VoiceVolume=read_buffer[0];	
	}
	if((0!=istate)||(read_buffer[0]>=100))
	{
		iptparam->VoiceVolume=80;
	}
	//打印机选择，默认为A2								
	istate=paramSetupRead(IPT1_PRINTER, read_buffer, 1);
	if(0==istate)
	{
		iptparam->Printer=read_buffer[0];	
	}
	if((0!=istate)||((0x10!=read_buffer[0])&&(0x11!=read_buffer[0])&&(0x20!=read_buffer[0])&&(0x21!=read_buffer[0])&&(0x30!=read_buffer[0])&&(0x31!=read_buffer[0])))
	{
		iptparam->Printer=0x11;
	}					

	//是否自动打印，默认为自动打印
	istate=paramSetupRead(IPT1_PRINT_AUTO, read_buffer, 1);
	if(0==istate)
	{
		iptparam->PrintAuto=read_buffer[0];	
	}
	if((0!=istate)||((0!=read_buffer[0])&&(1!=read_buffer[0])))
	{
		iptparam->PrintAuto=1;
	}

	//自动打印联数，默认为只打印一联										
	istate=paramSetupRead(IPT1_PRINT_UNION, read_buffer, 1);
	if(0==istate)
	{
		iptparam->PrintUnion=read_buffer[0];
	}
	if((0!=istate)||((0!=read_buffer[0])&&(1!=read_buffer[0])))
	{
		iptparam->PrintUnion=0;
	}

	//用户卡自动打印账单类型，默认为所有账单类型均自动打印											
	istate=paramSetupRead(IPT1_PRN_CARD_USER, read_buffer, 2);
	if(0==istate)
	{
		iptparam->PrintCardUser=(read_buffer[0]<<8)|(read_buffer[1]<<0);
	}
	if((0!=istate)||(iptparam->PrintCardUser>0x03ff))
	{
		iptparam->PrintCardUser=(1<<9)|(1<<8)|(1<<7)|(1<<6)|(1<<5)|(1<<4)|(1<<3)|(1<<2)|(1<<1)|(1<<0);
	}

	//管理卡自动打印账单类型，默认为所有账单类型均自动打印											
	istate=paramSetupRead(IPT1_PRN_CARD_MANAGE, read_buffer, 2);
	if(0==istate)
	{
		iptparam->PrintCardManage=(read_buffer[0]<<8)|(read_buffer[1]<<0);
	}
	if((0!=istate)||(iptparam->PrintCardUser>0x03ff))
	{
		iptparam->PrintCardManage=(1<<9)|(1<<8)|(1<<7)|(1<<6)|(1<<5)|(1<<4)|(1<<3)|(1<<2)|(1<<1)|(1<<0);
	}

	//员工卡自动打印账单类型，默认为所有账单类型均自动打印											
	istate=paramSetupRead(IPT1_PRN_CARD_STAFF, read_buffer, 2);
	if(0==istate)
	{
		iptparam->PrintCardStaff=(read_buffer[0]<<8)|(read_buffer[1]<<0);
	}
	if((0!=istate)||(iptparam->PrintCardUser>0x03ff))
	{
		iptparam->PrintCardStaff=(1<<9)|(1<<8)|(1<<7)|(1<<6)|(1<<5)|(1<<4)|(1<<3)|(1<<2)|(1<<1)|(1<<0);
	}	

	//验泵卡自动打印账单类型，默认为所有账单类型均自动打印											
	istate=paramSetupRead(IPT1_PRN_CARD_PUMP, read_buffer, 2);
	if(0==istate)
	{
		iptparam->PrintCardPump=(read_buffer[0]<<8)|(read_buffer[1]<<0);
	}
	if((0!=istate)||(iptparam->PrintCardUser>0x03ff))
	{
		iptparam->PrintCardPump=(1<<9)|(1<<8)|(1<<7)|(1<<6)|(1<<5)|(1<<4)|(1<<3)|(1<<2)|(1<<1)|(1<<0);
	}

	//维修卡自动打印账单类型，默认为所有账单类型均自动打印											
	istate=paramSetupRead(IPT1_PRN_CARD_SERVICE, read_buffer, 2);
	if(0==istate)
	{
		iptparam->PrintCardService=(read_buffer[0]<<8)|(read_buffer[1]<<0);
	}
	if((0!=istate)||(iptparam->PrintCardUser>0x03ff))
	{
		iptparam->PrintCardService=(1<<9)|(1<<8)|(1<<7)|(1<<6)|(1<<5)|(1<<4)|(1<<3)|(1<<2)|(1<<1)|(1<<0);
	}	

	//逻辑枪号，默认为2
	istate=paramSetupRead(IPT1_LOGIC_NOZZLE, read_buffer, 1);
	if(0==istate)
	{
		iptparam->LogicNozzle=read_buffer[0];
	}
	if((0!=istate)||(0==iptparam->LogicNozzle))
	{
		iptparam->LogicNozzle=2;
	}
	//物理枪号，默认为2
	istate=paramSetupRead(IPT1_PHYSICAL_NOZZLE, read_buffer, 1);
	if(0==istate)
	{
		iptparam->PhysicalNozzle=read_buffer[0];
	}
	if((0!=istate)||(0==iptparam->PhysicalNozzle))
	{
		iptparam->PhysicalNozzle=2;
	}
	//操作密码，默认为'0000'
	istate=paramSetupRead(IPT1_PASSWORD, read_buffer, 2);
	if(0==istate)
	{
		memcpy(iptparam->Password, read_buffer, 2);
	}
	if((0!=istate)||(((read_buffer[0]>>0)&0x0f)>9)||(((read_buffer[0]>>4)&0x0f)>9)||(((read_buffer[1]>>0)&0x0f)>9)||(((read_buffer[1]>>4)&0x0f)>9))
	{
		memcpy(iptparam->Password, IPT_STAPASS_DEFAULT, 2);
	}
	//工作模式，默认为'卡机联动模式'
	istate=paramSetupRead(IPT1_WORKMODE, read_buffer, 1);
	if(0==istate)
	{
		iptparam->Mode=read_buffer[0];
	}
	if(IPT_MODE_IC!=iptparam->Mode && IPT_MODE_UNSELF!=iptparam->Mode && IPT_MODE_BARCODE!=iptparam->Mode)
	{
		iptparam->Mode=IPT_MODE_IC;
	}
	//维修密码，默认为'9999'
	istate=paramSetupRead(IPT1_SERVICE_PASS, read_buffer, 2);
	if(0==istate)
	{
		memcpy(iptparam->ServicePass, read_buffer, 2);
	}
	if((0!=istate)||(((read_buffer[0]>>0)&0x0f)>9)||(((read_buffer[0]>>4)&0x0f)>9)||(((read_buffer[1]>>0)&0x0f)>9)||(((read_buffer[1]>>4)&0x0f)>9))
	{
		memcpy(iptparam->ServicePass, IPT_SERVEPASS_DEFAULT, 2);
	}
	//加油前是否DES认证，默认为需要DES认证
	istate=paramSetupRead(IPT1_AUTHEN, read_buffer, 1);
	if(0==istate)
	{
		iptparam->DESAuthen=read_buffer[0];
	}
	if((0!=istate)||((0!=read_buffer[0])&&(1!=read_buffer[0])))
	{
		iptparam->DESAuthen=0;
	}
	//油品信息
	//istate=paramSetupRead(IPT1_PRICE_INFO, read_buffer, 2);
	istate=paramSetupRead(IPT1_PRICE_INFO, read_buffer, 5); //szb_fj_20171120,update
	if(0==istate)
	{
		memcpy(iptparam->OilCode, read_buffer + 0, 2);
		memcpy(iptparam->OilPriceBySNPC, read_buffer + 2, 2);
		iptparam->OilVersion = *(read_buffer + 4);
		
		read_buffer[0]=((iptparam->OilCode[0]>>4)&0x0f)+0x30;	read_buffer[1]=((iptparam->OilCode[0]>>0)&0x0f)+0x30;
		read_buffer[2]=((iptparam->OilCode[1]>>4)&0x0f)+0x30;	read_buffer[3]=((iptparam->OilCode[1]>>0)&0x0f)+0x30;
		memset(iptparam->OilName, 0xff, 16);
		oilNameGet(read_buffer, iptparam->OilName, 16);
	}
	//jlPriceRead(iptparam->JlNozzle, &iptparam->OilPrice); //fj:20171117
	GetjlPriceRead(iptparam->JlNozzle,&iptparam->OilPrice); 
	
	//员工卡加油限制信息，默认为允许
	istate=paramSetupRead(IPT1_STAFF_LIMIT, read_buffer, 1);
	if(0==istate)
	{
		iptparam->CardStaffLimit=read_buffer[0];
	}
	if((0!=istate)||((0!=read_buffer[0])&&(1!=read_buffer[0])))
	{
		iptparam->CardStaffLimit=0;
	}
	//获取注册信息
	istate=paramSetupRead(IPT1_BIND_TIME, read_buffer, 7);
	if(0==istate)	memcpy(iptparam->BindTime, read_buffer, 7);
	istate=paramSetupRead(IPT1_BIND_MBOARD_ID, read_buffer, 8);
	if(0==istate)	memcpy(iptparam->BindMboardId, read_buffer, 8);
	istate=paramSetupRead(IPT1_BIND_ACT_APPID, read_buffer, 10);
	if(0==istate)	memcpy(iptparam->BindACTAppId, read_buffer, 10);
	istate=paramSetupRead(IPT1_BIND_RID_APPID, read_buffer, 10);
	if(0==istate)	memcpy(iptparam->BindRIDAppId, read_buffer, 10);
	//获取油品语音代码信息
	istate=paramSetupRead(IPT1_OIL_VOICE, read_buffer, 4);
	if(0==istate){
		memcpy(iptparam->OilVoice, read_buffer, 4);
	}
	//获取键盘显示对比度
	istate=paramSetupRead(IPT1_CONTRAST, read_buffer, 4);
	iptparam->Contrast = *read_buffer;
	if(iptparam->Contrast<IPT_DSPCONTRAST_MIN || iptparam->Contrast>IPT_DSPCONTRAST_MAX){
		iptparam->Contrast = IPT_DSPCONTRAST_DEFAULT;
	}
	kbDspContrastSet(DEV_DSP_KEYB, iptparam->Contrast);
	

	//上电预处理过程
	iptPidSet(iptparam, IPT_PID_PRETREAT);
	
	
	
	//接收消息队列初始化,fj:20170914
	//iptparam->MsgIdRx=msgQCreate(20, IPT_MSG_MAX_LEN, MSG_Q_FIFO);
	//if(NULL==iptparam->MsgIdRx)	printf("Error!	Creat messages  'IptParamB1.MsgIdRx' failed!\n");
	//IPT任务初始化
	//iptparam->tId=taskSpawn("tIptB", 155, 0, 0x20000, (FUNCPTR)iptTask, 1,1,2,3,4,5,6,7,8,9);
	//if(!(OK==taskIdVerify(iptparam->tId)))		printf("Error!	Creat task 'tIptB' failed!\n");*/
	

	iptparam->MsgIdRx = msgget(IPC_PRIVATE,IPC_CREAT|0666);
	if(iptparam->MsgIdRx < 0)
	{
	    printf("Error!	Creat messages  'IptParamB1.MsgIdRx' failed!\n");
		perror("get IptParamB.MsgIdRx is error");
		return false;
	}
	else
	{
		printf("------ipt:create message IptParamB1.MsgIdRx is success!\n");
	}

	return true;
}


